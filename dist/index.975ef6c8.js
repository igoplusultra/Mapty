// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"farZc":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "890e741a975ef6c8";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && ![
        "localhost",
        "127.0.0.1",
        "0.0.0.0"
    ].includes(hostname) ? "wss" : "ws";
    var ws;
    if (HMR_USE_SSE) ws = new EventSource("/__parcel_hmr");
    else try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    if (ws instanceof WebSocket) {
        ws.onerror = function(e) {
            if (e.message) console.error(e.message);
        };
        ws.onclose = function() {
            console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
        };
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"8lqZg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _mapboxGl = require("mapbox-gl");
var _mapboxGlDefault = parcelHelpers.interopDefault(_mapboxGl);
var _statePng = require("../img/state.png");
var _statePngDefault = parcelHelpers.interopDefault(_statePng);
var _countryPng = require("../img/country.png");
var _countryPngDefault = parcelHelpers.interopDefault(_countryPng);
var _runningBoltPng = require("../img/activities/running-bolt.png");
var _runningBoltPngDefault = parcelHelpers.interopDefault(_runningBoltPng);
var _runningTimePng = require("../img/activities/running-time.png");
var _runningTimePngDefault = parcelHelpers.interopDefault(_runningTimePng);
var _runningActivityPng = require("../img/activities/running-activity.png");
var _runningActivityPngDefault = parcelHelpers.interopDefault(_runningActivityPng);
var _runningPng = require("../img/activities/running.png");
var _runningPngDefault = parcelHelpers.interopDefault(_runningPng);
var _cyclingBoltPng = require("../img/activities/cycling-bolt.png");
var _cyclingBoltPngDefault = parcelHelpers.interopDefault(_cyclingBoltPng);
var _cyclingTimePng = require("../img/activities/cycling-time.png");
var _cyclingTimePngDefault = parcelHelpers.interopDefault(_cyclingTimePng);
var _cyclingActivityPng = require("../img/activities/cycling-activity.png");
var _cyclingActivityPngDefault = parcelHelpers.interopDefault(_cyclingActivityPng);
var _cyclingPng = require("../img/activities/cycling.png");
var _cyclingPngDefault = parcelHelpers.interopDefault(_cyclingPng);
// dom
const workoutForm = document.querySelector("form");
const maptyHeader = document.querySelector(".header");
const inputDistance = document.getElementById("workout--distance");
const inputDuration = document.getElementById("workout--duration");
const inputCadence = document.getElementById("workout--cadence");
const inputGain = document.getElementById("workout--gain");
const inputType = document.getElementById("workout--type");
const errorBox = document.querySelector(".error");
const errorMessage = document.querySelector(".error__message");
const map = document.querySelector("#map");
const activityContainer = document.querySelector(".user__activities");
const deleteAll = document.querySelector(".btn--delete-all");
const home = document.querySelector(".btn--go-home");
const fullMonths = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
];
class App {
    #map;
    #currentWorkout;
    #allWorkouts = [];
    #home;
    #click;
    #spinner;
    #location;
    #error = false;
    constructor(){
        this.getUserCoordinates();
        this.changeWorkoutType();
        this.findWorkout();
        this.deleteAllWorkouts();
        this.onGo();
        this.onHome();
    }
    getUserCoordinates() {
        if (!navigator.geolocation) return;
        navigator.geolocation.getCurrentPosition((pos)=>{
            const { latitude, longitude } = pos.coords;
            this.#home = [
                longitude,
                latitude
            ]; // Longitude first, then latitude
            this.createMap(this.#home);
        }, (err)=>this.handleCoordinatesError("User denied geolocation!"));
    }
    createSpinner() {
        return `<div data-show="false" class="spinner"></div>`;
    }
    createMap(coordinates) {
        (0, _mapboxGlDefault.default).accessToken = "pk.eyJ1Ijoia2VhbmRyZWxvdmVzY29kaW5nIiwiYSI6ImNseXVuNzZpejE2bHkycXE3eXIwd251MDEifQ.am0e8s43Le7W302oz_LivQ";
        this.#map = new (0, _mapboxGlDefault.default).Map({
            container: "map",
            style: "mapbox://styles/mapbox/streets-v12",
            center: coordinates,
            zoom: 13.5,
            bearing: -16,
            antialias: true
        });
        this.#map.on("style.load", ()=>{
            this.#map.setFog({
                color: "#7dcf9b",
                "high-color": "#444b54",
                "horizon-blend": 0.4
            });
            this.getLocalStorage();
            setTimeout(function() {
                home.classList.remove("hidden");
            }, 3250);
            const layers = this.#map.getStyle().layers;
            const labelLayer = layers.find((layer)=>layer.type === "symbol" && layer.layout["text-field"]);
            if (labelLayer) {
                const labelLayerId = labelLayer.id;
                this.#map.addLayer({
                    id: "add-3d-buildings",
                    source: "composite",
                    "source-layer": "building",
                    filter: [
                        "==",
                        "extrude",
                        "true"
                    ],
                    type: "fill-extrusion",
                    minzoom: 15,
                    paint: {
                        "fill-extrusion-color": "#aaa",
                        "fill-extrusion-height": [
                            "interpolate",
                            [
                                "linear"
                            ],
                            [
                                "zoom"
                            ],
                            15,
                            0,
                            15.05,
                            [
                                "get",
                                "height"
                            ]
                        ],
                        "fill-extrusion-base": [
                            "interpolate",
                            [
                                "linear"
                            ],
                            [
                                "zoom"
                            ],
                            15,
                            0,
                            15.05,
                            [
                                "get",
                                "min_height"
                            ]
                        ],
                        "fill-extrusion-opacity": 0.6
                    }
                }, labelLayerId);
            } else this.handleError("Layer not found");
        });
        maptyHeader.classList.remove("hidden");
        this.addUserMarker(this.#home);
        this.listenMapClick();
    }
    addUserMarker(homeCoordinates) {
        const customMarker = document.createElement("div");
        customMarker.className = "homeMarker";
        const marker = new (0, _mapboxGlDefault.default).Marker(customMarker).setLngLat(homeCoordinates).addTo(this.#map);
        this.#home = Object.values(marker._lngLat);
    }
    listenMapClick() {
        this.#map.on("click", async (e)=>{
            // Check if there is an error before proceeding
            if (this.#error) {
                this.handleError("This location could not be found");
                return;
            }
            try {
                this.#click = Object.values(e.lngLat);
                this.#spinner = this.createSpinner();
                // Only proceed if workoutForm is hidden, spinner is not already showing, and there's no error
                if (workoutForm.classList.contains("hidden") && !document.querySelector(".spinner[data-show='true']")) {
                    maptyHeader.insertAdjacentHTML("afterend", this.#spinner);
                    document.querySelector(".spinner").dataset.show = true;
                    setTimeout(function() {
                        workoutForm.classList.remove("hidden");
                        document.querySelector(".spinner").dataset.show = false;
                        document.querySelector(".spinner").remove();
                    }, 1000);
                }
                let gain = 0;
                if (inputType.value === "cycling") // Await the elevation gain
                gain = await this.getElevation();
                if (inputType.value === "running") this.#currentWorkout = this.calculateMetrics(this.#home, this.#click, inputType.value);
                if (inputType.value === "cycling") this.#currentWorkout = this.calculateMetrics(this.#home, this.#click, inputType.value, 6, 0, 15, gain);
                this.setDescription();
                this.setWorkoutData(this.#currentWorkout, inputType.value);
                this.reverseGeocoding(this.#click[0], this.#click[1]);
            } catch (err) {
                this.handleError(err);
            }
        });
    }
    addClickedMarker() {
        const customMarker = document.createElement("div");
        customMarker.className = "clickedMarker";
        this.#currentWorkout.type === "running" ? customMarker.classList.add("clickedMarker__running") : customMarker.classList.add("clickedMarker__cycling");
        const marker = new (0, _mapboxGlDefault.default).Marker(customMarker).setLngLat(this.#currentWorkout.pos).addTo(this.#map);
        this.#click = Object.values(marker._lngLat);
    }
    setDescription() {
        const date = new Date();
        const monthIndex = date.getMonth();
        const day = date.getDate();
        const year = date.getFullYear();
        this.#currentWorkout.description = `${this.#currentWorkout.type === "running" ? "Running" : "Cycling"} on ${fullMonths[monthIndex - 1]} ${day}, ${year}`;
    }
    async reverseGeocoding(lng, lat) {
        try {
            const fetchGeo = await fetch(`https://api.mapbox.com/search/geocode/v6/reverse?longitude=${lng}&latitude=${lat}&types=address&access_token=${(0, _mapboxGlDefault.default).accessToken}`);
            if (!fetchGeo.ok) {
                this.#error = true;
                throw new Error("This location could not be found");
            }
            const recievedGeo = await fetchGeo.json();
            const geo = recievedGeo.features?.at(0)?.geometry;
            if (geo === undefined) {
                this.#error = true;
                throw new Error("This location could not be found");
            }
            const info = recievedGeo.features?.at(0)?.properties?.context;
            if (info === undefined) {
                this.#error = true;
                throw new Error("This location could not be found");
            }
            this.#location = {
                activity: this.#currentWorkout.type,
                coords: geo.coordinates,
                country: info.country.name,
                state: info.region.name,
                city: info.place.name,
                street: info.address.name
            };
            this.#currentWorkout.home = this.#home;
            this.#currentWorkout.place = this.#location;
            await this.getAddressPhoto(this.#location.coords[0], this.#location.coords[1]);
            this.#error = false;
            this.displayLocation();
        } catch (err) {
            this.handleError(err);
        }
    }
    async getAddressPhoto(lng, lat, apiKey = "AIzaSyDWUJJr8PT9MAXL3AFfQU_cQWnf2ZO_OwU") {
        try {
            const corsProxy = "https://corsproxy.io/?";
            const size = "600x400";
            const address = await fetch(`${corsProxy}https://maps.googleapis.com/maps/api/streetview?size=${size}&location=${lat},${lng}&heading=151.78&pitch=-0.76&key=${apiKey}`);
            if (!address.ok) throw new Error(`Location data could not be found`);
            this.#location.url = address.url;
        } catch (err) {
            this.handleError(err);
        }
    }
    async displayLocation(type = this.#currentWorkout.type) {
        const locationHTML = ` <div class="location">
        <img
          class="location__img"
          src="${this.#location.url}"
          alt="Location image"
        />
        <div class="location__info">
          <div class="location__header">
            <h2 class="location__city">${this.#location.city}</h2>
            <h3 class="location__address">${this.#location.street}</h3>
          </div>
        </div>
        <div class="location__state">
          <img
            class="location__state--logo"
            src="${(0, _statePngDefault.default)}"
            alt="State image"
          />
          <h4 class="location__state--name">${this.#location.state}</h4>
        </div>
        <div class="location__country">
          <img
            class="location__country--logo"
            src="${(0, _countryPngDefault.default)}"
            alt="Country image"
          />
          <h4 class="location__country--name">${this.#location.country}</h4>
        </div>
        <div class="confirm__location">
          <h4 class="confirm__location--text">
            Is this where you are ${type}?
          </h4>
          <div class="confirm__location--btns">
            <button class="btn yes">yes</button>
            <button class="btn no">no</button>
          </div>
        </div>
      </div>`;
        if (document.querySelector(".location")) document.querySelector(".location").remove();
        map.insertAdjacentHTML("afterend", locationHTML);
        this.confirmLocation();
    }
    confirmLocation() {
        document.querySelector(".location").addEventListener("click", (async function(e) {
            try {
                if (!this.#currentWorkout) throw new Error();
                if (!e.target.classList.contains("btn")) return;
                if (e.target.classList.contains("yes")) {
                    const yesBtn = e.target;
                    const location = yesBtn.closest(".location");
                    await this.handleFormSubmit();
                    await this.displayEverything();
                    this.newWorkout();
                    this.reset();
                    setTimeout(function() {
                        location.remove();
                    }, 1200);
                    location.style.animation = "pushReleaseToRight 1.2s ease-in-out";
                } else {
                    const noBtn = e.target;
                    const location = noBtn.closest(".location");
                    setTimeout(function() {
                        location.remove();
                    }, 1200);
                    location.style.animation = "pushReleaseToRight 1.2s ease-in-out";
                    this.removeForm();
                }
            } catch (err) {
                this.handleError(err);
            }
        }).bind(this));
    }
    createWorkout() {
        const workoutMarkup = `<div data-id="${this.#currentWorkout.id}" class="activity activity__${this.#currentWorkout.type}">
            <div class="activity__config">
              <h2 class="activity__config--date activity__config--${this.#currentWorkout.description.includes("Running") ? "running" : "cycling"}">${this.#currentWorkout.description}</h2>
              <div class="activity__config--btns">
                <button class="btn delete btn--small activity__btns__${this.#currentWorkout.type}">
                  delete
                </button>
                 <button class="btn go btn--small activity__btns__${this.#currentWorkout.type}">
                 go
                </button>
              </div>
            </div>
            <ul class="activity__nav">
              <li class="activity__items">
                <img src="${this.#currentWorkout.type === "running" ? (0, _runningActivityPngDefault.default) : (0, _cyclingActivityPngDefault.default)}" alt="" />
                <span class="number">${this.#currentWorkout.distance}</span> MI
              </li>
              <li class="activity__items">
                <img src="${this.#currentWorkout.type === "running" ? (0, _runningTimePngDefault.default) : (0, _cyclingTimePngDefault.default)}" alt="" />
                <span class="number">${this.#currentWorkout.duration}</span> MINS
              </li>
              <li class="activity__items">
                <img src="${this.#currentWorkout.type === "running" ? (0, _runningBoltPngDefault.default) : (0, _cyclingBoltPngDefault.default)}" alt="" />
                <span class="number">2.0</span>
              </li>
              <li class="activity__items">
                <img src="${this.#currentWorkout.type === "running" ? (0, _runningPngDefault.default) : (0, _cyclingPngDefault.default)}" alt="" />
                <span class="number">${this.#currentWorkout.type === "running" ? this.#currentWorkout.cadence : this.#currentWorkout.gain}</span> ${this.#currentWorkout.type === "running" ? "SPM" : "M"}
              </li>
            </ul>
          </div>`;
        activityContainer.insertAdjacentHTML("afterbegin", workoutMarkup);
    }
    removeForm() {
        workoutForm.classList.toggle("hidden");
        inputDistance.value = inputDuration.value = "";
        this.#location.type === "running" ? inputCadence.value = "" : inputGain.value = "";
    }
    setWorkoutData(workout, type = "running") {
        if (type === "running") {
            inputDistance.value = workout.distance;
            inputDuration.value = workout.duration;
            inputCadence.value = workout.cadence;
        } else {
            inputDistance.value = workout.distance;
            inputDuration.value = workout.duration;
            inputGain.value = workout.gain;
        }
    }
    changeWorkoutType() {
        inputType.addEventListener("change", async (e)=>{
            e.preventDefault();
            const type = inputType.value;
            // Toggle visibility of inputs based on selected workout type
            inputCadence.closest(".workout--activity").classList.toggle("hidden");
            inputGain.closest(".workout--activity").classList.toggle("hidden");
            // If there's an existing workout, update the form fields based on the selected type
            if (this.#currentWorkout) {
                if (this.#currentWorkout.type === type) // Type hasn't changed, just update the form with existing data
                this.setWorkoutData(this.#currentWorkout, type);
                else {
                    // Type has changed, clear the form fields
                    inputDistance.value = "";
                    inputDuration.value = "";
                    inputCadence.value = "";
                    inputGain.value = "";
                    // If the new type is running, update the workout type
                    if (type === "running") {
                        this.#currentWorkout = {
                            ...this.#currentWorkout,
                            type
                        };
                        this.setDescription();
                        this.setWorkoutData(this.#currentWorkout, type);
                        this.displayLocation(type);
                    }
                    // If the new type is cycling, fetch the elevation data and update the workout type
                    if (type === "cycling") try {
                        if (this.#click) {
                            const gain = await this.getElevation();
                            this.#currentWorkout = {
                                ...this.#currentWorkout,
                                type,
                                gain
                            };
                            this.setDescription();
                            this.setWorkoutData(this.#currentWorkout, type);
                            this.displayLocation(type);
                        }
                    } catch (err) {
                        this.handleError(err);
                    }
                }
            }
        });
    }
    calculateMetrics(startCoordinates, endCoordinates, type, speed = 6, strideLength = 2.5, bikeSpeed = 15, gain = 0) {
        // Function to convert degrees to radians
        const toRadians = (degrees)=>degrees * Math.PI / 180;
        // Function to calculate distance between two coordinates using Haversine formula
        function calculateDistance(coord1, coord2) {
            const [lon1, lat1] = coord1;
            const [lon2, lat2] = coord2;
            const R = 3959; // Radius of the Earth in miles
            const \u03C61 = toRadians(lat1);
            const \u03C62 = toRadians(lat2);
            const \u0394\u03C6 = toRadians(lat2 - lat1);
            const \u0394\u03BB = toRadians(lon2 - lon1);
            const a = Math.sin(\u0394\u03C6 / 2) ** 2 + Math.cos(\u03C61) * Math.cos(\u03C62) * Math.sin(\u0394\u03BB / 2) ** 2;
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }
        // Function to calculate running duration based on distance and speed
        function calculateRunningDuration(distance, speed) {
            const timeInHours = distance / speed; // Time in hours
            return Math.round(timeInHours * 60); // Time in minutes
        }
        // Function to calculate running cadence (steps per minute)
        function calculateRunningCadence(distance, duration, strideLength) {
            const distanceInFeet = distance * 5280; // Convert miles to feet
            const steps = distanceInFeet / strideLength; // Total steps
            const cadence = steps / duration; // Steps per minute
            return Math.round(cadence);
        }
        // Function to calculate cycling duration based on distance and speed
        function calculateCyclingDuration(distance, bikeSpeed) {
            const timeInHours = distance / bikeSpeed; // Time in hours
            return Math.round(timeInHours * 60); // Time in minutes
        }
        // Function to calculate elevation gain from coordinates
        function calculateElevationGain(startCoords, endCoords) {
            // Placeholder for elevation gain calculation
            return gain; // You would need actual elevation data from a map service
        }
        // Calculate metrics based on the type
        const distance = calculateDistance(startCoordinates, endCoordinates);
        let duration, cadence, gainValue;
        if (type === "running") {
            duration = calculateRunningDuration(distance, speed);
            cadence = calculateRunningCadence(distance, duration, strideLength);
            return {
                distance: +distance.toFixed(2),
                duration,
                cadence,
                type: inputType.value,
                id: +(Date.now() + "").slice(-8),
                pos: this.#click
            };
        } else if (type === "cycling") {
            duration = calculateCyclingDuration(distance, bikeSpeed);
            gainValue = calculateElevationGain(startCoordinates, endCoordinates);
            return {
                distance: +distance.toFixed(2),
                duration,
                gain,
                type: inputType.value,
                id: +(Date.now() + "").slice(-8),
                pos: this.#click
            };
        } else throw new Error("Invalid type. Must be 'running' or 'cycling'.");
    }
    async getElevation() {
        try {
            // Construct the API request.
            const query = await fetch(`https://api.mapbox.com/v4/mapbox.mapbox-terrain-v2/tilequery/${this.#currentWorkout.pos[0]},${this.#currentWorkout.pos[1]}.json?layers=contour&limit=50&access_token=${(0, _mapboxGlDefault.default).accessToken}`, {
                method: "GET"
            });
            if (query.status !== 200) throw new Error("Failed to fetch elevation data");
            const data = await query.json();
            // Get all the returned features.
            const allFeatures = data.features;
            // For each returned feature, add elevation data to the elevations array.
            const elevations = allFeatures.map((feature)=>feature.properties.ele);
            // In the elevations array, find the largest value.
            const highestElevation = Math.max(...elevations);
            return highestElevation;
        } catch (err) {
            this.handleError(err);
        }
    }
    handleFormSubmit() {
        try {
            if (!this.#currentWorkout || !this.#currentWorkout.id) throw new Error("Location not set");
            const type = inputType.value;
            const distance = +inputDistance.value;
            const duration = +inputDuration.value;
            if (type === "running") {
                const cadence = +inputCadence.value;
                if (!isFinite(distance && duration && cadence)) throw new Error("Please only use numbers!");
                inputDistance.value = inputDuration.value = inputCadence.value = "";
                inputCadence.blur();
            }
            if (type === "cycling") {
                const gain = +inputGain.value;
                if (!isFinite(distance && duration && gain)) throw new Error("Please only use numbers!");
                inputDistance.value = inputDuration.value = inputGain.value = "";
                inputGain.blur();
            }
            workoutForm.classList.toggle("blurOutTop");
            setTimeout(function() {
                workoutForm.classList.toggle("blurOutTop");
                workoutForm.classList.toggle("hidden");
            }, 1000);
        } catch (err) {
            this.handleError(err);
        }
    }
    async createGeoLine() {
        try {
            if (!this.#currentWorkout.place || !this.#currentWorkout.id || !this.#currentWorkout) throw new Error("Location is not set");
            const response = await fetch(`https://api.mapbox.com/directions/v5/mapbox/${this.#currentWorkout.type === "running" ? "walking" : "cycling"}/${this.#currentWorkout.home.join(",")};${this.#currentWorkout.pos.join(",")}?steps=true&geometries=geojson&access_token=${(0, _mapboxGlDefault.default).accessToken}`);
            if (!response.ok) throw new Error("Could not create GEO line");
            const data = await response.json();
            const route = data.routes[0].geometry.coordinates;
            const routeId = `route-${this.#currentWorkout.id}`;
            this.#currentWorkout.route = route;
            this.#currentWorkout.routeId = routeId;
            if (!this.#currentWorkout.routeId) throw new Error("Failed: RouteId");
            // Add the route as a GeoJSON source
            this.#map.addSource(this.#currentWorkout.routeId, {
                type: "geojson",
                data: {
                    type: "Feature",
                    properties: {},
                    geometry: {
                        type: "LineString",
                        coordinates: this.#currentWorkout.route
                    }
                }
            });
            // Add the route as a line layer
            this.#map.addLayer({
                id: this.#currentWorkout.routeId,
                type: "line",
                source: this.#currentWorkout.routeId,
                layout: {
                    "line-cap": "round",
                    "line-join": "round"
                },
                paint: {
                    "line-color": `${this.#currentWorkout.type === "running" ? "#007acc" : "#ff8800"}`,
                    "line-width": 8
                }
            });
        } catch (err) {
            this.handleError(err);
        }
    }
    handleError(message) {
        // Clear form fields
        if (inputType.value === "running") inputDistance.value = inputDuration.value = inputCadence.value = "";
        if (inputType.value === "cycling") inputDistance.value = inputDuration.value = inputGain.value = "";
        // Display error message
        errorBox.classList.remove("hidden");
        errorMessage.textContent = message;
        // Hide form
        workoutForm.classList.add("hidden");
        // Hide error message after a delay
        setTimeout(function() {
            errorBox.classList.add("hidden");
        }, 2500);
        // Reset error state
        this.#error = false;
        // Remove location display if present
        if (document.querySelector(".location")) document.querySelector(".location").remove();
    }
    handleCoordinatesError(message) {
        errorMessage.textContent = message;
        errorBox.classList.toggle("hidden");
        setTimeout(function() {
            errorBox.classList.toggle("hidden");
        }, 3500);
    }
    reset() {
        // Handle the form submission based on the current workout type
        if (inputType.value === "cycling") {
            inputType.value = "running";
            // Switch the type to running and update the form fields
            inputGain.closest(".workout--activity").classList.toggle("hidden");
            inputCadence.closest(".workout--activity").classList.toggle("hidden");
        }
        // Clear the form fields
        inputDistance.value = "";
        inputDuration.value = "";
        // Reset cadence and gain fields based on type
        if (inputType.value === "running") inputCadence.value = "";
        else inputGain.value = "";
    }
    setLocalStorage(workoutsList) {
        localStorage.setItem("workouts", JSON.stringify(workoutsList));
    }
    async getLocalStorage() {
        const data = localStorage.getItem("workouts");
        // Check if data is not null or an empty string
        if (data && data.length > 0) {
            this.#allWorkouts = JSON.parse(data);
            // Create and display the storage markup
            this.createStorageMarkup();
            // Delay removal of the storage markup and processing of workouts
            setTimeout(async ()=>{
                document.querySelector(".storage").remove();
                for (const workout of this.#allWorkouts){
                    this.#currentWorkout = workout;
                    try {
                        await this.displayEverything();
                    } catch (err) {
                        this.handleError(err);
                    }
                    this.#currentWorkout = {};
                    this.showDeleteAll();
                }
            }, 3000);
        }
    }
    async displayEverything() {
        this.createWorkout();
        this.addClickedMarker();
        await this.createGeoLine();
    }
    newWorkout() {
        this.#allWorkouts.push(this.#currentWorkout);
        this.showDeleteAll();
        this.setLocalStorage(this.#allWorkouts);
        this.#currentWorkout = {};
    }
    createStorageMarkup() {
        const storage = ` <div class="storage">
          <div class="storage__spinner"></div>
          <div class="storage__progress"></div>
          <div class="storage__info">
            <div class="storage__header">
              <img src="img/happy.gif" alt="" />
              <h3>Looking for your workouts</h3>
            </div>
            <p class="storage__wait">please be patient</p>
          </div>
        </div>`;
        maptyHeader.insertAdjacentHTML("afterend", storage);
    }
    findWorkout() {
        activityContainer.addEventListener("click", (function(e) {
            if (!e.target.classList.contains("delete")) return;
            const foundElement = e.target.closest(".activity");
            const foundElementId = +foundElement.dataset.id;
            const foundWorkoutIndex = this.#allWorkouts.findIndex((workout)=>workout.id === foundElementId);
            this.#allWorkouts.splice(foundWorkoutIndex, 1);
            foundElement.remove();
            this.setLocalStorage(this.#allWorkouts);
            window.location.reload();
        }).bind(this));
    }
    showDeleteAll() {
        if (this.#allWorkouts.length >= 2) deleteAll.classList.remove("hidden");
        if (this.#allWorkouts.length <= 1) deleteAll.classList.add("hidden");
    }
    deleteAllWorkouts() {
        deleteAll.addEventListener("click", (function() {
            this.#allWorkouts = [];
            this.setLocalStorage(this.#allWorkouts);
            activityContainer.innerHTML = "";
            window.location.reload();
        }).bind(this));
    }
    onGo() {
        activityContainer.addEventListener("click", (function(e) {
            if (!e.target.classList.contains("go")) return;
            const foundElementId = e.target.closest(".activity").dataset.id;
            this.#currentWorkout = this.#allWorkouts.find((workout)=>workout.id === +foundElementId);
            this.flyToWorkout();
        }).bind(this));
    }
    flyToWorkout() {
        this.#map.flyTo({
            center: this.#currentWorkout.pos,
            duration: 6000,
            zoom: 17.5,
            speed: 1.2,
            curve: 1.5,
            essential: true
        });
    }
    onHome() {
        home.addEventListener("click", (function(e) {
            this.flyToHome();
        }).bind(this));
    }
    flyToHome() {
        this.#map.flyTo({
            center: this.#home,
            duration: 6000,
            zoom: 17.5,
            speed: 1.2,
            curve: 1.5,
            essential: true
        });
    }
}
const start = new App();

},{"mapbox-gl":"562rs","../img/state.png":"f0qvZ","../img/country.png":"1PBVp","../img/activities/running-bolt.png":"dPSuH","../img/activities/running-time.png":"l4x0p","../img/activities/running-activity.png":"knKF0","../img/activities/running.png":"c2u2T","../img/activities/cycling-bolt.png":"cV8VT","../img/activities/cycling-time.png":"ju7M8","../img/activities/cycling-activity.png":"ekBrc","../img/activities/cycling.png":"fMgm3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"562rs":[function(require,module,exports) {
/* Mapbox GL JS is Copyright © 2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */ (function(global, factory) {
    module.exports = factory();
})(this, function() {
    "use strict";
    /* eslint-disable */ var shared, worker, mapboxgl;
    // define gets called three times: one for each chunk. we rely on the order
    // they're imported to know which is which
    function define(_, chunk) {
        if (!shared) shared = chunk;
        else if (!worker) worker = chunk;
        else {
            var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
            var sharedChunk = {};
            shared(sharedChunk);
            mapboxgl = chunk(sharedChunk);
            if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([
                workerBundleString
            ], {
                type: "text/javascript"
            }));
        }
    }
    define([
        "exports"
    ], function(t1) {
        var e = "3.5.2";
        let r;
        const n = {
            API_URL: "https://api.mapbox.com",
            get API_URL_REGEX () {
                if (null == r) {
                    const t1 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
                    try {
                        r = t1;
                    } catch (e) {
                        r = t1;
                    }
                }
                return r;
            },
            get API_TILEJSON_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
            },
            get API_SPRITE_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
            },
            get API_FONTS_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
            },
            get API_STYLE_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
            },
            get API_CDN_URL_REGEX () {
                return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
            },
            get EVENTS_URL () {
                if (!n.API_URL) return null;
                try {
                    const t1 = new URL(n.API_URL);
                    return "api.mapbox.cn" === t1.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t1.hostname ? "https://events.mapbox.com/events/v2" : null;
                } catch (t1) {
                    return null;
                }
            },
            SESSION_PATH: "/map-sessions/v1",
            FEEDBACK_URL: "https://apps.mapbox.com/feedback",
            TILE_URL_VERSION: "v4",
            RASTER_URL_PREFIX: "raster/v1",
            RASTERARRAYS_URL_PREFIX: "rasterarrays/v1",
            REQUIRE_ACCESS_TOKEN: !0,
            ACCESS_TOKEN: null,
            DEFAULT_STYLE: "mapbox://styles/mapbox/standard",
            MAX_PARALLEL_IMAGE_REQUESTS: 16,
            DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm",
            MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm",
            MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm",
            GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf",
            TILES3D_URL_PREFIX: "3dtiles/v1"
        };
        function i(t1) {
            return n.API_URL_REGEX.test(t1);
        }
        function s(t1) {
            return 0 === t1.indexOf("mapbox:");
        }
        function a(t1) {
            return n.API_CDN_URL_REGEX.test(t1);
        }
        function o(t1) {
            return n.API_SPRITE_REGEX.test(t1);
        }
        function l(t1) {
            return n.API_STYLE_REGEX.test(t1) && !o(t1);
        }
        const u = {
            create: "create",
            load: "load",
            fullLoad: "fullLoad"
        }, c = {
            mark (t1) {
                performance.mark(t1);
            },
            measure (t1, e, r) {
                performance.measure(t1, e, r);
            }
        };
        function h(t1) {
            const e = t1.name.split("?")[0];
            return a(e) && e.includes("mapbox-gl.js") ? "javascript" : a(e) && e.includes("mapbox-gl.css") ? "css" : function(t1) {
                return n.API_FONTS_REGEX.test(t1);
            }(e) ? "fontRange" : o(e) ? "sprite" : l(e) ? "style" : function(t1) {
                return n.API_TILEJSON_REGEX.test(t1);
            }(e) ? "tilejson" : "other";
        }
        function p(t1) {
            return t1 && t1.__esModule && Object.prototype.hasOwnProperty.call(t1, "default") ? t1.default : t1;
        }
        var f = {}, d = {};
        Object.defineProperty(d, "__esModule", {
            value: !0
        }), d.setMatrixArrayType = function(t1) {
            d.ARRAY_TYPE = y = t1;
        }, d.toRadian = function(t1) {
            return t1 * x;
        }, d.equals = function(t1, e) {
            return Math.abs(t1 - e) <= m * Math.max(1, Math.abs(t1), Math.abs(e));
        }, d.RANDOM = d.ARRAY_TYPE = d.EPSILON = void 0;
        var m = 1e-6;
        d.EPSILON = m;
        var y = "undefined" != typeof Float32Array ? Float32Array : Array;
        d.ARRAY_TYPE = y;
        var g = Math.random;
        d.RANDOM = g;
        var x = Math.PI / 180;
        Math.hypot || (Math.hypot = function() {
            for(var t1 = 0, e = arguments.length; e--;)t1 += arguments[e] * arguments[e];
            return Math.sqrt(t1);
        });
        var b = {};
        function v(t1) {
            return v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                return typeof t1;
            } : function(t1) {
                return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
            }, v(t1);
        }
        Object.defineProperty(b, "__esModule", {
            value: !0
        }), b.create = function() {
            var t1 = new _.ARRAY_TYPE(4);
            return _.ARRAY_TYPE != Float32Array && (t1[1] = 0, t1[2] = 0), t1[0] = 1, t1[3] = 1, t1;
        }, b.clone = function(t1) {
            var e = new _.ARRAY_TYPE(4);
            return e[0] = t1[0], e[1] = t1[1], e[2] = t1[2], e[3] = t1[3], e;
        }, b.copy = function(t1, e) {
            return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1;
        }, b.identity = function(t1) {
            return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1;
        }, b.fromValues = function(t1, e, r, n) {
            var i = new _.ARRAY_TYPE(4);
            return i[0] = t1, i[1] = e, i[2] = r, i[3] = n, i;
        }, b.set = function(t1, e, r, n, i) {
            return t1[0] = e, t1[1] = r, t1[2] = n, t1[3] = i, t1;
        }, b.transpose = function(t1, e) {
            if (t1 === e) {
                var r = e[1];
                t1[1] = e[2], t1[2] = r;
            } else t1[0] = e[0], t1[1] = e[2], t1[2] = e[1], t1[3] = e[3];
            return t1;
        }, b.invert = function(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = r * s - i * n;
            return a ? (t1[0] = s * (a = 1 / a), t1[1] = -n * a, t1[2] = -i * a, t1[3] = r * a, t1) : null;
        }, b.adjoint = function(t1, e) {
            var r = e[0];
            return t1[0] = e[3], t1[1] = -e[1], t1[2] = -e[2], t1[3] = r, t1;
        }, b.determinant = function(t1) {
            return t1[0] * t1[3] - t1[2] * t1[1];
        }, b.multiply = M, b.rotate = function(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l + s * o, t1[1] = i * l + a * o, t1[2] = n * -o + s * l, t1[3] = i * -o + a * l, t1;
        }, b.scale = function(t1, e, r) {
            var n = e[1], i = e[2], s = e[3], a = r[0], o = r[1];
            return t1[0] = e[0] * a, t1[1] = n * a, t1[2] = i * o, t1[3] = s * o, t1;
        }, b.fromRotation = function(t1, e) {
            var r = Math.sin(e), n = Math.cos(e);
            return t1[0] = n, t1[1] = r, t1[2] = -r, t1[3] = n, t1;
        }, b.fromScaling = function(t1, e) {
            return t1[0] = e[0], t1[1] = 0, t1[2] = 0, t1[3] = e[1], t1;
        }, b.str = function(t1) {
            return "mat2(" + t1[0] + ", " + t1[1] + ", " + t1[2] + ", " + t1[3] + ")";
        }, b.frob = function(t1) {
            return Math.hypot(t1[0], t1[1], t1[2], t1[3]);
        }, b.LDU = function(t1, e, r, n) {
            return t1[2] = n[2] / n[0], r[0] = n[0], r[1] = n[1], r[3] = n[3] - t1[2] * r[1], [
                t1,
                e,
                r
            ];
        }, b.add = function(t1, e, r) {
            return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1[2] = e[2] + r[2], t1[3] = e[3] + r[3], t1;
        }, b.subtract = A, b.exactEquals = function(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2] && t1[3] === e[3];
        }, b.equals = function(t1, e) {
            var r = t1[0], n = t1[1], i = t1[2], s = t1[3], a = e[0], o = e[1], l = e[2], u = e[3];
            return Math.abs(r - a) <= _.EPSILON * Math.max(1, Math.abs(r), Math.abs(a)) && Math.abs(n - o) <= _.EPSILON * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(i - l) <= _.EPSILON * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(s - u) <= _.EPSILON * Math.max(1, Math.abs(s), Math.abs(u));
        }, b.multiplyScalar = function(t1, e, r) {
            return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1[3] = e[3] * r, t1;
        }, b.multiplyScalarAndAdd = function(t1, e, r, n) {
            return t1[0] = e[0] + r[0] * n, t1[1] = e[1] + r[1] * n, t1[2] = e[2] + r[2] * n, t1[3] = e[3] + r[3] * n, t1;
        }, b.sub = b.mul = void 0;
        var _ = function(t1, e) {
            if (t1 && t1.__esModule) return t1;
            if (null === t1 || "object" !== v(t1) && "function" != typeof t1) return {
                default: t1
            };
            var r = w(void 0);
            if (r && r.has(t1)) return r.get(t1);
            var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for(var s in t1)if ("default" !== s && Object.prototype.hasOwnProperty.call(t1, s)) {
                var a = i ? Object.getOwnPropertyDescriptor(t1, s) : null;
                a && (a.get || a.set) ? Object.defineProperty(n, s, a) : n[s] = t1[s];
            }
            return n.default = t1, r && r.set(t1, n), n;
        }(d);
        function w(t1) {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap, r = new WeakMap;
            return (w = function(t1) {
                return t1 ? r : e;
            })(t1);
        }
        function M(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = r[0], l = r[1], u = r[2], c = r[3];
            return t1[0] = n * o + s * l, t1[1] = i * o + a * l, t1[2] = n * u + s * c, t1[3] = i * u + a * c, t1;
        }
        function A(t1, e, r) {
            return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1[2] = e[2] - r[2], t1[3] = e[3] - r[3], t1;
        }
        b.mul = M, b.sub = A;
        var S = {};
        function I(t1) {
            return I = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                return typeof t1;
            } : function(t1) {
                return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
            }, I(t1);
        }
        Object.defineProperty(S, "__esModule", {
            value: !0
        }), S.create = function() {
            var t1 = new T.ARRAY_TYPE(6);
            return T.ARRAY_TYPE != Float32Array && (t1[1] = 0, t1[2] = 0, t1[4] = 0, t1[5] = 0), t1[0] = 1, t1[3] = 1, t1;
        }, S.clone = function(t1) {
            var e = new T.ARRAY_TYPE(6);
            return e[0] = t1[0], e[1] = t1[1], e[2] = t1[2], e[3] = t1[3], e[4] = t1[4], e[5] = t1[5], e;
        }, S.copy = function(t1, e) {
            return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1[4] = e[4], t1[5] = e[5], t1;
        }, S.identity = function(t1) {
            return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1[4] = 0, t1[5] = 0, t1;
        }, S.fromValues = function(t1, e, r, n, i, s) {
            var a = new T.ARRAY_TYPE(6);
            return a[0] = t1, a[1] = e, a[2] = r, a[3] = n, a[4] = i, a[5] = s, a;
        }, S.set = function(t1, e, r, n, i, s, a) {
            return t1[0] = e, t1[1] = r, t1[2] = n, t1[3] = i, t1[4] = s, t1[5] = a, t1;
        }, S.invert = function(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = e[4], o = e[5], l = r * s - n * i;
            return l ? (t1[0] = s * (l = 1 / l), t1[1] = -n * l, t1[2] = -i * l, t1[3] = r * l, t1[4] = (i * o - s * a) * l, t1[5] = (n * a - r * o) * l, t1) : null;
        }, S.determinant = function(t1) {
            return t1[0] * t1[3] - t1[1] * t1[2];
        }, S.multiply = P, S.rotate = function(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = Math.sin(r), c = Math.cos(r);
            return t1[0] = n * c + s * u, t1[1] = i * c + a * u, t1[2] = n * -u + s * c, t1[3] = i * -u + a * c, t1[4] = o, t1[5] = l, t1;
        }, S.scale = function(t1, e, r) {
            var n = e[1], i = e[2], s = e[3], a = e[4], o = e[5], l = r[0], u = r[1];
            return t1[0] = e[0] * l, t1[1] = n * l, t1[2] = i * u, t1[3] = s * u, t1[4] = a, t1[5] = o, t1;
        }, S.translate = function(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = r[0], c = r[1];
            return t1[0] = n, t1[1] = i, t1[2] = s, t1[3] = a, t1[4] = n * u + s * c + o, t1[5] = i * u + a * c + l, t1;
        }, S.fromRotation = function(t1, e) {
            var r = Math.sin(e), n = Math.cos(e);
            return t1[0] = n, t1[1] = r, t1[2] = -r, t1[3] = n, t1[4] = 0, t1[5] = 0, t1;
        }, S.fromScaling = function(t1, e) {
            return t1[0] = e[0], t1[1] = 0, t1[2] = 0, t1[3] = e[1], t1[4] = 0, t1[5] = 0, t1;
        }, S.fromTranslation = function(t1, e) {
            return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1[4] = e[0], t1[5] = e[1], t1;
        }, S.str = function(t1) {
            return "mat2d(" + t1[0] + ", " + t1[1] + ", " + t1[2] + ", " + t1[3] + ", " + t1[4] + ", " + t1[5] + ")";
        }, S.frob = function(t1) {
            return Math.hypot(t1[0], t1[1], t1[2], t1[3], t1[4], t1[5], 1);
        }, S.add = function(t1, e, r) {
            return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1[2] = e[2] + r[2], t1[3] = e[3] + r[3], t1[4] = e[4] + r[4], t1[5] = e[5] + r[5], t1;
        }, S.subtract = z, S.multiplyScalar = function(t1, e, r) {
            return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1[3] = e[3] * r, t1[4] = e[4] * r, t1[5] = e[5] * r, t1;
        }, S.multiplyScalarAndAdd = function(t1, e, r, n) {
            return t1[0] = e[0] + r[0] * n, t1[1] = e[1] + r[1] * n, t1[2] = e[2] + r[2] * n, t1[3] = e[3] + r[3] * n, t1[4] = e[4] + r[4] * n, t1[5] = e[5] + r[5] * n, t1;
        }, S.exactEquals = function(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2] && t1[3] === e[3] && t1[4] === e[4] && t1[5] === e[5];
        }, S.equals = function(t1, e) {
            var r = t1[0], n = t1[1], i = t1[2], s = t1[3], a = t1[4], o = t1[5], l = e[0], u = e[1], c = e[2], h = e[3], p = e[4], f = e[5];
            return Math.abs(r - l) <= T.EPSILON * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(n - u) <= T.EPSILON * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(i - c) <= T.EPSILON * Math.max(1, Math.abs(i), Math.abs(c)) && Math.abs(s - h) <= T.EPSILON * Math.max(1, Math.abs(s), Math.abs(h)) && Math.abs(a - p) <= T.EPSILON * Math.max(1, Math.abs(a), Math.abs(p)) && Math.abs(o - f) <= T.EPSILON * Math.max(1, Math.abs(o), Math.abs(f));
        }, S.sub = S.mul = void 0;
        var T = function(t1, e) {
            if (t1 && t1.__esModule) return t1;
            if (null === t1 || "object" !== I(t1) && "function" != typeof t1) return {
                default: t1
            };
            var r = k(void 0);
            if (r && r.has(t1)) return r.get(t1);
            var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for(var s in t1)if ("default" !== s && Object.prototype.hasOwnProperty.call(t1, s)) {
                var a = i ? Object.getOwnPropertyDescriptor(t1, s) : null;
                a && (a.get || a.set) ? Object.defineProperty(n, s, a) : n[s] = t1[s];
            }
            return n.default = t1, r && r.set(t1, n), n;
        }(d);
        function k(t1) {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap, r = new WeakMap;
            return (k = function(t1) {
                return t1 ? r : e;
            })(t1);
        }
        function P(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = r[0], c = r[1], h = r[2], p = r[3], f = r[4], d = r[5];
            return t1[0] = n * u + s * c, t1[1] = i * u + a * c, t1[2] = n * h + s * p, t1[3] = i * h + a * p, t1[4] = n * f + s * d + o, t1[5] = i * f + a * d + l, t1;
        }
        function z(t1, e, r) {
            return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1[2] = e[2] - r[2], t1[3] = e[3] - r[3], t1[4] = e[4] - r[4], t1[5] = e[5] - r[5], t1;
        }
        S.mul = P, S.sub = z;
        var E = {};
        function B(t1) {
            return B = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                return typeof t1;
            } : function(t1) {
                return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
            }, B(t1);
        }
        Object.defineProperty(E, "__esModule", {
            value: !0
        }), E.create = function() {
            var t1 = new D.ARRAY_TYPE(9);
            return D.ARRAY_TYPE != Float32Array && (t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[5] = 0, t1[6] = 0, t1[7] = 0), t1[0] = 1, t1[4] = 1, t1[8] = 1, t1;
        }, E.fromMat4 = function(t1, e) {
            return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[4], t1[4] = e[5], t1[5] = e[6], t1[6] = e[8], t1[7] = e[9], t1[8] = e[10], t1;
        }, E.clone = function(t1) {
            var e = new D.ARRAY_TYPE(9);
            return e[0] = t1[0], e[1] = t1[1], e[2] = t1[2], e[3] = t1[3], e[4] = t1[4], e[5] = t1[5], e[6] = t1[6], e[7] = t1[7], e[8] = t1[8], e;
        }, E.copy = function(t1, e) {
            return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1[4] = e[4], t1[5] = e[5], t1[6] = e[6], t1[7] = e[7], t1[8] = e[8], t1;
        }, E.fromValues = function(t1, e, r, n, i, s, a, o, l) {
            var u = new D.ARRAY_TYPE(9);
            return u[0] = t1, u[1] = e, u[2] = r, u[3] = n, u[4] = i, u[5] = s, u[6] = a, u[7] = o, u[8] = l, u;
        }, E.set = function(t1, e, r, n, i, s, a, o, l, u) {
            return t1[0] = e, t1[1] = r, t1[2] = n, t1[3] = i, t1[4] = s, t1[5] = a, t1[6] = o, t1[7] = l, t1[8] = u, t1;
        }, E.identity = function(t1) {
            return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 1, t1[5] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 1, t1;
        }, E.transpose = function(t1, e) {
            if (t1 === e) {
                var r = e[1], n = e[2], i = e[5];
                t1[1] = e[3], t1[2] = e[6], t1[3] = r, t1[5] = e[7], t1[6] = n, t1[7] = i;
            } else t1[0] = e[0], t1[1] = e[3], t1[2] = e[6], t1[3] = e[1], t1[4] = e[4], t1[5] = e[7], t1[6] = e[2], t1[7] = e[5], t1[8] = e[8];
            return t1;
        }, E.invert = function(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = e[4], o = e[5], l = e[6], u = e[7], c = e[8], h = c * a - o * u, p = -c * s + o * l, f = u * s - a * l, d = r * h + n * p + i * f;
            return d ? (t1[0] = h * (d = 1 / d), t1[1] = (-c * n + i * u) * d, t1[2] = (o * n - i * a) * d, t1[3] = p * d, t1[4] = (c * r - i * l) * d, t1[5] = (-o * r + i * s) * d, t1[6] = f * d, t1[7] = (-u * r + n * l) * d, t1[8] = (a * r - n * s) * d, t1) : null;
        }, E.adjoint = function(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = e[4], o = e[5], l = e[6], u = e[7], c = e[8];
            return t1[0] = a * c - o * u, t1[1] = i * u - n * c, t1[2] = n * o - i * a, t1[3] = o * l - s * c, t1[4] = r * c - i * l, t1[5] = i * s - r * o, t1[6] = s * u - a * l, t1[7] = n * l - r * u, t1[8] = r * a - n * s, t1;
        }, E.determinant = function(t1) {
            var e = t1[3], r = t1[4], n = t1[5], i = t1[6], s = t1[7], a = t1[8];
            return t1[0] * (a * r - n * s) + t1[1] * (-a * e + n * i) + t1[2] * (s * e - r * i);
        }, E.multiply = R, E.translate = function(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = r[0], f = r[1];
            return t1[0] = n, t1[1] = i, t1[2] = s, t1[3] = a, t1[4] = o, t1[5] = l, t1[6] = p * n + f * a + u, t1[7] = p * i + f * o + c, t1[8] = p * s + f * l + h, t1;
        }, E.rotate = function(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = Math.sin(r), f = Math.cos(r);
            return t1[0] = f * n + p * a, t1[1] = f * i + p * o, t1[2] = f * s + p * l, t1[3] = f * a - p * n, t1[4] = f * o - p * i, t1[5] = f * l - p * s, t1[6] = u, t1[7] = c, t1[8] = h, t1;
        }, E.scale = function(t1, e, r) {
            var n = r[0], i = r[1];
            return t1[0] = n * e[0], t1[1] = n * e[1], t1[2] = n * e[2], t1[3] = i * e[3], t1[4] = i * e[4], t1[5] = i * e[5], t1[6] = e[6], t1[7] = e[7], t1[8] = e[8], t1;
        }, E.fromTranslation = function(t1, e) {
            return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 1, t1[5] = 0, t1[6] = e[0], t1[7] = e[1], t1[8] = 1, t1;
        }, E.fromRotation = function(t1, e) {
            var r = Math.sin(e), n = Math.cos(e);
            return t1[0] = n, t1[1] = r, t1[2] = 0, t1[3] = -r, t1[4] = n, t1[5] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 1, t1;
        }, E.fromScaling = function(t1, e) {
            return t1[0] = e[0], t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = e[1], t1[5] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 1, t1;
        }, E.fromMat2d = function(t1, e) {
            return t1[0] = e[0], t1[1] = e[1], t1[2] = 0, t1[3] = e[2], t1[4] = e[3], t1[5] = 0, t1[6] = e[4], t1[7] = e[5], t1[8] = 1, t1;
        }, E.fromQuat = function(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = r + r, o = n + n, l = i + i, u = r * a, c = n * a, h = n * o, p = i * a, f = i * o, d = i * l, m = s * a, y = s * o, g = s * l;
            return t1[0] = 1 - h - d, t1[3] = c - g, t1[6] = p + y, t1[1] = c + g, t1[4] = 1 - u - d, t1[7] = f - m, t1[2] = p - y, t1[5] = f + m, t1[8] = 1 - u - h, t1;
        }, E.normalFromMat4 = function(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = e[4], o = e[5], l = e[6], u = e[7], c = e[8], h = e[9], p = e[10], f = e[11], d = e[12], m = e[13], y = e[14], g = e[15], x = r * o - n * a, b = r * l - i * a, v = r * u - s * a, _ = n * l - i * o, w = n * u - s * o, M = i * u - s * l, A = c * m - h * d, S = c * y - p * d, I = c * g - f * d, T = h * y - p * m, k = h * g - f * m, P = p * g - f * y, z = x * P - b * k + v * T + _ * I - w * S + M * A;
            return z ? (t1[0] = (o * P - l * k + u * T) * (z = 1 / z), t1[1] = (l * I - a * P - u * S) * z, t1[2] = (a * k - o * I + u * A) * z, t1[3] = (i * k - n * P - s * T) * z, t1[4] = (r * P - i * I + s * S) * z, t1[5] = (n * I - r * k - s * A) * z, t1[6] = (m * M - y * w + g * _) * z, t1[7] = (y * v - d * M - g * b) * z, t1[8] = (d * w - m * v + g * x) * z, t1) : null;
        }, E.projection = function(t1, e, r) {
            return t1[0] = 2 / e, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = -2 / r, t1[5] = 0, t1[6] = -1, t1[7] = 1, t1[8] = 1, t1;
        }, E.str = function(t1) {
            return "mat3(" + t1[0] + ", " + t1[1] + ", " + t1[2] + ", " + t1[3] + ", " + t1[4] + ", " + t1[5] + ", " + t1[6] + ", " + t1[7] + ", " + t1[8] + ")";
        }, E.frob = function(t1) {
            return Math.hypot(t1[0], t1[1], t1[2], t1[3], t1[4], t1[5], t1[6], t1[7], t1[8]);
        }, E.add = function(t1, e, r) {
            return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1[2] = e[2] + r[2], t1[3] = e[3] + r[3], t1[4] = e[4] + r[4], t1[5] = e[5] + r[5], t1[6] = e[6] + r[6], t1[7] = e[7] + r[7], t1[8] = e[8] + r[8], t1;
        }, E.subtract = V, E.multiplyScalar = function(t1, e, r) {
            return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1[3] = e[3] * r, t1[4] = e[4] * r, t1[5] = e[5] * r, t1[6] = e[6] * r, t1[7] = e[7] * r, t1[8] = e[8] * r, t1;
        }, E.multiplyScalarAndAdd = function(t1, e, r, n) {
            return t1[0] = e[0] + r[0] * n, t1[1] = e[1] + r[1] * n, t1[2] = e[2] + r[2] * n, t1[3] = e[3] + r[3] * n, t1[4] = e[4] + r[4] * n, t1[5] = e[5] + r[5] * n, t1[6] = e[6] + r[6] * n, t1[7] = e[7] + r[7] * n, t1[8] = e[8] + r[8] * n, t1;
        }, E.exactEquals = function(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2] && t1[3] === e[3] && t1[4] === e[4] && t1[5] === e[5] && t1[6] === e[6] && t1[7] === e[7] && t1[8] === e[8];
        }, E.equals = function(t1, e) {
            var r = t1[0], n = t1[1], i = t1[2], s = t1[3], a = t1[4], o = t1[5], l = t1[6], u = t1[7], c = t1[8], h = e[0], p = e[1], f = e[2], d = e[3], m = e[4], y = e[5], g = e[6], x = e[7], b = e[8];
            return Math.abs(r - h) <= D.EPSILON * Math.max(1, Math.abs(r), Math.abs(h)) && Math.abs(n - p) <= D.EPSILON * Math.max(1, Math.abs(n), Math.abs(p)) && Math.abs(i - f) <= D.EPSILON * Math.max(1, Math.abs(i), Math.abs(f)) && Math.abs(s - d) <= D.EPSILON * Math.max(1, Math.abs(s), Math.abs(d)) && Math.abs(a - m) <= D.EPSILON * Math.max(1, Math.abs(a), Math.abs(m)) && Math.abs(o - y) <= D.EPSILON * Math.max(1, Math.abs(o), Math.abs(y)) && Math.abs(l - g) <= D.EPSILON * Math.max(1, Math.abs(l), Math.abs(g)) && Math.abs(u - x) <= D.EPSILON * Math.max(1, Math.abs(u), Math.abs(x)) && Math.abs(c - b) <= D.EPSILON * Math.max(1, Math.abs(c), Math.abs(b));
        }, E.sub = E.mul = void 0;
        var D = function(t1, e) {
            if (t1 && t1.__esModule) return t1;
            if (null === t1 || "object" !== B(t1) && "function" != typeof t1) return {
                default: t1
            };
            var r = C(void 0);
            if (r && r.has(t1)) return r.get(t1);
            var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for(var s in t1)if ("default" !== s && Object.prototype.hasOwnProperty.call(t1, s)) {
                var a = i ? Object.getOwnPropertyDescriptor(t1, s) : null;
                a && (a.get || a.set) ? Object.defineProperty(n, s, a) : n[s] = t1[s];
            }
            return n.default = t1, r && r.set(t1, n), n;
        }(d);
        function C(t1) {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap, r = new WeakMap;
            return (C = function(t1) {
                return t1 ? r : e;
            })(t1);
        }
        function R(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = r[0], f = r[1], d = r[2], m = r[3], y = r[4], g = r[5], x = r[6], b = r[7], v = r[8];
            return t1[0] = p * n + f * a + d * u, t1[1] = p * i + f * o + d * c, t1[2] = p * s + f * l + d * h, t1[3] = m * n + y * a + g * u, t1[4] = m * i + y * o + g * c, t1[5] = m * s + y * l + g * h, t1[6] = x * n + b * a + v * u, t1[7] = x * i + b * o + v * c, t1[8] = x * s + b * l + v * h, t1;
        }
        function V(t1, e, r) {
            return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1[2] = e[2] - r[2], t1[3] = e[3] - r[3], t1[4] = e[4] - r[4], t1[5] = e[5] - r[5], t1[6] = e[6] - r[6], t1[7] = e[7] - r[7], t1[8] = e[8] - r[8], t1;
        }
        E.mul = R, E.sub = V;
        var L = {};
        function O(t1) {
            return O = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                return typeof t1;
            } : function(t1) {
                return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
            }, O(t1);
        }
        Object.defineProperty(L, "__esModule", {
            value: !0
        }), L.create = function() {
            var t1 = new F.ARRAY_TYPE(16);
            return F.ARRAY_TYPE != Float32Array && (t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0), t1[0] = 1, t1[5] = 1, t1[10] = 1, t1[15] = 1, t1;
        }, L.clone = function(t1) {
            var e = new F.ARRAY_TYPE(16);
            return e[0] = t1[0], e[1] = t1[1], e[2] = t1[2], e[3] = t1[3], e[4] = t1[4], e[5] = t1[5], e[6] = t1[6], e[7] = t1[7], e[8] = t1[8], e[9] = t1[9], e[10] = t1[10], e[11] = t1[11], e[12] = t1[12], e[13] = t1[13], e[14] = t1[14], e[15] = t1[15], e;
        }, L.copy = function(t1, e) {
            return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1[4] = e[4], t1[5] = e[5], t1[6] = e[6], t1[7] = e[7], t1[8] = e[8], t1[9] = e[9], t1[10] = e[10], t1[11] = e[11], t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15], t1;
        }, L.fromValues = function(t1, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m) {
            var y = new F.ARRAY_TYPE(16);
            return y[0] = t1, y[1] = e, y[2] = r, y[3] = n, y[4] = i, y[5] = s, y[6] = a, y[7] = o, y[8] = l, y[9] = u, y[10] = c, y[11] = h, y[12] = p, y[13] = f, y[14] = d, y[15] = m, y;
        }, L.set = function(t1, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y) {
            return t1[0] = e, t1[1] = r, t1[2] = n, t1[3] = i, t1[4] = s, t1[5] = a, t1[6] = o, t1[7] = l, t1[8] = u, t1[9] = c, t1[10] = h, t1[11] = p, t1[12] = f, t1[13] = d, t1[14] = m, t1[15] = y, t1;
        }, L.identity = N, L.transpose = function(t1, e) {
            if (t1 === e) {
                var r = e[1], n = e[2], i = e[3], s = e[6], a = e[7], o = e[11];
                t1[1] = e[4], t1[2] = e[8], t1[3] = e[12], t1[4] = r, t1[6] = e[9], t1[7] = e[13], t1[8] = n, t1[9] = s, t1[11] = e[14], t1[12] = i, t1[13] = a, t1[14] = o;
            } else t1[0] = e[0], t1[1] = e[4], t1[2] = e[8], t1[3] = e[12], t1[4] = e[1], t1[5] = e[5], t1[6] = e[9], t1[7] = e[13], t1[8] = e[2], t1[9] = e[6], t1[10] = e[10], t1[11] = e[14], t1[12] = e[3], t1[13] = e[7], t1[14] = e[11], t1[15] = e[15];
            return t1;
        }, L.invert = function(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = e[4], o = e[5], l = e[6], u = e[7], c = e[8], h = e[9], p = e[10], f = e[11], d = e[12], m = e[13], y = e[14], g = e[15], x = r * o - n * a, b = r * l - i * a, v = r * u - s * a, _ = n * l - i * o, w = n * u - s * o, M = i * u - s * l, A = c * m - h * d, S = c * y - p * d, I = c * g - f * d, T = h * y - p * m, k = h * g - f * m, P = p * g - f * y, z = x * P - b * k + v * T + _ * I - w * S + M * A;
            return z ? (t1[0] = (o * P - l * k + u * T) * (z = 1 / z), t1[1] = (i * k - n * P - s * T) * z, t1[2] = (m * M - y * w + g * _) * z, t1[3] = (p * w - h * M - f * _) * z, t1[4] = (l * I - a * P - u * S) * z, t1[5] = (r * P - i * I + s * S) * z, t1[6] = (y * v - d * M - g * b) * z, t1[7] = (c * M - p * v + f * b) * z, t1[8] = (a * k - o * I + u * A) * z, t1[9] = (n * I - r * k - s * A) * z, t1[10] = (d * w - m * v + g * x) * z, t1[11] = (h * v - c * w - f * x) * z, t1[12] = (o * S - a * T - l * A) * z, t1[13] = (r * T - n * S + i * A) * z, t1[14] = (m * b - d * _ - y * x) * z, t1[15] = (c * _ - h * b + p * x) * z, t1) : null;
        }, L.adjoint = function(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = e[4], o = e[5], l = e[6], u = e[7], c = e[8], h = e[9], p = e[10], f = e[11], d = e[12], m = e[13], y = e[14], g = e[15];
            return t1[0] = o * (p * g - f * y) - h * (l * g - u * y) + m * (l * f - u * p), t1[1] = -(n * (p * g - f * y) - h * (i * g - s * y) + m * (i * f - s * p)), t1[2] = n * (l * g - u * y) - o * (i * g - s * y) + m * (i * u - s * l), t1[3] = -(n * (l * f - u * p) - o * (i * f - s * p) + h * (i * u - s * l)), t1[4] = -(a * (p * g - f * y) - c * (l * g - u * y) + d * (l * f - u * p)), t1[5] = r * (p * g - f * y) - c * (i * g - s * y) + d * (i * f - s * p), t1[6] = -(r * (l * g - u * y) - a * (i * g - s * y) + d * (i * u - s * l)), t1[7] = r * (l * f - u * p) - a * (i * f - s * p) + c * (i * u - s * l), t1[8] = a * (h * g - f * m) - c * (o * g - u * m) + d * (o * f - u * h), t1[9] = -(r * (h * g - f * m) - c * (n * g - s * m) + d * (n * f - s * h)), t1[10] = r * (o * g - u * m) - a * (n * g - s * m) + d * (n * u - s * o), t1[11] = -(r * (o * f - u * h) - a * (n * f - s * h) + c * (n * u - s * o)), t1[12] = -(a * (h * y - p * m) - c * (o * y - l * m) + d * (o * p - l * h)), t1[13] = r * (h * y - p * m) - c * (n * y - i * m) + d * (n * p - i * h), t1[14] = -(r * (o * y - l * m) - a * (n * y - i * m) + d * (n * l - i * o)), t1[15] = r * (o * p - l * h) - a * (n * p - i * h) + c * (n * l - i * o), t1;
        }, L.determinant = function(t1) {
            var e = t1[0], r = t1[1], n = t1[2], i = t1[3], s = t1[4], a = t1[5], o = t1[6], l = t1[7], u = t1[8], c = t1[9], h = t1[10], p = t1[11], f = t1[12], d = t1[13], m = t1[14], y = t1[15];
            return (e * a - r * s) * (h * y - p * m) - (e * o - n * s) * (c * y - p * d) + (e * l - i * s) * (c * m - h * d) + (r * o - n * a) * (u * y - p * f) - (r * l - i * a) * (u * m - h * f) + (n * l - i * o) * (u * d - c * f);
        }, L.multiply = j, L.translate = function(t1, e, r) {
            var n, i, s, a, o, l, u, c, h, p, f, d, m = r[0], y = r[1], g = r[2];
            return e === t1 ? (t1[12] = e[0] * m + e[4] * y + e[8] * g + e[12], t1[13] = e[1] * m + e[5] * y + e[9] * g + e[13], t1[14] = e[2] * m + e[6] * y + e[10] * g + e[14], t1[15] = e[3] * m + e[7] * y + e[11] * g + e[15]) : (i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], f = e[10], d = e[11], t1[0] = n = e[0], t1[1] = i, t1[2] = s, t1[3] = a, t1[4] = o, t1[5] = l, t1[6] = u, t1[7] = c, t1[8] = h, t1[9] = p, t1[10] = f, t1[11] = d, t1[12] = n * m + o * y + h * g + e[12], t1[13] = i * m + l * y + p * g + e[13], t1[14] = s * m + u * y + f * g + e[14], t1[15] = a * m + c * y + d * g + e[15]), t1;
        }, L.scale = function(t1, e, r) {
            var n = r[0], i = r[1], s = r[2];
            return t1[0] = e[0] * n, t1[1] = e[1] * n, t1[2] = e[2] * n, t1[3] = e[3] * n, t1[4] = e[4] * i, t1[5] = e[5] * i, t1[6] = e[6] * i, t1[7] = e[7] * i, t1[8] = e[8] * s, t1[9] = e[9] * s, t1[10] = e[10] * s, t1[11] = e[11] * s, t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15], t1;
        }, L.rotate = function(t1, e, r, n) {
            var i, s, a, o, l, u, c, h, p, f, d, m, y, g, x, b, v, _, w, M, A, S, I, T, k = n[0], P = n[1], z = n[2], E = Math.hypot(k, P, z);
            return E < F.EPSILON ? null : (k *= E = 1 / E, P *= E, z *= E, i = Math.sin(r), s = Math.cos(r), l = e[1], u = e[2], c = e[3], p = e[5], f = e[6], d = e[7], y = e[9], g = e[10], x = e[11], b = k * k * (a = 1 - s) + s, w = k * P * a - z * i, M = P * P * a + s, A = z * P * a + k * i, S = k * z * a + P * i, I = P * z * a - k * i, T = z * z * a + s, t1[0] = (o = e[0]) * b + (h = e[4]) * (v = P * k * a + z * i) + (m = e[8]) * (_ = z * k * a - P * i), t1[1] = l * b + p * v + y * _, t1[2] = u * b + f * v + g * _, t1[3] = c * b + d * v + x * _, t1[4] = o * w + h * M + m * A, t1[5] = l * w + p * M + y * A, t1[6] = u * w + f * M + g * A, t1[7] = c * w + d * M + x * A, t1[8] = o * S + h * I + m * T, t1[9] = l * S + p * I + y * T, t1[10] = u * S + f * I + g * T, t1[11] = c * S + d * I + x * T, e !== t1 && (t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15]), t1);
        }, L.rotateX = function(t1, e, r) {
            var n = Math.sin(r), i = Math.cos(r), s = e[4], a = e[5], o = e[6], l = e[7], u = e[8], c = e[9], h = e[10], p = e[11];
            return e !== t1 && (t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15]), t1[4] = s * i + u * n, t1[5] = a * i + c * n, t1[6] = o * i + h * n, t1[7] = l * i + p * n, t1[8] = u * i - s * n, t1[9] = c * i - a * n, t1[10] = h * i - o * n, t1[11] = p * i - l * n, t1;
        }, L.rotateY = function(t1, e, r) {
            var n = Math.sin(r), i = Math.cos(r), s = e[0], a = e[1], o = e[2], l = e[3], u = e[8], c = e[9], h = e[10], p = e[11];
            return e !== t1 && (t1[4] = e[4], t1[5] = e[5], t1[6] = e[6], t1[7] = e[7], t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15]), t1[0] = s * i - u * n, t1[1] = a * i - c * n, t1[2] = o * i - h * n, t1[3] = l * i - p * n, t1[8] = s * n + u * i, t1[9] = a * n + c * i, t1[10] = o * n + h * i, t1[11] = l * n + p * i, t1;
        }, L.rotateZ = function(t1, e, r) {
            var n = Math.sin(r), i = Math.cos(r), s = e[0], a = e[1], o = e[2], l = e[3], u = e[4], c = e[5], h = e[6], p = e[7];
            return e !== t1 && (t1[8] = e[8], t1[9] = e[9], t1[10] = e[10], t1[11] = e[11], t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15]), t1[0] = s * i + u * n, t1[1] = a * i + c * n, t1[2] = o * i + h * n, t1[3] = l * i + p * n, t1[4] = u * i - s * n, t1[5] = c * i - a * n, t1[6] = h * i - o * n, t1[7] = p * i - l * n, t1;
        }, L.fromTranslation = function(t1, e) {
            return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = 1, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 1, t1[11] = 0, t1[12] = e[0], t1[13] = e[1], t1[14] = e[2], t1[15] = 1, t1;
        }, L.fromScaling = function(t1, e) {
            return t1[0] = e[0], t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = e[1], t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = e[2], t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }, L.fromRotation = function(t1, e, r) {
            var n, i, s, a = r[0], o = r[1], l = r[2], u = Math.hypot(a, o, l);
            return u < F.EPSILON ? null : (a *= u = 1 / u, o *= u, l *= u, n = Math.sin(e), i = Math.cos(e), t1[0] = a * a * (s = 1 - i) + i, t1[1] = o * a * s + l * n, t1[2] = l * a * s - o * n, t1[3] = 0, t1[4] = a * o * s - l * n, t1[5] = o * o * s + i, t1[6] = l * o * s + a * n, t1[7] = 0, t1[8] = a * l * s + o * n, t1[9] = o * l * s - a * n, t1[10] = l * l * s + i, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1);
        }, L.fromXRotation = function(t1, e) {
            var r = Math.sin(e), n = Math.cos(e);
            return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = n, t1[6] = r, t1[7] = 0, t1[8] = 0, t1[9] = -r, t1[10] = n, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }, L.fromYRotation = function(t1, e) {
            var r = Math.sin(e), n = Math.cos(e);
            return t1[0] = n, t1[1] = 0, t1[2] = -r, t1[3] = 0, t1[4] = 0, t1[5] = 1, t1[6] = 0, t1[7] = 0, t1[8] = r, t1[9] = 0, t1[10] = n, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }, L.fromZRotation = function(t1, e) {
            var r = Math.sin(e), n = Math.cos(e);
            return t1[0] = n, t1[1] = r, t1[2] = 0, t1[3] = 0, t1[4] = -r, t1[5] = n, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 1, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }, L.fromRotationTranslation = q, L.fromQuat2 = function(t1, e) {
            var r = new F.ARRAY_TYPE(3), n = -e[0], i = -e[1], s = -e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = n * n + i * i + s * s + a * a;
            return h > 0 ? (r[0] = 2 * (o * a + c * n + l * s - u * i) / h, r[1] = 2 * (l * a + c * i + u * n - o * s) / h, r[2] = 2 * (u * a + c * s + o * i - l * n) / h) : (r[0] = 2 * (o * a + c * n + l * s - u * i), r[1] = 2 * (l * a + c * i + u * n - o * s), r[2] = 2 * (u * a + c * s + o * i - l * n)), q(t1, e, r), t1;
        }, L.getTranslation = function(t1, e) {
            return t1[0] = e[12], t1[1] = e[13], t1[2] = e[14], t1;
        }, L.getScaling = $, L.getRotation = function(t1, e) {
            var r = new F.ARRAY_TYPE(3);
            $(r, e);
            var n = 1 / r[0], i = 1 / r[1], s = 1 / r[2], a = e[0] * n, o = e[1] * i, l = e[2] * s, u = e[4] * n, c = e[5] * i, h = e[6] * s, p = e[8] * n, f = e[9] * i, d = e[10] * s, m = a + c + d, y = 0;
            return m > 0 ? (y = 2 * Math.sqrt(m + 1), t1[3] = .25 * y, t1[0] = (h - f) / y, t1[1] = (p - l) / y, t1[2] = (o - u) / y) : a > c && a > d ? (y = 2 * Math.sqrt(1 + a - c - d), t1[3] = (h - f) / y, t1[0] = .25 * y, t1[1] = (o + u) / y, t1[2] = (p + l) / y) : c > d ? (y = 2 * Math.sqrt(1 + c - a - d), t1[3] = (p - l) / y, t1[0] = (o + u) / y, t1[1] = .25 * y, t1[2] = (h + f) / y) : (y = 2 * Math.sqrt(1 + d - a - c), t1[3] = (o - u) / y, t1[0] = (p + l) / y, t1[1] = (h + f) / y, t1[2] = .25 * y), t1;
        }, L.fromRotationTranslationScale = function(t1, e, r, n) {
            var i = e[0], s = e[1], a = e[2], o = e[3], l = i + i, u = s + s, c = a + a, h = i * l, p = i * u, f = i * c, d = s * u, m = s * c, y = a * c, g = o * l, x = o * u, b = o * c, v = n[0], _ = n[1], w = n[2];
            return t1[0] = (1 - (d + y)) * v, t1[1] = (p + b) * v, t1[2] = (f - x) * v, t1[3] = 0, t1[4] = (p - b) * _, t1[5] = (1 - (h + y)) * _, t1[6] = (m + g) * _, t1[7] = 0, t1[8] = (f + x) * w, t1[9] = (m - g) * w, t1[10] = (1 - (h + d)) * w, t1[11] = 0, t1[12] = r[0], t1[13] = r[1], t1[14] = r[2], t1[15] = 1, t1;
        }, L.fromRotationTranslationScaleOrigin = function(t1, e, r, n, i) {
            var s = e[0], a = e[1], o = e[2], l = e[3], u = s + s, c = a + a, h = o + o, p = s * u, f = s * c, d = s * h, m = a * c, y = a * h, g = o * h, x = l * u, b = l * c, v = l * h, _ = n[0], w = n[1], M = n[2], A = i[0], S = i[1], I = i[2], T = (1 - (m + g)) * _, k = (f + v) * _, P = (d - b) * _, z = (f - v) * w, E = (1 - (p + g)) * w, B = (y + x) * w, D = (d + b) * M, C = (y - x) * M, R = (1 - (p + m)) * M;
            return t1[0] = T, t1[1] = k, t1[2] = P, t1[3] = 0, t1[4] = z, t1[5] = E, t1[6] = B, t1[7] = 0, t1[8] = D, t1[9] = C, t1[10] = R, t1[11] = 0, t1[12] = r[0] + A - (T * A + z * S + D * I), t1[13] = r[1] + S - (k * A + E * S + C * I), t1[14] = r[2] + I - (P * A + B * S + R * I), t1[15] = 1, t1;
        }, L.fromQuat = function(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = r + r, o = n + n, l = i + i, u = r * a, c = n * a, h = n * o, p = i * a, f = i * o, d = i * l, m = s * a, y = s * o, g = s * l;
            return t1[0] = 1 - h - d, t1[1] = c + g, t1[2] = p - y, t1[3] = 0, t1[4] = c - g, t1[5] = 1 - u - d, t1[6] = f + m, t1[7] = 0, t1[8] = p + y, t1[9] = f - m, t1[10] = 1 - u - h, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }, L.frustum = function(t1, e, r, n, i, s, a) {
            var o = 1 / (r - e), l = 1 / (i - n), u = 1 / (s - a);
            return t1[0] = 2 * s * o, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = 2 * s * l, t1[6] = 0, t1[7] = 0, t1[8] = (r + e) * o, t1[9] = (i + n) * l, t1[10] = (a + s) * u, t1[11] = -1, t1[12] = 0, t1[13] = 0, t1[14] = a * s * 2 * u, t1[15] = 0, t1;
        }, L.perspectiveNO = G, L.perspectiveZO = function(t1, e, r, n, i) {
            var s, a = 1 / Math.tan(e / 2);
            return t1[0] = a / r, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = a, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[11] = -1, t1[12] = 0, t1[13] = 0, t1[15] = 0, null != i && i !== 1 / 0 ? (t1[10] = i * (s = 1 / (n - i)), t1[14] = i * n * s) : (t1[10] = -1, t1[14] = -n), t1;
        }, L.perspectiveFromFieldOfView = function(t1, e, r, n) {
            var i = Math.tan(e.upDegrees * Math.PI / 180), s = Math.tan(e.downDegrees * Math.PI / 180), a = Math.tan(e.leftDegrees * Math.PI / 180), o = Math.tan(e.rightDegrees * Math.PI / 180), l = 2 / (a + o), u = 2 / (i + s);
            return t1[0] = l, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = u, t1[6] = 0, t1[7] = 0, t1[8] = -(a - o) * l * .5, t1[9] = (i - s) * u * .5, t1[10] = n / (r - n), t1[11] = -1, t1[12] = 0, t1[13] = 0, t1[14] = n * r / (r - n), t1[15] = 0, t1;
        }, L.orthoNO = Y, L.orthoZO = function(t1, e, r, n, i, s, a) {
            var o = 1 / (e - r), l = 1 / (n - i), u = 1 / (s - a);
            return t1[0] = -2 * o, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = -2 * l, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = u, t1[11] = 0, t1[12] = (e + r) * o, t1[13] = (i + n) * l, t1[14] = s * u, t1[15] = 1, t1;
        }, L.lookAt = function(t1, e, r, n) {
            var i, s, a, o, l, u, c, h, p, f, d = e[0], m = e[1], y = e[2], g = n[0], x = n[1], b = n[2], v = r[0], _ = r[1], w = r[2];
            return Math.abs(d - v) < F.EPSILON && Math.abs(m - _) < F.EPSILON && Math.abs(y - w) < F.EPSILON ? N(t1) : (c = d - v, h = m - _, p = y - w, i = x * (p *= f = 1 / Math.hypot(c, h, p)) - b * (h *= f), s = b * (c *= f) - g * p, a = g * h - x * c, (f = Math.hypot(i, s, a)) ? (i *= f = 1 / f, s *= f, a *= f) : (i = 0, s = 0, a = 0), o = h * a - p * s, l = p * i - c * a, u = c * s - h * i, (f = Math.hypot(o, l, u)) ? (o *= f = 1 / f, l *= f, u *= f) : (o = 0, l = 0, u = 0), t1[0] = i, t1[1] = o, t1[2] = c, t1[3] = 0, t1[4] = s, t1[5] = l, t1[6] = h, t1[7] = 0, t1[8] = a, t1[9] = u, t1[10] = p, t1[11] = 0, t1[12] = -(i * d + s * m + a * y), t1[13] = -(o * d + l * m + u * y), t1[14] = -(c * d + h * m + p * y), t1[15] = 1, t1);
        }, L.targetTo = function(t1, e, r, n) {
            var i = e[0], s = e[1], a = e[2], o = n[0], l = n[1], u = n[2], c = i - r[0], h = s - r[1], p = a - r[2], f = c * c + h * h + p * p;
            f > 0 && (c *= f = 1 / Math.sqrt(f), h *= f, p *= f);
            var d = l * p - u * h, m = u * c - o * p, y = o * h - l * c;
            return (f = d * d + m * m + y * y) > 0 && (d *= f = 1 / Math.sqrt(f), m *= f, y *= f), t1[0] = d, t1[1] = m, t1[2] = y, t1[3] = 0, t1[4] = h * y - p * m, t1[5] = p * d - c * y, t1[6] = c * m - h * d, t1[7] = 0, t1[8] = c, t1[9] = h, t1[10] = p, t1[11] = 0, t1[12] = i, t1[13] = s, t1[14] = a, t1[15] = 1, t1;
        }, L.str = function(t1) {
            return "mat4(" + t1[0] + ", " + t1[1] + ", " + t1[2] + ", " + t1[3] + ", " + t1[4] + ", " + t1[5] + ", " + t1[6] + ", " + t1[7] + ", " + t1[8] + ", " + t1[9] + ", " + t1[10] + ", " + t1[11] + ", " + t1[12] + ", " + t1[13] + ", " + t1[14] + ", " + t1[15] + ")";
        }, L.frob = function(t1) {
            return Math.hypot(t1[0], t1[1], t1[2], t1[3], t1[4], t1[5], t1[6], t1[7], t1[8], t1[9], t1[10], t1[11], t1[12], t1[13], t1[14], t1[15]);
        }, L.add = function(t1, e, r) {
            return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1[2] = e[2] + r[2], t1[3] = e[3] + r[3], t1[4] = e[4] + r[4], t1[5] = e[5] + r[5], t1[6] = e[6] + r[6], t1[7] = e[7] + r[7], t1[8] = e[8] + r[8], t1[9] = e[9] + r[9], t1[10] = e[10] + r[10], t1[11] = e[11] + r[11], t1[12] = e[12] + r[12], t1[13] = e[13] + r[13], t1[14] = e[14] + r[14], t1[15] = e[15] + r[15], t1;
        }, L.subtract = X, L.multiplyScalar = function(t1, e, r) {
            return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1[3] = e[3] * r, t1[4] = e[4] * r, t1[5] = e[5] * r, t1[6] = e[6] * r, t1[7] = e[7] * r, t1[8] = e[8] * r, t1[9] = e[9] * r, t1[10] = e[10] * r, t1[11] = e[11] * r, t1[12] = e[12] * r, t1[13] = e[13] * r, t1[14] = e[14] * r, t1[15] = e[15] * r, t1;
        }, L.multiplyScalarAndAdd = function(t1, e, r, n) {
            return t1[0] = e[0] + r[0] * n, t1[1] = e[1] + r[1] * n, t1[2] = e[2] + r[2] * n, t1[3] = e[3] + r[3] * n, t1[4] = e[4] + r[4] * n, t1[5] = e[5] + r[5] * n, t1[6] = e[6] + r[6] * n, t1[7] = e[7] + r[7] * n, t1[8] = e[8] + r[8] * n, t1[9] = e[9] + r[9] * n, t1[10] = e[10] + r[10] * n, t1[11] = e[11] + r[11] * n, t1[12] = e[12] + r[12] * n, t1[13] = e[13] + r[13] * n, t1[14] = e[14] + r[14] * n, t1[15] = e[15] + r[15] * n, t1;
        }, L.exactEquals = function(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2] && t1[3] === e[3] && t1[4] === e[4] && t1[5] === e[5] && t1[6] === e[6] && t1[7] === e[7] && t1[8] === e[8] && t1[9] === e[9] && t1[10] === e[10] && t1[11] === e[11] && t1[12] === e[12] && t1[13] === e[13] && t1[14] === e[14] && t1[15] === e[15];
        }, L.equals = function(t1, e) {
            var r = t1[0], n = t1[1], i = t1[2], s = t1[3], a = t1[4], o = t1[5], l = t1[6], u = t1[7], c = t1[8], h = t1[9], p = t1[10], f = t1[11], d = t1[12], m = t1[13], y = t1[14], g = t1[15], x = e[0], b = e[1], v = e[2], _ = e[3], w = e[4], M = e[5], A = e[6], S = e[7], I = e[8], T = e[9], k = e[10], P = e[11], z = e[12], E = e[13], B = e[14], D = e[15];
            return Math.abs(r - x) <= F.EPSILON * Math.max(1, Math.abs(r), Math.abs(x)) && Math.abs(n - b) <= F.EPSILON * Math.max(1, Math.abs(n), Math.abs(b)) && Math.abs(i - v) <= F.EPSILON * Math.max(1, Math.abs(i), Math.abs(v)) && Math.abs(s - _) <= F.EPSILON * Math.max(1, Math.abs(s), Math.abs(_)) && Math.abs(a - w) <= F.EPSILON * Math.max(1, Math.abs(a), Math.abs(w)) && Math.abs(o - M) <= F.EPSILON * Math.max(1, Math.abs(o), Math.abs(M)) && Math.abs(l - A) <= F.EPSILON * Math.max(1, Math.abs(l), Math.abs(A)) && Math.abs(u - S) <= F.EPSILON * Math.max(1, Math.abs(u), Math.abs(S)) && Math.abs(c - I) <= F.EPSILON * Math.max(1, Math.abs(c), Math.abs(I)) && Math.abs(h - T) <= F.EPSILON * Math.max(1, Math.abs(h), Math.abs(T)) && Math.abs(p - k) <= F.EPSILON * Math.max(1, Math.abs(p), Math.abs(k)) && Math.abs(f - P) <= F.EPSILON * Math.max(1, Math.abs(f), Math.abs(P)) && Math.abs(d - z) <= F.EPSILON * Math.max(1, Math.abs(d), Math.abs(z)) && Math.abs(m - E) <= F.EPSILON * Math.max(1, Math.abs(m), Math.abs(E)) && Math.abs(y - B) <= F.EPSILON * Math.max(1, Math.abs(y), Math.abs(B)) && Math.abs(g - D) <= F.EPSILON * Math.max(1, Math.abs(g), Math.abs(D));
        }, L.sub = L.mul = L.ortho = L.perspective = void 0;
        var F = function(t1, e) {
            if (t1 && t1.__esModule) return t1;
            if (null === t1 || "object" !== O(t1) && "function" != typeof t1) return {
                default: t1
            };
            var r = U(void 0);
            if (r && r.has(t1)) return r.get(t1);
            var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for(var s in t1)if ("default" !== s && Object.prototype.hasOwnProperty.call(t1, s)) {
                var a = i ? Object.getOwnPropertyDescriptor(t1, s) : null;
                a && (a.get || a.set) ? Object.defineProperty(n, s, a) : n[s] = t1[s];
            }
            return n.default = t1, r && r.set(t1, n), n;
        }(d);
        function U(t1) {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap, r = new WeakMap;
            return (U = function(t1) {
                return t1 ? r : e;
            })(t1);
        }
        function N(t1) {
            return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = 1, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 1, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }
        function j(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], f = e[10], d = e[11], m = e[12], y = e[13], g = e[14], x = e[15], b = r[0], v = r[1], _ = r[2], w = r[3];
            return t1[0] = b * n + v * o + _ * h + w * m, t1[1] = b * i + v * l + _ * p + w * y, t1[2] = b * s + v * u + _ * f + w * g, t1[3] = b * a + v * c + _ * d + w * x, t1[4] = (b = r[4]) * n + (v = r[5]) * o + (_ = r[6]) * h + (w = r[7]) * m, t1[5] = b * i + v * l + _ * p + w * y, t1[6] = b * s + v * u + _ * f + w * g, t1[7] = b * a + v * c + _ * d + w * x, t1[8] = (b = r[8]) * n + (v = r[9]) * o + (_ = r[10]) * h + (w = r[11]) * m, t1[9] = b * i + v * l + _ * p + w * y, t1[10] = b * s + v * u + _ * f + w * g, t1[11] = b * a + v * c + _ * d + w * x, t1[12] = (b = r[12]) * n + (v = r[13]) * o + (_ = r[14]) * h + (w = r[15]) * m, t1[13] = b * i + v * l + _ * p + w * y, t1[14] = b * s + v * u + _ * f + w * g, t1[15] = b * a + v * c + _ * d + w * x, t1;
        }
        function q(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = n + n, l = i + i, u = s + s, c = n * o, h = n * l, p = n * u, f = i * l, d = i * u, m = s * u, y = a * o, g = a * l, x = a * u;
            return t1[0] = 1 - (f + m), t1[1] = h + x, t1[2] = p - g, t1[3] = 0, t1[4] = h - x, t1[5] = 1 - (c + m), t1[6] = d + y, t1[7] = 0, t1[8] = p + g, t1[9] = d - y, t1[10] = 1 - (c + f), t1[11] = 0, t1[12] = r[0], t1[13] = r[1], t1[14] = r[2], t1[15] = 1, t1;
        }
        function $(t1, e) {
            var r = e[4], n = e[5], i = e[6], s = e[8], a = e[9], o = e[10];
            return t1[0] = Math.hypot(e[0], e[1], e[2]), t1[1] = Math.hypot(r, n, i), t1[2] = Math.hypot(s, a, o), t1;
        }
        function G(t1, e, r, n, i) {
            var s, a = 1 / Math.tan(e / 2);
            return t1[0] = a / r, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = a, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[11] = -1, t1[12] = 0, t1[13] = 0, t1[15] = 0, null != i && i !== 1 / 0 ? (t1[10] = (i + n) * (s = 1 / (n - i)), t1[14] = 2 * i * n * s) : (t1[10] = -1, t1[14] = -2 * n), t1;
        }
        function Y(t1, e, r, n, i, s, a) {
            var o = 1 / (e - r), l = 1 / (n - i), u = 1 / (s - a);
            return t1[0] = -2 * o, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = -2 * l, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 2 * u, t1[11] = 0, t1[12] = (e + r) * o, t1[13] = (i + n) * l, t1[14] = (a + s) * u, t1[15] = 1, t1;
        }
        function X(t1, e, r) {
            return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1[2] = e[2] - r[2], t1[3] = e[3] - r[3], t1[4] = e[4] - r[4], t1[5] = e[5] - r[5], t1[6] = e[6] - r[6], t1[7] = e[7] - r[7], t1[8] = e[8] - r[8], t1[9] = e[9] - r[9], t1[10] = e[10] - r[10], t1[11] = e[11] - r[11], t1[12] = e[12] - r[12], t1[13] = e[13] - r[13], t1[14] = e[14] - r[14], t1[15] = e[15] - r[15], t1;
        }
        L.perspective = G, L.ortho = Y, L.mul = j, L.sub = X;
        var Z = {}, H = {};
        function K(t1) {
            return K = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                return typeof t1;
            } : function(t1) {
                return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
            }, K(t1);
        }
        Object.defineProperty(H, "__esModule", {
            value: !0
        }), H.create = Q, H.clone = function(t1) {
            var e = new W.ARRAY_TYPE(3);
            return e[0] = t1[0], e[1] = t1[1], e[2] = t1[2], e;
        }, H.length = tt, H.fromValues = function(t1, e, r) {
            var n = new W.ARRAY_TYPE(3);
            return n[0] = t1, n[1] = e, n[2] = r, n;
        }, H.copy = function(t1, e) {
            return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1;
        }, H.set = function(t1, e, r, n) {
            return t1[0] = e, t1[1] = r, t1[2] = n, t1;
        }, H.add = function(t1, e, r) {
            return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1[2] = e[2] + r[2], t1;
        }, H.subtract = et, H.multiply = rt, H.divide = nt, H.ceil = function(t1, e) {
            return t1[0] = Math.ceil(e[0]), t1[1] = Math.ceil(e[1]), t1[2] = Math.ceil(e[2]), t1;
        }, H.floor = function(t1, e) {
            return t1[0] = Math.floor(e[0]), t1[1] = Math.floor(e[1]), t1[2] = Math.floor(e[2]), t1;
        }, H.min = function(t1, e, r) {
            return t1[0] = Math.min(e[0], r[0]), t1[1] = Math.min(e[1], r[1]), t1[2] = Math.min(e[2], r[2]), t1;
        }, H.max = function(t1, e, r) {
            return t1[0] = Math.max(e[0], r[0]), t1[1] = Math.max(e[1], r[1]), t1[2] = Math.max(e[2], r[2]), t1;
        }, H.round = function(t1, e) {
            return t1[0] = Math.round(e[0]), t1[1] = Math.round(e[1]), t1[2] = Math.round(e[2]), t1;
        }, H.scale = function(t1, e, r) {
            return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1;
        }, H.scaleAndAdd = function(t1, e, r, n) {
            return t1[0] = e[0] + r[0] * n, t1[1] = e[1] + r[1] * n, t1[2] = e[2] + r[2] * n, t1;
        }, H.distance = it, H.squaredDistance = st, H.squaredLength = at, H.negate = function(t1, e) {
            return t1[0] = -e[0], t1[1] = -e[1], t1[2] = -e[2], t1;
        }, H.inverse = function(t1, e) {
            return t1[0] = 1 / e[0], t1[1] = 1 / e[1], t1[2] = 1 / e[2], t1;
        }, H.normalize = function(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = r * r + n * n + i * i;
            return s > 0 && (s = 1 / Math.sqrt(s)), t1[0] = e[0] * s, t1[1] = e[1] * s, t1[2] = e[2] * s, t1;
        }, H.dot = ot, H.cross = function(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = r[0], o = r[1], l = r[2];
            return t1[0] = i * l - s * o, t1[1] = s * a - n * l, t1[2] = n * o - i * a, t1;
        }, H.lerp = function(t1, e, r, n) {
            var i = e[0], s = e[1], a = e[2];
            return t1[0] = i + n * (r[0] - i), t1[1] = s + n * (r[1] - s), t1[2] = a + n * (r[2] - a), t1;
        }, H.hermite = function(t1, e, r, n, i, s) {
            var a = s * s, o = a * (2 * s - 3) + 1, l = a * (s - 2) + s, u = a * (s - 1), c = a * (3 - 2 * s);
            return t1[0] = e[0] * o + r[0] * l + n[0] * u + i[0] * c, t1[1] = e[1] * o + r[1] * l + n[1] * u + i[1] * c, t1[2] = e[2] * o + r[2] * l + n[2] * u + i[2] * c, t1;
        }, H.bezier = function(t1, e, r, n, i, s) {
            var a = 1 - s, o = a * a, l = s * s, u = o * a, c = 3 * s * o, h = 3 * l * a, p = l * s;
            return t1[0] = e[0] * u + r[0] * c + n[0] * h + i[0] * p, t1[1] = e[1] * u + r[1] * c + n[1] * h + i[1] * p, t1[2] = e[2] * u + r[2] * c + n[2] * h + i[2] * p, t1;
        }, H.random = function(t1, e) {
            e = e || 1;
            var r = 2 * W.RANDOM() * Math.PI, n = 2 * W.RANDOM() - 1, i = Math.sqrt(1 - n * n) * e;
            return t1[0] = Math.cos(r) * i, t1[1] = Math.sin(r) * i, t1[2] = n * e, t1;
        }, H.transformMat4 = function(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = r[3] * n + r[7] * i + r[11] * s + r[15];
            return t1[0] = (r[0] * n + r[4] * i + r[8] * s + r[12]) / (a = a || 1), t1[1] = (r[1] * n + r[5] * i + r[9] * s + r[13]) / a, t1[2] = (r[2] * n + r[6] * i + r[10] * s + r[14]) / a, t1;
        }, H.transformMat3 = function(t1, e, r) {
            var n = e[0], i = e[1], s = e[2];
            return t1[0] = n * r[0] + i * r[3] + s * r[6], t1[1] = n * r[1] + i * r[4] + s * r[7], t1[2] = n * r[2] + i * r[5] + s * r[8], t1;
        }, H.transformQuat = function(t1, e, r) {
            var n = r[0], i = r[1], s = r[2], a = e[0], o = e[1], l = e[2], u = i * l - s * o, c = s * a - n * l, h = n * o - i * a, p = i * h - s * c, f = s * u - n * h, d = n * c - i * u, m = 2 * r[3];
            return c *= m, h *= m, f *= 2, d *= 2, t1[0] = a + (u *= m) + (p *= 2), t1[1] = o + c + f, t1[2] = l + h + d, t1;
        }, H.rotateX = function(t1, e, r, n) {
            var i = [], s = [];
            return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], s[0] = i[0], s[1] = i[1] * Math.cos(n) - i[2] * Math.sin(n), s[2] = i[1] * Math.sin(n) + i[2] * Math.cos(n), t1[0] = s[0] + r[0], t1[1] = s[1] + r[1], t1[2] = s[2] + r[2], t1;
        }, H.rotateY = function(t1, e, r, n) {
            var i = [], s = [];
            return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], s[0] = i[2] * Math.sin(n) + i[0] * Math.cos(n), s[1] = i[1], s[2] = i[2] * Math.cos(n) - i[0] * Math.sin(n), t1[0] = s[0] + r[0], t1[1] = s[1] + r[1], t1[2] = s[2] + r[2], t1;
        }, H.rotateZ = function(t1, e, r, n) {
            var i = [], s = [];
            return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], s[0] = i[0] * Math.cos(n) - i[1] * Math.sin(n), s[1] = i[0] * Math.sin(n) + i[1] * Math.cos(n), s[2] = i[2], t1[0] = s[0] + r[0], t1[1] = s[1] + r[1], t1[2] = s[2] + r[2], t1;
        }, H.angle = function(t1, e) {
            var r = t1[0], n = t1[1], i = t1[2], s = e[0], a = e[1], o = e[2], l = Math.sqrt(r * r + n * n + i * i) * Math.sqrt(s * s + a * a + o * o), u = l && ot(t1, e) / l;
            return Math.acos(Math.min(Math.max(u, -1), 1));
        }, H.zero = function(t1) {
            return t1[0] = 0, t1[1] = 0, t1[2] = 0, t1;
        }, H.str = function(t1) {
            return "vec3(" + t1[0] + ", " + t1[1] + ", " + t1[2] + ")";
        }, H.exactEquals = function(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2];
        }, H.equals = function(t1, e) {
            var r = t1[0], n = t1[1], i = t1[2], s = e[0], a = e[1], o = e[2];
            return Math.abs(r - s) <= W.EPSILON * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(n - a) <= W.EPSILON * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - o) <= W.EPSILON * Math.max(1, Math.abs(i), Math.abs(o));
        }, H.forEach = H.sqrLen = H.len = H.sqrDist = H.dist = H.div = H.mul = H.sub = void 0;
        var W = function(t1, e) {
            if (t1 && t1.__esModule) return t1;
            if (null === t1 || "object" !== K(t1) && "function" != typeof t1) return {
                default: t1
            };
            var r = J(void 0);
            if (r && r.has(t1)) return r.get(t1);
            var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for(var s in t1)if ("default" !== s && Object.prototype.hasOwnProperty.call(t1, s)) {
                var a = i ? Object.getOwnPropertyDescriptor(t1, s) : null;
                a && (a.get || a.set) ? Object.defineProperty(n, s, a) : n[s] = t1[s];
            }
            return n.default = t1, r && r.set(t1, n), n;
        }(d);
        function J(t1) {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap, r = new WeakMap;
            return (J = function(t1) {
                return t1 ? r : e;
            })(t1);
        }
        function Q() {
            var t1 = new W.ARRAY_TYPE(3);
            return W.ARRAY_TYPE != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0), t1;
        }
        function tt(t1) {
            return Math.hypot(t1[0], t1[1], t1[2]);
        }
        function et(t1, e, r) {
            return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1[2] = e[2] - r[2], t1;
        }
        function rt(t1, e, r) {
            return t1[0] = e[0] * r[0], t1[1] = e[1] * r[1], t1[2] = e[2] * r[2], t1;
        }
        function nt(t1, e, r) {
            return t1[0] = e[0] / r[0], t1[1] = e[1] / r[1], t1[2] = e[2] / r[2], t1;
        }
        function it(t1, e) {
            return Math.hypot(e[0] - t1[0], e[1] - t1[1], e[2] - t1[2]);
        }
        function st(t1, e) {
            var r = e[0] - t1[0], n = e[1] - t1[1], i = e[2] - t1[2];
            return r * r + n * n + i * i;
        }
        function at(t1) {
            var e = t1[0], r = t1[1], n = t1[2];
            return e * e + r * r + n * n;
        }
        function ot(t1, e) {
            return t1[0] * e[0] + t1[1] * e[1] + t1[2] * e[2];
        }
        H.sub = et, H.mul = rt, H.div = nt, H.dist = it, H.sqrDist = st, H.len = tt, H.sqrLen = at;
        var lt, ut = (lt = Q(), function(t1, e, r, n, i, s) {
            var a, o;
            for(e || (e = 3), r || (r = 0), o = n ? Math.min(n * e + r, t1.length) : t1.length, a = r; a < o; a += e)lt[0] = t1[a], lt[1] = t1[a + 1], lt[2] = t1[a + 2], i(lt, lt, s), t1[a] = lt[0], t1[a + 1] = lt[1], t1[a + 2] = lt[2];
            return t1;
        });
        H.forEach = ut;
        var ct = {};
        function ht(t1) {
            return ht = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                return typeof t1;
            } : function(t1) {
                return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
            }, ht(t1);
        }
        Object.defineProperty(ct, "__esModule", {
            value: !0
        }), ct.create = dt, ct.clone = function(t1) {
            var e = new pt.ARRAY_TYPE(4);
            return e[0] = t1[0], e[1] = t1[1], e[2] = t1[2], e[3] = t1[3], e;
        }, ct.fromValues = function(t1, e, r, n) {
            var i = new pt.ARRAY_TYPE(4);
            return i[0] = t1, i[1] = e, i[2] = r, i[3] = n, i;
        }, ct.copy = function(t1, e) {
            return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1;
        }, ct.set = function(t1, e, r, n, i) {
            return t1[0] = e, t1[1] = r, t1[2] = n, t1[3] = i, t1;
        }, ct.add = function(t1, e, r) {
            return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1[2] = e[2] + r[2], t1[3] = e[3] + r[3], t1;
        }, ct.subtract = mt, ct.multiply = yt, ct.divide = gt, ct.ceil = function(t1, e) {
            return t1[0] = Math.ceil(e[0]), t1[1] = Math.ceil(e[1]), t1[2] = Math.ceil(e[2]), t1[3] = Math.ceil(e[3]), t1;
        }, ct.floor = function(t1, e) {
            return t1[0] = Math.floor(e[0]), t1[1] = Math.floor(e[1]), t1[2] = Math.floor(e[2]), t1[3] = Math.floor(e[3]), t1;
        }, ct.min = function(t1, e, r) {
            return t1[0] = Math.min(e[0], r[0]), t1[1] = Math.min(e[1], r[1]), t1[2] = Math.min(e[2], r[2]), t1[3] = Math.min(e[3], r[3]), t1;
        }, ct.max = function(t1, e, r) {
            return t1[0] = Math.max(e[0], r[0]), t1[1] = Math.max(e[1], r[1]), t1[2] = Math.max(e[2], r[2]), t1[3] = Math.max(e[3], r[3]), t1;
        }, ct.round = function(t1, e) {
            return t1[0] = Math.round(e[0]), t1[1] = Math.round(e[1]), t1[2] = Math.round(e[2]), t1[3] = Math.round(e[3]), t1;
        }, ct.scale = function(t1, e, r) {
            return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1[3] = e[3] * r, t1;
        }, ct.scaleAndAdd = function(t1, e, r, n) {
            return t1[0] = e[0] + r[0] * n, t1[1] = e[1] + r[1] * n, t1[2] = e[2] + r[2] * n, t1[3] = e[3] + r[3] * n, t1;
        }, ct.distance = xt, ct.squaredDistance = bt, ct.length = vt, ct.squaredLength = _t, ct.negate = function(t1, e) {
            return t1[0] = -e[0], t1[1] = -e[1], t1[2] = -e[2], t1[3] = -e[3], t1;
        }, ct.inverse = function(t1, e) {
            return t1[0] = 1 / e[0], t1[1] = 1 / e[1], t1[2] = 1 / e[2], t1[3] = 1 / e[3], t1;
        }, ct.normalize = function(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = r * r + n * n + i * i + s * s;
            return a > 0 && (a = 1 / Math.sqrt(a)), t1[0] = r * a, t1[1] = n * a, t1[2] = i * a, t1[3] = s * a, t1;
        }, ct.dot = function(t1, e) {
            return t1[0] * e[0] + t1[1] * e[1] + t1[2] * e[2] + t1[3] * e[3];
        }, ct.cross = function(t1, e, r, n) {
            var i = r[0] * n[1] - r[1] * n[0], s = r[0] * n[2] - r[2] * n[0], a = r[0] * n[3] - r[3] * n[0], o = r[1] * n[2] - r[2] * n[1], l = r[1] * n[3] - r[3] * n[1], u = r[2] * n[3] - r[3] * n[2], c = e[0], h = e[1], p = e[2], f = e[3];
            return t1[0] = h * u - p * l + f * o, t1[1] = -c * u + p * a - f * s, t1[2] = c * l - h * a + f * i, t1[3] = -c * o + h * s - p * i, t1;
        }, ct.lerp = function(t1, e, r, n) {
            var i = e[0], s = e[1], a = e[2], o = e[3];
            return t1[0] = i + n * (r[0] - i), t1[1] = s + n * (r[1] - s), t1[2] = a + n * (r[2] - a), t1[3] = o + n * (r[3] - o), t1;
        }, ct.random = function(t1, e) {
            var r, n, i, s, a, o;
            e = e || 1;
            do a = (r = 2 * pt.RANDOM() - 1) * r + (n = 2 * pt.RANDOM() - 1) * n;
            while (a >= 1);
            do o = (i = 2 * pt.RANDOM() - 1) * i + (s = 2 * pt.RANDOM() - 1) * s;
            while (o >= 1);
            var l = Math.sqrt((1 - a) / o);
            return t1[0] = e * r, t1[1] = e * n, t1[2] = e * i * l, t1[3] = e * s * l, t1;
        }, ct.transformMat4 = function(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3];
            return t1[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * a, t1[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * a, t1[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * a, t1[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * a, t1;
        }, ct.transformQuat = function(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = r[0], o = r[1], l = r[2], u = r[3], c = u * n + o * s - l * i, h = u * i + l * n - a * s, p = u * s + a * i - o * n, f = -a * n - o * i - l * s;
            return t1[0] = c * u + f * -a + h * -l - p * -o, t1[1] = h * u + f * -o + p * -a - c * -l, t1[2] = p * u + f * -l + c * -o - h * -a, t1[3] = e[3], t1;
        }, ct.zero = function(t1) {
            return t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1;
        }, ct.str = function(t1) {
            return "vec4(" + t1[0] + ", " + t1[1] + ", " + t1[2] + ", " + t1[3] + ")";
        }, ct.exactEquals = function(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2] && t1[3] === e[3];
        }, ct.equals = function(t1, e) {
            var r = t1[0], n = t1[1], i = t1[2], s = t1[3], a = e[0], o = e[1], l = e[2], u = e[3];
            return Math.abs(r - a) <= pt.EPSILON * Math.max(1, Math.abs(r), Math.abs(a)) && Math.abs(n - o) <= pt.EPSILON * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(i - l) <= pt.EPSILON * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(s - u) <= pt.EPSILON * Math.max(1, Math.abs(s), Math.abs(u));
        }, ct.forEach = ct.sqrLen = ct.len = ct.sqrDist = ct.dist = ct.div = ct.mul = ct.sub = void 0;
        var pt = function(t1, e) {
            if (t1 && t1.__esModule) return t1;
            if (null === t1 || "object" !== ht(t1) && "function" != typeof t1) return {
                default: t1
            };
            var r = ft(void 0);
            if (r && r.has(t1)) return r.get(t1);
            var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for(var s in t1)if ("default" !== s && Object.prototype.hasOwnProperty.call(t1, s)) {
                var a = i ? Object.getOwnPropertyDescriptor(t1, s) : null;
                a && (a.get || a.set) ? Object.defineProperty(n, s, a) : n[s] = t1[s];
            }
            return n.default = t1, r && r.set(t1, n), n;
        }(d);
        function ft(t1) {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap, r = new WeakMap;
            return (ft = function(t1) {
                return t1 ? r : e;
            })(t1);
        }
        function dt() {
            var t1 = new pt.ARRAY_TYPE(4);
            return pt.ARRAY_TYPE != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 0), t1;
        }
        function mt(t1, e, r) {
            return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1[2] = e[2] - r[2], t1[3] = e[3] - r[3], t1;
        }
        function yt(t1, e, r) {
            return t1[0] = e[0] * r[0], t1[1] = e[1] * r[1], t1[2] = e[2] * r[2], t1[3] = e[3] * r[3], t1;
        }
        function gt(t1, e, r) {
            return t1[0] = e[0] / r[0], t1[1] = e[1] / r[1], t1[2] = e[2] / r[2], t1[3] = e[3] / r[3], t1;
        }
        function xt(t1, e) {
            return Math.hypot(e[0] - t1[0], e[1] - t1[1], e[2] - t1[2], e[3] - t1[3]);
        }
        function bt(t1, e) {
            var r = e[0] - t1[0], n = e[1] - t1[1], i = e[2] - t1[2], s = e[3] - t1[3];
            return r * r + n * n + i * i + s * s;
        }
        function vt(t1) {
            return Math.hypot(t1[0], t1[1], t1[2], t1[3]);
        }
        function _t(t1) {
            var e = t1[0], r = t1[1], n = t1[2], i = t1[3];
            return e * e + r * r + n * n + i * i;
        }
        ct.sub = mt, ct.mul = yt, ct.div = gt, ct.dist = xt, ct.sqrDist = bt, ct.len = vt, ct.sqrLen = _t;
        var wt = function() {
            var t1 = dt();
            return function(e, r, n, i, s, a) {
                var o, l;
                for(r || (r = 4), n || (n = 0), l = i ? Math.min(i * r + n, e.length) : e.length, o = n; o < l; o += r)t1[0] = e[o], t1[1] = e[o + 1], t1[2] = e[o + 2], t1[3] = e[o + 3], s(t1, t1, a), e[o] = t1[0], e[o + 1] = t1[1], e[o + 2] = t1[2], e[o + 3] = t1[3];
                return e;
            };
        }();
        function Mt(t1) {
            return Mt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                return typeof t1;
            } : function(t1) {
                return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
            }, Mt(t1);
        }
        ct.forEach = wt, Object.defineProperty(Z, "__esModule", {
            value: !0
        }), Z.create = zt, Z.identity = function(t1) {
            return t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1;
        }, Z.setAxisAngle = Et, Z.getAxisAngle = function(t1, e) {
            var r = 2 * Math.acos(e[3]), n = Math.sin(r / 2);
            return n > At.EPSILON ? (t1[0] = e[0] / n, t1[1] = e[1] / n, t1[2] = e[2] / n) : (t1[0] = 1, t1[1] = 0, t1[2] = 0), r;
        }, Z.getAngle = function(t1, e) {
            var r = Ot(t1, e);
            return Math.acos(2 * r * r - 1);
        }, Z.multiply = Bt, Z.rotateX = function(t1, e, r) {
            r *= .5;
            var n = e[0], i = e[1], s = e[2], a = e[3], o = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l + a * o, t1[1] = i * l + s * o, t1[2] = s * l - i * o, t1[3] = a * l - n * o, t1;
        }, Z.rotateY = function(t1, e, r) {
            r *= .5;
            var n = e[0], i = e[1], s = e[2], a = e[3], o = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l - s * o, t1[1] = i * l + a * o, t1[2] = s * l + n * o, t1[3] = a * l - i * o, t1;
        }, Z.rotateZ = function(t1, e, r) {
            r *= .5;
            var n = e[0], i = e[1], s = e[2], a = e[3], o = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l + i * o, t1[1] = i * l - n * o, t1[2] = s * l + a * o, t1[3] = a * l - s * o, t1;
        }, Z.calculateW = function(t1, e) {
            var r = e[0], n = e[1], i = e[2];
            return t1[0] = r, t1[1] = n, t1[2] = i, t1[3] = Math.sqrt(Math.abs(1 - r * r - n * n - i * i)), t1;
        }, Z.exp = Dt, Z.ln = Ct, Z.pow = function(t1, e, r) {
            return Ct(t1, e), Lt(t1, t1, r), Dt(t1, t1), t1;
        }, Z.slerp = Rt, Z.random = function(t1) {
            var e = At.RANDOM(), r = At.RANDOM(), n = At.RANDOM(), i = Math.sqrt(1 - e), s = Math.sqrt(e);
            return t1[0] = i * Math.sin(2 * Math.PI * r), t1[1] = i * Math.cos(2 * Math.PI * r), t1[2] = s * Math.sin(2 * Math.PI * n), t1[3] = s * Math.cos(2 * Math.PI * n), t1;
        }, Z.invert = function(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = r * r + n * n + i * i + s * s, o = a ? 1 / a : 0;
            return t1[0] = -r * o, t1[1] = -n * o, t1[2] = -i * o, t1[3] = s * o, t1;
        }, Z.conjugate = function(t1, e) {
            return t1[0] = -e[0], t1[1] = -e[1], t1[2] = -e[2], t1[3] = e[3], t1;
        }, Z.fromMat3 = Vt, Z.fromEuler = function(t1, e, r, n) {
            var i = .5 * Math.PI / 180;
            e *= i, r *= i, n *= i;
            var s = Math.sin(e), a = Math.cos(e), o = Math.sin(r), l = Math.cos(r), u = Math.sin(n), c = Math.cos(n);
            return t1[0] = s * l * c - a * o * u, t1[1] = a * o * c + s * l * u, t1[2] = a * l * u - s * o * c, t1[3] = a * l * c + s * o * u, t1;
        }, Z.str = function(t1) {
            return "quat(" + t1[0] + ", " + t1[1] + ", " + t1[2] + ", " + t1[3] + ")";
        }, Z.setAxes = Z.sqlerp = Z.rotationTo = Z.equals = Z.exactEquals = Z.normalize = Z.sqrLen = Z.squaredLength = Z.len = Z.length = Z.lerp = Z.dot = Z.scale = Z.mul = Z.add = Z.set = Z.copy = Z.fromValues = Z.clone = void 0;
        var At = Pt(d), St = Pt(E), It = Pt(H), Tt = Pt(ct);
        function kt(t1) {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap, r = new WeakMap;
            return (kt = function(t1) {
                return t1 ? r : e;
            })(t1);
        }
        function Pt(t1, e) {
            if (t1 && t1.__esModule) return t1;
            if (null === t1 || "object" !== Mt(t1) && "function" != typeof t1) return {
                default: t1
            };
            var r = kt(e);
            if (r && r.has(t1)) return r.get(t1);
            var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for(var s in t1)if ("default" !== s && Object.prototype.hasOwnProperty.call(t1, s)) {
                var a = i ? Object.getOwnPropertyDescriptor(t1, s) : null;
                a && (a.get || a.set) ? Object.defineProperty(n, s, a) : n[s] = t1[s];
            }
            return n.default = t1, r && r.set(t1, n), n;
        }
        function zt() {
            var t1 = new At.ARRAY_TYPE(4);
            return At.ARRAY_TYPE != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0), t1[3] = 1, t1;
        }
        function Et(t1, e, r) {
            r *= .5;
            var n = Math.sin(r);
            return t1[0] = n * e[0], t1[1] = n * e[1], t1[2] = n * e[2], t1[3] = Math.cos(r), t1;
        }
        function Bt(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = r[0], l = r[1], u = r[2], c = r[3];
            return t1[0] = n * c + a * o + i * u - s * l, t1[1] = i * c + a * l + s * o - n * u, t1[2] = s * c + a * u + n * l - i * o, t1[3] = a * c - n * o - i * l - s * u, t1;
        }
        function Dt(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = Math.sqrt(r * r + n * n + i * i), o = Math.exp(s), l = a > 0 ? o * Math.sin(a) / a : 0;
            return t1[0] = r * l, t1[1] = n * l, t1[2] = i * l, t1[3] = o * Math.cos(a), t1;
        }
        function Ct(t1, e) {
            var r = e[0], n = e[1], i = e[2], s = e[3], a = Math.sqrt(r * r + n * n + i * i), o = a > 0 ? Math.atan2(a, s) / a : 0;
            return t1[0] = r * o, t1[1] = n * o, t1[2] = i * o, t1[3] = .5 * Math.log(r * r + n * n + i * i + s * s), t1;
        }
        function Rt(t1, e, r, n) {
            var i, s, a, o, l, u = e[0], c = e[1], h = e[2], p = e[3], f = r[0], d = r[1], m = r[2], y = r[3];
            return (s = u * f + c * d + h * m + p * y) < 0 && (s = -s, f = -f, d = -d, m = -m, y = -y), 1 - s > At.EPSILON ? (i = Math.acos(s), a = Math.sin(i), o = Math.sin((1 - n) * i) / a, l = Math.sin(n * i) / a) : (o = 1 - n, l = n), t1[0] = o * u + l * f, t1[1] = o * c + l * d, t1[2] = o * h + l * m, t1[3] = o * p + l * y, t1;
        }
        function Vt(t1, e) {
            var r, n = e[0] + e[4] + e[8];
            if (n > 0) r = Math.sqrt(n + 1), t1[3] = .5 * r, t1[0] = (e[5] - e[7]) * (r = .5 / r), t1[1] = (e[6] - e[2]) * r, t1[2] = (e[1] - e[3]) * r;
            else {
                var i = 0;
                e[4] > e[0] && (i = 1), e[8] > e[3 * i + i] && (i = 2);
                var s = (i + 1) % 3, a = (i + 2) % 3;
                r = Math.sqrt(e[3 * i + i] - e[3 * s + s] - e[3 * a + a] + 1), t1[i] = .5 * r, t1[3] = (e[3 * s + a] - e[3 * a + s]) * (r = .5 / r), t1[s] = (e[3 * s + i] + e[3 * i + s]) * r, t1[a] = (e[3 * a + i] + e[3 * i + a]) * r;
            }
            return t1;
        }
        Z.clone = Tt.clone, Z.fromValues = Tt.fromValues, Z.copy = Tt.copy, Z.set = Tt.set, Z.add = Tt.add, Z.mul = Bt;
        var Lt = Tt.scale;
        Z.scale = Lt;
        var Ot = Tt.dot;
        Z.dot = Ot, Z.lerp = Tt.lerp;
        var Ft = Tt.length;
        Z.length = Ft, Z.len = Ft;
        var Ut = Tt.squaredLength;
        Z.squaredLength = Ut, Z.sqrLen = Ut;
        var Nt = Tt.normalize;
        Z.normalize = Nt, Z.exactEquals = Tt.exactEquals, Z.equals = Tt.equals;
        var jt, qt, $t, Gt = (jt = It.create(), qt = It.fromValues(1, 0, 0), $t = It.fromValues(0, 1, 0), function(t1, e, r) {
            var n = It.dot(e, r);
            return n < -0.999999 ? (It.cross(jt, qt, e), It.len(jt) < 1e-6 && It.cross(jt, $t, e), It.normalize(jt, jt), Et(t1, jt, Math.PI), t1) : n > .999999 ? (t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1) : (It.cross(jt, e, r), t1[0] = jt[0], t1[1] = jt[1], t1[2] = jt[2], t1[3] = 1 + n, Nt(t1, t1));
        });
        Z.rotationTo = Gt;
        var Yt, Xt, Zt = (Yt = zt(), Xt = zt(), function(t1, e, r, n, i, s) {
            return Rt(Yt, e, i, s), Rt(Xt, r, n, s), Rt(t1, Yt, Xt, 2 * s * (1 - s)), t1;
        });
        Z.sqlerp = Zt;
        var Ht, Kt = (Ht = St.create(), function(t1, e, r, n) {
            return Ht[0] = r[0], Ht[3] = r[1], Ht[6] = r[2], Ht[1] = n[0], Ht[4] = n[1], Ht[7] = n[2], Ht[2] = -e[0], Ht[5] = -e[1], Ht[8] = -e[2], Nt(t1, Vt(t1, Ht));
        });
        Z.setAxes = Kt;
        var Wt = {};
        function Jt(t1) {
            return Jt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                return typeof t1;
            } : function(t1) {
                return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
            }, Jt(t1);
        }
        Object.defineProperty(Wt, "__esModule", {
            value: !0
        }), Wt.create = function() {
            var t1 = new Qt.ARRAY_TYPE(8);
            return Qt.ARRAY_TYPE != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[4] = 0, t1[5] = 0, t1[6] = 0, t1[7] = 0), t1[3] = 1, t1;
        }, Wt.clone = function(t1) {
            var e = new Qt.ARRAY_TYPE(8);
            return e[0] = t1[0], e[1] = t1[1], e[2] = t1[2], e[3] = t1[3], e[4] = t1[4], e[5] = t1[5], e[6] = t1[6], e[7] = t1[7], e;
        }, Wt.fromValues = function(t1, e, r, n, i, s, a, o) {
            var l = new Qt.ARRAY_TYPE(8);
            return l[0] = t1, l[1] = e, l[2] = r, l[3] = n, l[4] = i, l[5] = s, l[6] = a, l[7] = o, l;
        }, Wt.fromRotationTranslationValues = function(t1, e, r, n, i, s, a) {
            var o = new Qt.ARRAY_TYPE(8);
            o[0] = t1, o[1] = e, o[2] = r, o[3] = n;
            var l = .5 * i, u = .5 * s, c = .5 * a;
            return o[4] = l * n + u * r - c * e, o[5] = u * n + c * t1 - l * r, o[6] = c * n + l * e - u * t1, o[7] = -l * t1 - u * e - c * r, o;
        }, Wt.fromRotationTranslation = ie, Wt.fromTranslation = function(t1, e) {
            return t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1[4] = .5 * e[0], t1[5] = .5 * e[1], t1[6] = .5 * e[2], t1[7] = 0, t1;
        }, Wt.fromRotation = function(t1, e) {
            return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1[4] = 0, t1[5] = 0, t1[6] = 0, t1[7] = 0, t1;
        }, Wt.fromMat4 = function(t1, e) {
            var r = te.create();
            ee.getRotation(r, e);
            var n = new Qt.ARRAY_TYPE(3);
            return ee.getTranslation(n, e), ie(t1, r, n), t1;
        }, Wt.copy = se, Wt.identity = function(t1) {
            return t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1[4] = 0, t1[5] = 0, t1[6] = 0, t1[7] = 0, t1;
        }, Wt.set = function(t1, e, r, n, i, s, a, o, l) {
            return t1[0] = e, t1[1] = r, t1[2] = n, t1[3] = i, t1[4] = s, t1[5] = a, t1[6] = o, t1[7] = l, t1;
        }, Wt.getDual = function(t1, e) {
            return t1[0] = e[4], t1[1] = e[5], t1[2] = e[6], t1[3] = e[7], t1;
        }, Wt.setDual = function(t1, e) {
            return t1[4] = e[0], t1[5] = e[1], t1[6] = e[2], t1[7] = e[3], t1;
        }, Wt.getTranslation = function(t1, e) {
            var r = e[4], n = e[5], i = e[6], s = e[7], a = -e[0], o = -e[1], l = -e[2], u = e[3];
            return t1[0] = 2 * (r * u + s * a + n * l - i * o), t1[1] = 2 * (n * u + s * o + i * a - r * l), t1[2] = 2 * (i * u + s * l + r * o - n * a), t1;
        }, Wt.translate = function(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = .5 * r[0], l = .5 * r[1], u = .5 * r[2], c = e[4], h = e[5], p = e[6], f = e[7];
            return t1[0] = n, t1[1] = i, t1[2] = s, t1[3] = a, t1[4] = a * o + i * u - s * l + c, t1[5] = a * l + s * o - n * u + h, t1[6] = a * u + n * l - i * o + p, t1[7] = -n * o - i * l - s * u + f, t1;
        }, Wt.rotateX = function(t1, e, r) {
            var n = -e[0], i = -e[1], s = -e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = o * a + c * n + l * s - u * i, p = l * a + c * i + u * n - o * s, f = u * a + c * s + o * i - l * n, d = c * a - o * n - l * i - u * s;
            return te.rotateX(t1, e, r), t1[4] = h * (a = t1[3]) + d * (n = t1[0]) + p * (s = t1[2]) - f * (i = t1[1]), t1[5] = p * a + d * i + f * n - h * s, t1[6] = f * a + d * s + h * i - p * n, t1[7] = d * a - h * n - p * i - f * s, t1;
        }, Wt.rotateY = function(t1, e, r) {
            var n = -e[0], i = -e[1], s = -e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = o * a + c * n + l * s - u * i, p = l * a + c * i + u * n - o * s, f = u * a + c * s + o * i - l * n, d = c * a - o * n - l * i - u * s;
            return te.rotateY(t1, e, r), t1[4] = h * (a = t1[3]) + d * (n = t1[0]) + p * (s = t1[2]) - f * (i = t1[1]), t1[5] = p * a + d * i + f * n - h * s, t1[6] = f * a + d * s + h * i - p * n, t1[7] = d * a - h * n - p * i - f * s, t1;
        }, Wt.rotateZ = function(t1, e, r) {
            var n = -e[0], i = -e[1], s = -e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = o * a + c * n + l * s - u * i, p = l * a + c * i + u * n - o * s, f = u * a + c * s + o * i - l * n, d = c * a - o * n - l * i - u * s;
            return te.rotateZ(t1, e, r), t1[4] = h * (a = t1[3]) + d * (n = t1[0]) + p * (s = t1[2]) - f * (i = t1[1]), t1[5] = p * a + d * i + f * n - h * s, t1[6] = f * a + d * s + h * i - p * n, t1[7] = d * a - h * n - p * i - f * s, t1;
        }, Wt.rotateByQuatAppend = function(t1, e, r) {
            var n = r[0], i = r[1], s = r[2], a = r[3], o = e[0], l = e[1], u = e[2], c = e[3];
            return t1[0] = o * a + c * n + l * s - u * i, t1[1] = l * a + c * i + u * n - o * s, t1[2] = u * a + c * s + o * i - l * n, t1[3] = c * a - o * n - l * i - u * s, t1[4] = (o = e[4]) * a + (c = e[7]) * n + (l = e[5]) * s - (u = e[6]) * i, t1[5] = l * a + c * i + u * n - o * s, t1[6] = u * a + c * s + o * i - l * n, t1[7] = c * a - o * n - l * i - u * s, t1;
        }, Wt.rotateByQuatPrepend = function(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = r[0], l = r[1], u = r[2], c = r[3];
            return t1[0] = n * c + a * o + i * u - s * l, t1[1] = i * c + a * l + s * o - n * u, t1[2] = s * c + a * u + n * l - i * o, t1[3] = a * c - n * o - i * l - s * u, t1[4] = n * (c = r[7]) + a * (o = r[4]) + i * (u = r[6]) - s * (l = r[5]), t1[5] = i * c + a * l + s * o - n * u, t1[6] = s * c + a * u + n * l - i * o, t1[7] = a * c - n * o - i * l - s * u, t1;
        }, Wt.rotateAroundAxis = function(t1, e, r, n) {
            if (Math.abs(n) < Qt.EPSILON) return se(t1, e);
            var i = Math.hypot(r[0], r[1], r[2]);
            n *= .5;
            var s = Math.sin(n), a = s * r[0] / i, o = s * r[1] / i, l = s * r[2] / i, u = Math.cos(n), c = e[0], h = e[1], p = e[2], f = e[3];
            t1[0] = c * u + f * a + h * l - p * o, t1[1] = h * u + f * o + p * a - c * l, t1[2] = p * u + f * l + c * o - h * a, t1[3] = f * u - c * a - h * o - p * l;
            var d = e[4], m = e[5], y = e[6], g = e[7];
            return t1[4] = d * u + g * a + m * l - y * o, t1[5] = m * u + g * o + y * a - d * l, t1[6] = y * u + g * l + d * o - m * a, t1[7] = g * u - d * a - m * o - y * l, t1;
        }, Wt.add = function(t1, e, r) {
            return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1[2] = e[2] + r[2], t1[3] = e[3] + r[3], t1[4] = e[4] + r[4], t1[5] = e[5] + r[5], t1[6] = e[6] + r[6], t1[7] = e[7] + r[7], t1;
        }, Wt.multiply = ae, Wt.scale = function(t1, e, r) {
            return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1[3] = e[3] * r, t1[4] = e[4] * r, t1[5] = e[5] * r, t1[6] = e[6] * r, t1[7] = e[7] * r, t1;
        }, Wt.lerp = function(t1, e, r, n) {
            var i = 1 - n;
            return oe(e, r) < 0 && (n = -n), t1[0] = e[0] * i + r[0] * n, t1[1] = e[1] * i + r[1] * n, t1[2] = e[2] * i + r[2] * n, t1[3] = e[3] * i + r[3] * n, t1[4] = e[4] * i + r[4] * n, t1[5] = e[5] * i + r[5] * n, t1[6] = e[6] * i + r[6] * n, t1[7] = e[7] * i + r[7] * n, t1;
        }, Wt.invert = function(t1, e) {
            var r = ue(e);
            return t1[0] = -e[0] / r, t1[1] = -e[1] / r, t1[2] = -e[2] / r, t1[3] = e[3] / r, t1[4] = -e[4] / r, t1[5] = -e[5] / r, t1[6] = -e[6] / r, t1[7] = e[7] / r, t1;
        }, Wt.conjugate = function(t1, e) {
            return t1[0] = -e[0], t1[1] = -e[1], t1[2] = -e[2], t1[3] = e[3], t1[4] = -e[4], t1[5] = -e[5], t1[6] = -e[6], t1[7] = e[7], t1;
        }, Wt.normalize = function(t1, e) {
            var r = ue(e);
            if (r > 0) {
                r = Math.sqrt(r);
                var n = e[0] / r, i = e[1] / r, s = e[2] / r, a = e[3] / r, o = e[4], l = e[5], u = e[6], c = e[7], h = n * o + i * l + s * u + a * c;
                t1[0] = n, t1[1] = i, t1[2] = s, t1[3] = a, t1[4] = (o - n * h) / r, t1[5] = (l - i * h) / r, t1[6] = (u - s * h) / r, t1[7] = (c - a * h) / r;
            }
            return t1;
        }, Wt.str = function(t1) {
            return "quat2(" + t1[0] + ", " + t1[1] + ", " + t1[2] + ", " + t1[3] + ", " + t1[4] + ", " + t1[5] + ", " + t1[6] + ", " + t1[7] + ")";
        }, Wt.exactEquals = function(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2] && t1[3] === e[3] && t1[4] === e[4] && t1[5] === e[5] && t1[6] === e[6] && t1[7] === e[7];
        }, Wt.equals = function(t1, e) {
            var r = t1[0], n = t1[1], i = t1[2], s = t1[3], a = t1[4], o = t1[5], l = t1[6], u = t1[7], c = e[0], h = e[1], p = e[2], f = e[3], d = e[4], m = e[5], y = e[6], g = e[7];
            return Math.abs(r - c) <= Qt.EPSILON * Math.max(1, Math.abs(r), Math.abs(c)) && Math.abs(n - h) <= Qt.EPSILON * Math.max(1, Math.abs(n), Math.abs(h)) && Math.abs(i - p) <= Qt.EPSILON * Math.max(1, Math.abs(i), Math.abs(p)) && Math.abs(s - f) <= Qt.EPSILON * Math.max(1, Math.abs(s), Math.abs(f)) && Math.abs(a - d) <= Qt.EPSILON * Math.max(1, Math.abs(a), Math.abs(d)) && Math.abs(o - m) <= Qt.EPSILON * Math.max(1, Math.abs(o), Math.abs(m)) && Math.abs(l - y) <= Qt.EPSILON * Math.max(1, Math.abs(l), Math.abs(y)) && Math.abs(u - g) <= Qt.EPSILON * Math.max(1, Math.abs(u), Math.abs(g));
        }, Wt.sqrLen = Wt.squaredLength = Wt.len = Wt.length = Wt.dot = Wt.mul = Wt.setReal = Wt.getReal = void 0;
        var Qt = ne(d), te = ne(Z), ee = ne(L);
        function re(t1) {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap, r = new WeakMap;
            return (re = function(t1) {
                return t1 ? r : e;
            })(t1);
        }
        function ne(t1, e) {
            if (t1 && t1.__esModule) return t1;
            if (null === t1 || "object" !== Jt(t1) && "function" != typeof t1) return {
                default: t1
            };
            var r = re(e);
            if (r && r.has(t1)) return r.get(t1);
            var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for(var s in t1)if ("default" !== s && Object.prototype.hasOwnProperty.call(t1, s)) {
                var a = i ? Object.getOwnPropertyDescriptor(t1, s) : null;
                a && (a.get || a.set) ? Object.defineProperty(n, s, a) : n[s] = t1[s];
            }
            return n.default = t1, r && r.set(t1, n), n;
        }
        function ie(t1, e, r) {
            var n = .5 * r[0], i = .5 * r[1], s = .5 * r[2], a = e[0], o = e[1], l = e[2], u = e[3];
            return t1[0] = a, t1[1] = o, t1[2] = l, t1[3] = u, t1[4] = n * u + i * l - s * o, t1[5] = i * u + s * a - n * l, t1[6] = s * u + n * o - i * a, t1[7] = -n * a - i * o - s * l, t1;
        }
        function se(t1, e) {
            return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1[4] = e[4], t1[5] = e[5], t1[6] = e[6], t1[7] = e[7], t1;
        }
        function ae(t1, e, r) {
            var n = e[0], i = e[1], s = e[2], a = e[3], o = r[4], l = r[5], u = r[6], c = r[7], h = e[4], p = e[5], f = e[6], d = e[7], m = r[0], y = r[1], g = r[2], x = r[3];
            return t1[0] = n * x + a * m + i * g - s * y, t1[1] = i * x + a * y + s * m - n * g, t1[2] = s * x + a * g + n * y - i * m, t1[3] = a * x - n * m - i * y - s * g, t1[4] = n * c + a * o + i * u - s * l + h * x + d * m + p * g - f * y, t1[5] = i * c + a * l + s * o - n * u + p * x + d * y + f * m - h * g, t1[6] = s * c + a * u + n * l - i * o + f * x + d * g + h * y - p * m, t1[7] = a * c - n * o - i * l - s * u + d * x - h * m - p * y - f * g, t1;
        }
        Wt.getReal = te.copy, Wt.setReal = te.copy, Wt.mul = ae;
        var oe = te.dot;
        Wt.dot = oe;
        var le = te.length;
        Wt.length = le, Wt.len = le;
        var ue = te.squaredLength;
        Wt.squaredLength = ue, Wt.sqrLen = ue;
        var ce = {};
        function he(t1) {
            return he = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                return typeof t1;
            } : function(t1) {
                return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
            }, he(t1);
        }
        Object.defineProperty(ce, "__esModule", {
            value: !0
        }), ce.create = de, ce.clone = function(t1) {
            var e = new pe.ARRAY_TYPE(2);
            return e[0] = t1[0], e[1] = t1[1], e;
        }, ce.fromValues = function(t1, e) {
            var r = new pe.ARRAY_TYPE(2);
            return r[0] = t1, r[1] = e, r;
        }, ce.copy = function(t1, e) {
            return t1[0] = e[0], t1[1] = e[1], t1;
        }, ce.set = function(t1, e, r) {
            return t1[0] = e, t1[1] = r, t1;
        }, ce.add = function(t1, e, r) {
            return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1;
        }, ce.subtract = me, ce.multiply = ye, ce.divide = ge, ce.ceil = function(t1, e) {
            return t1[0] = Math.ceil(e[0]), t1[1] = Math.ceil(e[1]), t1;
        }, ce.floor = function(t1, e) {
            return t1[0] = Math.floor(e[0]), t1[1] = Math.floor(e[1]), t1;
        }, ce.min = function(t1, e, r) {
            return t1[0] = Math.min(e[0], r[0]), t1[1] = Math.min(e[1], r[1]), t1;
        }, ce.max = function(t1, e, r) {
            return t1[0] = Math.max(e[0], r[0]), t1[1] = Math.max(e[1], r[1]), t1;
        }, ce.round = function(t1, e) {
            return t1[0] = Math.round(e[0]), t1[1] = Math.round(e[1]), t1;
        }, ce.scale = function(t1, e, r) {
            return t1[0] = e[0] * r, t1[1] = e[1] * r, t1;
        }, ce.scaleAndAdd = function(t1, e, r, n) {
            return t1[0] = e[0] + r[0] * n, t1[1] = e[1] + r[1] * n, t1;
        }, ce.distance = xe, ce.squaredDistance = be, ce.length = ve, ce.squaredLength = _e, ce.negate = function(t1, e) {
            return t1[0] = -e[0], t1[1] = -e[1], t1;
        }, ce.inverse = function(t1, e) {
            return t1[0] = 1 / e[0], t1[1] = 1 / e[1], t1;
        }, ce.normalize = function(t1, e) {
            var r = e[0], n = e[1], i = r * r + n * n;
            return i > 0 && (i = 1 / Math.sqrt(i)), t1[0] = e[0] * i, t1[1] = e[1] * i, t1;
        }, ce.dot = function(t1, e) {
            return t1[0] * e[0] + t1[1] * e[1];
        }, ce.cross = function(t1, e, r) {
            var n = e[0] * r[1] - e[1] * r[0];
            return t1[0] = t1[1] = 0, t1[2] = n, t1;
        }, ce.lerp = function(t1, e, r, n) {
            var i = e[0], s = e[1];
            return t1[0] = i + n * (r[0] - i), t1[1] = s + n * (r[1] - s), t1;
        }, ce.random = function(t1, e) {
            e = e || 1;
            var r = 2 * pe.RANDOM() * Math.PI;
            return t1[0] = Math.cos(r) * e, t1[1] = Math.sin(r) * e, t1;
        }, ce.transformMat2 = function(t1, e, r) {
            var n = e[0], i = e[1];
            return t1[0] = r[0] * n + r[2] * i, t1[1] = r[1] * n + r[3] * i, t1;
        }, ce.transformMat2d = function(t1, e, r) {
            var n = e[0], i = e[1];
            return t1[0] = r[0] * n + r[2] * i + r[4], t1[1] = r[1] * n + r[3] * i + r[5], t1;
        }, ce.transformMat3 = function(t1, e, r) {
            var n = e[0], i = e[1];
            return t1[0] = r[0] * n + r[3] * i + r[6], t1[1] = r[1] * n + r[4] * i + r[7], t1;
        }, ce.transformMat4 = function(t1, e, r) {
            var n = e[0], i = e[1];
            return t1[0] = r[0] * n + r[4] * i + r[12], t1[1] = r[1] * n + r[5] * i + r[13], t1;
        }, ce.rotate = function(t1, e, r, n) {
            var i = e[0] - r[0], s = e[1] - r[1], a = Math.sin(n), o = Math.cos(n);
            return t1[0] = i * o - s * a + r[0], t1[1] = i * a + s * o + r[1], t1;
        }, ce.angle = function(t1, e) {
            var r = t1[0], n = t1[1], i = e[0], s = e[1], a = Math.sqrt(r * r + n * n) * Math.sqrt(i * i + s * s);
            return Math.acos(Math.min(Math.max(a && (r * i + n * s) / a, -1), 1));
        }, ce.zero = function(t1) {
            return t1[0] = 0, t1[1] = 0, t1;
        }, ce.str = function(t1) {
            return "vec2(" + t1[0] + ", " + t1[1] + ")";
        }, ce.exactEquals = function(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1];
        }, ce.equals = function(t1, e) {
            var r = t1[0], n = t1[1], i = e[0], s = e[1];
            return Math.abs(r - i) <= pe.EPSILON * Math.max(1, Math.abs(r), Math.abs(i)) && Math.abs(n - s) <= pe.EPSILON * Math.max(1, Math.abs(n), Math.abs(s));
        }, ce.forEach = ce.sqrLen = ce.sqrDist = ce.dist = ce.div = ce.mul = ce.sub = ce.len = void 0;
        var pe = function(t1, e) {
            if (t1 && t1.__esModule) return t1;
            if (null === t1 || "object" !== he(t1) && "function" != typeof t1) return {
                default: t1
            };
            var r = fe(void 0);
            if (r && r.has(t1)) return r.get(t1);
            var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for(var s in t1)if ("default" !== s && Object.prototype.hasOwnProperty.call(t1, s)) {
                var a = i ? Object.getOwnPropertyDescriptor(t1, s) : null;
                a && (a.get || a.set) ? Object.defineProperty(n, s, a) : n[s] = t1[s];
            }
            return n.default = t1, r && r.set(t1, n), n;
        }(d);
        function fe(t1) {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap, r = new WeakMap;
            return (fe = function(t1) {
                return t1 ? r : e;
            })(t1);
        }
        function de() {
            var t1 = new pe.ARRAY_TYPE(2);
            return pe.ARRAY_TYPE != Float32Array && (t1[0] = 0, t1[1] = 0), t1;
        }
        function me(t1, e, r) {
            return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1;
        }
        function ye(t1, e, r) {
            return t1[0] = e[0] * r[0], t1[1] = e[1] * r[1], t1;
        }
        function ge(t1, e, r) {
            return t1[0] = e[0] / r[0], t1[1] = e[1] / r[1], t1;
        }
        function xe(t1, e) {
            return Math.hypot(e[0] - t1[0], e[1] - t1[1]);
        }
        function be(t1, e) {
            var r = e[0] - t1[0], n = e[1] - t1[1];
            return r * r + n * n;
        }
        function ve(t1) {
            return Math.hypot(t1[0], t1[1]);
        }
        function _e(t1) {
            var e = t1[0], r = t1[1];
            return e * e + r * r;
        }
        ce.len = ve, ce.sub = me, ce.mul = ye, ce.div = ge, ce.dist = xe, ce.sqrDist = be, ce.sqrLen = _e;
        var we = function() {
            var t1 = de();
            return function(e, r, n, i, s, a) {
                var o, l;
                for(r || (r = 2), n || (n = 0), l = i ? Math.min(i * r + n, e.length) : e.length, o = n; o < l; o += r)t1[0] = e[o], t1[1] = e[o + 1], s(t1, t1, a), e[o] = t1[0], e[o + 1] = t1[1];
                return e;
            };
        }();
        function Me(t1) {
            return Me = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                return typeof t1;
            } : function(t1) {
                return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
            }, Me(t1);
        }
        ce.forEach = we, Object.defineProperty(f, "__esModule", {
            value: !0
        }), t1.aA = f.vec4 = t1._ = f.vec3 = f.vec2 = f.quat2 = t1.av = f.quat = t1.ad = f.mat4 = t1.bC = f.mat3 = f.mat2d = t1.aC = f.mat2 = f.glMatrix = void 0;
        var Ae = Re(d);
        f.glMatrix = Ae;
        var Se = Re(b);
        t1.aC = f.mat2 = Se;
        var Ie = Re(S);
        f.mat2d = Ie;
        var Te = Re(E);
        t1.bC = f.mat3 = Te;
        var ke = Re(L);
        t1.ad = f.mat4 = ke;
        var Pe = Re(Z);
        t1.av = f.quat = Pe;
        var ze = Re(Wt);
        f.quat2 = ze;
        var Ee = Re(ce);
        f.vec2 = Ee;
        var Be = Re(H);
        t1._ = f.vec3 = Be;
        var De = Re(ct);
        function Ce(t1) {
            if ("function" != typeof WeakMap) return null;
            var e = new WeakMap, r = new WeakMap;
            return (Ce = function(t1) {
                return t1 ? r : e;
            })(t1);
        }
        function Re(t1, e) {
            if (t1 && t1.__esModule) return t1;
            if (null === t1 || "object" !== Me(t1) && "function" != typeof t1) return {
                default: t1
            };
            var r = Ce(e);
            if (r && r.has(t1)) return r.get(t1);
            var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for(var s in t1)if ("default" !== s && Object.prototype.hasOwnProperty.call(t1, s)) {
                var a = i ? Object.getOwnPropertyDescriptor(t1, s) : null;
                a && (a.get || a.set) ? Object.defineProperty(n, s, a) : n[s] = t1[s];
            }
            return n.default = t1, r && r.set(t1, n), n;
        }
        t1.aA = f.vec4 = De;
        var Ve = Le;
        function Le(t1, e, r, n) {
            this.cx = 3 * t1, this.bx = 3 * (r - t1) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t1, this.p1y = e, this.p2x = r, this.p2y = n;
        }
        Le.prototype = {
            sampleCurveX: function(t1) {
                return ((this.ax * t1 + this.bx) * t1 + this.cx) * t1;
            },
            sampleCurveY: function(t1) {
                return ((this.ay * t1 + this.by) * t1 + this.cy) * t1;
            },
            sampleCurveDerivativeX: function(t1) {
                return (3 * this.ax * t1 + 2 * this.bx) * t1 + this.cx;
            },
            solveCurveX: function(t1, e) {
                if (void 0 === e && (e = 1e-6), t1 < 0) return 0;
                if (t1 > 1) return 1;
                for(var r = t1, n = 0; n < 8; n++){
                    var i = this.sampleCurveX(r) - t1;
                    if (Math.abs(i) < e) return r;
                    var s = this.sampleCurveDerivativeX(r);
                    if (Math.abs(s) < 1e-6) break;
                    r -= i / s;
                }
                var a = 0, o = 1;
                for(r = t1, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - t1) < e)); n++)t1 > i ? a = r : o = r, r = .5 * (o - a) + a;
                return r;
            },
            solve: function(t1, e) {
                return this.sampleCurveY(this.solveCurveX(t1, e));
            }
        };
        var Oe = p(Ve), Fe = Ue;
        function Ue(t1, e) {
            this.x = t1, this.y = e;
        }
        Ue.prototype = {
            clone: function() {
                return new Ue(this.x, this.y);
            },
            add: function(t1) {
                return this.clone()._add(t1);
            },
            sub: function(t1) {
                return this.clone()._sub(t1);
            },
            multByPoint: function(t1) {
                return this.clone()._multByPoint(t1);
            },
            divByPoint: function(t1) {
                return this.clone()._divByPoint(t1);
            },
            mult: function(t1) {
                return this.clone()._mult(t1);
            },
            div: function(t1) {
                return this.clone()._div(t1);
            },
            rotate: function(t1) {
                return this.clone()._rotate(t1);
            },
            rotateAround: function(t1, e) {
                return this.clone()._rotateAround(t1, e);
            },
            matMult: function(t1) {
                return this.clone()._matMult(t1);
            },
            unit: function() {
                return this.clone()._unit();
            },
            perp: function() {
                return this.clone()._perp();
            },
            round: function() {
                return this.clone()._round();
            },
            mag: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            equals: function(t1) {
                return this.x === t1.x && this.y === t1.y;
            },
            dist: function(t1) {
                return Math.sqrt(this.distSqr(t1));
            },
            distSqr: function(t1) {
                var e = t1.x - this.x, r = t1.y - this.y;
                return e * e + r * r;
            },
            angle: function() {
                return Math.atan2(this.y, this.x);
            },
            angleTo: function(t1) {
                return Math.atan2(this.y - t1.y, this.x - t1.x);
            },
            angleWith: function(t1) {
                return this.angleWithSep(t1.x, t1.y);
            },
            angleWithSep: function(t1, e) {
                return Math.atan2(this.x * e - this.y * t1, this.x * t1 + this.y * e);
            },
            _matMult: function(t1) {
                var e = t1[2] * this.x + t1[3] * this.y;
                return this.x = t1[0] * this.x + t1[1] * this.y, this.y = e, this;
            },
            _add: function(t1) {
                return this.x += t1.x, this.y += t1.y, this;
            },
            _sub: function(t1) {
                return this.x -= t1.x, this.y -= t1.y, this;
            },
            _mult: function(t1) {
                return this.x *= t1, this.y *= t1, this;
            },
            _div: function(t1) {
                return this.x /= t1, this.y /= t1, this;
            },
            _multByPoint: function(t1) {
                return this.x *= t1.x, this.y *= t1.y, this;
            },
            _divByPoint: function(t1) {
                return this.x /= t1.x, this.y /= t1.y, this;
            },
            _unit: function() {
                return this._div(this.mag()), this;
            },
            _perp: function() {
                var t1 = this.y;
                return this.y = this.x, this.x = -t1, this;
            },
            _rotate: function(t1) {
                var e = Math.cos(t1), r = Math.sin(t1), n = r * this.x + e * this.y;
                return this.x = e * this.x - r * this.y, this.y = n, this;
            },
            _rotateAround: function(t1, e) {
                var r = Math.cos(t1), n = Math.sin(t1), i = e.y + n * (this.x - e.x) + r * (this.y - e.y);
                return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;
            },
            _round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
            }
        }, Ue.convert = function(t1) {
            return t1 instanceof Ue ? t1 : Array.isArray(t1) ? new Ue(t1[0], t1[1]) : t1;
        };
        var Ne = p(Fe);
        const je = Math.PI / 180, qe = 180 / Math.PI;
        function $e(t1) {
            return t1 * je;
        }
        function Ge(t1) {
            return t1 * qe;
        }
        const Ye = [
            [
                0,
                0
            ],
            [
                1,
                0
            ],
            [
                1,
                1
            ],
            [
                0,
                1
            ]
        ];
        function Xe(t1) {
            if (t1 <= 0) return 0;
            if (t1 >= 1) return 1;
            const e = t1 * t1, r = e * t1;
            return 4 * (t1 < .5 ? r : 3 * (t1 - e) + r - .75);
        }
        function Ze(t1, e, r, n) {
            const i = new Oe(t1, e, r, n);
            return function(t1) {
                return i.solve(t1);
            };
        }
        const He = Ze(.25, .1, .25, 1);
        function Ke(t1, e, r) {
            return Math.min(r, Math.max(e, t1));
        }
        function We(t1, e, r) {
            return (r = Ke((r - t1) / (e - t1), 0, 1)) * r * (3 - 2 * r);
        }
        function Je(t1, e, r) {
            const n = r - e, i = ((t1 - e) % n + n) % n + e;
            return i === e ? r : i;
        }
        function Qe(t1, e, r) {
            if (!t1.length) return r(null, []);
            let n = t1.length;
            const i = new Array(t1.length);
            let s = null;
            t1.forEach((t1, a)=>{
                e(t1, (t1, e)=>{
                    t1 && (s = t1), i[a] = e, 0 == --n && r(s, i);
                });
            });
        }
        function tr(t1) {
            const e = [];
            for(const r in t1)e.push(t1[r]);
            return e;
        }
        function er(t1, ...e) {
            for (const r of e)for(const e in r)t1[e] = r[e];
            return t1;
        }
        let rr = 1;
        function nr() {
            return rr++;
        }
        function ir() {
            return function t1(e) {
                return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([
                    1e7
                ] + -[
                    1e3
                ] + -4000 + -8000 + -100000000000).replace(/[018]/g, t1);
            }();
        }
        function sr(t1) {
            return t1 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t1) / Math.LN2));
        }
        function ar(t1) {
            return !!t1 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t1);
        }
        function or(t1, e) {
            t1.forEach((t1)=>{
                e[t1] && (e[t1] = e[t1].bind(e));
            });
        }
        function lr(t1, e) {
            return -1 !== t1.indexOf(e, t1.length - e.length);
        }
        function ur(t1, e, r) {
            const n = {};
            for(const r in t1)n[r] = e.call(this, t1[r], r, t1);
            return n;
        }
        function cr(t1, e, r) {
            const n = {};
            for(const r in t1)e.call(this, t1[r], r, t1) && (n[r] = t1[r]);
            return n;
        }
        function hr(t1) {
            return Array.isArray(t1) ? t1.map(hr) : "object" == typeof t1 && t1 ? ur(t1, hr) : t1;
        }
        const pr = {};
        function fr(t1) {
            pr[t1] || ("undefined" != typeof console && console.warn(t1), pr[t1] = !0);
        }
        function dr(t1, e, r) {
            return (r.y - t1.y) * (e.x - t1.x) > (e.y - t1.y) * (r.x - t1.x);
        }
        function mr(t1) {
            let e = 0;
            for(let r, n, i = 0, s = t1.length, a = s - 1; i < s; a = i++)r = t1[i], n = t1[a], e += (n.x - r.x) * (r.y + n.y);
            return e;
        }
        function yr([t1, e, r]) {
            const n = $e(e + 90), i = $e(r);
            return {
                x: t1 * Math.cos(n) * Math.sin(i),
                y: t1 * Math.sin(n) * Math.sin(i),
                z: t1 * Math.cos(i),
                azimuthal: e,
                polar: r
            };
        }
        function gr() {
            return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        function xr(t1) {
            const e = {};
            if (t1.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t1, r, n, i)=>{
                const s = n || i;
                return e[r] = !s || s.toLowerCase(), "";
            }), e["max-age"]) {
                const t1 = parseInt(e["max-age"], 10);
                isNaN(t1) ? delete e["max-age"] : e["max-age"] = t1;
            }
            return e;
        }
        let br, vr, _r, wr, Mr, Ar, Sr = null;
        function Ir(t1) {
            try {
                const e = self[t1];
                return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0;
            } catch (t1) {
                return !1;
            }
        }
        function Tr(t1, e) {
            return [
                t1[4 * e],
                t1[4 * e + 1],
                t1[4 * e + 2],
                t1[4 * e + 3]
            ];
        }
        function kr(t1, e, r, n) {
            for(; e < r;){
                const i = e + r >> 1;
                t1[i] < n ? e = i + 1 : r = i;
            }
            return e;
        }
        function Pr(t1, e, r, n) {
            for(; e < r;){
                const i = e + r >> 1;
                t1[i] <= n ? e = i + 1 : r = i;
            }
            return e;
        }
        function zr(t1) {
            return t1 > 0 ? 1 / (1.001 - t1) : 1 + t1;
        }
        function Er(t1) {
            return t1 > 0 ? 1 - 1 / (1.001 - t1) : -t1;
        }
        function Br() {
            return null == br && (br = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof self.createImageBitmap), br;
        }
        const Dr = {
            now: ()=>void 0 !== wr ? wr : performance.now(),
            setNow (t1) {
                wr = t1;
            },
            restoreNow () {
                wr = void 0;
            },
            frame (t1) {
                const e = requestAnimationFrame(t1);
                return {
                    cancel: ()=>cancelAnimationFrame(e)
                };
            },
            getImageData (t1, e = 0) {
                const { width: r, height: n } = t1;
                Mr || (Mr = document.createElement("canvas"));
                const i = Mr.getContext("2d", {
                    willReadFrequently: !0
                });
                if (!i) throw new Error("failed to create canvas 2d context");
                return (r > Mr.width || n > Mr.height) && (Mr.width = r, Mr.height = n), i.clearRect(-e, -e, r + 2 * e, n + 2 * e), i.drawImage(t1, 0, 0, r, n), i.getImageData(-e, -e, r + 2 * e, n + 2 * e);
            },
            resolveURL: (t1)=>(vr || (vr = document.createElement("a")), vr.href = t1, vr.href),
            get devicePixelRatio () {
                return window.devicePixelRatio;
            },
            get prefersReducedMotion () {
                return !!window.matchMedia && (null == _r && (_r = window.matchMedia("(prefers-reduced-motion: reduce)")), _r.matches);
            },
            hasCanvasFingerprintNoise () {
                if (void 0 !== Ar) return Ar;
                if (!Br()) return Ar = !1, !1;
                const t1 = new OffscreenCanvas(85, 1), e = t1.getContext("2d", {
                    willReadFrequently: !0
                });
                let r = 0;
                for(let n = 0; n < t1.width; ++n)e.fillStyle = `rgba(${r++},${r++},${r++}, 255)`, e.fillRect(n, 0, 1, 1);
                const n = e.getImageData(0, 0, t1.width, t1.height);
                r = 0;
                for(let t1 = 0; t1 < n.data.length; ++t1)if (t1 % 4 != 3 && r++ !== n.data[t1]) return Ar = !0, !0;
                return Ar = !1, !1;
            }
        };
        function Cr(t1, e) {
            const r = t1.indexOf("?");
            if (r < 0) return `${t1}?${new URLSearchParams(e).toString()}`;
            const n = new URLSearchParams(t1.slice(r));
            for(const t1 in e)n.set(t1, e[t1]);
            return `${t1.slice(0, r)}?${n.toString()}`;
        }
        function Rr(t1, e = {
            persistentParams: []
        }) {
            const r = t1.indexOf("?");
            if (r < 0) return t1;
            const n = new URLSearchParams, i = new URLSearchParams(t1.slice(r));
            for (const t1 of e.persistentParams){
                const e = i.get(t1);
                e && n.set(t1, e);
            }
            const s = n.toString();
            return `${t1.slice(0, r)}${s.length > 0 ? `?${s}` : ""}`;
        }
        const Vr = "mapbox-tiles";
        let Lr = 500, Or = 50;
        let Fr, Ur;
        function Nr() {
            try {
                return caches;
            } catch (t1) {}
        }
        function jr() {
            const t1 = Nr();
            t1 && !Fr && (Fr = t1.open(Vr));
        }
        let qr = 1 / 0;
        const $r = {
            supported: !1,
            testSupport: function(t1) {
                !Xr && Yr && (Zr ? Kr(t1) : Gr = t1);
            }
        };
        let Gr, Yr, Xr = !1, Zr = !1;
        const Hr = "undefined" != typeof self ? self : {};
        function Kr(t1) {
            const e = t1.createTexture();
            t1.bindTexture(t1.TEXTURE_2D, e);
            try {
                if (t1.texImage2D(t1.TEXTURE_2D, 0, t1.RGBA, t1.RGBA, t1.UNSIGNED_BYTE, Yr), t1.isContextLost()) return;
                $r.supported = !0;
            } catch (t1) {}
            t1.deleteTexture(e), Xr = !0;
        }
        Hr.document && (Yr = Hr.document.createElement("img"), Yr.onload = function() {
            Gr && Kr(Gr), Gr = null, Zr = !0;
        }, Yr.onerror = function() {
            Xr = !0, Gr = null;
        }, Yr.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const Wr = {
            Unknown: "Unknown",
            Style: "Style",
            Source: "Source",
            Tile: "Tile",
            Glyphs: "Glyphs",
            SpriteImage: "SpriteImage",
            SpriteJSON: "SpriteJSON",
            Image: "Image",
            Model: "Model"
        };
        "function" == typeof Object.freeze && Object.freeze(Wr);
        class Jr extends Error {
            constructor(t1, e, r){
                401 === e && i(r) && (t1 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t1), this.status = e, this.url = r;
            }
            toString() {
                return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
            }
        }
        const Qr = gr() ? ()=>self.worker && self.worker.referrer : ()=>("blob:" === location.protocol ? parent : self).location.href;
        const tn = function(t1, e) {
            if (!(/^file:/.test(r = t1.url) || /^file:/.test(Qr()) && !/^\w+:/.test(r))) {
                if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal")) return function(t1, e) {
                    const r = new AbortController, n = new Request(t1.url, {
                        method: t1.method || "GET",
                        body: t1.body,
                        credentials: t1.credentials,
                        headers: t1.headers,
                        referrer: Qr(),
                        referrerPolicy: t1.referrerPolicy,
                        signal: r.signal
                    });
                    let s = !1, a = !1;
                    const o = (l = n.url).indexOf("sku=") > 0 && i(l);
                    var l;
                    "json" === t1.type && n.headers.set("Accept", "application/json");
                    const u = (r, i, s)=>{
                        if (a) return;
                        if (r && "SecurityError" !== r.message && fr(r.toString()), i && s) return c(i);
                        const l = Date.now();
                        fetch(n).then((r)=>{
                            if (r.ok) {
                                const t1 = o ? r.clone() : null;
                                return c(r, t1, l);
                            }
                            return e(new Jr(r.statusText, r.status, t1.url));
                        }).catch((r)=>{
                            "AbortError" !== r.name && e(new Error(`${r.message} ${t1.url}`));
                        });
                    }, c = (r, i, o)=>{
                        ("arrayBuffer" === t1.type ? r.arrayBuffer() : "json" === t1.type ? r.json() : r.text()).then((t1)=>{
                            a || (i && o && function(t1, e, r) {
                                if (jr(), !Fr) return;
                                const n = xr(e.headers.get("Cache-Control") || "");
                                if (n["no-store"]) return;
                                const i = {
                                    status: e.status,
                                    statusText: e.statusText,
                                    headers: new Headers
                                };
                                e.headers.forEach((t1, e)=>i.headers.set(e, t1)), n["max-age"] && i.headers.set("Expires", new Date(r + 1e3 * n["max-age"]).toUTCString());
                                const s = i.headers.get("Expires");
                                if (!s) return;
                                if (new Date(s).getTime() - r < 42e4) return;
                                let a = Rr(t1.url, {
                                    persistentParams: [
                                        "language",
                                        "worldview"
                                    ]
                                });
                                if (206 === e.status) {
                                    const e = t1.headers.get("Range");
                                    if (!e) return;
                                    i.status = 200, a = Cr(a, {
                                        range: e
                                    });
                                }
                                !function(t1, e) {
                                    if (void 0 === Ur) try {
                                        new Response(new ReadableStream), Ur = !0;
                                    } catch (t1) {
                                        Ur = !1;
                                    }
                                    Ur ? e(t1.body) : t1.blob().then(e);
                                }(e, (t1)=>{
                                    const r = new Response(200 !== (n = e.status) && 404 !== n && [
                                        101,
                                        103,
                                        204,
                                        205,
                                        304
                                    ].includes(n) ? null : t1, i);
                                    var n;
                                    jr(), Fr && Fr.then((t1)=>t1.put(a, r)).catch((t1)=>fr(t1.message));
                                });
                            }(n, i, o), s = !0, e(null, t1, r.headers.get("Cache-Control"), r.headers.get("Expires")));
                        }).catch((t1)=>{
                            a || e(new Error(t1.message));
                        });
                    };
                    return o ? function(t1, e) {
                        if (jr(), !Fr) return e(null);
                        Fr.then((r)=>{
                            let n = Rr(t1.url, {
                                persistentParams: [
                                    "language",
                                    "worldview"
                                ]
                            });
                            const i = t1.headers.get("Range");
                            i && (n = Cr(n, {
                                range: i
                            })), r.match(n).then((t1)=>{
                                const i = function(t1) {
                                    if (!t1) return !1;
                                    const e = new Date(t1.headers.get("Expires") || 0), r = xr(t1.headers.get("Cache-Control") || "");
                                    return e > Date.now() && !r["no-cache"];
                                }(t1);
                                r.delete(n), i && r.put(n, t1.clone()), e(null, t1, i);
                            }).catch(e);
                        }).catch(e);
                    }(n, u) : u(null, null), {
                        cancel: ()=>{
                            a = !0, s || r.abort();
                        }
                    };
                }(t1, e);
                if (gr() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t1, e, void 0, !0);
            }
            var r;
            return function(t1, e) {
                const r = new XMLHttpRequest;
                r.open(t1.method || "GET", t1.url, !0), "arrayBuffer" === t1.type && (r.responseType = "arraybuffer");
                for(const e in t1.headers)r.setRequestHeader(e, t1.headers[e]);
                return "json" === t1.type && (r.responseType = "text", r.setRequestHeader("Accept", "application/json")), r.withCredentials = "include" === t1.credentials, r.onerror = ()=>{
                    e(new Error(r.statusText));
                }, r.onload = ()=>{
                    if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {
                        let n = r.response;
                        if ("json" === t1.type) try {
                            n = JSON.parse(r.response);
                        } catch (t1) {
                            return e(t1);
                        }
                        e(null, n, r.getResponseHeader("Cache-Control"), r.getResponseHeader("Expires"));
                    } else e(new Jr(r.statusText, r.status, t1.url));
                }, r.send(t1.body), {
                    cancel: ()=>r.abort()
                };
            }(t1, e);
        }, en = function(t1, e) {
            return tn(er(t1, {
                type: "arrayBuffer"
            }), e);
        };
        function rn(t1) {
            const e = document.createElement("a");
            return e.href = t1, e.protocol === location.protocol && e.host === location.host;
        }
        const nn = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let sn, an;
        sn = [], an = 0;
        const on = function(t1, e) {
            if ($r.supported && (t1.headers || (t1.headers = {}), t1.headers.accept = "image/webp,*/*"), an >= n.MAX_PARALLEL_IMAGE_REQUESTS) {
                const r = {
                    requestParameters: t1,
                    callback: e,
                    cancelled: !1,
                    cancel () {
                        this.cancelled = !0;
                    }
                };
                return sn.push(r), r;
            }
            an++;
            let r = !1;
            const i = ()=>{
                if (!r) for(r = !0, an--; sn.length && an < n.MAX_PARALLEL_IMAGE_REQUESTS;){
                    const t1 = sn.shift(), { requestParameters: e, callback: r, cancelled: n } = t1;
                    n || (t1.cancel = on(e, r).cancel);
                }
            }, s = en(t1, (t1, r, n, s)=>{
                i(), t1 ? e(t1) : r && (self.createImageBitmap ? function(t1, e) {
                    const r = new Blob([
                        new Uint8Array(t1)
                    ], {
                        type: "image/png"
                    });
                    createImageBitmap(r).then((t1)=>{
                        e(null, t1);
                    }).catch((t1)=>{
                        e(new Error(`Could not load image because of ${t1.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                    });
                }(r, (t1, r)=>e(t1, r, n, s)) : function(t1, e) {
                    const r = new Image;
                    r.onload = ()=>{
                        e(null, r), URL.revokeObjectURL(r.src), r.onload = null, requestAnimationFrame(()=>{
                            r.src = nn;
                        });
                    }, r.onerror = ()=>e(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                    const n = new Blob([
                        new Uint8Array(t1)
                    ], {
                        type: "image/png"
                    });
                    r.src = t1.byteLength ? URL.createObjectURL(n) : nn;
                }(r, (t1, r)=>e(t1, r, n, s)));
            });
            return {
                cancel: ()=>{
                    s.cancel(), i();
                }
            };
        }, ln = "01", un = "NO_ACCESS_TOKEN", cn = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function hn(t1) {
            const e = t1.match(cn);
            if (!e) throw new Error("Unable to parse URL object");
            return {
                protocol: e[1],
                authority: e[2],
                path: e[3] || "/",
                params: e[4] ? e[4].split("&") : []
            };
        }
        function pn(t1) {
            const e = t1.params.length ? `?${t1.params.join("&")}` : "";
            return `${t1.protocol}://${t1.authority}${t1.path}${e}`;
        }
        const fn = "mapbox.eventData";
        function dn(t1) {
            if (!t1) return null;
            const e = t1.split(".");
            if (!e || 3 !== e.length) return null;
            try {
                return JSON.parse(decodeURIComponent(atob(e[1]).split("").map((t1)=>"%" + ("00" + t1.charCodeAt(0).toString(16)).slice(-2)).join("")));
            } catch (t1) {
                return null;
            }
        }
        class mn {
            constructor(t1){
                this.type = t1, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
            }
            getStorageKey(t1) {
                const e = dn(n.ACCESS_TOKEN);
                let r = "";
                return r = e && e.u ? btoa(encodeURIComponent(e.u).replace(/%([0-9A-F]{2})/g, (t1, e)=>String.fromCharCode(Number("0x" + e)))) : n.ACCESS_TOKEN || "", t1 ? `${fn}.${t1}:${r}` : `${fn}:${r}`;
            }
            fetchEventData() {
                const t1 = Ir("localStorage"), e = this.getStorageKey(), r = this.getStorageKey("uuid");
                if (t1) try {
                    const t1 = localStorage.getItem(e);
                    t1 && (this.eventData = JSON.parse(t1));
                    const n = localStorage.getItem(r);
                    n && (this.anonId = n);
                } catch (t1) {
                    fr("Unable to read from LocalStorage");
                }
            }
            saveEventData() {
                const t1 = Ir("localStorage"), e = this.getStorageKey(), r = this.getStorageKey("uuid"), n = this.anonId;
                if (t1 && n) try {
                    localStorage.setItem(r, n), Object.keys(this.eventData).length >= 1 && localStorage.setItem(e, JSON.stringify(this.eventData));
                } catch (t1) {
                    fr("Unable to write to LocalStorage");
                }
            }
            processRequests(t1) {}
            postEvent(t1, e, r, i) {
                if (!n.EVENTS_URL) return;
                const s = hn(n.EVENTS_URL);
                s.params.push(`access_token=${i || n.ACCESS_TOKEN || ""}`);
                const a = {
                    event: this.type,
                    created: new Date(t1).toISOString()
                }, o = e ? er(a, e) : a, l = {
                    url: pn(s),
                    headers: {
                        "Content-Type": "text/plain"
                    },
                    body: JSON.stringify([
                        o
                    ])
                };
                this.pendingRequest = function(t1, e) {
                    return tn(er(t1, {
                        method: "POST"
                    }), e);
                }(l, (t1)=>{
                    this.pendingRequest = null, r(t1), this.saveEventData(), this.processRequests(i);
                });
            }
            queueRequest(t1, e) {
                this.queue.push(t1), this.processRequests(e);
            }
        }
        const yn = new class extends mn {
            constructor(t1){
                super("appUserTurnstile"), this._customAccessToken = t1;
            }
            postTurnstileEvent(t1, e) {
                n.EVENTS_URL && n.ACCESS_TOKEN && Array.isArray(t1) && t1.some((t1)=>s(t1) || i(t1)) && this.queueRequest(Date.now(), e);
            }
            processRequests(t1) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
                const r = dn(n.ACCESS_TOKEN), i = r ? r.u : n.ACCESS_TOKEN;
                let s = i !== this.eventData.tokenU;
                ar(this.anonId) || (this.anonId = ir(), s = !0);
                const a = this.queue.shift();
                if (this.eventData.lastSuccess) {
                    const t1 = new Date(this.eventData.lastSuccess), e = new Date(a), r = (a - this.eventData.lastSuccess) / 864e5;
                    s = s || r >= 1 || r < -1 || t1.getDate() !== e.getDate();
                } else s = !0;
                s ? this.postEvent(a, {
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: e,
                    skuId: ln,
                    "enabled.telemetry": !1,
                    userId: this.anonId
                }, (t1)=>{
                    t1 || (this.eventData.lastSuccess = a, this.eventData.tokenU = i);
                }, t1) : this.processRequests();
            }
        }, gn = yn.postTurnstileEvent.bind(yn), xn = new class extends mn {
            constructor(){
                super("map.load"), this.success = {}, this.skuToken = "";
            }
            postMapLoadEvent(t1, e, r, i) {
                this.skuToken = e, this.errorCb = i, n.EVENTS_URL && (r || n.ACCESS_TOKEN ? this.queueRequest({
                    id: t1,
                    timestamp: Date.now()
                }, r) : this.errorCb(new Error(un)));
            }
            processRequests(t1) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { id: r, timestamp: n } = this.queue.shift();
                r && this.success[r] || (this.anonId || this.fetchEventData(), ar(this.anonId) || (this.anonId = ir()), this.postEvent(n, {
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: e,
                    skuId: ln,
                    skuToken: this.skuToken,
                    userId: this.anonId
                }, (t1)=>{
                    t1 ? this.errorCb(t1) : r && (this.success[r] = !0);
                }, t1));
            }
            remove() {
                this.errorCb = null;
            }
        }, bn = xn.postMapLoadEvent.bind(xn), vn = new class extends mn {
            constructor(){
                super("style.load"), this.eventIdPerMapInstanceMap = new Map, this.mapInstanceIdMap = new WeakMap;
            }
            getMapInstanceId(t1) {
                let e = this.mapInstanceIdMap.get(t1);
                return e || (e = ir(), this.mapInstanceIdMap.set(t1, e)), e;
            }
            getEventId(t1) {
                const e = this.eventIdPerMapInstanceMap.get(t1) || 0;
                return this.eventIdPerMapInstanceMap.set(t1, e + 1), e;
            }
            postStyleLoadEvent(t1, e) {
                const { map: r, style: i, importedStyles: s } = e;
                if (!n.EVENTS_URL || !t1 && !n.ACCESS_TOKEN) return;
                const a = this.getMapInstanceId(r), o = {
                    mapInstanceId: a,
                    eventId: this.getEventId(a),
                    style: i
                };
                s.length && (o.importedStyles = s), this.queueRequest({
                    timestamp: Date.now(),
                    payload: o
                }, t1);
            }
            processRequests(t1) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { timestamp: e, payload: r } = this.queue.shift();
                this.postEvent(e, r, ()=>{}, t1);
            }
        }, _n = vn.postStyleLoadEvent.bind(vn), wn = new class extends mn {
            constructor(){
                super("gljs.performance");
            }
            postPerformanceEvent(t1, e) {
                n.EVENTS_URL && (t1 || n.ACCESS_TOKEN) && this.queueRequest({
                    timestamp: Date.now(),
                    performanceData: e
                }, t1);
            }
            processRequests(t1) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { timestamp: r, performanceData: n } = this.queue.shift(), i = function(t1) {
                    const r = performance.getEntriesByType("resource"), n = performance.getEntriesByType("mark"), i = function(t1) {
                        const e = {};
                        if (t1) {
                            for(const r in t1)if ("other" !== r) for (const n of t1[r]){
                                const t1 = `${r}ResolveRangeMin`, i = `${r}ResolveRangeMax`, s = `${r}RequestCount`, a = `${r}RequestCachedCount`;
                                e[t1] = Math.min(e[t1] || 1 / 0, n.startTime), e[i] = Math.max(e[i] || -1 / 0, n.responseEnd);
                                const o = (t1)=>{
                                    void 0 === e[t1] && (e[t1] = 0), ++e[t1];
                                };
                                void 0 !== n.transferSize && 0 === n.transferSize && o(a), o(s);
                            }
                        }
                        return e;
                    }(function(t1, e) {
                        const r = {};
                        if (t1) for (const n of t1){
                            const t1 = e(n);
                            void 0 === r[t1] && (r[t1] = []), r[t1].push(n);
                        }
                        return r;
                    }(r, h)), s = window.devicePixelRatio, a = navigator.connection || navigator.mozConnection || navigator.webkitConnection, o = a ? a.effectiveType : void 0, c = {
                        counters: [],
                        metadata: [],
                        attributes: []
                    }, p = (t1, e, r)=>{
                        null != r && t1.push({
                            name: e,
                            value: r.toString()
                        });
                    };
                    for(const t1 in i)p(c.counters, t1, i[t1]);
                    if (t1.interactionRange[0] !== 1 / 0 && t1.interactionRange[1] !== -1 / 0 && (p(c.counters, "interactionRangeMin", t1.interactionRange[0]), p(c.counters, "interactionRangeMax", t1.interactionRange[1])), n) for (const t1 of Object.keys(u)){
                        const e = u[t1], r = n.find((t1)=>t1.name === e);
                        r && p(c.counters, e, r.startTime);
                    }
                    return p(c.counters, "visibilityHidden", t1.visibilityHidden), p(c.attributes, "style", function(t1) {
                        if (t1) for (const e of t1){
                            const t1 = e.name.split("?")[0];
                            if (l(t1)) {
                                const e = t1.split("/").slice(-2);
                                if (2 === e.length) return `mapbox://styles/${e[0]}/${e[1]}`;
                            }
                        }
                    }(r)), p(c.attributes, "terrainEnabled", t1.terrainEnabled ? "true" : "false"), p(c.attributes, "fogEnabled", t1.fogEnabled ? "true" : "false"), p(c.attributes, "projection", t1.projection), p(c.attributes, "zoom", t1.zoom), p(c.metadata, "devicePixelRatio", s), p(c.metadata, "connectionEffectiveType", o), p(c.metadata, "navigatorUserAgent", navigator.userAgent), p(c.metadata, "screenWidth", window.screen.width), p(c.metadata, "screenHeight", window.screen.height), p(c.metadata, "windowWidth", window.innerWidth), p(c.metadata, "windowHeight", window.innerHeight), p(c.metadata, "mapWidth", t1.width / s), p(c.metadata, "mapHeight", t1.height / s), p(c.metadata, "webglRenderer", t1.renderer), p(c.metadata, "webglVendor", t1.vendor), p(c.metadata, "sdkVersion", e), p(c.metadata, "sdkIdentifier", "mapbox-gl-js"), c;
                }(n);
                for (const t1 of i.metadata);
                for (const t1 of i.counters);
                for (const t1 of i.attributes);
                this.postEvent(r, i, ()=>{}, t1);
            }
        }, Mn = wn.postPerformanceEvent.bind(wn), An = new class extends mn {
            constructor(){
                super("map.auth"), this.success = {}, this.skuToken = "";
            }
            getSession(t1, e, r, i) {
                if (!n.API_URL || !n.SESSION_PATH) return;
                const s = hn(n.API_URL + n.SESSION_PATH);
                s.params.push(`sku=${e || ""}`), s.params.push(`access_token=${i || n.ACCESS_TOKEN || ""}`);
                const a = {
                    url: pn(s),
                    headers: {
                        "Content-Type": "text/plain"
                    }
                };
                this.pendingRequest = function(t1, e) {
                    return tn(er(t1, {
                        method: "GET"
                    }), e);
                }(a, (t1)=>{
                    this.pendingRequest = null, r(t1), this.saveEventData(), this.processRequests(i);
                });
            }
            getSessionAPI(t1, e, r, i) {
                this.skuToken = e, this.errorCb = i, n.SESSION_PATH && n.API_URL && (r || n.ACCESS_TOKEN ? this.queueRequest({
                    id: t1,
                    timestamp: Date.now()
                }, r) : this.errorCb(new Error(un)));
            }
            processRequests(t1) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { id: e, timestamp: r } = this.queue.shift();
                e && this.success[e] || this.getSession(r, this.skuToken, (t1)=>{
                    t1 ? this.errorCb(t1) : e && (this.success[e] = !0);
                }, t1);
            }
            remove() {
                this.errorCb = null;
            }
        }, Sn = An.getSessionAPI.bind(An), In = new Set;
        var Tn = {
            exports: {}
        }, kn = {
            exports: function(t1, e) {
                var r, n, i, s, a, o, l, u;
                for(n = t1.length - (r = 3 & t1.length), i = e, a = 3432918353, o = 461845907, u = 0; u < n;)l = 255 & t1.charCodeAt(u) | (255 & t1.charCodeAt(++u)) << 8 | (255 & t1.charCodeAt(++u)) << 16 | (255 & t1.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (s = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s >>> 16) & 65535) << 16);
                switch(l = 0, r){
                    case 3:
                        l ^= (255 & t1.charCodeAt(u + 2)) << 16;
                    case 2:
                        l ^= (255 & t1.charCodeAt(u + 1)) << 8;
                    case 1:
                        i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t1.charCodeAt(u))) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295;
                }
                return i ^= t1.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;
            }
        }, Pn = {
            exports: function(t1, e) {
                for(var r, n = t1.length, i = e ^ n, s = 0; n >= 4;)r = 1540483477 * (65535 & (r = 255 & t1.charCodeAt(s) | (255 & t1.charCodeAt(++s)) << 8 | (255 & t1.charCodeAt(++s)) << 16 | (255 & t1.charCodeAt(++s)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++s;
                switch(n){
                    case 3:
                        i ^= (255 & t1.charCodeAt(s + 2)) << 16;
                    case 2:
                        i ^= (255 & t1.charCodeAt(s + 1)) << 8;
                    case 1:
                        i = 1540483477 * (65535 & (i ^= 255 & t1.charCodeAt(s))) + ((1540483477 * (i >>> 16) & 65535) << 16);
                }
                return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;
            }
        }, zn = kn.exports, En = Pn.exports;
        Tn.exports = zn, Tn.exports.murmur3 = zn, Tn.exports.murmur2 = En;
        var Bn = p(Tn.exports);
        class Dn {
            constructor(t1, ...e){
                er(this, e[0] || {}), this.type = t1;
            }
        }
        class Cn extends Dn {
            constructor(t1, e = {}){
                super("error", er({
                    error: t1
                }, e));
            }
        }
        function Rn(t1, e, r) {
            r[t1] && -1 !== r[t1].indexOf(e) || (r[t1] = r[t1] || [], r[t1].push(e));
        }
        function Vn(t1, e, r) {
            if (r && r[t1]) {
                const n = r[t1].indexOf(e);
                -1 !== n && r[t1].splice(n, 1);
            }
        }
        class Ln {
            on(t1, e) {
                return this._listeners = this._listeners || {}, Rn(t1, e, this._listeners), this;
            }
            off(t1, e) {
                return Vn(t1, e, this._listeners), Vn(t1, e, this._oneTimeListeners), this;
            }
            once(t1, e) {
                return e ? (this._oneTimeListeners = this._oneTimeListeners || {}, Rn(t1, e, this._oneTimeListeners), this) : new Promise((e)=>this.once(t1, e));
            }
            fire(t1, e) {
                const r = "string" == typeof t1 ? new Dn(t1, e) : t1, n = r.type;
                if (this.listens(n)) {
                    r.target = this;
                    const t1 = this._listeners && this._listeners[n] ? this._listeners[n].slice() : [];
                    for (const e of t1)e.call(this, r);
                    const e = this._oneTimeListeners && this._oneTimeListeners[n] ? this._oneTimeListeners[n].slice() : [];
                    for (const t1 of e)Vn(n, t1, this._oneTimeListeners), t1.call(this, r);
                    const i = this._eventedParent;
                    i && (er(r, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(r));
                } else r instanceof Cn && console.error(r.error);
                return this;
            }
            listens(t1) {
                return !!(this._listeners && this._listeners[t1] && this._listeners[t1].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t1] && this._oneTimeListeners[t1].length > 0 || this._eventedParent && this._eventedParent.listens(t1));
            }
            setEventedParent(t1, e) {
                return this._eventedParent = t1, this._eventedParentData = e, this;
            }
        }
        t1.F = void 0;
        var On = {
            transparent: [
                0,
                0,
                0,
                0
            ],
            aliceblue: [
                240,
                248,
                255,
                1
            ],
            antiquewhite: [
                250,
                235,
                215,
                1
            ],
            aqua: [
                0,
                255,
                255,
                1
            ],
            aquamarine: [
                127,
                255,
                212,
                1
            ],
            azure: [
                240,
                255,
                255,
                1
            ],
            beige: [
                245,
                245,
                220,
                1
            ],
            bisque: [
                255,
                228,
                196,
                1
            ],
            black: [
                0,
                0,
                0,
                1
            ],
            blanchedalmond: [
                255,
                235,
                205,
                1
            ],
            blue: [
                0,
                0,
                255,
                1
            ],
            blueviolet: [
                138,
                43,
                226,
                1
            ],
            brown: [
                165,
                42,
                42,
                1
            ],
            burlywood: [
                222,
                184,
                135,
                1
            ],
            cadetblue: [
                95,
                158,
                160,
                1
            ],
            chartreuse: [
                127,
                255,
                0,
                1
            ],
            chocolate: [
                210,
                105,
                30,
                1
            ],
            coral: [
                255,
                127,
                80,
                1
            ],
            cornflowerblue: [
                100,
                149,
                237,
                1
            ],
            cornsilk: [
                255,
                248,
                220,
                1
            ],
            crimson: [
                220,
                20,
                60,
                1
            ],
            cyan: [
                0,
                255,
                255,
                1
            ],
            darkblue: [
                0,
                0,
                139,
                1
            ],
            darkcyan: [
                0,
                139,
                139,
                1
            ],
            darkgoldenrod: [
                184,
                134,
                11,
                1
            ],
            darkgray: [
                169,
                169,
                169,
                1
            ],
            darkgreen: [
                0,
                100,
                0,
                1
            ],
            darkgrey: [
                169,
                169,
                169,
                1
            ],
            darkkhaki: [
                189,
                183,
                107,
                1
            ],
            darkmagenta: [
                139,
                0,
                139,
                1
            ],
            darkolivegreen: [
                85,
                107,
                47,
                1
            ],
            darkorange: [
                255,
                140,
                0,
                1
            ],
            darkorchid: [
                153,
                50,
                204,
                1
            ],
            darkred: [
                139,
                0,
                0,
                1
            ],
            darksalmon: [
                233,
                150,
                122,
                1
            ],
            darkseagreen: [
                143,
                188,
                143,
                1
            ],
            darkslateblue: [
                72,
                61,
                139,
                1
            ],
            darkslategray: [
                47,
                79,
                79,
                1
            ],
            darkslategrey: [
                47,
                79,
                79,
                1
            ],
            darkturquoise: [
                0,
                206,
                209,
                1
            ],
            darkviolet: [
                148,
                0,
                211,
                1
            ],
            deeppink: [
                255,
                20,
                147,
                1
            ],
            deepskyblue: [
                0,
                191,
                255,
                1
            ],
            dimgray: [
                105,
                105,
                105,
                1
            ],
            dimgrey: [
                105,
                105,
                105,
                1
            ],
            dodgerblue: [
                30,
                144,
                255,
                1
            ],
            firebrick: [
                178,
                34,
                34,
                1
            ],
            floralwhite: [
                255,
                250,
                240,
                1
            ],
            forestgreen: [
                34,
                139,
                34,
                1
            ],
            fuchsia: [
                255,
                0,
                255,
                1
            ],
            gainsboro: [
                220,
                220,
                220,
                1
            ],
            ghostwhite: [
                248,
                248,
                255,
                1
            ],
            gold: [
                255,
                215,
                0,
                1
            ],
            goldenrod: [
                218,
                165,
                32,
                1
            ],
            gray: [
                128,
                128,
                128,
                1
            ],
            green: [
                0,
                128,
                0,
                1
            ],
            greenyellow: [
                173,
                255,
                47,
                1
            ],
            grey: [
                128,
                128,
                128,
                1
            ],
            honeydew: [
                240,
                255,
                240,
                1
            ],
            hotpink: [
                255,
                105,
                180,
                1
            ],
            indianred: [
                205,
                92,
                92,
                1
            ],
            indigo: [
                75,
                0,
                130,
                1
            ],
            ivory: [
                255,
                255,
                240,
                1
            ],
            khaki: [
                240,
                230,
                140,
                1
            ],
            lavender: [
                230,
                230,
                250,
                1
            ],
            lavenderblush: [
                255,
                240,
                245,
                1
            ],
            lawngreen: [
                124,
                252,
                0,
                1
            ],
            lemonchiffon: [
                255,
                250,
                205,
                1
            ],
            lightblue: [
                173,
                216,
                230,
                1
            ],
            lightcoral: [
                240,
                128,
                128,
                1
            ],
            lightcyan: [
                224,
                255,
                255,
                1
            ],
            lightgoldenrodyellow: [
                250,
                250,
                210,
                1
            ],
            lightgray: [
                211,
                211,
                211,
                1
            ],
            lightgreen: [
                144,
                238,
                144,
                1
            ],
            lightgrey: [
                211,
                211,
                211,
                1
            ],
            lightpink: [
                255,
                182,
                193,
                1
            ],
            lightsalmon: [
                255,
                160,
                122,
                1
            ],
            lightseagreen: [
                32,
                178,
                170,
                1
            ],
            lightskyblue: [
                135,
                206,
                250,
                1
            ],
            lightslategray: [
                119,
                136,
                153,
                1
            ],
            lightslategrey: [
                119,
                136,
                153,
                1
            ],
            lightsteelblue: [
                176,
                196,
                222,
                1
            ],
            lightyellow: [
                255,
                255,
                224,
                1
            ],
            lime: [
                0,
                255,
                0,
                1
            ],
            limegreen: [
                50,
                205,
                50,
                1
            ],
            linen: [
                250,
                240,
                230,
                1
            ],
            magenta: [
                255,
                0,
                255,
                1
            ],
            maroon: [
                128,
                0,
                0,
                1
            ],
            mediumaquamarine: [
                102,
                205,
                170,
                1
            ],
            mediumblue: [
                0,
                0,
                205,
                1
            ],
            mediumorchid: [
                186,
                85,
                211,
                1
            ],
            mediumpurple: [
                147,
                112,
                219,
                1
            ],
            mediumseagreen: [
                60,
                179,
                113,
                1
            ],
            mediumslateblue: [
                123,
                104,
                238,
                1
            ],
            mediumspringgreen: [
                0,
                250,
                154,
                1
            ],
            mediumturquoise: [
                72,
                209,
                204,
                1
            ],
            mediumvioletred: [
                199,
                21,
                133,
                1
            ],
            midnightblue: [
                25,
                25,
                112,
                1
            ],
            mintcream: [
                245,
                255,
                250,
                1
            ],
            mistyrose: [
                255,
                228,
                225,
                1
            ],
            moccasin: [
                255,
                228,
                181,
                1
            ],
            navajowhite: [
                255,
                222,
                173,
                1
            ],
            navy: [
                0,
                0,
                128,
                1
            ],
            oldlace: [
                253,
                245,
                230,
                1
            ],
            olive: [
                128,
                128,
                0,
                1
            ],
            olivedrab: [
                107,
                142,
                35,
                1
            ],
            orange: [
                255,
                165,
                0,
                1
            ],
            orangered: [
                255,
                69,
                0,
                1
            ],
            orchid: [
                218,
                112,
                214,
                1
            ],
            palegoldenrod: [
                238,
                232,
                170,
                1
            ],
            palegreen: [
                152,
                251,
                152,
                1
            ],
            paleturquoise: [
                175,
                238,
                238,
                1
            ],
            palevioletred: [
                219,
                112,
                147,
                1
            ],
            papayawhip: [
                255,
                239,
                213,
                1
            ],
            peachpuff: [
                255,
                218,
                185,
                1
            ],
            peru: [
                205,
                133,
                63,
                1
            ],
            pink: [
                255,
                192,
                203,
                1
            ],
            plum: [
                221,
                160,
                221,
                1
            ],
            powderblue: [
                176,
                224,
                230,
                1
            ],
            purple: [
                128,
                0,
                128,
                1
            ],
            rebeccapurple: [
                102,
                51,
                153,
                1
            ],
            red: [
                255,
                0,
                0,
                1
            ],
            rosybrown: [
                188,
                143,
                143,
                1
            ],
            royalblue: [
                65,
                105,
                225,
                1
            ],
            saddlebrown: [
                139,
                69,
                19,
                1
            ],
            salmon: [
                250,
                128,
                114,
                1
            ],
            sandybrown: [
                244,
                164,
                96,
                1
            ],
            seagreen: [
                46,
                139,
                87,
                1
            ],
            seashell: [
                255,
                245,
                238,
                1
            ],
            sienna: [
                160,
                82,
                45,
                1
            ],
            silver: [
                192,
                192,
                192,
                1
            ],
            skyblue: [
                135,
                206,
                235,
                1
            ],
            slateblue: [
                106,
                90,
                205,
                1
            ],
            slategray: [
                112,
                128,
                144,
                1
            ],
            slategrey: [
                112,
                128,
                144,
                1
            ],
            snow: [
                255,
                250,
                250,
                1
            ],
            springgreen: [
                0,
                255,
                127,
                1
            ],
            steelblue: [
                70,
                130,
                180,
                1
            ],
            tan: [
                210,
                180,
                140,
                1
            ],
            teal: [
                0,
                128,
                128,
                1
            ],
            thistle: [
                216,
                191,
                216,
                1
            ],
            tomato: [
                255,
                99,
                71,
                1
            ],
            turquoise: [
                64,
                224,
                208,
                1
            ],
            violet: [
                238,
                130,
                238,
                1
            ],
            wheat: [
                245,
                222,
                179,
                1
            ],
            white: [
                255,
                255,
                255,
                1
            ],
            whitesmoke: [
                245,
                245,
                245,
                1
            ],
            yellow: [
                255,
                255,
                0,
                1
            ],
            yellowgreen: [
                154,
                205,
                50,
                1
            ]
        };
        function Fn(t1) {
            return (t1 = Math.round(t1)) < 0 ? 0 : t1 > 255 ? 255 : t1;
        }
        function Un(t1) {
            return Fn("%" === t1[t1.length - 1] ? parseFloat(t1) / 100 * 255 : parseInt(t1));
        }
        function Nn(t1) {
            var e;
            return (e = "%" === t1[t1.length - 1] ? parseFloat(t1) / 100 : parseFloat(t1)) < 0 ? 0 : e > 1 ? 1 : e;
        }
        function jn(t1, e, r) {
            return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t1 + (e - t1) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t1 + (e - t1) * (2 / 3 - r) * 6 : t1;
        }
        try {
            t1.F = ({}).parseCSSColor = function(t1) {
                var e, r = t1.replace(/ /g, "").toLowerCase();
                if (r in On) return On[r].slice();
                if ("#" === r[0]) return 4 === r.length ? (e = parseInt(r.substr(1), 16)) >= 0 && e <= 4095 ? [
                    (3840 & e) >> 4 | (3840 & e) >> 8,
                    240 & e | (240 & e) >> 4,
                    15 & e | (15 & e) << 4,
                    1
                ] : null : 7 === r.length && (e = parseInt(r.substr(1), 16)) >= 0 && e <= 16777215 ? [
                    (16711680 & e) >> 16,
                    (65280 & e) >> 8,
                    255 & e,
                    1
                ] : null;
                var n = r.indexOf("("), i = r.indexOf(")");
                if (-1 !== n && i + 1 === r.length) {
                    var s = r.substr(0, n), a = r.substr(n + 1, i - (n + 1)).split(","), o = 1;
                    switch(s){
                        case "rgba":
                            if (4 !== a.length) return null;
                            o = Nn(a.pop());
                        case "rgb":
                            return 3 !== a.length ? null : [
                                Un(a[0]),
                                Un(a[1]),
                                Un(a[2]),
                                o
                            ];
                        case "hsla":
                            if (4 !== a.length) return null;
                            o = Nn(a.pop());
                        case "hsl":
                            if (3 !== a.length) return null;
                            var l = (parseFloat(a[0]) % 360 + 360) % 360 / 360, u = Nn(a[1]), c = Nn(a[2]), h = c <= .5 ? c * (u + 1) : c + u - c * u, p = 2 * c - h;
                            return [
                                Fn(255 * jn(p, h, l + 1 / 3)),
                                Fn(255 * jn(p, h, l)),
                                Fn(255 * jn(p, h, l - 1 / 3)),
                                o
                            ];
                        default:
                            return null;
                    }
                }
                return null;
            };
        } catch (t1) {}
        class qn {
            constructor(t1, e, r, n = 1){
                this.r = t1, this.g = e, this.b = r, this.a = n;
            }
            static parse(e) {
                if (!e) return;
                if (e instanceof qn) return e;
                if ("string" != typeof e) return;
                const r = t1.F(e);
                return r ? new qn(r[0] / 255 * r[3], r[1] / 255 * r[3], r[2] / 255 * r[3], r[3]) : void 0;
            }
            toString() {
                const [t1, e, r, n] = 0 === this.a ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    255 * this.r / this.a,
                    255 * this.g / this.a,
                    255 * this.b / this.a,
                    this.a
                ];
                return `rgba(${Math.round(t1)},${Math.round(e)},${Math.round(r)},${n})`;
            }
            toRenderColor(t1) {
                const { r: e, g: r, b: n, a: i } = this;
                return new $n(t1, e, r, n, i);
            }
        }
        class $n {
            constructor(t1, e, r, n, i){
                if (t1) {
                    const s = t1.image.height, a = s * s;
                    e = 0 === i ? 0 : e / i * (s - 1), r = 0 === i ? 0 : r / i * (s - 1), n = 0 === i ? 0 : n / i * (s - 1);
                    const o = Math.floor(e), l = Math.floor(r), u = Math.floor(n), c = Math.ceil(e), h = Math.ceil(r), p = Math.ceil(n), f = e - o, d = r - l, m = n - u, y = t1.image.data, g = 4 * (o + l * a + u * s), x = 4 * (o + l * a + p * s), b = 4 * (o + h * a + u * s), v = 4 * (o + h * a + p * s), _ = 4 * (c + l * a + u * s), w = 4 * (c + l * a + p * s), M = 4 * (c + h * a + u * s), A = 4 * (c + h * a + p * s);
                    if (g < 0 || A >= y.length) throw new Error("out of range");
                    this.r = Gn(Gn(Gn(y[g], y[x], m), Gn(y[b], y[v], m), d), Gn(Gn(y[_], y[w], m), Gn(y[M], y[A], m), d), f) / 255 * i, this.g = Gn(Gn(Gn(y[g + 1], y[x + 1], m), Gn(y[b + 1], y[v + 1], m), d), Gn(Gn(y[_ + 1], y[w + 1], m), Gn(y[M + 1], y[A + 1], m), d), f) / 255 * i, this.b = Gn(Gn(Gn(y[g + 2], y[x + 2], m), Gn(y[b + 2], y[v + 2], m), d), Gn(Gn(y[_ + 2], y[w + 2], m), Gn(y[M + 2], y[A + 2], m), d), f) / 255 * i, this.a = i;
                } else this.r = e, this.g = r, this.b = n, this.a = i;
            }
            toArray() {
                const { r: t1, g: e, b: r, a: n } = this;
                return 0 === n ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    255 * t1 / n,
                    255 * e / n,
                    255 * r / n,
                    n
                ];
            }
            toArray01() {
                const { r: t1, g: e, b: r, a: n } = this;
                return 0 === n ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    t1 / n,
                    e / n,
                    r / n,
                    n
                ];
            }
            toArray01Scaled(t1) {
                const { r: e, g: r, b: n, a: i } = this;
                return 0 === i ? [
                    0,
                    0,
                    0
                ] : [
                    e / i * t1,
                    r / i * t1,
                    n / i * t1
                ];
            }
            toArray01PremultipliedAlpha() {
                const { r: t1, g: e, b: r, a: n } = this;
                return [
                    t1,
                    e,
                    r,
                    n
                ];
            }
            toArray01Linear() {
                const { r: t1, g: e, b: r, a: n } = this;
                return 0 === n ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    Math.pow(t1 / n, 2.2),
                    Math.pow(e / n, 2.2),
                    Math.pow(r / n, 2.2),
                    n
                ];
            }
        }
        function Gn(t1, e, r) {
            return t1 * (1 - r) + e * r;
        }
        function Yn(t1, e, r) {
            return t1.map((t1, n)=>Gn(t1, e[n], r));
        }
        qn.black = new qn(0, 0, 0, 1), qn.white = new qn(1, 1, 1, 1), qn.transparent = new qn(0, 0, 0, 0), qn.red = new qn(1, 0, 0, 1), qn.blue = new qn(0, 0, 1, 1);
        var Xn = Object.freeze({
            __proto__: null,
            array: Yn,
            color: function(t1, e, r) {
                return new qn(Gn(t1.r, e.r, r), Gn(t1.g, e.g, r), Gn(t1.b, e.b, r), Gn(t1.a, e.a, r));
            },
            number: Gn
        });
        function Zn(t1, ...e) {
            for (const r of e)for(const e in r)t1[e] = r[e];
            return t1;
        }
        class Hn extends Error {
            constructor(t1, e){
                super(e), this.message = e, this.key = t1;
            }
        }
        class Kn {
            constructor(t1, e = []){
                this.parent = t1, this.bindings = {};
                for (const [t1, r] of e)this.bindings[t1] = r;
            }
            concat(t1) {
                return new Kn(this, t1);
            }
            get(t1) {
                if (this.bindings[t1]) return this.bindings[t1];
                if (this.parent) return this.parent.get(t1);
                throw new Error(`${t1} not found in scope.`);
            }
            has(t1) {
                return !!this.bindings[t1] || !!this.parent && this.parent.has(t1);
            }
        }
        const Wn = {
            kind: "null"
        }, Jn = {
            kind: "number"
        }, Qn = {
            kind: "string"
        }, ti = {
            kind: "boolean"
        }, ei = {
            kind: "color"
        }, ri = {
            kind: "object"
        }, ni = {
            kind: "value"
        }, ii = {
            kind: "collator"
        }, si = {
            kind: "formatted"
        }, ai = {
            kind: "resolvedImage"
        };
        function oi(t1, e) {
            return {
                kind: "array",
                itemType: t1,
                N: e
            };
        }
        function li(t1) {
            if ("array" === t1.kind) {
                const e = li(t1.itemType);
                return "number" == typeof t1.N ? `array<${e}, ${t1.N}>` : "value" === t1.itemType.kind ? "array" : `array<${e}>`;
            }
            return t1.kind;
        }
        const ui = [
            Wn,
            Jn,
            Qn,
            ti,
            ei,
            si,
            ri,
            oi(ni),
            ai
        ];
        function ci(t1, e) {
            if ("error" === e.kind) return null;
            if ("array" === t1.kind) {
                if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !ci(t1.itemType, e.itemType)) && ("number" != typeof t1.N || t1.N === e.N)) return null;
            } else {
                if (t1.kind === e.kind) return null;
                if ("value" === t1.kind) {
                    for (const t1 of ui)if (!ci(t1, e)) return null;
                }
            }
            return `Expected ${li(t1)} but found ${li(e)} instead.`;
        }
        function hi(t1, e) {
            return e.some((e)=>e.kind === t1.kind);
        }
        function pi(t1, e) {
            return e.some((e)=>"null" === e ? null === t1 : "array" === e ? Array.isArray(t1) : "object" === e ? t1 && !Array.isArray(t1) && "object" == typeof t1 : e === typeof t1);
        }
        class fi {
            constructor(t1, e, r){
                this.sensitivity = t1 ? e ? "variant" : "case" : e ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
                    sensitivity: this.sensitivity,
                    usage: "search"
                });
            }
            compare(t1, e) {
                return this.collator.compare(t1, e);
            }
            resolvedLocale() {
                return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
        }
        class di {
            constructor(t1, e, r, n, i){
                this.text = t1.normalize ? t1.normalize() : t1, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;
            }
        }
        class mi {
            constructor(t1){
                this.sections = t1;
            }
            static fromString(t1) {
                return new mi([
                    new di(t1, null, null, null, null)
                ]);
            }
            isEmpty() {
                return 0 === this.sections.length || !this.sections.some((t1)=>0 !== t1.text.length || t1.image && 0 !== t1.image.namePrimary.length);
            }
            static factory(t1) {
                return t1 instanceof mi ? t1 : mi.fromString(t1);
            }
            toString() {
                return 0 === this.sections.length ? "" : this.sections.map((t1)=>t1.text).join("");
            }
            serialize() {
                const t1 = [
                    "format"
                ];
                for (const e of this.sections){
                    if (e.image) {
                        t1.push([
                            "image",
                            e.image.namePrimary
                        ]);
                        continue;
                    }
                    t1.push(e.text);
                    const r = {};
                    e.fontStack && (r["text-font"] = [
                        "literal",
                        e.fontStack.split(",")
                    ]), e.scale && (r["font-scale"] = e.scale), e.textColor && (r["text-color"] = [
                        "rgba"
                    ].concat(e.textColor.toRenderColor(null).toArray())), t1.push(r);
                }
                return t1;
            }
        }
        class yi {
            constructor(t1){
                this.namePrimary = t1.namePrimary, t1.nameSecondary && (this.nameSecondary = t1.nameSecondary), this.available = t1.available;
            }
            toString() {
                return this.nameSecondary ? `[${this.namePrimary},${this.nameSecondary}]` : this.namePrimary;
            }
            static fromString(t1, e) {
                return t1 ? new yi({
                    namePrimary: t1,
                    nameSecondary: e,
                    available: !1
                }) : null;
            }
            serialize() {
                return this.nameSecondary ? [
                    "image",
                    this.namePrimary,
                    this.nameSecondary
                ] : [
                    "image",
                    this.namePrimary
                ];
            }
        }
        function gi(t1, e, r, n) {
            return "number" == typeof t1 && t1 >= 0 && t1 <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[
                t1,
                e,
                r,
                n
            ].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n ? [
                t1,
                e,
                r,
                n
            ] : [
                t1,
                e,
                r
            ]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function xi(t1) {
            if (null === t1) return !0;
            if ("string" == typeof t1) return !0;
            if ("boolean" == typeof t1) return !0;
            if ("number" == typeof t1) return !0;
            if (t1 instanceof qn) return !0;
            if (t1 instanceof fi) return !0;
            if (t1 instanceof mi) return !0;
            if (t1 instanceof yi) return !0;
            if (Array.isArray(t1)) {
                for (const e of t1)if (!xi(e)) return !1;
                return !0;
            }
            if ("object" == typeof t1) {
                for(const e in t1)if (!xi(t1[e])) return !1;
                return !0;
            }
            return !1;
        }
        function bi(t1) {
            if (null === t1) return Wn;
            if ("string" == typeof t1) return Qn;
            if ("boolean" == typeof t1) return ti;
            if ("number" == typeof t1) return Jn;
            if (t1 instanceof qn) return ei;
            if (t1 instanceof fi) return ii;
            if (t1 instanceof mi) return si;
            if (t1 instanceof yi) return ai;
            if (Array.isArray(t1)) {
                const e = t1.length;
                let r;
                for (const e of t1){
                    const t1 = bi(e);
                    if (r) {
                        if (r === t1) continue;
                        r = ni;
                        break;
                    }
                    r = t1;
                }
                return oi(r || ni, e);
            }
            return ri;
        }
        function vi(t1) {
            const e = typeof t1;
            return null === t1 ? "" : "string" === e || "number" === e || "boolean" === e ? String(t1) : t1 instanceof qn || t1 instanceof mi || t1 instanceof yi ? t1.toString() : JSON.stringify(t1);
        }
        class _i {
            constructor(t1, e){
                this.type = t1, this.value = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error(`'literal' expression requires exactly one argument, but found ${t1.length - 1} instead.`);
                if (!xi(t1[1])) return e.error("invalid value");
                const r = t1[1];
                let n = bi(r);
                const i = e.expectedType;
                return "array" !== n.kind || 0 !== n.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (n = i), new _i(n, r);
            }
            evaluate() {
                return this.value;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
            serialize() {
                return "array" === this.type.kind || "object" === this.type.kind ? [
                    "literal",
                    this.value
                ] : this.value instanceof qn ? [
                    "rgba"
                ].concat(this.value.toRenderColor(null).toArray()) : this.value instanceof mi ? this.value.serialize() : this.value;
            }
        }
        class wi {
            constructor(t1){
                this.name = "ExpressionEvaluationError", this.message = t1;
            }
            toJSON() {
                return this.message;
            }
        }
        const Mi = {
            string: Qn,
            number: Jn,
            boolean: ti,
            object: ri
        };
        class Ai {
            constructor(t1, e){
                this.type = t1, this.args = e;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expected at least one argument.");
                let r, n = 1;
                const i = t1[0];
                if ("array" === i) {
                    let i, s;
                    if (t1.length > 2) {
                        const r = t1[1];
                        if ("string" != typeof r || !(r in Mi) || "object" === r) return e.error('The item type argument of "array" must be one of string, number, boolean', 1);
                        i = Mi[r], n++;
                    } else i = ni;
                    if (t1.length > 3) {
                        if (null !== t1[2] && ("number" != typeof t1[2] || t1[2] < 0 || t1[2] !== Math.floor(t1[2]))) return e.error('The length argument to "array" must be a positive integer literal', 2);
                        s = t1[2], n++;
                    }
                    r = oi(i, s);
                } else r = Mi[i];
                const s = [];
                for(; n < t1.length; n++){
                    const r = e.parse(t1[n], n, ni);
                    if (!r) return null;
                    s.push(r);
                }
                return new Ai(r, s);
            }
            evaluate(t1) {
                for(let e = 0; e < this.args.length; e++){
                    const r = this.args[e].evaluate(t1);
                    if (!ci(this.type, bi(r))) return r;
                    if (e === this.args.length - 1) throw new wi(`Expected value to be of type ${li(this.type)}, but found ${li(bi(r))} instead.`);
                }
                return null;
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = this.type, e = [
                    t1.kind
                ];
                if ("array" === t1.kind) {
                    const r = t1.itemType;
                    if ("string" === r.kind || "number" === r.kind || "boolean" === r.kind) {
                        e.push(r.kind);
                        const n = t1.N;
                        ("number" == typeof n || this.args.length > 1) && e.push(n);
                    }
                }
                return e.concat(this.args.map((t1)=>t1.serialize()));
            }
        }
        class Si {
            constructor(t1){
                this.type = si, this.sections = t1;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expected at least one argument.");
                const r = t1[1];
                if (!Array.isArray(r) && "object" == typeof r) return e.error("First argument must be an image or text section.");
                const n = [];
                let i = !1;
                for(let r = 1; r <= t1.length - 1; ++r){
                    const s = t1[r];
                    if (i && "object" == typeof s && !Array.isArray(s)) {
                        i = !1;
                        let t1 = null;
                        if (s["font-scale"] && (t1 = e.parse(s["font-scale"], 1, Jn), !t1)) return null;
                        let r = null;
                        if (s["text-font"] && (r = e.parse(s["text-font"], 1, oi(Qn)), !r)) return null;
                        let a = null;
                        if (s["text-color"] && (a = e.parse(s["text-color"], 1, ei), !a)) return null;
                        const o = n[n.length - 1];
                        o.scale = t1, o.font = r, o.textColor = a;
                    } else {
                        const s = e.parse(t1[r], 1, ni);
                        if (!s) return null;
                        const a = s.type.kind;
                        if ("string" !== a && "value" !== a && "null" !== a && "resolvedImage" !== a) return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                        i = !0, n.push({
                            content: s,
                            scale: null,
                            font: null,
                            textColor: null
                        });
                    }
                }
                return new Si(n);
            }
            evaluate(t1) {
                return new mi(this.sections.map((e)=>{
                    const r = e.content.evaluate(t1);
                    return bi(r) === ai ? new di("", r, null, null, null) : new di(vi(r), null, e.scale ? e.scale.evaluate(t1) : null, e.font ? e.font.evaluate(t1).join(",") : null, e.textColor ? e.textColor.evaluate(t1) : null);
                }));
            }
            eachChild(t1) {
                for (const e of this.sections)t1(e.content), e.scale && t1(e.scale), e.font && t1(e.font), e.textColor && t1(e.textColor);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = [
                    "format"
                ];
                for (const e of this.sections){
                    t1.push(e.content.serialize());
                    const r = {};
                    e.scale && (r["font-scale"] = e.scale.serialize()), e.font && (r["text-font"] = e.font.serialize()), e.textColor && (r["text-color"] = e.textColor.serialize()), t1.push(r);
                }
                return t1;
            }
        }
        class Ii {
            constructor(t1, e){
                this.type = ai, this.inputPrimary = t1, this.inputSecondary = e;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expected two or more arguments.");
                const r = e.parse(t1[1], 1, Qn);
                if (!r) return e.error("No image name provided.");
                if (2 === t1.length) return new Ii(r);
                const n = e.parse(t1[2], 1, Qn);
                return n ? new Ii(r, n) : e.error("Secondary image variant is not a string.");
            }
            evaluate(t1) {
                const e = yi.fromString(this.inputPrimary.evaluate(t1), this.inputSecondary ? this.inputSecondary.evaluate(t1) : void 0);
                return e && t1.availableImages && (e.available = t1.availableImages.indexOf(e.namePrimary) > -1, e.nameSecondary && e.available && t1.availableImages && (e.available = t1.availableImages.indexOf(e.nameSecondary) > -1)), e;
            }
            eachChild(t1) {
                t1(this.inputPrimary), this.inputSecondary && t1(this.inputSecondary);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return this.inputSecondary ? [
                    "image",
                    this.inputPrimary.serialize(),
                    this.inputSecondary.serialize()
                ] : [
                    "image",
                    this.inputPrimary.serialize()
                ];
            }
        }
        function Ti(t1) {
            return t1 instanceof Number ? "number" : t1 instanceof String ? "string" : t1 instanceof Boolean ? "boolean" : Array.isArray(t1) ? "array" : null === t1 ? "null" : typeof t1;
        }
        const ki = {
            "to-boolean": ti,
            "to-color": ei,
            "to-number": Jn,
            "to-string": Qn
        };
        class Pi {
            constructor(t1, e){
                this.type = t1, this.args = e;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expected at least one argument.");
                const r = t1[0], n = [];
                let i = Wn;
                if ("to-array" === r) {
                    if (!Array.isArray(t1[1])) return null;
                    const r = t1[1].length;
                    if (e.expectedType) {
                        if ("array" !== e.expectedType.kind) return e.error(`Expected ${e.expectedType.kind} but found array.`);
                        i = oi(e.expectedType.itemType, r);
                    } else {
                        if (!(r > 0 && xi(t1[1][0]))) return null;
                        i = oi(bi(t1[1][0]), r);
                    }
                    for(let s = 0; s < r; s++){
                        const r = t1[1][s];
                        let a;
                        if ("array" === Ti(r)) a = e.parse(r, void 0, i.itemType);
                        else {
                            const t1 = Ti(r);
                            if (t1 !== i.itemType.kind) return e.error(`Expected ${i.itemType.kind} but found ${t1}.`);
                            a = e.registry.literal.parse([
                                "literal",
                                void 0 === r ? null : r
                            ], e);
                        }
                        if (!a) return null;
                        n.push(a);
                    }
                } else {
                    if (("to-boolean" === r || "to-string" === r) && 2 !== t1.length) return e.error("Expected one argument.");
                    i = ki[r];
                    for(let r = 1; r < t1.length; r++){
                        const i = e.parse(t1[r], r, ni);
                        if (!i) return null;
                        n.push(i);
                    }
                }
                return new Pi(i, n);
            }
            evaluate(t1) {
                if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t1));
                if ("color" === this.type.kind) {
                    let e, r;
                    for (const n of this.args){
                        if (e = n.evaluate(t1), r = null, e instanceof qn) return e;
                        if ("string" == typeof e) {
                            const r = t1.parseColor(e);
                            if (r) return r;
                        } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : gi(e[0], e[1], e[2], e[3]), !r)) return new qn(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);
                    }
                    throw new wi(r || `Could not parse color from value '${"string" == typeof e ? e : String(JSON.stringify(e))}'`);
                }
                if ("number" === this.type.kind) {
                    let e = null;
                    for (const r of this.args){
                        if (e = r.evaluate(t1), null === e) return 0;
                        const n = Number(e);
                        if (!isNaN(n)) return n;
                    }
                    throw new wi(`Could not convert ${JSON.stringify(e)} to number.`);
                }
                return "formatted" === this.type.kind ? mi.fromString(vi(this.args[0].evaluate(t1))) : "resolvedImage" === this.type.kind ? yi.fromString(vi(this.args[0].evaluate(t1))) : "array" === this.type.kind ? this.args.map((e)=>e.evaluate(t1)) : vi(this.args[0].evaluate(t1));
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                if ("formatted" === this.type.kind) return new Si([
                    {
                        content: this.args[0],
                        scale: null,
                        font: null,
                        textColor: null
                    }
                ]).serialize();
                if ("resolvedImage" === this.type.kind) return new Ii(this.args[0]).serialize();
                const t1 = "array" === this.type.kind ? [] : [
                    `to-${this.type.kind}`
                ];
                return this.eachChild((e)=>{
                    t1.push(e.serialize());
                }), t1;
            }
        }
        const zi = [
            "Unknown",
            "Point",
            "LineString",
            "Polygon"
        ];
        class Ei {
            constructor(t1, e){
                this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = t1, this.options = e;
            }
            id() {
                return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
            }
            geometryType() {
                return this.feature ? "number" == typeof this.feature.type ? zi[this.feature.type] : this.feature.type : null;
            }
            geometry() {
                return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
                return this.canonical;
            }
            properties() {
                return this.feature && this.feature.properties || {};
            }
            measureLight(t1) {
                return this.globals.brightness || 0;
            }
            distanceFromCenter() {
                if (this.featureTileCoord && this.featureDistanceData) {
                    const t1 = this.featureDistanceData.center, e = this.featureDistanceData.scale, { x: r, y: n } = this.featureTileCoord;
                    return this.featureDistanceData.bearing[0] * (r * e - t1[0]) + this.featureDistanceData.bearing[1] * (n * e - t1[1]);
                }
                return 0;
            }
            parseColor(t1) {
                let e = this._parseColorCache[t1];
                return e || (e = this._parseColorCache[t1] = qn.parse(t1)), e;
            }
            getConfig(t1) {
                return this.options ? this.options.get(t1) : null;
            }
        }
        class Bi {
            constructor(t1, e, r, n, i){
                this.name = t1, this.type = e, this._evaluate = r, this.args = n, this._overloadIndex = i;
            }
            evaluate(t1) {
                if (!this._evaluate) {
                    const t1 = Bi.definitions[this.name];
                    this._evaluate = Array.isArray(t1) ? t1[2] : t1.overloads[this._overloadIndex][1];
                }
                return this._evaluate(t1, this.args);
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    this.name
                ].concat(this.args.map((t1)=>t1.serialize()));
            }
            static parse(t1, e) {
                const r = t1[0], n = Bi.definitions[r];
                if (!n) return e.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0);
                const i = Array.isArray(n) ? n[0] : n.type, s = Array.isArray(n) ? [
                    [
                        n[1],
                        n[2]
                    ]
                ] : n.overloads, a = [];
                let o = null, l = -1;
                for (const [n, u] of s){
                    if (Array.isArray(n) && n.length !== t1.length - 1) continue;
                    a.push(n), l++, o = new Js(e.registry, e.path, null, e.scope, void 0, e._scope, e.options);
                    const s = [];
                    let c = !1;
                    for(let e = 1; e < t1.length; e++){
                        const r = t1[e], i = Array.isArray(n) ? n[e - 1] : n.type, a = o.parse(r, 1 + s.length, i);
                        if (!a) {
                            c = !0;
                            break;
                        }
                        s.push(a);
                    }
                    if (!c) {
                        if (Array.isArray(n) && n.length !== s.length) o.error(`Expected ${n.length} arguments, but found ${s.length} instead.`);
                        else {
                            for(let t1 = 0; t1 < s.length; t1++){
                                const e = Array.isArray(n) ? n[t1] : n.type, r = s[t1];
                                o.concat(t1 + 1).checkSubtype(e, r.type);
                            }
                            if (0 === o.errors.length) return new Bi(r, i, u, s, l);
                        }
                    }
                }
                if (1 === a.length) e.errors.push(...o.errors);
                else {
                    const r = (a.length ? a : s.map(([t1])=>t1)).map(Di).join(" | "), n = [];
                    for(let r = 1; r < t1.length; r++){
                        const i = e.parse(t1[r], 1 + n.length);
                        if (!i) return null;
                        n.push(li(i.type));
                    }
                    e.error(`Expected arguments of type ${r}, but found (${n.join(", ")}) instead.`);
                }
                return null;
            }
            static register(t1, e) {
                Bi.definitions = e;
                for(const r in e)t1[r] = Bi;
            }
        }
        function Di(t1) {
            return Array.isArray(t1) ? `(${t1.map(li).join(", ")})` : `(${li(t1.type)}...)`;
        }
        class Ci {
            constructor(t1, e, r){
                this.type = ii, this.locale = r, this.caseSensitive = t1, this.diacriticSensitive = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error("Expected one argument.");
                const r = t1[1];
                if ("object" != typeof r || Array.isArray(r)) return e.error("Collator options argument must be an object.");
                const n = e.parse(void 0 !== r["case-sensitive"] && r["case-sensitive"], 1, ti);
                if (!n) return null;
                const i = e.parse(void 0 !== r["diacritic-sensitive"] && r["diacritic-sensitive"], 1, ti);
                if (!i) return null;
                let s = null;
                return r.locale && (s = e.parse(r.locale, 1, Qn), !s) ? null : new Ci(n, i, s);
            }
            evaluate(t1) {
                return new fi(this.caseSensitive.evaluate(t1), this.diacriticSensitive.evaluate(t1), this.locale ? this.locale.evaluate(t1) : null);
            }
            eachChild(t1) {
                t1(this.caseSensitive), t1(this.diacriticSensitive), this.locale && t1(this.locale);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = {};
                return t1["case-sensitive"] = this.caseSensitive.serialize(), t1["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t1.locale = this.locale.serialize()), [
                    "collator",
                    t1
                ];
            }
        }
        function Ri(t1, e, r = 0, n = t1.length - 1, i = Li) {
            for(; n > r;){
                if (n - r > 600) {
                    const s = n - r + 1, a = e - r + 1, o = Math.log(s), l = .5 * Math.exp(2 * o / 3), u = .5 * Math.sqrt(o * l * (s - l) / s) * (a - s / 2 < 0 ? -1 : 1);
                    Ri(t1, e, Math.max(r, Math.floor(e - a * l / s + u)), Math.min(n, Math.floor(e + (s - a) * l / s + u)), i);
                }
                const s = t1[e];
                let a = r, o = n;
                for(Vi(t1, r, e), i(t1[n], s) > 0 && Vi(t1, r, n); a < o;){
                    for(Vi(t1, a, o), a++, o--; i(t1[a], s) < 0;)a++;
                    for(; i(t1[o], s) > 0;)o--;
                }
                0 === i(t1[r], s) ? Vi(t1, r, o) : (o++, Vi(t1, o, n)), o <= e && (r = o + 1), e <= o && (n = o - 1);
            }
        }
        function Vi(t1, e, r) {
            const n = t1[e];
            t1[e] = t1[r], t1[r] = n;
        }
        function Li(t1, e) {
            return t1 < e ? -1 : t1 > e ? 1 : 0;
        }
        function Oi(t1) {
            let e = 0;
            for(let r, n, i = 0, s = t1.length, a = s - 1; i < s; a = i++)r = t1[i], n = t1[a], e += (n.x - r.x) * (r.y + n.y);
            return e;
        }
        function Fi(t1, e) {
            t1[0] = Math.min(t1[0], e[0]), t1[1] = Math.min(t1[1], e[1]), t1[2] = Math.max(t1[2], e[0]), t1[3] = Math.max(t1[3], e[1]);
        }
        function Ui(t1, e) {
            return !(t1[0] <= e[0] || t1[2] >= e[2] || t1[1] <= e[1] || t1[3] >= e[3]);
        }
        function Ni(t1, e, r) {
            const n = t1[0] - e[0], i = t1[1] - e[1], s = t1[0] - r[0], a = t1[1] - r[1];
            return n * a - s * i == 0 && n * s <= 0 && i * a <= 0;
        }
        function ji(t1, e, r = !1) {
            let n = !1;
            for(let o = 0, l = e.length; o < l; o++){
                const l = e[o];
                for(let e = 0, o = l.length, u = o - 1; e < o; u = e++){
                    const o = l[u], c = l[e];
                    if (Ni(t1, o, c)) return r;
                    (s = o)[1] > (i = t1)[1] != (a = c)[1] > i[1] && i[0] < (a[0] - s[0]) * (i[1] - s[1]) / (a[1] - s[1]) + s[0] && (n = !n);
                }
            }
            var i, s, a;
            return n;
        }
        function qi(t1, e, r, n) {
            const i = n[0] - r[0], s = n[1] - r[1], a = (t1[0] - r[0]) * s - i * (t1[1] - r[1]), o = (e[0] - r[0]) * s - i * (e[1] - r[1]);
            return a > 0 && o < 0 || a < 0 && o > 0;
        }
        function $i(t1, e, r, n) {
            var i, s;
            return 0 != (i = [
                n[0] - r[0],
                n[1] - r[1]
            ])[0] * (s = [
                e[0] - t1[0],
                e[1] - t1[1]
            ])[1] - i[1] * s[0] && !(!qi(t1, e, r, n) || !qi(r, n, t1, e));
        }
        const Gi = 8192;
        function Yi(t1, e) {
            const r = (180 + t1[0]) / 360, n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t1[1] * Math.PI / 360))) / 360, i = Math.pow(2, e.z);
            return [
                Math.round(r * i * Gi),
                Math.round(n * i * Gi)
            ];
        }
        function Xi(t1, e) {
            for(let r = 0; r < e.length; r++)if (ji(t1, e[r])) return !0;
            return !1;
        }
        function Zi(t1, e, r) {
            for (const n of r)for(let r = 0, i = n.length, s = i - 1; r < i; s = r++)if ($i(t1, e, n[s], n[r])) return !0;
            return !1;
        }
        function Hi(t1, e) {
            for(let r = 0; r < t1.length; ++r)if (!ji(t1[r], e)) return !1;
            for(let r = 0; r < t1.length - 1; ++r)if (Zi(t1[r], t1[r + 1], e)) return !1;
            return !0;
        }
        function Ki(t1, e) {
            for(let r = 0; r < e.length; r++)if (Hi(t1, e[r])) return !0;
            return !1;
        }
        function Wi(t1, e, r) {
            const n = [];
            for(let i = 0; i < t1.length; i++){
                const s = [];
                for(let n = 0; n < t1[i].length; n++){
                    const a = Yi(t1[i][n], r);
                    Fi(e, a), s.push(a);
                }
                n.push(s);
            }
            return n;
        }
        function Ji(t1, e, r) {
            const n = [];
            for(let i = 0; i < t1.length; i++){
                const s = Wi(t1[i], e, r);
                n.push(s);
            }
            return n;
        }
        function Qi(t1, e, r, n) {
            if (t1[0] < r[0] || t1[0] > r[2]) {
                const e = .5 * n;
                let i = t1[0] - r[0] > e ? -n : r[0] - t1[0] > e ? n : 0;
                0 === i && (i = t1[0] - r[2] > e ? -n : r[2] - t1[0] > e ? n : 0), t1[0] += i;
            }
            Fi(e, t1);
        }
        function ts(t1, e, r, n) {
            const i = Math.pow(2, n.z) * Gi, s = [
                n.x * Gi,
                n.y * Gi
            ], a = [];
            if (!t1) return a;
            for (const n of t1)for (const t1 of n){
                const n = [
                    t1.x + s[0],
                    t1.y + s[1]
                ];
                Qi(n, e, r, i), a.push(n);
            }
            return a;
        }
        function es(t1, e, r, n) {
            const i = Math.pow(2, n.z) * Gi, s = [
                n.x * Gi,
                n.y * Gi
            ], a = [];
            if (!t1) return a;
            for (const r of t1){
                const t1 = [];
                for (const n of r){
                    const r = [
                        n.x + s[0],
                        n.y + s[1]
                    ];
                    Fi(e, r), t1.push(r);
                }
                a.push(t1);
            }
            if (e[2] - e[0] <= i / 2) {
                (o = e)[0] = o[1] = 1 / 0, o[2] = o[3] = -1 / 0;
                for (const t1 of a)for (const n of t1)Qi(n, e, r, i);
            }
            var o;
            return a;
        }
        class rs {
            constructor(t1, e){
                this.type = ti, this.geojson = t1, this.geometries = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error(`'within' expression requires exactly one argument, but found ${t1.length - 1} instead.`);
                if (xi(t1[1])) {
                    const e = t1[1];
                    if ("FeatureCollection" === e.type) for(let t1 = 0; t1 < e.features.length; ++t1){
                        const r = e.features[t1].geometry.type;
                        if ("Polygon" === r || "MultiPolygon" === r) return new rs(e, e.features[t1].geometry);
                    }
                    else if ("Feature" === e.type) {
                        const t1 = e.geometry.type;
                        if ("Polygon" === t1 || "MultiPolygon" === t1) return new rs(e, e.geometry);
                    } else if ("Polygon" === e.type || "MultiPolygon" === e.type) return new rs(e, e);
                }
                return e.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t1) {
                if (null != t1.geometry() && null != t1.canonicalID()) {
                    if ("Point" === t1.geometryType()) return function(t1, e) {
                        const r = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], n = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], i = t1.canonicalID();
                        if (!i) return !1;
                        if ("Polygon" === e.type) {
                            const s = Wi(e.coordinates, n, i), a = ts(t1.geometry(), r, n, i);
                            if (!Ui(r, n)) return !1;
                            for (const t1 of a)if (!ji(t1, s)) return !1;
                        }
                        if ("MultiPolygon" === e.type) {
                            const s = Ji(e.coordinates, n, i), a = ts(t1.geometry(), r, n, i);
                            if (!Ui(r, n)) return !1;
                            for (const t1 of a)if (!Xi(t1, s)) return !1;
                        }
                        return !0;
                    }(t1, this.geometries);
                    if ("LineString" === t1.geometryType()) return function(t1, e) {
                        const r = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], n = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], i = t1.canonicalID();
                        if (!i) return !1;
                        if ("Polygon" === e.type) {
                            const s = Wi(e.coordinates, n, i), a = es(t1.geometry(), r, n, i);
                            if (!Ui(r, n)) return !1;
                            for (const t1 of a)if (!Hi(t1, s)) return !1;
                        }
                        if ("MultiPolygon" === e.type) {
                            const s = Ji(e.coordinates, n, i), a = es(t1.geometry(), r, n, i);
                            if (!Ui(r, n)) return !1;
                            for (const t1 of a)if (!Ki(t1, s)) return !1;
                        }
                        return !0;
                    }(t1, this.geometries);
                }
                return !1;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "within",
                    this.geojson
                ];
            }
        }
        const ns = {
            kilometers: 1,
            miles: 1e3 / 1609.344,
            nauticalmiles: 1e3 / 1852,
            meters: 1e3,
            metres: 1e3,
            yards: 1e3 / .9144,
            feet: 1e3 / .3048,
            inches: 1e3 / .0254
        }, is = 1 / 298.257223563, ss = is * (2 - is), as = Math.PI / 180;
        class os {
            static fromTile(t1, e, r) {
                const n = Math.PI * (1 - 2 * (t1 + .5) / Math.pow(2, e)), i = Math.atan(.5 * (Math.exp(n) - Math.exp(-n))) / as;
                return new os(i, r);
            }
            static get units() {
                return ns;
            }
            constructor(t1, e){
                if (void 0 === t1) throw new Error("No latitude given.");
                if (e && !ns[e]) throw new Error(`Unknown unit ${e}. Use one of: ${Object.keys(ns).join(", ")}`);
                const r = 6378.137 * as * (e ? ns[e] : 1), n = Math.cos(t1 * as), i = 1 / (1 - ss * (1 - n * n)), s = Math.sqrt(i);
                this.kx = r * s * n, this.ky = r * s * i * (1 - ss);
            }
            distance(t1, e) {
                const r = cs(t1[0] - e[0]) * this.kx, n = (t1[1] - e[1]) * this.ky;
                return Math.sqrt(r * r + n * n);
            }
            bearing(t1, e) {
                const r = cs(e[0] - t1[0]) * this.kx;
                return Math.atan2(r, (e[1] - t1[1]) * this.ky) / as;
            }
            destination(t1, e, r) {
                const n = r * as;
                return this.offset(t1, Math.sin(n) * e, Math.cos(n) * e);
            }
            offset(t1, e, r) {
                return [
                    t1[0] + e / this.kx,
                    t1[1] + r / this.ky
                ];
            }
            lineDistance(t1) {
                let e = 0;
                for(let r = 0; r < t1.length - 1; r++)e += this.distance(t1[r], t1[r + 1]);
                return e;
            }
            area(t1) {
                let e = 0;
                for(let r = 0; r < t1.length; r++){
                    const n = t1[r];
                    for(let t1 = 0, i = n.length, s = i - 1; t1 < i; s = t1++)e += cs(n[t1][0] - n[s][0]) * (n[t1][1] + n[s][1]) * (r ? -1 : 1);
                }
                return Math.abs(e) / 2 * this.kx * this.ky;
            }
            along(t1, e) {
                let r = 0;
                if (e <= 0) return t1[0];
                for(let n = 0; n < t1.length - 1; n++){
                    const i = t1[n], s = t1[n + 1], a = this.distance(i, s);
                    if (r += a, r > e) return us(i, s, (e - (r - a)) / a);
                }
                return t1[t1.length - 1];
            }
            pointToSegmentDistance(t1, e, r) {
                let [n, i] = e, s = cs(r[0] - n) * this.kx, a = (r[1] - i) * this.ky;
                if (0 !== s || 0 !== a) {
                    const e = (cs(t1[0] - n) * this.kx * s + (t1[1] - i) * this.ky * a) / (s * s + a * a);
                    e > 1 ? (n = r[0], i = r[1]) : e > 0 && (n += s / this.kx * e, i += a / this.ky * e);
                }
                return s = cs(t1[0] - n) * this.kx, a = (t1[1] - i) * this.ky, Math.sqrt(s * s + a * a);
            }
            pointOnLine(t1, e) {
                let r = 1 / 0, n = t1[0][0], i = t1[0][1], s = 0, a = 0;
                for(let o = 0; o < t1.length - 1; o++){
                    let l = t1[o][0], u = t1[o][1], c = cs(t1[o + 1][0] - l) * this.kx, h = (t1[o + 1][1] - u) * this.ky, p = 0;
                    0 === c && 0 === h || (p = (cs(e[0] - l) * this.kx * c + (e[1] - u) * this.ky * h) / (c * c + h * h), p > 1 ? (l = t1[o + 1][0], u = t1[o + 1][1]) : p > 0 && (l += c / this.kx * p, u += h / this.ky * p)), c = cs(e[0] - l) * this.kx, h = (e[1] - u) * this.ky;
                    const f = c * c + h * h;
                    f < r && (r = f, n = l, i = u, s = o, a = p);
                }
                return {
                    point: [
                        n,
                        i
                    ],
                    index: s,
                    t: Math.max(0, Math.min(1, a))
                };
            }
            lineSlice(t1, e, r) {
                let n = this.pointOnLine(r, t1), i = this.pointOnLine(r, e);
                if (n.index > i.index || n.index === i.index && n.t > i.t) {
                    const t1 = n;
                    n = i, i = t1;
                }
                const s = [
                    n.point
                ], a = n.index + 1, o = i.index;
                !ls(r[a], s[0]) && a <= o && s.push(r[a]);
                for(let t1 = a + 1; t1 <= o; t1++)s.push(r[t1]);
                return ls(r[o], i.point) || s.push(i.point), s;
            }
            lineSliceAlong(t1, e, r) {
                let n = 0;
                const i = [];
                for(let s = 0; s < r.length - 1; s++){
                    const a = r[s], o = r[s + 1], l = this.distance(a, o);
                    if (n += l, n > t1 && 0 === i.length && i.push(us(a, o, (t1 - (n - l)) / l)), n >= e) return i.push(us(a, o, (e - (n - l)) / l)), i;
                    n > t1 && i.push(o);
                }
                return i;
            }
            bufferPoint(t1, e) {
                const r = e / this.ky, n = e / this.kx;
                return [
                    t1[0] - n,
                    t1[1] - r,
                    t1[0] + n,
                    t1[1] + r
                ];
            }
            bufferBBox(t1, e) {
                const r = e / this.ky, n = e / this.kx;
                return [
                    t1[0] - n,
                    t1[1] - r,
                    t1[2] + n,
                    t1[3] + r
                ];
            }
            insideBBox(t1, e) {
                return cs(t1[0] - e[0]) >= 0 && cs(t1[0] - e[2]) <= 0 && t1[1] >= e[1] && t1[1] <= e[3];
            }
        }
        function ls(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1];
        }
        function us(t1, e, r) {
            const n = cs(e[0] - t1[0]);
            return [
                t1[0] + n * r,
                t1[1] + (e[1] - t1[1]) * r
            ];
        }
        function cs(t1) {
            for(; t1 < -180;)t1 += 360;
            for(; t1 > 180;)t1 -= 360;
            return t1;
        }
        class hs {
            constructor(t1 = [], e = (t1, e)=>t1 < e ? -1 : t1 > e ? 1 : 0){
                if (this.data = t1, this.length = this.data.length, this.compare = e, this.length > 0) for(let t1 = (this.length >> 1) - 1; t1 >= 0; t1--)this._down(t1);
            }
            push(t1) {
                this.data.push(t1), this._up(this.length++);
            }
            pop() {
                if (0 === this.length) return;
                const t1 = this.data[0], e = this.data.pop();
                return --this.length > 0 && (this.data[0] = e, this._down(0)), t1;
            }
            peek() {
                return this.data[0];
            }
            _up(t1) {
                const { data: e, compare: r } = this, n = e[t1];
                for(; t1 > 0;){
                    const i = t1 - 1 >> 1, s = e[i];
                    if (r(n, s) >= 0) break;
                    e[t1] = s, t1 = i;
                }
                e[t1] = n;
            }
            _down(t1) {
                const { data: e, compare: r } = this, n = this.length >> 1, i = e[t1];
                for(; t1 < n;){
                    let n = 1 + (t1 << 1);
                    const s = n + 1;
                    if (s < this.length && r(e[s], e[n]) < 0 && (n = s), r(e[n], i) >= 0) break;
                    e[t1] = e[n], t1 = n;
                }
                e[t1] = i;
            }
        }
        var ps = 8192;
        function fs(t1, e) {
            return e.dist - t1.dist;
        }
        const ds = 100, ms = 50;
        function ys(t1) {
            const e = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ];
            if (e.length !== t1.length) return !1;
            for(let r = 0; r < e.length; r++)if (e[r] !== t1[r]) return !1;
            return !0;
        }
        function gs(t1) {
            return t1[1] - t1[0] + 1;
        }
        function xs(t1, e) {
            const r = t1[1] >= t1[0] && t1[1] < e;
            return r || console.warn("Distance Expression: Index is out of range"), r;
        }
        function bs(t1, e) {
            if (t1[0] > t1[1]) return [
                null,
                null
            ];
            const r = gs(t1);
            if (e) {
                if (2 === r) return [
                    t1,
                    null
                ];
                const e = Math.floor(r / 2);
                return [
                    [
                        t1[0],
                        t1[0] + e
                    ],
                    [
                        t1[0] + e,
                        t1[1]
                    ]
                ];
            }
            {
                if (1 === r) return [
                    t1,
                    null
                ];
                const e = Math.floor(r / 2) - 1;
                return [
                    [
                        t1[0],
                        t1[0] + e
                    ],
                    [
                        t1[0] + e + 1,
                        t1[1]
                    ]
                ];
            }
        }
        function vs(t1, e) {
            const r = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ];
            if (!xs(e, t1.length)) return r;
            for(let n = e[0]; n <= e[1]; ++n)Fi(r, t1[n]);
            return r;
        }
        function _s(t1) {
            const e = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ];
            for(let r = 0; r < t1.length; ++r)for(let n = 0; n < t1[r].length; ++n)Fi(e, t1[r][n]);
            return e;
        }
        function ws(t1, e, r) {
            if (ys(t1) || ys(e)) return NaN;
            let n = 0, i = 0;
            return t1[2] < e[0] && (n = e[0] - t1[2]), t1[0] > e[2] && (n = t1[0] - e[2]), t1[1] > e[3] && (i = t1[1] - e[3]), t1[3] < e[1] && (i = e[1] - t1[3]), r.distance([
                0,
                0
            ], [
                n,
                i
            ]);
        }
        function Ms(t1) {
            return 360 * t1 - 180;
        }
        function As(t1) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t1) * Math.PI / 180)) - 90;
        }
        function Ss(t1, e) {
            const r = Math.pow(2, e.z), n = (t1.y / ps + e.y) / r;
            return [
                Ms((t1.x / ps + e.x) / r),
                As(n)
            ];
        }
        function Is(t1, e) {
            const r = [];
            for(let n = 0; n < t1.length; ++n)r.push(Ss(t1[n], e));
            return r;
        }
        function Ts(t1, e, r) {
            const n = r.pointOnLine(e, t1).point;
            return r.distance(t1, n);
        }
        function ks(t1, e, r, n, i) {
            const s = r.slice(n[0], n[1] + 1);
            let a = 1 / 0;
            for(let r = e[0]; r <= e[1]; ++r)if (0 === (a = Math.min(a, Ts(t1[r], s, i)))) return 0;
            return a;
        }
        function Ps(t1, e, r, n, i) {
            const s = Math.min(i.pointToSegmentDistance(t1, r, n), i.pointToSegmentDistance(e, r, n)), a = Math.min(i.pointToSegmentDistance(r, t1, e), i.pointToSegmentDistance(n, t1, e));
            return Math.min(s, a);
        }
        function zs(t1, e, r, n, i) {
            if (!xs(e, t1.length) || !xs(n, r.length)) return NaN;
            let s = 1 / 0;
            for(let a = e[0]; a < e[1]; ++a)for(let e = n[0]; e < n[1]; ++e){
                if ($i(t1[a], t1[a + 1], r[e], r[e + 1])) return 0;
                s = Math.min(s, Ps(t1[a], t1[a + 1], r[e], r[e + 1], i));
            }
            return s;
        }
        function Es(t1, e, r, n, i) {
            if (!xs(e, t1.length) || !xs(n, r.length)) return NaN;
            let s = 1 / 0;
            for(let a = e[0]; a <= e[1]; ++a)for(let e = n[0]; e <= n[1]; ++e)if (0 === (s = Math.min(s, i.distance(t1[a], r[e])))) return s;
            return s;
        }
        function Bs(t1, e, r) {
            if (ji(t1, e, !0)) return 0;
            let n = 1 / 0;
            for (const i of e){
                const e = i.length;
                if (e < 2) return console.warn("Distance Expression: Invalid polygon!"), NaN;
                if (i[0] !== i[e - 1] && 0 === (n = Math.min(n, r.pointToSegmentDistance(t1, i[e - 1], i[0])))) return n;
                if (0 === (n = Math.min(n, Ts(t1, i, r)))) return n;
            }
            return n;
        }
        function Ds(t1, e, r, n) {
            if (!xs(e, t1.length)) return NaN;
            for(let n = e[0]; n <= e[1]; ++n)if (ji(t1[n], r, !0)) return 0;
            let i = 1 / 0;
            for(let s = e[0]; s < e[1]; ++s)for (const e of r)for(let r = 0, a = e.length, o = a - 1; r < a; o = r++){
                if ($i(t1[s], t1[s + 1], e[o], e[r])) return 0;
                i = Math.min(i, Ps(t1[s], t1[s + 1], e[o], e[r], n));
            }
            return i;
        }
        function Cs(t1, e) {
            for (const r of t1)for(let t1 = 0; t1 <= r.length - 1; ++t1)if (ji(r[t1], e, !0)) return !0;
            return !1;
        }
        function Rs(t1, e, r, n = 1 / 0) {
            const i = _s(t1), s = _s(e);
            if (n !== 1 / 0 && ws(i, s, r) >= n) return n;
            if (Ui(i, s)) {
                if (Cs(t1, e)) return 0;
            } else if (Cs(e, t1)) return 0;
            let a = n;
            for (const n of t1)for(let t1 = 0, i = n.length, s = i - 1; t1 < i; s = t1++)for (const i of e)for(let e = 0, o = i.length, l = o - 1; e < o; l = e++){
                if ($i(n[s], n[t1], i[l], i[e])) return 0;
                a = Math.min(a, Ps(n[s], n[t1], i[l], i[e], r));
            }
            return a;
        }
        function Vs(t1, e, r, n, i, s, a) {
            if (null === s || null === a) return;
            const o = ws(vs(n, s), vs(i, a), r);
            o < e && t1.push({
                dist: o,
                range1: s,
                range2: a
            });
        }
        function Ls(t1, e, r, n, i = 1 / 0) {
            let s = Math.min(n.distance(t1[0], r[0][0]), i);
            if (0 === s) return s;
            const a = new hs([
                {
                    dist: 0,
                    range1: [
                        0,
                        t1.length - 1
                    ],
                    range2: [
                        0,
                        0
                    ]
                }
            ], fs), o = e ? ms : ds, l = _s(r);
            for(; a.length;){
                const i = a.pop();
                if (i.dist >= s) continue;
                const u = i.range1;
                if (gs(u) <= o) {
                    if (!xs(u, t1.length)) return NaN;
                    if (e) {
                        const e = Ds(t1, u, r, n);
                        if (0 === (s = Math.min(s, e))) return s;
                    } else for(let e = u[0]; e <= u[1]; ++e){
                        const i = Bs(t1[e], r, n);
                        if (0 === (s = Math.min(s, i))) return s;
                    }
                } else {
                    const r = bs(u, e);
                    if (null !== r[0]) {
                        const e = ws(vs(t1, r[0]), l, n);
                        e < s && a.push({
                            dist: e,
                            range1: r[0],
                            range2: [
                                0,
                                0
                            ]
                        });
                    }
                    if (null !== r[1]) {
                        const e = ws(vs(t1, r[1]), l, n);
                        e < s && a.push({
                            dist: e,
                            range1: r[1],
                            range2: [
                                0,
                                0
                            ]
                        });
                    }
                }
            }
            return s;
        }
        function Os(t1, e, r, n, i, s = 1 / 0) {
            let a = Math.min(s, i.distance(t1[0], r[0]));
            if (0 === a) return a;
            const o = new hs([
                {
                    dist: 0,
                    range1: [
                        0,
                        t1.length - 1
                    ],
                    range2: [
                        0,
                        r.length - 1
                    ]
                }
            ], fs), l = e ? ms : ds, u = n ? ms : ds;
            for(; o.length;){
                const s = o.pop();
                if (s.dist >= a) continue;
                const c = s.range1, h = s.range2;
                if (gs(c) <= l && gs(h) <= u) {
                    if (!xs(c, t1.length) || !xs(h, r.length)) return NaN;
                    if (e && n ? a = Math.min(a, zs(t1, c, r, h, i)) : e || n ? e && !n ? a = Math.min(a, ks(r, h, t1, c, i)) : !e && n && (a = Math.min(a, ks(t1, c, r, h, i))) : a = Math.min(a, Es(t1, c, r, h, i)), 0 === a) return a;
                } else {
                    const s = bs(c, e), l = bs(h, n);
                    Vs(o, a, i, t1, r, s[0], l[0]), Vs(o, a, i, t1, r, s[0], l[1]), Vs(o, a, i, t1, r, s[1], l[0]), Vs(o, a, i, t1, r, s[1], l[1]);
                }
            }
            return a;
        }
        function Fs(t1, e, r, n, i = 1 / 0) {
            let s = i;
            const a = vs(t1, [
                0,
                t1.length - 1
            ]);
            for (const i of r)if (!(s !== 1 / 0 && ws(a, vs(i, [
                0,
                i.length - 1
            ]), n) >= s) && (s = Math.min(s, Os(t1, e, i, !0, n, s)), 0 === s)) return s;
            return s;
        }
        function Us(t1, e, r, n, i = 1 / 0) {
            let s = i;
            const a = vs(t1, [
                0,
                t1.length - 1
            ]);
            for (const i of r){
                if (s !== 1 / 0 && ws(a, _s(i), n) >= s) continue;
                const r = Ls(t1, e, i, n, s);
                if (isNaN(r)) return r;
                if (0 === (s = Math.min(s, r))) return s;
            }
            return s;
        }
        function Ns(t1) {
            return "Point" === t1 || "MultiPoint" === t1 || "LineString" === t1 || "MultiLineString" === t1 || "Polygon" === t1 || "MultiPolygon" === t1;
        }
        class js {
            constructor(t1, e){
                this.type = Jn, this.geojson = t1, this.geometries = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error(`'distance' expression requires either one argument, but found ' ${t1.length - 1} instead.`);
                if (xi(t1[1])) {
                    const e = t1[1];
                    if ("FeatureCollection" === e.type) {
                        for(let t1 = 0; t1 < e.features.length; ++t1)if (Ns(e.features[t1].geometry.type)) return new js(e, e.features[t1].geometry);
                    } else if ("Feature" === e.type) {
                        if (Ns(e.geometry.type)) return new js(e, e.geometry);
                    } else if (Ns(e.type)) return new js(e, e);
                }
                return e.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
            }
            evaluate(t1) {
                const e = t1.geometry(), r = t1.canonicalID();
                if (null != e && null != r) {
                    if ("Point" === t1.geometryType()) return function(t1, e, r) {
                        const n = [];
                        for (const r of t1)for (const t1 of r)n.push(Ss(t1, e));
                        const i = new os(n[0][1], "meters");
                        return "Point" === r.type || "MultiPoint" === r.type || "LineString" === r.type ? Os(n, !1, "Point" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, "LineString" === r.type, i) : "MultiLineString" === r.type ? Fs(n, !1, r.coordinates, i) : "Polygon" === r.type || "MultiPolygon" === r.type ? Us(n, !1, "Polygon" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, i) : null;
                    }(e, r, this.geometries);
                    if ("LineString" === t1.geometryType()) return function(t1, e, r) {
                        const n = [];
                        for (const r of t1){
                            const t1 = [];
                            for (const n of r)t1.push(Ss(n, e));
                            n.push(t1);
                        }
                        const i = new os(n[0][0][1], "meters");
                        if ("Point" === r.type || "MultiPoint" === r.type || "LineString" === r.type) return Fs("Point" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, "LineString" === r.type, n, i);
                        if ("MultiLineString" === r.type) {
                            let t1 = 1 / 0;
                            for(let e = 0; e < r.coordinates.length; e++){
                                const s = Fs(r.coordinates[e], !0, n, i, t1);
                                if (isNaN(s)) return s;
                                if (0 === (t1 = Math.min(t1, s))) return t1;
                            }
                            return t1;
                        }
                        if ("Polygon" === r.type || "MultiPolygon" === r.type) {
                            let t1 = 1 / 0;
                            for(let e = 0; e < n.length; e++){
                                const s = Us(n[e], !0, "Polygon" === r.type ? [
                                    r.coordinates
                                ] : r.coordinates, i, t1);
                                if (isNaN(s)) return s;
                                if (0 === (t1 = Math.min(t1, s))) return t1;
                            }
                            return t1;
                        }
                        return null;
                    }(e, r, this.geometries);
                    if ("Polygon" === t1.geometryType()) return function(t1, e, r) {
                        const n = [];
                        for (const r of function(t1, e) {
                            const r = t1.length;
                            if (r <= 1) return [
                                t1
                            ];
                            const n = [];
                            let i, s;
                            for(let e = 0; e < r; e++){
                                const r = Oi(t1[e]);
                                0 !== r && (t1[e].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [
                                    t1[e]
                                ]) : i.push(t1[e]));
                            }
                            return i && n.push(i), n;
                        }(t1)){
                            const t1 = [];
                            for(let n = 0; n < r.length; ++n)t1.push(Is(r[n], e));
                            n.push(t1);
                        }
                        const i = new os(n[0][0][0][1], "meters");
                        if ("Point" === r.type || "MultiPoint" === r.type || "LineString" === r.type) return Us("Point" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, "LineString" === r.type, n, i);
                        if ("MultiLineString" === r.type) {
                            let t1 = 1 / 0;
                            for(let e = 0; e < r.coordinates.length; e++){
                                const s = Us(r.coordinates[e], !0, n, i, t1);
                                if (isNaN(s)) return s;
                                if (0 === (t1 = Math.min(t1, s))) return t1;
                            }
                            return t1;
                        }
                        return "Polygon" === r.type || "MultiPolygon" === r.type ? function(t1, e, r) {
                            let n = 1 / 0;
                            for (const i of t1)for (const t1 of e){
                                const e = Rs(i, t1, r, n);
                                if (isNaN(e)) return e;
                                if (0 === (n = Math.min(n, e))) return n;
                            }
                            return n;
                        }("Polygon" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, n, i) : null;
                    }(e, r, this.geometries);
                    console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
                } else console.warn("Distance Expression: requirs valid feature and canonical information.");
                return null;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "distance",
                    this.geojson
                ];
            }
        }
        function qs(t1, e) {
            switch(t1){
                case "string":
                    return vi(e);
                case "number":
                    return +e;
                case "boolean":
                    return !!e;
                case "color":
                    return qn.parse(e);
                case "formatted":
                    return mi.fromString(vi(e));
                case "resolvedImage":
                    return yi.fromString(vi(e));
            }
            return e;
        }
        function $s(t1, e, r, n) {
            return void 0 !== n && (t1 = n * Math.round(t1 / n)), void 0 !== e && t1 < e && (t1 = e), void 0 !== r && t1 > r && (t1 = r), t1;
        }
        class Gs {
            constructor(t1, e, r){
                this.type = t1, this.key = e, this.scope = r;
            }
            static parse(t1, e) {
                let r = e.expectedType;
                if (null == r && (r = ni), t1.length < 2 || t1.length > 3) return e.error("Invalid number of arguments for 'config' expression.");
                const n = e.parse(t1[1], 1);
                if (!(n instanceof _i)) return e.error("Key name of 'config' expression must be a string literal.");
                if (t1.length >= 3) {
                    const i = e.parse(t1[2], 2);
                    return i instanceof _i ? new Gs(r, vi(n.value), vi(i.value)) : e.error("Scope of 'config' expression must be a string literal.");
                }
                return new Gs(r, vi(n.value));
            }
            evaluate(t1) {
                const e = [
                    this.key,
                    this.scope,
                    t1.scope
                ].filter(Boolean).join("\x1f"), r = t1.getConfig(e);
                if (!r) return null;
                const { type: n, value: i, values: s, minValue: a, maxValue: o, stepValue: l } = r, u = r.default.evaluate(t1);
                let c = u;
                if (i) {
                    const e = t1.scope;
                    t1.scope = (e || "").split("\x1f").slice(1).join("\x1f"), c = i.evaluate(t1), t1.scope = e;
                }
                return n && (c = qs(n, c)), void 0 === c || void 0 === a && void 0 === o && void 0 === l || ("number" == typeof c ? c = $s(c, a, o, l) : Array.isArray(c) && (c = c.map((t1)=>"number" == typeof t1 ? $s(t1, a, o, l) : t1))), void 0 !== i && void 0 !== c && s && !s.includes(c) && (c = u, n && (c = qs(n, c))), (n && n !== this.type || void 0 !== c && bi(c) !== this.type) && (c = qs(this.type.kind, c)), c;
            }
            eachChild() {}
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = [
                    "config",
                    this.key
                ];
                return this.scope && t1.concat(this.key), t1;
            }
        }
        function Ys(t1) {
            if (t1 instanceof Bi) {
                if ("get" === t1.name && 1 === t1.args.length) return !1;
                if ("feature-state" === t1.name) return !1;
                if ("has" === t1.name && 1 === t1.args.length) return !1;
                if ("properties" === t1.name || "geometry-type" === t1.name || "id" === t1.name) return !1;
                if (/^filter-/.test(t1.name)) return !1;
            }
            if (t1 instanceof rs) return !1;
            if (t1 instanceof js) return !1;
            let e = !0;
            return t1.eachChild((t1)=>{
                e && !Ys(t1) && (e = !1);
            }), e;
        }
        function Xs(t1) {
            if (t1 instanceof Bi && "feature-state" === t1.name) return !1;
            let e = !0;
            return t1.eachChild((t1)=>{
                e && !Xs(t1) && (e = !1);
            }), e;
        }
        function Zs(t1) {
            if (t1 instanceof Gs) return !1;
            let e = !0;
            return t1.eachChild((t1)=>{
                e && !Zs(t1) && (e = !1);
            }), e;
        }
        function Hs(t1, e) {
            if (t1 instanceof Bi && e.indexOf(t1.name) >= 0) return !1;
            let r = !0;
            return t1.eachChild((t1)=>{
                r && !Hs(t1, e) && (r = !1);
            }), r;
        }
        class Ks {
            constructor(t1, e){
                this.type = e.type, this.name = t1, this.boundExpression = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length || "string" != typeof t1[1]) return e.error("'var' expression requires exactly one string literal argument.");
                const r = t1[1];
                return e.scope.has(r) ? new Ks(r, e.scope.get(r)) : e.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t1) {
                return this.boundExpression.evaluate(t1);
            }
            eachChild() {}
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "var",
                    this.name
                ];
            }
        }
        class Ws {
            constructor(t1, e = [], r, n = new Kn, i = [], s, a){
                this.registry = t1, this.path = e, this.key = e.map((t1)=>`[${t1}]`).join(""), this.scope = n, this.errors = i, this.expectedType = r, this._scope = s, this.options = a;
            }
            parse(t1, e, r, n, i = {}) {
                return e || r ? this.concat(e, r, n)._parse(t1, i) : this._parse(t1, i);
            }
            _parse(t1, e) {
                function r(t1, e, r) {
                    return "assert" === r ? new Ai(e, [
                        t1
                    ]) : "coerce" === r ? new Pi(e, [
                        t1
                    ]) : t1;
                }
                if (null !== t1 && "string" != typeof t1 && "boolean" != typeof t1 && "number" != typeof t1 || (t1 = [
                    "literal",
                    t1
                ]), Array.isArray(t1)) {
                    if (0 === t1.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                    const n = "string" == typeof t1[0] ? this.registry[t1[0]] : void 0;
                    if (n) {
                        let i = n.parse(t1, this);
                        if (!i) return null;
                        if (this.expectedType) {
                            const t1 = this.expectedType, n = i.type;
                            if ("string" !== t1.kind && "number" !== t1.kind && "boolean" !== t1.kind && "object" !== t1.kind && "array" !== t1.kind || "value" !== n.kind) {
                                if ("color" !== t1.kind && "formatted" !== t1.kind && "resolvedImage" !== t1.kind || "value" !== n.kind && "string" !== n.kind) {
                                    if (this.checkSubtype(t1, n)) return null;
                                } else i = r(i, t1, e.typeAnnotation || "coerce");
                            } else i = r(i, t1, e.typeAnnotation || "assert");
                        }
                        if (!(i instanceof _i) && "resolvedImage" !== i.type.kind && Qs(i)) {
                            const t1 = new Ei(this._scope, this.options);
                            try {
                                i = new _i(i.type, i.evaluate(t1));
                            } catch (t1) {
                                return this.error(t1.message), null;
                            }
                        }
                        return i;
                    }
                    return Pi.parse([
                        "to-array",
                        t1
                    ], this);
                }
                return this.error(void 0 === t1 ? "'undefined' value invalid. Use null instead." : "object" == typeof t1 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t1} instead.`);
            }
            concat(t1, e, r) {
                const n = "number" == typeof t1 ? this.path.concat(t1) : this.path, i = r ? this.scope.concat(r) : this.scope;
                return new Ws(this.registry, n, e || null, i, this.errors, this._scope, this.options);
            }
            error(t1, ...e) {
                const r = `${this.key}${e.map((t1)=>`[${t1}]`).join("")}`;
                this.errors.push(new Hn(r, t1));
            }
            checkSubtype(t1, e) {
                const r = ci(t1, e);
                return r && this.error(r), r;
            }
        }
        var Js = Ws;
        function Qs(t1) {
            if (t1 instanceof Ks) return Qs(t1.boundExpression);
            if (t1 instanceof Bi && "error" === t1.name) return !1;
            if (t1 instanceof Ci) return !1;
            if (t1 instanceof rs) return !1;
            if (t1 instanceof js) return !1;
            if (t1 instanceof Gs) return !1;
            const e = t1 instanceof Pi || t1 instanceof Ai;
            let r = !0;
            return t1.eachChild((t1)=>{
                r = e ? r && Qs(t1) : r && t1 instanceof _i;
            }), !!r && Ys(t1) && Hs(t1, [
                "zoom",
                "heatmap-density",
                "line-progress",
                "raster-value",
                "sky-radial-progress",
                "accumulated",
                "is-supported-script",
                "pitch",
                "distance-from-center",
                "measure-light",
                "raster-particle-speed"
            ]);
        }
        function ta(t1, e) {
            const r = t1.length - 1;
            let n, i, s = 0, a = r, o = 0;
            for(; s <= a;)if (o = Math.floor((s + a) / 2), n = t1[o], i = t1[o + 1], n <= e) {
                if (o === r || e < i) return o;
                s = o + 1;
            } else {
                if (!(n > e)) throw new wi("Input is not a number.");
                a = o - 1;
            }
            return 0;
        }
        class ea {
            constructor(t1, e, r){
                this.type = t1, this.input = e, this.labels = [], this.outputs = [];
                for (const [t1, e] of r)this.labels.push(t1), this.outputs.push(e);
            }
            static parse(t1, e) {
                if (t1.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if ((t1.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");
                const r = e.parse(t1[1], 1, Jn);
                if (!r) return null;
                const n = [];
                let i = null;
                e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType);
                for(let r = 1; r < t1.length; r += 2){
                    const s = 1 === r ? -1 / 0 : t1[r], a = t1[r + 1], o = r, l = r + 1;
                    if ("number" != typeof s) return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o);
                    if (n.length && n[n.length - 1][0] >= s) return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o);
                    const u = e.parse(a, l, i);
                    if (!u) return null;
                    i = i || u.type, n.push([
                        s,
                        u
                    ]);
                }
                return new ea(i, r, n);
            }
            evaluate(t1) {
                const e = this.labels, r = this.outputs;
                if (1 === e.length) return r[0].evaluate(t1);
                const n = this.input.evaluate(t1);
                if (n <= e[0]) return r[0].evaluate(t1);
                const i = e.length;
                return n >= e[i - 1] ? r[i - 1].evaluate(t1) : r[ta(e, n)].evaluate(t1);
            }
            eachChild(t1) {
                t1(this.input);
                for (const e of this.outputs)t1(e);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = [
                    "step",
                    this.input.serialize()
                ];
                for(let e = 0; e < this.labels.length; e++)e > 0 && t1.push(this.labels[e]), t1.push(this.outputs[e].serialize());
                return t1;
            }
        }
        const ra = .95047, na = 1.08883, ia = 4 / 29, sa = 6 / 29, aa = 3 * sa * sa, oa = sa * sa * sa, la = Math.PI / 180, ua = 180 / Math.PI;
        function ca(t1) {
            return t1 > oa ? Math.pow(t1, 1 / 3) : t1 / aa + ia;
        }
        function ha(t1) {
            return t1 > sa ? t1 * t1 * t1 : aa * (t1 - ia);
        }
        function pa(t1) {
            return 255 * (t1 <= .0031308 ? 12.92 * t1 : 1.055 * Math.pow(t1, 1 / 2.4) - .055);
        }
        function fa(t1) {
            return (t1 /= 255) <= .04045 ? t1 / 12.92 : Math.pow((t1 + .055) / 1.055, 2.4);
        }
        function da(t1) {
            const e = fa(t1.r), r = fa(t1.g), n = fa(t1.b), i = ca((.4124564 * e + .3575761 * r + .1804375 * n) / ra), s = ca((.2126729 * e + .7151522 * r + .072175 * n) / 1);
            return {
                l: 116 * s - 16,
                a: 500 * (i - s),
                b: 200 * (s - ca((.0193339 * e + .119192 * r + .9503041 * n) / na)),
                alpha: t1.a
            };
        }
        function ma(t1) {
            let e = (t1.l + 16) / 116, r = isNaN(t1.a) ? e : e + t1.a / 500, n = isNaN(t1.b) ? e : e - t1.b / 200;
            return e = 1 * ha(e), r = ra * ha(r), n = na * ha(n), new qn(pa(3.2404542 * r - 1.5371385 * e - .4985314 * n), pa(-0.969266 * r + 1.8760108 * e + .041556 * n), pa(.0556434 * r - .2040259 * e + 1.0572252 * n), t1.alpha);
        }
        function ya(t1, e, r) {
            const n = e - t1;
            return t1 + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);
        }
        const ga = {
            forward: da,
            reverse: ma,
            interpolate: function(t1, e, r) {
                return {
                    l: Gn(t1.l, e.l, r),
                    a: Gn(t1.a, e.a, r),
                    b: Gn(t1.b, e.b, r),
                    alpha: Gn(t1.alpha, e.alpha, r)
                };
            }
        }, xa = {
            forward: function(t1) {
                const { l: e, a: r, b: n } = da(t1), i = Math.atan2(n, r) * ua;
                return {
                    h: i < 0 ? i + 360 : i,
                    c: Math.sqrt(r * r + n * n),
                    l: e,
                    alpha: t1.a
                };
            },
            reverse: function(t1) {
                const e = t1.h * la, r = t1.c;
                return ma({
                    l: t1.l,
                    a: Math.cos(e) * r,
                    b: Math.sin(e) * r,
                    alpha: t1.alpha
                });
            },
            interpolate: function(t1, e, r) {
                return {
                    h: ya(t1.h, e.h, r),
                    c: Gn(t1.c, e.c, r),
                    l: Gn(t1.l, e.l, r),
                    alpha: Gn(t1.alpha, e.alpha, r)
                };
            }
        };
        var ba = Object.freeze({
            __proto__: null,
            hcl: xa,
            lab: ga
        });
        class va {
            constructor(t1, e, r, n, i){
                this.type = t1, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];
                for (const [t1, e] of i)this.labels.push(t1), this.outputs.push(e);
            }
            static interpolationFactor(t1, e, r, n) {
                let i = 0;
                if ("exponential" === t1.name) i = _a(e, t1.base, r, n);
                else if ("linear" === t1.name) i = _a(e, 1, r, n);
                else if ("cubic-bezier" === t1.name) {
                    const s = t1.controlPoints;
                    i = new Oe(s[0], s[1], s[2], s[3]).solve(_a(e, 1, r, n));
                }
                return i;
            }
            static parse(t1, e) {
                let [r, n, i, ...s] = t1;
                if (!Array.isArray(n) || 0 === n.length) return e.error("Expected an interpolation type expression.", 1);
                if ("linear" === n[0]) n = {
                    name: "linear"
                };
                else if ("exponential" === n[0]) {
                    const t1 = n[1];
                    if ("number" != typeof t1) return e.error("Exponential interpolation requires a numeric base.", 1, 1);
                    n = {
                        name: "exponential",
                        base: t1
                    };
                } else {
                    if ("cubic-bezier" !== n[0]) return e.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);
                    {
                        const t1 = n.slice(1);
                        if (4 !== t1.length || t1.some((t1)=>"number" != typeof t1 || t1 < 0 || t1 > 1)) return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                        n = {
                            name: "cubic-bezier",
                            controlPoints: t1
                        };
                    }
                }
                if (t1.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if ((t1.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");
                if (i = e.parse(i, 2, Jn), !i) return null;
                const a = [];
                let o = null;
                "interpolate-hcl" === r || "interpolate-lab" === r ? o = ei : e.expectedType && "value" !== e.expectedType.kind && (o = e.expectedType);
                for(let t1 = 0; t1 < s.length; t1 += 2){
                    const r = s[t1], n = s[t1 + 1], i = t1 + 3, l = t1 + 4;
                    if ("number" != typeof r) return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);
                    if (a.length && a[a.length - 1][0] >= r) return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i);
                    const u = e.parse(n, l, o);
                    if (!u) return null;
                    o = o || u.type, a.push([
                        r,
                        u
                    ]);
                }
                return "number" === o.kind || "color" === o.kind || "array" === o.kind && "number" === o.itemType.kind && "number" == typeof o.N ? new va(o, r, n, i, a) : e.error(`Type ${li(o)} is not interpolatable.`);
            }
            evaluate(t1) {
                const e = this.labels, r = this.outputs;
                if (1 === e.length) return r[0].evaluate(t1);
                const n = this.input.evaluate(t1);
                if (n <= e[0]) return r[0].evaluate(t1);
                const i = e.length;
                if (n >= e[i - 1]) return r[i - 1].evaluate(t1);
                const s = ta(e, n), a = va.interpolationFactor(this.interpolation, n, e[s], e[s + 1]), o = r[s].evaluate(t1), l = r[s + 1].evaluate(t1);
                return "interpolate" === this.operator ? Xn[this.type.kind.toLowerCase()](o, l, a) : "interpolate-hcl" === this.operator ? xa.reverse(xa.interpolate(xa.forward(o), xa.forward(l), a)) : ga.reverse(ga.interpolate(ga.forward(o), ga.forward(l), a));
            }
            eachChild(t1) {
                t1(this.input);
                for (const e of this.outputs)t1(e);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined());
            }
            serialize() {
                let t1;
                t1 = "linear" === this.interpolation.name ? [
                    "linear"
                ] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? [
                    "linear"
                ] : [
                    "exponential",
                    this.interpolation.base
                ] : [
                    "cubic-bezier"
                ].concat(this.interpolation.controlPoints);
                const e = [
                    this.operator,
                    t1,
                    this.input.serialize()
                ];
                for(let t1 = 0; t1 < this.labels.length; t1++)e.push(this.labels[t1], this.outputs[t1].serialize());
                return e;
            }
        }
        function _a(t1, e, r, n) {
            const i = n - r, s = t1 - r;
            return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);
        }
        class wa {
            constructor(t1, e){
                this.type = t1, this.args = e;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expectected at least one argument.");
                let r = null;
                const n = e.expectedType;
                n && "value" !== n.kind && (r = n);
                const i = [];
                for (const n of t1.slice(1)){
                    const t1 = e.parse(n, 1 + i.length, r, void 0, {
                        typeAnnotation: "omit"
                    });
                    if (!t1) return null;
                    r = r || t1.type, i.push(t1);
                }
                const s = n && i.some((t1)=>ci(n, t1.type));
                return new wa(s ? ni : r, i);
            }
            evaluate(t1) {
                let e, r = null, n = 0;
                for (const i of this.args){
                    if (n++, r = i.evaluate(t1), r && r instanceof yi && !r.available && (e || (e = r), r = null, n === this.args.length)) return e;
                    if (null !== r) break;
                }
                return r;
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = [
                    "coalesce"
                ];
                return this.eachChild((e)=>{
                    t1.push(e.serialize());
                }), t1;
            }
        }
        class Ma {
            constructor(t1, e){
                this.type = e.type, this.bindings = [].concat(t1), this.result = e;
            }
            evaluate(t1) {
                return this.result.evaluate(t1);
            }
            eachChild(t1) {
                for (const e of this.bindings)t1(e[1]);
                t1(this.result);
            }
            static parse(t1, e) {
                if (t1.length < 4) return e.error(`Expected at least 3 arguments, but found ${t1.length - 1} instead.`);
                const r = [];
                for(let n = 1; n < t1.length - 1; n += 2){
                    const i = t1[n];
                    if ("string" != typeof i) return e.error(`Expected string, but found ${typeof i} instead.`, n);
                    if (/[^a-zA-Z0-9_]/.test(i)) return e.error("Variable names must contain only alphanumeric characters or '_'.", n);
                    const s = e.parse(t1[n + 1], n + 1);
                    if (!s) return null;
                    r.push([
                        i,
                        s
                    ]);
                }
                const n = e.parse(t1[t1.length - 1], t1.length - 1, e.expectedType, r);
                return n ? new Ma(r, n) : null;
            }
            outputDefined() {
                return this.result.outputDefined();
            }
            serialize() {
                const t1 = [
                    "let"
                ];
                for (const [e, r] of this.bindings)t1.push(e, r.serialize());
                return t1.push(this.result.serialize()), t1;
            }
        }
        class Aa {
            constructor(t1, e, r){
                this.type = t1, this.index = e, this.input = r;
            }
            static parse(t1, e) {
                if (3 !== t1.length) return e.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, Jn), n = e.parse(t1[2], 2, oi(e.expectedType || ni));
                return r && n ? new Aa(n.type.itemType, r, n) : null;
            }
            evaluate(t1) {
                const e = this.index.evaluate(t1), r = this.input.evaluate(t1);
                if (e < 0) throw new wi(`Array index out of bounds: ${e} < 0.`);
                if (e >= r.length) throw new wi(`Array index out of bounds: ${e} > ${r.length - 1}.`);
                if (e !== Math.floor(e)) throw new wi(`Array index must be an integer, but found ${e} instead.`);
                return r[e];
            }
            eachChild(t1) {
                t1(this.index), t1(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "at",
                    this.index.serialize(),
                    this.input.serialize()
                ];
            }
        }
        class Sa {
            constructor(t1, e){
                this.type = ti, this.needle = t1, this.haystack = e;
            }
            static parse(t1, e) {
                if (3 !== t1.length) return e.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, ni), n = e.parse(t1[2], 2, ni);
                return r && n ? hi(r.type, [
                    ti,
                    Qn,
                    Jn,
                    Wn,
                    ni
                ]) ? new Sa(r, n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${li(r.type)} instead`) : null;
            }
            evaluate(t1) {
                const e = this.needle.evaluate(t1), r = this.haystack.evaluate(t1);
                if (null == r) return !1;
                if (!pi(e, [
                    "boolean",
                    "string",
                    "number",
                    "null"
                ])) throw new wi(`Expected first argument to be of type boolean, string, number or null, but found ${li(bi(e))} instead.`);
                if (!pi(r, [
                    "string",
                    "array"
                ])) throw new wi(`Expected second argument to be of type array or string, but found ${li(bi(r))} instead.`);
                return r.indexOf(e) >= 0;
            }
            eachChild(t1) {
                t1(this.needle), t1(this.haystack);
            }
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "in",
                    this.needle.serialize(),
                    this.haystack.serialize()
                ];
            }
        }
        class Ia {
            constructor(t1, e, r){
                this.type = Jn, this.needle = t1, this.haystack = e, this.fromIndex = r;
            }
            static parse(t1, e) {
                if (t1.length <= 2 || t1.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, ni), n = e.parse(t1[2], 2, ni);
                if (!r || !n) return null;
                if (!hi(r.type, [
                    ti,
                    Qn,
                    Jn,
                    Wn,
                    ni
                ])) return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${li(r.type)} instead`);
                if (4 === t1.length) {
                    const i = e.parse(t1[3], 3, Jn);
                    return i ? new Ia(r, n, i) : null;
                }
                return new Ia(r, n);
            }
            evaluate(t1) {
                const e = this.needle.evaluate(t1), r = this.haystack.evaluate(t1);
                if (!pi(e, [
                    "boolean",
                    "string",
                    "number",
                    "null"
                ])) throw new wi(`Expected first argument to be of type boolean, string, number or null, but found ${li(bi(e))} instead.`);
                if (!pi(r, [
                    "string",
                    "array"
                ])) throw new wi(`Expected second argument to be of type array or string, but found ${li(bi(r))} instead.`);
                if (this.fromIndex) {
                    const n = this.fromIndex.evaluate(t1);
                    return r.indexOf(e, n);
                }
                return r.indexOf(e);
            }
            eachChild(t1) {
                t1(this.needle), t1(this.haystack), this.fromIndex && t1(this.fromIndex);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                if (null != this.fromIndex && void 0 !== this.fromIndex) {
                    const t1 = this.fromIndex.serialize();
                    return [
                        "index-of",
                        this.needle.serialize(),
                        this.haystack.serialize(),
                        t1
                    ];
                }
                return [
                    "index-of",
                    this.needle.serialize(),
                    this.haystack.serialize()
                ];
            }
        }
        class Ta {
            constructor(t1, e, r, n, i, s){
                this.inputType = t1, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = s;
            }
            static parse(t1, e) {
                if (t1.length < 5) return e.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if (t1.length % 2 != 1) return e.error("Expected an even number of arguments.");
                let r, n;
                e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType);
                const i = {}, s = [];
                for(let a = 2; a < t1.length - 1; a += 2){
                    let o = t1[a];
                    const l = t1[a + 1];
                    Array.isArray(o) || (o = [
                        o
                    ]);
                    const u = e.concat(a);
                    if (0 === o.length) return u.error("Expected at least one branch label.");
                    for (const t1 of o){
                        if ("number" != typeof t1 && "string" != typeof t1) return u.error("Branch labels must be numbers or strings.");
                        if ("number" == typeof t1 && Math.abs(t1) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                        if ("number" == typeof t1 && Math.floor(t1) !== t1) return u.error("Numeric branch labels must be integer values.");
                        if (r) {
                            if (u.checkSubtype(r, bi(t1))) return null;
                        } else r = bi(t1);
                        if (void 0 !== i[String(t1)]) return u.error("Branch labels must be unique.");
                        i[String(t1)] = s.length;
                    }
                    const c = e.parse(l, a, n);
                    if (!c) return null;
                    n = n || c.type, s.push(c);
                }
                const a = e.parse(t1[1], 1, ni);
                if (!a) return null;
                const o = e.parse(t1[t1.length - 1], t1.length - 1, n);
                return o ? "value" !== a.type.kind && e.concat(1).checkSubtype(r, a.type) ? null : new Ta(r, n, a, i, s, o) : null;
            }
            evaluate(t1) {
                const e = this.input.evaluate(t1);
                return (bi(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t1);
            }
            eachChild(t1) {
                t1(this.input), this.outputs.forEach(t1), t1(this.otherwise);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
                const t1 = [
                    "match",
                    this.input.serialize()
                ], e = Object.keys(this.cases).sort(), r = [], n = {};
                for (const t1 of e){
                    const e = n[this.cases[t1]];
                    void 0 === e ? (n[this.cases[t1]] = r.length, r.push([
                        this.cases[t1],
                        [
                            t1
                        ]
                    ])) : r[e][1].push(t1);
                }
                const i = (t1)=>"number" === this.inputType.kind ? Number(t1) : t1;
                for (const [e, n] of r)t1.push(1 === n.length ? i(n[0]) : n.map(i)), t1.push(this.outputs[e].serialize());
                return t1.push(this.otherwise.serialize()), t1;
            }
        }
        class ka {
            constructor(t1, e, r){
                this.type = t1, this.branches = e, this.otherwise = r;
            }
            static parse(t1, e) {
                if (t1.length < 4) return e.error(`Expected at least 3 arguments, but found only ${t1.length - 1}.`);
                if (t1.length % 2 != 0) return e.error("Expected an odd number of arguments.");
                let r;
                e.expectedType && "value" !== e.expectedType.kind && (r = e.expectedType);
                const n = [];
                for(let i = 1; i < t1.length - 1; i += 2){
                    const s = e.parse(t1[i], i, ti);
                    if (!s) return null;
                    const a = e.parse(t1[i + 1], i + 1, r);
                    if (!a) return null;
                    n.push([
                        s,
                        a
                    ]), r = r || a.type;
                }
                const i = e.parse(t1[t1.length - 1], t1.length - 1, r);
                return i ? new ka(r, n, i) : null;
            }
            evaluate(t1) {
                for (const [e, r] of this.branches)if (e.evaluate(t1)) return r.evaluate(t1);
                return this.otherwise.evaluate(t1);
            }
            eachChild(t1) {
                for (const [e, r] of this.branches)t1(e), t1(r);
                t1(this.otherwise);
            }
            outputDefined() {
                return this.branches.every(([t1, e])=>e.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
                const t1 = [
                    "case"
                ];
                return this.eachChild((e)=>{
                    t1.push(e.serialize());
                }), t1;
            }
        }
        class Pa {
            constructor(t1, e, r, n){
                this.type = t1, this.input = e, this.beginIndex = r, this.endIndex = n;
            }
            static parse(t1, e) {
                if (t1.length <= 2 || t1.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, ni), n = e.parse(t1[2], 2, Jn);
                if (!r || !n) return null;
                if (!hi(r.type, [
                    oi(ni),
                    Qn,
                    ni
                ])) return e.error(`Expected first argument to be of type array or string, but found ${li(r.type)} instead`);
                if (4 === t1.length) {
                    const i = e.parse(t1[3], 3, Jn);
                    return i ? new Pa(r.type, r, n, i) : null;
                }
                return new Pa(r.type, r, n);
            }
            evaluate(t1) {
                const e = this.input.evaluate(t1), r = this.beginIndex.evaluate(t1);
                if (!pi(e, [
                    "string",
                    "array"
                ])) throw new wi(`Expected first argument to be of type array or string, but found ${li(bi(e))} instead.`);
                if (this.endIndex) {
                    const n = this.endIndex.evaluate(t1);
                    return e.slice(r, n);
                }
                return e.slice(r);
            }
            eachChild(t1) {
                t1(this.input), t1(this.beginIndex), this.endIndex && t1(this.endIndex);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                if (null != this.endIndex && void 0 !== this.endIndex) {
                    const t1 = this.endIndex.serialize();
                    return [
                        "slice",
                        this.input.serialize(),
                        this.beginIndex.serialize(),
                        t1
                    ];
                }
                return [
                    "slice",
                    this.input.serialize(),
                    this.beginIndex.serialize()
                ];
            }
        }
        function za(t1, e) {
            return "==" === t1 || "!=" === t1 ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind;
        }
        function Ea(t1, e, r, n) {
            return 0 === n.compare(e, r);
        }
        function Ba(t1, e, r) {
            const n = "==" !== t1 && "!=" !== t1;
            return class i {
                constructor(t1, e, r){
                    this.type = ti, this.lhs = t1, this.rhs = e, this.collator = r, this.hasUntypedArgument = "value" === t1.type.kind || "value" === e.type.kind;
                }
                static parse(t1, e) {
                    if (3 !== t1.length && 4 !== t1.length) return e.error("Expected two or three arguments.");
                    const r = t1[0];
                    let s = e.parse(t1[1], 1, ni);
                    if (!s) return null;
                    if (!za(r, s.type)) return e.concat(1).error(`"${r}" comparisons are not supported for type '${li(s.type)}'.`);
                    let a = e.parse(t1[2], 2, ni);
                    if (!a) return null;
                    if (!za(r, a.type)) return e.concat(2).error(`"${r}" comparisons are not supported for type '${li(a.type)}'.`);
                    if (s.type.kind !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind) return e.error(`Cannot compare types '${li(s.type)}' and '${li(a.type)}'.`);
                    n && ("value" === s.type.kind && "value" !== a.type.kind ? s = new Ai(a.type, [
                        s
                    ]) : "value" !== s.type.kind && "value" === a.type.kind && (a = new Ai(s.type, [
                        a
                    ])));
                    let o = null;
                    if (4 === t1.length) {
                        if ("string" !== s.type.kind && "string" !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind) return e.error("Cannot use collator to compare non-string types.");
                        if (o = e.parse(t1[3], 3, ii), !o) return null;
                    }
                    return new i(s, a, o);
                }
                evaluate(i) {
                    const s = this.lhs.evaluate(i), a = this.rhs.evaluate(i);
                    if (n && this.hasUntypedArgument) {
                        const e = bi(s), r = bi(a);
                        if (e.kind !== r.kind || "string" !== e.kind && "number" !== e.kind) throw new wi(`Expected arguments for "${t1}" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`);
                    }
                    if (this.collator && !n && this.hasUntypedArgument) {
                        const t1 = bi(s), r = bi(a);
                        if ("string" !== t1.kind || "string" !== r.kind) return e(i, s, a);
                    }
                    return this.collator ? r(i, s, a, this.collator.evaluate(i)) : e(i, s, a);
                }
                eachChild(t1) {
                    t1(this.lhs), t1(this.rhs), this.collator && t1(this.collator);
                }
                outputDefined() {
                    return !0;
                }
                serialize() {
                    const e = [
                        t1
                    ];
                    return this.eachChild((t1)=>{
                        e.push(t1.serialize());
                    }), e;
                }
            };
        }
        const Da = Ba("==", function(t1, e, r) {
            return e === r;
        }, Ea), Ca = Ba("!=", function(t1, e, r) {
            return e !== r;
        }, function(t1, e, r, n) {
            return !Ea(0, e, r, n);
        }), Ra = Ba("<", function(t1, e, r) {
            return e < r;
        }, function(t1, e, r, n) {
            return n.compare(e, r) < 0;
        }), Va = Ba(">", function(t1, e, r) {
            return e > r;
        }, function(t1, e, r, n) {
            return n.compare(e, r) > 0;
        }), La = Ba("<=", function(t1, e, r) {
            return e <= r;
        }, function(t1, e, r, n) {
            return n.compare(e, r) <= 0;
        }), Oa = Ba(">=", function(t1, e, r) {
            return e >= r;
        }, function(t1, e, r, n) {
            return n.compare(e, r) >= 0;
        });
        class Fa {
            constructor(t1, e, r, n, i, s){
                this.type = Qn, this.number = t1, this.locale = e, this.currency = r, this.unit = n, this.minFractionDigits = i, this.maxFractionDigits = s;
            }
            static parse(t1, e) {
                if (3 !== t1.length) return e.error("Expected two arguments.");
                const r = e.parse(t1[1], 1, Jn);
                if (!r) return null;
                const n = t1[2];
                if ("object" != typeof n || Array.isArray(n)) return e.error("NumberFormat options argument must be an object.");
                let i = null;
                if (n.locale && (i = e.parse(n.locale, 1, Qn), !i)) return null;
                let s = null;
                if (n.currency && (s = e.parse(n.currency, 1, Qn), !s)) return null;
                let a = null;
                if (n.unit && (a = e.parse(n.unit, 1, Qn), !a)) return null;
                let o = null;
                if (n["min-fraction-digits"] && (o = e.parse(n["min-fraction-digits"], 1, Jn), !o)) return null;
                let l = null;
                return n["max-fraction-digits"] && (l = e.parse(n["max-fraction-digits"], 1, Jn), !l) ? null : new Fa(r, i, s, a, o, l);
            }
            evaluate(t1) {
                return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t1) : [], {
                    style: (this.currency ? "currency" : this.unit && "unit") || "decimal",
                    currency: this.currency ? this.currency.evaluate(t1) : void 0,
                    unit: this.unit ? this.unit.evaluate(t1) : void 0,
                    minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t1) : void 0,
                    maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t1) : void 0
                }).format(this.number.evaluate(t1));
            }
            eachChild(t1) {
                t1(this.number), this.locale && t1(this.locale), this.currency && t1(this.currency), this.unit && t1(this.unit), this.minFractionDigits && t1(this.minFractionDigits), this.maxFractionDigits && t1(this.maxFractionDigits);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = {};
                return this.locale && (t1.locale = this.locale.serialize()), this.currency && (t1.currency = this.currency.serialize()), this.unit && (t1.unit = this.unit.serialize()), this.minFractionDigits && (t1["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t1["max-fraction-digits"] = this.maxFractionDigits.serialize()), [
                    "number-format",
                    this.number.serialize(),
                    t1
                ];
            }
        }
        class Ua {
            constructor(t1){
                this.type = Jn, this.input = t1;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error(`Expected 1 argument, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1);
                return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? e.error(`Expected argument of type string or array, but found ${li(r.type)} instead.`) : new Ua(r) : null;
            }
            evaluate(t1) {
                const e = this.input.evaluate(t1);
                if ("string" == typeof e) return e.length;
                if (Array.isArray(e)) return e.length;
                throw new wi(`Expected value to be of type string or array, but found ${li(bi(e))} instead.`);
            }
            eachChild(t1) {
                t1(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = [
                    "length"
                ];
                return this.eachChild((e)=>{
                    t1.push(e.serialize());
                }), t1;
            }
        }
        function Na(t1) {
            return function() {
                t1 = 1831565813 + (t1 |= 0) | 0;
                let e = Math.imul(t1 ^ t1 >>> 15, 1 | t1);
                return e = e + Math.imul(e ^ e >>> 7, 61 | e) ^ e, ((e ^ e >>> 14) >>> 0) / 4294967296;
            };
        }
        const ja = {
            "==": Da,
            "!=": Ca,
            ">": Va,
            "<": Ra,
            ">=": Oa,
            "<=": La,
            array: Ai,
            at: Aa,
            boolean: Ai,
            case: ka,
            coalesce: wa,
            collator: Ci,
            format: Si,
            image: Ii,
            in: Sa,
            "index-of": Ia,
            interpolate: va,
            "interpolate-hcl": va,
            "interpolate-lab": va,
            length: Ua,
            let: Ma,
            literal: _i,
            match: Ta,
            number: Ai,
            "number-format": Fa,
            object: Ai,
            slice: Pa,
            step: ea,
            string: Ai,
            "to-boolean": Pi,
            "to-color": Pi,
            "to-number": Pi,
            "to-string": Pi,
            var: Ks,
            within: rs,
            distance: js,
            config: Gs
        };
        function qa(t1, [e, r, n, i]) {
            e = e.evaluate(t1), r = r.evaluate(t1), n = n.evaluate(t1);
            const s = i ? i.evaluate(t1) : 1, a = gi(e, r, n, s);
            if (a) throw new wi(a);
            return new qn(e / 255 * s, r / 255 * s, n / 255 * s, s);
        }
        function $a(t1, [e, r, n, i]) {
            e = e.evaluate(t1), r = r.evaluate(t1), n = n.evaluate(t1);
            const s = i ? i.evaluate(t1) : 1, a = function(t1, e, r, n) {
                return "number" == typeof t1 && t1 >= 0 && t1 <= 360 ? "number" == typeof e && e >= 0 && e <= 100 && "number" == typeof r && r >= 0 && r <= 100 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid hsla value [${[
                    t1,
                    e,
                    r,
                    n
                ].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${("number" == typeof n ? [
                    t1,
                    e,
                    r,
                    n
                ] : [
                    t1,
                    e,
                    r
                ]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${("number" == typeof n ? [
                    t1,
                    e,
                    r,
                    n
                ] : [
                    t1,
                    e,
                    r
                ]).join(", ")}]: 'h' must be between 0 and 360.`;
            }(e, r, n, s);
            if (a) throw new wi(a);
            const o = `hsla(${e}, ${r}%, ${n}%, ${s})`, l = qn.parse(o);
            if (!l) throw new wi(`Failed to parse HSLA color: ${o}`);
            return l;
        }
        function Ga(t1, e) {
            return t1 in e;
        }
        function Ya(t1, e) {
            const r = e[t1];
            return void 0 === r ? null : r;
        }
        function Xa(t1) {
            return {
                type: t1
            };
        }
        function Za(t1) {
            return {
                result: "success",
                value: t1
            };
        }
        function Ha(t1) {
            return {
                result: "error",
                value: t1
            };
        }
        function Ka(t1, e) {
            return !!t1 && !!t1.parameters && t1.parameters.indexOf(e) > -1;
        }
        function Wa(t1) {
            return "data-driven" === t1["property-type"];
        }
        function Ja(t1) {
            return Ka(t1.expression, "measure-light");
        }
        function Qa(t1) {
            return Ka(t1.expression, "zoom");
        }
        function to(t1) {
            return !!t1.expression && t1.expression.interpolated;
        }
        function eo(t1) {
            return "object" == typeof t1 && null !== t1 && !Array.isArray(t1);
        }
        function ro(t1) {
            return t1;
        }
        function no(t1, e) {
            const r = "color" === e.type, n = t1.stops && "object" == typeof t1.stops[0][0], i = n || !(n || void 0 !== t1.property), s = t1.type || (to(e) ? "exponential" : "interval");
            if (r && ((t1 = Zn({}, t1)).stops && (t1.stops = t1.stops.map((t1)=>[
                    t1[0],
                    qn.parse(t1[1])
                ])), t1.default = qn.parse(t1.default ? t1.default : e.default)), t1.colorSpace && "rgb" !== t1.colorSpace && !ba[t1.colorSpace]) throw new Error(`Unknown color space: ${t1.colorSpace}`);
            let a, o, l;
            if ("exponential" === s) a = oo;
            else if ("interval" === s) a = ao;
            else if ("categorical" === s) {
                a = so, o = Object.create(null);
                for (const e of t1.stops)o[e[0]] = e[1];
                l = typeof t1.stops[0][0];
            } else {
                if ("identity" !== s) throw new Error(`Unknown function type "${s}"`);
                a = lo;
            }
            if (n) {
                const r = {}, n = [];
                for(let e = 0; e < t1.stops.length; e++){
                    const i = t1.stops[e], s = i[0].zoom;
                    void 0 === r[s] && (r[s] = {
                        zoom: s,
                        type: t1.type,
                        property: t1.property,
                        default: t1.default,
                        stops: []
                    }, n.push(s)), r[s].stops.push([
                        i[0].value,
                        i[1]
                    ]);
                }
                const i = [];
                for (const t1 of n)i.push([
                    r[t1].zoom,
                    no(r[t1], e)
                ]);
                const s = {
                    name: "linear"
                };
                return {
                    kind: "composite",
                    interpolationType: s,
                    interpolationFactor: va.interpolationFactor.bind(void 0, s),
                    zoomStops: i.map((t1)=>t1[0]),
                    evaluate: ({ zoom: r }, n)=>oo({
                            stops: i,
                            base: t1.base
                        }, e, r).evaluate(r, n)
                };
            }
            if (i) {
                const r = "exponential" === s ? {
                    name: "exponential",
                    base: void 0 !== t1.base ? t1.base : 1
                } : null;
                return {
                    kind: "camera",
                    interpolationType: r,
                    interpolationFactor: va.interpolationFactor.bind(void 0, r),
                    zoomStops: t1.stops.map((t1)=>t1[0]),
                    evaluate: ({ zoom: r })=>a(t1, e, r, o, l)
                };
            }
            return {
                kind: "source",
                evaluate (r, n) {
                    const i = n && n.properties ? n.properties[t1.property] : void 0;
                    return void 0 === i ? io(t1.default, e.default) : a(t1, e, i, o, l);
                }
            };
        }
        function io(t1, e, r) {
            return void 0 !== t1 ? t1 : void 0 !== e ? e : void 0 !== r ? r : void 0;
        }
        function so(t1, e, r, n, i) {
            return io(typeof r === i ? n[r] : void 0, t1.default, e.default);
        }
        function ao(t1, e, r) {
            if ("number" !== Ti(r)) return io(t1.default, e.default);
            const n = t1.stops.length;
            if (1 === n) return t1.stops[0][1];
            if (r <= t1.stops[0][0]) return t1.stops[0][1];
            if (r >= t1.stops[n - 1][0]) return t1.stops[n - 1][1];
            const i = ta(t1.stops.map((t1)=>t1[0]), r);
            return t1.stops[i][1];
        }
        function oo(t1, e, r) {
            const n = void 0 !== t1.base ? t1.base : 1;
            if ("number" !== Ti(r)) return io(t1.default, e.default);
            const i = t1.stops.length;
            if (1 === i) return t1.stops[0][1];
            if (r <= t1.stops[0][0]) return t1.stops[0][1];
            if (r >= t1.stops[i - 1][0]) return t1.stops[i - 1][1];
            const s = ta(t1.stops.map((t1)=>t1[0]), r), a = function(t1, e, r, n) {
                const i = n - r, s = t1 - r;
                return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);
            }(r, n, t1.stops[s][0], t1.stops[s + 1][0]), o = t1.stops[s][1], l = t1.stops[s + 1][1];
            let u = Xn[e.type] || ro;
            if (t1.colorSpace && "rgb" !== t1.colorSpace) {
                const e = ba[t1.colorSpace];
                u = (t1, r)=>e.reverse(e.interpolate(e.forward(t1), e.forward(r), a));
            }
            return "function" == typeof o.evaluate ? {
                evaluate (...t1) {
                    const e = o.evaluate.apply(void 0, t1), r = l.evaluate.apply(void 0, t1);
                    if (void 0 !== e && void 0 !== r) return u(e, r, a);
                }
            } : u(o, l, a);
        }
        function lo(t1, e, r) {
            return "color" === e.type ? r = qn.parse(r) : "formatted" === e.type ? r = mi.fromString(r.toString()) : "resolvedImage" === e.type ? r = yi.fromString(r.toString()) : Ti(r) === e.type || "enum" === e.type && e.values[r] || (r = void 0), io(r, t1.default, e.default);
        }
        Bi.register(ja, {
            error: [
                {
                    kind: "error"
                },
                [
                    Qn
                ],
                (t1, [e])=>{
                    throw new wi(e.evaluate(t1));
                }
            ],
            typeof: [
                Qn,
                [
                    ni
                ],
                (t1, [e])=>li(bi(e.evaluate(t1)))
            ],
            "to-rgba": [
                oi(Jn, 4),
                [
                    ei
                ],
                (t1, [e])=>e.evaluate(t1).toRenderColor(null).toArray()
            ],
            rgb: [
                ei,
                [
                    Jn,
                    Jn,
                    Jn
                ],
                qa
            ],
            rgba: [
                ei,
                [
                    Jn,
                    Jn,
                    Jn,
                    Jn
                ],
                qa
            ],
            hsl: [
                ei,
                [
                    Jn,
                    Jn,
                    Jn
                ],
                $a
            ],
            hsla: [
                ei,
                [
                    Jn,
                    Jn,
                    Jn,
                    Jn
                ],
                $a
            ],
            has: {
                type: ti,
                overloads: [
                    [
                        [
                            Qn
                        ],
                        (t1, [e])=>Ga(e.evaluate(t1), t1.properties())
                    ],
                    [
                        [
                            Qn,
                            ri
                        ],
                        (t1, [e, r])=>Ga(e.evaluate(t1), r.evaluate(t1))
                    ]
                ]
            },
            get: {
                type: ni,
                overloads: [
                    [
                        [
                            Qn
                        ],
                        (t1, [e])=>Ya(e.evaluate(t1), t1.properties())
                    ],
                    [
                        [
                            Qn,
                            ri
                        ],
                        (t1, [e, r])=>Ya(e.evaluate(t1), r.evaluate(t1))
                    ]
                ]
            },
            "feature-state": [
                ni,
                [
                    Qn
                ],
                (t1, [e])=>Ya(e.evaluate(t1), t1.featureState || {})
            ],
            properties: [
                ri,
                [],
                (t1)=>t1.properties()
            ],
            "geometry-type": [
                Qn,
                [],
                (t1)=>t1.geometryType()
            ],
            id: [
                ni,
                [],
                (t1)=>t1.id()
            ],
            zoom: [
                Jn,
                [],
                (t1)=>t1.globals.zoom
            ],
            pitch: [
                Jn,
                [],
                (t1)=>t1.globals.pitch || 0
            ],
            "distance-from-center": [
                Jn,
                [],
                (t1)=>t1.distanceFromCenter()
            ],
            "measure-light": [
                Jn,
                [
                    Qn
                ],
                (t1, [e])=>t1.measureLight(e.evaluate(t1))
            ],
            "heatmap-density": [
                Jn,
                [],
                (t1)=>t1.globals.heatmapDensity || 0
            ],
            "line-progress": [
                Jn,
                [],
                (t1)=>t1.globals.lineProgress || 0
            ],
            "raster-value": [
                Jn,
                [],
                (t1)=>t1.globals.rasterValue || 0
            ],
            "raster-particle-speed": [
                Jn,
                [],
                (t1)=>t1.globals.rasterParticleSpeed || 0
            ],
            "sky-radial-progress": [
                Jn,
                [],
                (t1)=>t1.globals.skyRadialProgress || 0
            ],
            accumulated: [
                ni,
                [],
                (t1)=>void 0 === t1.globals.accumulated ? null : t1.globals.accumulated
            ],
            "+": [
                Jn,
                Xa(Jn),
                (t1, e)=>{
                    let r = 0;
                    for (const n of e)r += n.evaluate(t1);
                    return r;
                }
            ],
            "*": [
                Jn,
                Xa(Jn),
                (t1, e)=>{
                    let r = 1;
                    for (const n of e)r *= n.evaluate(t1);
                    return r;
                }
            ],
            "-": {
                type: Jn,
                overloads: [
                    [
                        [
                            Jn,
                            Jn
                        ],
                        (t1, [e, r])=>e.evaluate(t1) - r.evaluate(t1)
                    ],
                    [
                        [
                            Jn
                        ],
                        (t1, [e])=>-e.evaluate(t1)
                    ]
                ]
            },
            "/": [
                Jn,
                [
                    Jn,
                    Jn
                ],
                (t1, [e, r])=>e.evaluate(t1) / r.evaluate(t1)
            ],
            "%": [
                Jn,
                [
                    Jn,
                    Jn
                ],
                (t1, [e, r])=>e.evaluate(t1) % r.evaluate(t1)
            ],
            ln2: [
                Jn,
                [],
                ()=>Math.LN2
            ],
            pi: [
                Jn,
                [],
                ()=>Math.PI
            ],
            e: [
                Jn,
                [],
                ()=>Math.E
            ],
            "^": [
                Jn,
                [
                    Jn,
                    Jn
                ],
                (t1, [e, r])=>Math.pow(e.evaluate(t1), r.evaluate(t1))
            ],
            sqrt: [
                Jn,
                [
                    Jn
                ],
                (t1, [e])=>Math.sqrt(e.evaluate(t1))
            ],
            log10: [
                Jn,
                [
                    Jn
                ],
                (t1, [e])=>Math.log(e.evaluate(t1)) / Math.LN10
            ],
            ln: [
                Jn,
                [
                    Jn
                ],
                (t1, [e])=>Math.log(e.evaluate(t1))
            ],
            log2: [
                Jn,
                [
                    Jn
                ],
                (t1, [e])=>Math.log(e.evaluate(t1)) / Math.LN2
            ],
            sin: [
                Jn,
                [
                    Jn
                ],
                (t1, [e])=>Math.sin(e.evaluate(t1))
            ],
            cos: [
                Jn,
                [
                    Jn
                ],
                (t1, [e])=>Math.cos(e.evaluate(t1))
            ],
            tan: [
                Jn,
                [
                    Jn
                ],
                (t1, [e])=>Math.tan(e.evaluate(t1))
            ],
            asin: [
                Jn,
                [
                    Jn
                ],
                (t1, [e])=>Math.asin(e.evaluate(t1))
            ],
            acos: [
                Jn,
                [
                    Jn
                ],
                (t1, [e])=>Math.acos(e.evaluate(t1))
            ],
            atan: [
                Jn,
                [
                    Jn
                ],
                (t1, [e])=>Math.atan(e.evaluate(t1))
            ],
            min: [
                Jn,
                Xa(Jn),
                (t1, e)=>Math.min(...e.map((e)=>e.evaluate(t1)))
            ],
            max: [
                Jn,
                Xa(Jn),
                (t1, e)=>Math.max(...e.map((e)=>e.evaluate(t1)))
            ],
            abs: [
                Jn,
                [
                    Jn
                ],
                (t1, [e])=>Math.abs(e.evaluate(t1))
            ],
            round: [
                Jn,
                [
                    Jn
                ],
                (t1, [e])=>{
                    const r = e.evaluate(t1);
                    return r < 0 ? -Math.round(-r) : Math.round(r);
                }
            ],
            floor: [
                Jn,
                [
                    Jn
                ],
                (t1, [e])=>Math.floor(e.evaluate(t1))
            ],
            ceil: [
                Jn,
                [
                    Jn
                ],
                (t1, [e])=>Math.ceil(e.evaluate(t1))
            ],
            "filter-==": [
                ti,
                [
                    Qn,
                    ni
                ],
                (t1, [e, r])=>t1.properties()[e.value] === r.value
            ],
            "filter-id-==": [
                ti,
                [
                    ni
                ],
                (t1, [e])=>t1.id() === e.value
            ],
            "filter-type-==": [
                ti,
                [
                    Qn
                ],
                (t1, [e])=>t1.geometryType() === e.value
            ],
            "filter-<": [
                ti,
                [
                    Qn,
                    ni
                ],
                (t1, [e, r])=>{
                    const n = t1.properties()[e.value], i = r.value;
                    return typeof n == typeof i && n < i;
                }
            ],
            "filter-id-<": [
                ti,
                [
                    ni
                ],
                (t1, [e])=>{
                    const r = t1.id(), n = e.value;
                    return typeof r == typeof n && r < n;
                }
            ],
            "filter->": [
                ti,
                [
                    Qn,
                    ni
                ],
                (t1, [e, r])=>{
                    const n = t1.properties()[e.value], i = r.value;
                    return typeof n == typeof i && n > i;
                }
            ],
            "filter-id->": [
                ti,
                [
                    ni
                ],
                (t1, [e])=>{
                    const r = t1.id(), n = e.value;
                    return typeof r == typeof n && r > n;
                }
            ],
            "filter-<=": [
                ti,
                [
                    Qn,
                    ni
                ],
                (t1, [e, r])=>{
                    const n = t1.properties()[e.value], i = r.value;
                    return typeof n == typeof i && n <= i;
                }
            ],
            "filter-id-<=": [
                ti,
                [
                    ni
                ],
                (t1, [e])=>{
                    const r = t1.id(), n = e.value;
                    return typeof r == typeof n && r <= n;
                }
            ],
            "filter->=": [
                ti,
                [
                    Qn,
                    ni
                ],
                (t1, [e, r])=>{
                    const n = t1.properties()[e.value], i = r.value;
                    return typeof n == typeof i && n >= i;
                }
            ],
            "filter-id->=": [
                ti,
                [
                    ni
                ],
                (t1, [e])=>{
                    const r = t1.id(), n = e.value;
                    return typeof r == typeof n && r >= n;
                }
            ],
            "filter-has": [
                ti,
                [
                    ni
                ],
                (t1, [e])=>e.value in t1.properties()
            ],
            "filter-has-id": [
                ti,
                [],
                (t1)=>null !== t1.id() && void 0 !== t1.id()
            ],
            "filter-type-in": [
                ti,
                [
                    oi(Qn)
                ],
                (t1, [e])=>e.value.indexOf(t1.geometryType()) >= 0
            ],
            "filter-id-in": [
                ti,
                [
                    oi(ni)
                ],
                (t1, [e])=>e.value.indexOf(t1.id()) >= 0
            ],
            "filter-in-small": [
                ti,
                [
                    Qn,
                    oi(ni)
                ],
                (t1, [e, r])=>r.value.indexOf(t1.properties()[e.value]) >= 0
            ],
            "filter-in-large": [
                ti,
                [
                    Qn,
                    oi(ni)
                ],
                (t1, [e, r])=>(function(t1, e, r, n) {
                        for(; r <= n;){
                            const i = r + n >> 1;
                            if (e[i] === t1) return !0;
                            e[i] > t1 ? n = i - 1 : r = i + 1;
                        }
                        return !1;
                    })(t1.properties()[e.value], r.value, 0, r.value.length - 1)
            ],
            all: {
                type: ti,
                overloads: [
                    [
                        [
                            ti,
                            ti
                        ],
                        (t1, [e, r])=>e.evaluate(t1) && r.evaluate(t1)
                    ],
                    [
                        Xa(ti),
                        (t1, e)=>{
                            for (const r of e)if (!r.evaluate(t1)) return !1;
                            return !0;
                        }
                    ]
                ]
            },
            any: {
                type: ti,
                overloads: [
                    [
                        [
                            ti,
                            ti
                        ],
                        (t1, [e, r])=>e.evaluate(t1) || r.evaluate(t1)
                    ],
                    [
                        Xa(ti),
                        (t1, e)=>{
                            for (const r of e)if (r.evaluate(t1)) return !0;
                            return !1;
                        }
                    ]
                ]
            },
            "!": [
                ti,
                [
                    ti
                ],
                (t1, [e])=>!e.evaluate(t1)
            ],
            "is-supported-script": [
                ti,
                [
                    Qn
                ],
                (t1, [e])=>{
                    const r = t1.globals && t1.globals.isSupportedScript;
                    return !r || r(e.evaluate(t1));
                }
            ],
            upcase: [
                Qn,
                [
                    Qn
                ],
                (t1, [e])=>e.evaluate(t1).toUpperCase()
            ],
            downcase: [
                Qn,
                [
                    Qn
                ],
                (t1, [e])=>e.evaluate(t1).toLowerCase()
            ],
            concat: [
                Qn,
                Xa(ni),
                (t1, e)=>e.map((e)=>vi(e.evaluate(t1))).join("")
            ],
            "resolved-locale": [
                Qn,
                [
                    ii
                ],
                (t1, [e])=>e.evaluate(t1).resolvedLocale()
            ],
            random: [
                Jn,
                [
                    Jn,
                    Jn,
                    ni
                ],
                (t1, e)=>{
                    const [r, n, i] = e.map((e)=>e.evaluate(t1));
                    if (r > n) return r;
                    if (r === n) return r;
                    let s;
                    if ("string" == typeof i) s = function(t1) {
                        let e = 0;
                        if (0 === t1.length) return e;
                        for(let r = 0; r < t1.length; r++)e = (e << 5) - e + t1.charCodeAt(r), e |= 0;
                        return e;
                    }(i);
                    else {
                        if ("number" != typeof i) throw new wi(`Invalid seed input: ${i}`);
                        s = i;
                    }
                    return r + Na(s)() * (n - r);
                }
            ]
        });
        class uo {
            constructor(t1, e, r, n){
                this.expression = t1, this._warningHistory = {}, this._evaluator = new Ei(r, n), this._defaultValue = e ? function(t1) {
                    return "color" === t1.type && (eo(t1.default) || Array.isArray(t1.default)) ? new qn(0, 0, 0, 0) : "color" === t1.type ? qn.parse(t1.default) || null : void 0 === t1.default ? null : t1.default;
                }(e) : null, this._enumValues = e && "enum" === e.type ? e.values : null;
            }
            evaluateWithoutErrorHandling(t1, e, r, n, i, s, a, o) {
                return this._evaluator.globals = t1, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null, this.expression.evaluate(this._evaluator);
            }
            evaluate(t1, e, r, n, i, s, a, o) {
                this._evaluator.globals = t1, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s || null, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null;
                try {
                    const t1 = this.expression.evaluate(this._evaluator);
                    if (null == t1 || "number" == typeof t1 && t1 != t1) return this._defaultValue;
                    if (this._enumValues && !(t1 in this._enumValues)) throw new wi(`Expected value to be one of ${Object.keys(this._enumValues).map((t1)=>JSON.stringify(t1)).join(", ")}, but found ${JSON.stringify(t1)} instead.`);
                    return t1;
                } catch (t1) {
                    return this._warningHistory[t1.message] || (this._warningHistory[t1.message] = !0, "undefined" != typeof console && console.warn(t1.message)), this._defaultValue;
                }
            }
        }
        function co(t1) {
            return Array.isArray(t1) && t1.length > 0 && "string" == typeof t1[0] && t1[0] in ja;
        }
        function ho(t1, e, r, n) {
            const i = new Js(ja, [], e ? function(t1) {
                const e = {
                    color: ei,
                    string: Qn,
                    number: Jn,
                    enum: Qn,
                    boolean: ti,
                    formatted: si,
                    resolvedImage: ai
                };
                return "array" === t1.type ? oi(e[t1.value] || ni, t1.length) : e[t1.type];
            }(e) : void 0, void 0, void 0, r, n), s = i.parse(t1, void 0, void 0, void 0, e && "string" === e.type ? {
                typeAnnotation: "coerce"
            } : void 0);
            return s ? Za(new uo(s, e, r, n)) : Ha(i.errors);
        }
        class po {
            constructor(t1, e, r){
                this.kind = t1, this._styleExpression = e, this.isLightConstant = r, this.isStateDependent = "constant" !== t1 && !Xs(e.expression), this.isConfigDependent = !Zs(e.expression);
            }
            evaluateWithoutErrorHandling(t1, e, r, n, i, s) {
                return this._styleExpression.evaluateWithoutErrorHandling(t1, e, r, n, i, s);
            }
            evaluate(t1, e, r, n, i, s) {
                return this._styleExpression.evaluate(t1, e, r, n, i, s);
            }
        }
        class fo {
            constructor(t1, e, r, n, i){
                this.kind = t1, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = "camera" !== t1 && !Xs(e.expression), this.isLightConstant = i, this.isConfigDependent = !Zs(e.expression), this.interpolationType = n;
            }
            evaluateWithoutErrorHandling(t1, e, r, n, i, s) {
                return this._styleExpression.evaluateWithoutErrorHandling(t1, e, r, n, i, s);
            }
            evaluate(t1, e, r, n, i, s) {
                return this._styleExpression.evaluate(t1, e, r, n, i, s);
            }
            interpolationFactor(t1, e, r) {
                return this.interpolationType ? va.interpolationFactor(this.interpolationType, t1, e, r) : 0;
            }
        }
        function mo(t1, e, r, n) {
            if ("error" === (t1 = ho(t1, e, r, n)).result) return t1;
            const i = t1.value.expression, s = Ys(i);
            if (!s && !Wa(e)) return Ha([
                new Hn("", "data expressions not supported")
            ]);
            const a = Hs(i, [
                "zoom",
                "pitch",
                "distance-from-center"
            ]);
            if (!a && !Qa(e)) return Ha([
                new Hn("", "zoom expressions not supported")
            ]);
            const o = Hs(i, [
                "measure-light"
            ]);
            if (!o && !Ja(e)) return Ha([
                new Hn("", "measure-light expression not supported")
            ]);
            const l = e.expression && e.expression.relaxZoomRestriction, u = go(i);
            return u || a || l ? u instanceof Hn ? Ha([
                u
            ]) : u instanceof va && !to(e) ? Ha([
                new Hn("", '"interpolate" expressions cannot be used with this property')
            ]) : Za(u ? new fo(s ? "camera" : "composite", t1.value, u.labels, u instanceof va ? u.interpolation : void 0, o) : new po(s ? "constant" : "source", t1.value, o)) : Ha([
                new Hn("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')
            ]);
        }
        class yo {
            constructor(t1, e){
                this._parameters = t1, this._specification = e, Zn(this, no(this._parameters, this._specification));
            }
            static deserialize(t1) {
                return new yo(t1._parameters, t1._specification);
            }
            static serialize(t1) {
                return {
                    _parameters: t1._parameters,
                    _specification: t1._specification
                };
            }
        }
        function go(t1) {
            let e = null;
            if (t1 instanceof Ma) e = go(t1.result);
            else if (t1 instanceof wa) {
                for (const r of t1.args)if (e = go(r), e) break;
            } else (t1 instanceof ea || t1 instanceof va) && t1.input instanceof Bi && "zoom" === t1.input.name && (e = t1);
            return e instanceof Hn || t1.eachChild((t1)=>{
                const r = go(t1);
                r instanceof Hn ? e = r : e && r && e !== r && (e = new Hn("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e;
        }
        var xo = vo, bo = 3;
        function vo(t1, e, r) {
            var n = this.cells = [];
            if (t1 instanceof ArrayBuffer) {
                this.arrayBuffer = t1;
                var i = new Int32Array(this.arrayBuffer);
                t1 = i[0], this.d = (e = i[1]) + 2 * (r = i[2]);
                for(var s = 0; s < this.d * this.d; s++){
                    var a = i[bo + s], o = i[bo + s + 1];
                    n.push(a === o ? null : i.subarray(a, o));
                }
                var l = i[bo + n.length + 1];
                this.keys = i.subarray(i[bo + n.length], l), this.bboxes = i.subarray(l), this.insert = this._insertReadonly;
            } else {
                this.d = e + 2 * r;
                for(var u = 0; u < this.d * this.d; u++)n.push([]);
                this.keys = [], this.bboxes = [];
            }
            this.n = e, this.extent = t1, this.padding = r, this.scale = e / t1, this.uid = 0;
            var c = r / e * t1;
            this.min = -c, this.max = t1 + c;
        }
        vo.prototype.insert = function(t1, e, r, n, i) {
            this._forEachCell(e, r, n, i, this._insertCell, this.uid++), this.keys.push(t1), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);
        }, vo.prototype._insertReadonly = function() {
            throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, vo.prototype._insertCell = function(t1, e, r, n, i, s) {
            this.cells[i].push(s);
        }, vo.prototype.query = function(t1, e, r, n, i) {
            var s = this.min, a = this.max;
            if (t1 <= s && e <= s && a <= r && a <= n && !i) return Array.prototype.slice.call(this.keys);
            var o = [];
            return this._forEachCell(t1, e, r, n, this._queryCell, o, {}, i), o;
        }, vo.prototype._queryCell = function(t1, e, r, n, i, s, a, o) {
            var l = this.cells[i];
            if (null !== l) for(var u = this.keys, c = this.bboxes, h = 0; h < l.length; h++){
                var p = l[h];
                if (void 0 === a[p]) {
                    var f = 4 * p;
                    (o ? o(c[f + 0], c[f + 1], c[f + 2], c[f + 3]) : t1 <= c[f + 2] && e <= c[f + 3] && r >= c[f + 0] && n >= c[f + 1]) ? (a[p] = !0, s.push(u[p])) : a[p] = !1;
                }
            }
        }, vo.prototype._forEachCell = function(t1, e, r, n, i, s, a, o) {
            for(var l = this._convertToCellCoord(t1), u = this._convertToCellCoord(e), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n), p = l; p <= c; p++)for(var f = u; f <= h; f++){
                var d = this.d * f + p;
                if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(f), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(f + 1))) && i.call(this, t1, e, r, n, d, s, a, o)) return;
            }
        }, vo.prototype._convertFromCellCoord = function(t1) {
            return (t1 - this.padding) / this.scale;
        }, vo.prototype._convertToCellCoord = function(t1) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t1 * this.scale) + this.padding));
        }, vo.prototype.toArrayBuffer = function() {
            if (this.arrayBuffer) return this.arrayBuffer;
            for(var t1 = this.cells, e = bo + this.cells.length + 1 + 1, r = 0, n = 0; n < this.cells.length; n++)r += this.cells[n].length;
            var i = new Int32Array(e + r + this.keys.length + this.bboxes.length);
            i[0] = this.extent, i[1] = this.n, i[2] = this.padding;
            for(var s = e, a = 0; a < t1.length; a++){
                var o = t1[a];
                i[bo + a] = s, i.set(o, s), s += o.length;
            }
            return i[bo + t1.length] = s, i.set(this.keys, s), i[bo + t1.length + 1] = s += this.keys.length, i.set(this.bboxes, s), s += this.bboxes.length, i.buffer;
        };
        var _o = p(xo);
        const wo = {};
        function Mo(t1, e, r = {}) {
            Object.defineProperty(t1, "_classRegistryKey", {
                value: e,
                writable: !1
            }), wo[e] = {
                klass: t1,
                omit: r.omit || []
            };
        }
        Mo(Object, "Object"), _o.serialize = function(t1, e) {
            const r = t1.toArrayBuffer();
            return e && e.add(r), {
                buffer: r
            };
        }, _o.deserialize = function(t1) {
            return new _o(t1.buffer);
        }, Object.defineProperty(_o, "name", {
            value: "Grid"
        }), Mo(_o, "Grid"), Mo(qn, "Color"), Mo(Error, "Error"), Mo(mi, "Formatted"), Mo(di, "FormattedSection"), Mo(Jr, "AJAXError"), Mo(yi, "ResolvedImage"), Mo(yo, "StylePropertyFunction"), Mo(uo, "StyleExpression", {
            omit: [
                "_evaluator"
            ]
        }), Mo(fo, "ZoomDependentExpression"), Mo(po, "ZoomConstantExpression"), Mo(Bi, "CompoundExpression", {
            omit: [
                "_evaluate"
            ]
        });
        for(const t1 in ja)wo[ja[t1]._classRegistryKey] || Mo(ja[t1], `Expression${t1}`);
        function Ao(t1) {
            return t1 && "undefined" != typeof ArrayBuffer && (t1 instanceof ArrayBuffer || t1.constructor && "ArrayBuffer" === t1.constructor.name);
        }
        function So(t1) {
            return self.ImageBitmap && t1 instanceof ImageBitmap;
        }
        function Io(t1, e) {
            if (null == t1 || "boolean" == typeof t1 || "number" == typeof t1 || "string" == typeof t1 || t1 instanceof Boolean || t1 instanceof Number || t1 instanceof String || t1 instanceof Date || t1 instanceof RegExp) return t1;
            if (Ao(t1) || So(t1)) return e && e.add(t1), t1;
            if (ArrayBuffer.isView(t1)) {
                const r = t1;
                return e && e.add(r.buffer), r;
            }
            if (t1 instanceof ImageData) return e && e.add(t1.data.buffer), t1;
            if (Array.isArray(t1)) {
                const r = [];
                for (const n of t1)r.push(Io(n, e));
                return r;
            }
            if (t1 instanceof Map) {
                const e = {
                    $name: "Map"
                };
                for (const [r, n] of t1.entries())e[r] = Io(n);
                return e;
            }
            if ("object" == typeof t1) {
                const r = t1.constructor, n = r._classRegistryKey;
                if (!n) throw new Error(`can't serialize object of unregistered class ${n}`);
                const i = r.serialize ? r.serialize(t1, e) : {};
                if (!r.serialize) {
                    for(const r in t1)t1.hasOwnProperty(r) && (wo[n].omit.indexOf(r) >= 0 || (i[r] = Io(t1[r], e)));
                    t1 instanceof Error && (i.message = t1.message);
                }
                if (i.$name) throw new Error("$name property is reserved for worker serialization logic.");
                return "Object" !== n && (i.$name = n), i;
            }
            throw new Error("can't serialize object of type " + typeof t1);
        }
        function To(t1) {
            if (null == t1 || "boolean" == typeof t1 || "number" == typeof t1 || "string" == typeof t1 || t1 instanceof Boolean || t1 instanceof Number || t1 instanceof String || t1 instanceof Date || t1 instanceof RegExp || Ao(t1) || So(t1) || ArrayBuffer.isView(t1) || t1 instanceof ImageData) return t1;
            if (Array.isArray(t1)) return t1.map(To);
            if ("object" == typeof t1) {
                const e = t1.$name || "Object";
                if ("Map" === e) {
                    const e = new Map;
                    for (const r of Object.keys(t1))"$name" !== r && e.set(r, To(t1[r]));
                    return e;
                }
                const { klass: r } = wo[e];
                if (!r) throw new Error(`can't deserialize unregistered class ${e}`);
                if (r.deserialize) return r.deserialize(t1);
                const n = Object.create(r.prototype);
                for (const e of Object.keys(t1))"$name" !== e && (n[e] = To(t1[e]));
                return n;
            }
            throw new Error("can't deserialize object of type " + typeof t1);
        }
        const ko = {
            "Latin-1 Supplement": (t1)=>t1 >= 128 && t1 <= 255,
            Arabic: (t1)=>t1 >= 1536 && t1 <= 1791,
            "Arabic Supplement": (t1)=>t1 >= 1872 && t1 <= 1919,
            "Arabic Extended-A": (t1)=>t1 >= 2208 && t1 <= 2303,
            "Hangul Jamo": (t1)=>t1 >= 4352 && t1 <= 4607,
            "Unified Canadian Aboriginal Syllabics": (t1)=>t1 >= 5120 && t1 <= 5759,
            Khmer: (t1)=>t1 >= 6016 && t1 <= 6143,
            "Unified Canadian Aboriginal Syllabics Extended": (t1)=>t1 >= 6320 && t1 <= 6399,
            "General Punctuation": (t1)=>t1 >= 8192 && t1 <= 8303,
            "Letterlike Symbols": (t1)=>t1 >= 8448 && t1 <= 8527,
            "Number Forms": (t1)=>t1 >= 8528 && t1 <= 8591,
            "Miscellaneous Technical": (t1)=>t1 >= 8960 && t1 <= 9215,
            "Control Pictures": (t1)=>t1 >= 9216 && t1 <= 9279,
            "Optical Character Recognition": (t1)=>t1 >= 9280 && t1 <= 9311,
            "Enclosed Alphanumerics": (t1)=>t1 >= 9312 && t1 <= 9471,
            "Geometric Shapes": (t1)=>t1 >= 9632 && t1 <= 9727,
            "Miscellaneous Symbols": (t1)=>t1 >= 9728 && t1 <= 9983,
            "Miscellaneous Symbols and Arrows": (t1)=>t1 >= 11008 && t1 <= 11263,
            "CJK Radicals Supplement": (t1)=>t1 >= 11904 && t1 <= 12031,
            "Kangxi Radicals": (t1)=>t1 >= 12032 && t1 <= 12255,
            "Ideographic Description Characters": (t1)=>t1 >= 12272 && t1 <= 12287,
            "CJK Symbols and Punctuation": (t1)=>t1 >= 12288 && t1 <= 12351,
            Hiragana: (t1)=>t1 >= 12352 && t1 <= 12447,
            Katakana: (t1)=>t1 >= 12448 && t1 <= 12543,
            Bopomofo: (t1)=>t1 >= 12544 && t1 <= 12591,
            "Hangul Compatibility Jamo": (t1)=>t1 >= 12592 && t1 <= 12687,
            Kanbun: (t1)=>t1 >= 12688 && t1 <= 12703,
            "Bopomofo Extended": (t1)=>t1 >= 12704 && t1 <= 12735,
            "CJK Strokes": (t1)=>t1 >= 12736 && t1 <= 12783,
            "Katakana Phonetic Extensions": (t1)=>t1 >= 12784 && t1 <= 12799,
            "Enclosed CJK Letters and Months": (t1)=>t1 >= 12800 && t1 <= 13055,
            "CJK Compatibility": (t1)=>t1 >= 13056 && t1 <= 13311,
            "CJK Unified Ideographs Extension A": (t1)=>t1 >= 13312 && t1 <= 19903,
            "Yijing Hexagram Symbols": (t1)=>t1 >= 19904 && t1 <= 19967,
            "CJK Unified Ideographs": (t1)=>t1 >= 19968 && t1 <= 40959,
            "Yi Syllables": (t1)=>t1 >= 40960 && t1 <= 42127,
            "Yi Radicals": (t1)=>t1 >= 42128 && t1 <= 42191,
            "Hangul Jamo Extended-A": (t1)=>t1 >= 43360 && t1 <= 43391,
            "Hangul Syllables": (t1)=>t1 >= 44032 && t1 <= 55215,
            "Hangul Jamo Extended-B": (t1)=>t1 >= 55216 && t1 <= 55295,
            "Private Use Area": (t1)=>t1 >= 57344 && t1 <= 63743,
            "CJK Compatibility Ideographs": (t1)=>t1 >= 63744 && t1 <= 64255,
            "Arabic Presentation Forms-A": (t1)=>t1 >= 64336 && t1 <= 65023,
            "Vertical Forms": (t1)=>t1 >= 65040 && t1 <= 65055,
            "CJK Compatibility Forms": (t1)=>t1 >= 65072 && t1 <= 65103,
            "Small Form Variants": (t1)=>t1 >= 65104 && t1 <= 65135,
            "Arabic Presentation Forms-B": (t1)=>t1 >= 65136 && t1 <= 65279,
            "Halfwidth and Fullwidth Forms": (t1)=>t1 >= 65280 && t1 <= 65519,
            "CJK Unified Ideographs Extension B": (t1)=>t1 >= 131072 && t1 <= 173791
        };
        function Po(t1) {
            for (const e of t1)if (Bo(e.charCodeAt(0))) return !0;
            return !1;
        }
        function zo(t1) {
            for (const e of t1)if (!Eo(e.charCodeAt(0))) return !1;
            return !0;
        }
        function Eo(t1) {
            return !(ko.Arabic(t1) || ko["Arabic Supplement"](t1) || ko["Arabic Extended-A"](t1) || ko["Arabic Presentation Forms-A"](t1) || ko["Arabic Presentation Forms-B"](t1));
        }
        function Bo(t1) {
            return !(746 !== t1 && 747 !== t1 && (t1 < 4352 || !(ko["Bopomofo Extended"](t1) || ko.Bopomofo(t1) || ko["CJK Compatibility Forms"](t1) && !(t1 >= 65097 && t1 <= 65103) || ko["CJK Compatibility Ideographs"](t1) || ko["CJK Compatibility"](t1) || ko["CJK Radicals Supplement"](t1) || ko["CJK Strokes"](t1) || !(!ko["CJK Symbols and Punctuation"](t1) || t1 >= 12296 && t1 <= 12305 || t1 >= 12308 && t1 <= 12319 || 12336 === t1) || ko["CJK Unified Ideographs Extension A"](t1) || ko["CJK Unified Ideographs"](t1) || ko["Enclosed CJK Letters and Months"](t1) || ko["Hangul Compatibility Jamo"](t1) || ko["Hangul Jamo Extended-A"](t1) || ko["Hangul Jamo Extended-B"](t1) || ko["Hangul Jamo"](t1) || ko["Hangul Syllables"](t1) || ko.Hiragana(t1) || ko["Ideographic Description Characters"](t1) || ko.Kanbun(t1) || ko["Kangxi Radicals"](t1) || ko["Katakana Phonetic Extensions"](t1) || ko.Katakana(t1) && 12540 !== t1 || !(!ko["Halfwidth and Fullwidth Forms"](t1) || 65288 === t1 || 65289 === t1 || 65293 === t1 || t1 >= 65306 && t1 <= 65310 || 65339 === t1 || 65341 === t1 || 65343 === t1 || t1 >= 65371 && t1 <= 65503 || 65507 === t1 || t1 >= 65512 && t1 <= 65519) || !(!ko["Small Form Variants"](t1) || t1 >= 65112 && t1 <= 65118 || t1 >= 65123 && t1 <= 65126) || ko["Unified Canadian Aboriginal Syllabics"](t1) || ko["Unified Canadian Aboriginal Syllabics Extended"](t1) || ko["Vertical Forms"](t1) || ko["Yijing Hexagram Symbols"](t1) || ko["Yi Syllables"](t1) || ko["Yi Radicals"](t1))));
        }
        function Do(t1) {
            return !(Bo(t1) || function(t1) {
                return !!(ko["Latin-1 Supplement"](t1) && (167 === t1 || 169 === t1 || 174 === t1 || 177 === t1 || 188 === t1 || 189 === t1 || 190 === t1 || 215 === t1 || 247 === t1) || ko["General Punctuation"](t1) && (8214 === t1 || 8224 === t1 || 8225 === t1 || 8240 === t1 || 8241 === t1 || 8251 === t1 || 8252 === t1 || 8258 === t1 || 8263 === t1 || 8264 === t1 || 8265 === t1 || 8273 === t1) || ko["Letterlike Symbols"](t1) || ko["Number Forms"](t1) || ko["Miscellaneous Technical"](t1) && (t1 >= 8960 && t1 <= 8967 || t1 >= 8972 && t1 <= 8991 || t1 >= 8996 && t1 <= 9e3 || 9003 === t1 || t1 >= 9085 && t1 <= 9114 || t1 >= 9150 && t1 <= 9165 || 9167 === t1 || t1 >= 9169 && t1 <= 9179 || t1 >= 9186 && t1 <= 9215) || ko["Control Pictures"](t1) && 9251 !== t1 || ko["Optical Character Recognition"](t1) || ko["Enclosed Alphanumerics"](t1) || ko["Geometric Shapes"](t1) || ko["Miscellaneous Symbols"](t1) && !(t1 >= 9754 && t1 <= 9759) || ko["Miscellaneous Symbols and Arrows"](t1) && (t1 >= 11026 && t1 <= 11055 || t1 >= 11088 && t1 <= 11097 || t1 >= 11192 && t1 <= 11243) || ko["CJK Symbols and Punctuation"](t1) || ko.Katakana(t1) || ko["Private Use Area"](t1) || ko["CJK Compatibility Forms"](t1) || ko["Small Form Variants"](t1) || ko["Halfwidth and Fullwidth Forms"](t1) || 8734 === t1 || 8756 === t1 || 8757 === t1 || t1 >= 9984 && t1 <= 10087 || t1 >= 10102 && t1 <= 10131 || 65532 === t1 || 65533 === t1);
            }(t1));
        }
        function Co(t1) {
            return t1 >= 1424 && t1 <= 2303 || ko["Arabic Presentation Forms-A"](t1) || ko["Arabic Presentation Forms-B"](t1);
        }
        function Ro(t1, e) {
            return !(!e && Co(t1) || t1 >= 2304 && t1 <= 3583 || t1 >= 3840 && t1 <= 4255 || ko.Khmer(t1));
        }
        function Vo(t1) {
            for (const e of t1)if (Co(e.charCodeAt(0))) return !0;
            return !1;
        }
        const Lo = "deferred", Oo = "loading", Fo = "loaded";
        let Uo = null, No = "unavailable", jo = null;
        const qo = function(t1) {
            t1 && "string" == typeof t1 && t1.indexOf("NetworkError") > -1 && (No = "error"), Uo && Uo(t1);
        };
        function $o() {
            Go.fire(new Dn("pluginStateChange", {
                pluginStatus: No,
                pluginURL: jo
            }));
        }
        const Go = new Ln, Yo = function() {
            return No;
        }, Xo = function() {
            if (No !== Lo || !jo) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            No = Oo, $o(), jo && en({
                url: jo
            }, (t1)=>{
                t1 ? qo(t1) : (No = Fo, $o());
            });
        }, Zo = {
            applyArabicShaping: null,
            processBidirectionalText: null,
            processStyledBidirectionalText: null,
            isLoaded: ()=>No === Fo || null != Zo.applyArabicShaping,
            isLoading: ()=>No === Oo,
            setState (t1) {
                No = t1.pluginStatus, jo = t1.pluginURL;
            },
            isParsed: ()=>null != Zo.applyArabicShaping && null != Zo.processBidirectionalText && null != Zo.processStyledBidirectionalText,
            getPluginURL: ()=>jo
        };
        class Ho {
            constructor(t1, e){
                this.zoom = t1, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.transition = e.transition, this.pitch = e.pitch, this.brightness = e.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
            }
            isSupportedScript(t1) {
                return function(t1, e) {
                    for (const r of t1)if (!Ro(r.charCodeAt(0), e)) return !1;
                    return !0;
                }(t1, Zo.isLoaded());
            }
        }
        class Ko {
            constructor(t1, e, r, n){
                this.property = t1, this.value = e, this.expression = function(t1, e, r, n) {
                    if (eo(t1)) return new yo(t1, e);
                    if (co(t1) || Array.isArray(t1) && t1.length > 0) {
                        const i = mo(t1, e, r, n);
                        if ("error" === i.result) throw new Error(i.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
                        return i.value;
                    }
                    {
                        let r = t1;
                        return "string" == typeof t1 && "color" === e.type && (r = qn.parse(t1)), {
                            kind: "constant",
                            isConfigDependent: !1,
                            evaluate: ()=>r
                        };
                    }
                }(void 0 === e ? t1.specification.default : e, t1.specification, r, n);
            }
            isDataDriven() {
                return "source" === this.expression.kind || "composite" === this.expression.kind;
            }
            possiblyEvaluate(t1, e, r) {
                return this.property.possiblyEvaluate(this, t1, e, r);
            }
        }
        class Wo {
            constructor(t1, e, r){
                this.property = t1, this.value = new Ko(t1, void 0, e, r);
            }
            transitioned(t1, e) {
                return new Qo(this.property, this.value, e, er({}, t1.transition, this.transition), t1.now);
            }
            untransitioned() {
                return new Qo(this.property, this.value, null, {}, 0);
            }
        }
        class Jo {
            constructor(t1, e, r){
                this._properties = t1, this._values = Object.create(t1.defaultTransitionablePropertyValues), this._scope = e, this._options = r, this.isConfigDependent = !1;
            }
            getValue(t1) {
                return hr(this._values[t1].value.value);
            }
            setValue(t1, e) {
                this._values.hasOwnProperty(t1) || (this._values[t1] = new Wo(this._values[t1].property, this._scope, this._options)), this._values[t1].value = new Ko(this._values[t1].property, null === e ? void 0 : hr(e), this._scope, this._options), this.isConfigDependent = this.isConfigDependent || this._values[t1].value.expression.isConfigDependent;
            }
            setTransitionOrValue(t1, e) {
                e && (this._options = e);
                const r = this._properties.properties;
                if (t1) for(const e in t1){
                    const n = t1[e];
                    if (lr(e, "-transition")) {
                        const t1 = e.slice(0, -11);
                        r[t1] && this.setTransition(t1, n);
                    } else r.hasOwnProperty(e) && this.setValue(e, n);
                }
            }
            getTransition(t1) {
                return hr(this._values[t1].transition);
            }
            setTransition(t1, e) {
                this._values.hasOwnProperty(t1) || (this._values[t1] = new Wo(this._values[t1].property)), this._values[t1].transition = hr(e) || void 0;
            }
            serialize() {
                const t1 = {};
                for (const e of Object.keys(this._values)){
                    const r = this.getValue(e);
                    void 0 !== r && (t1[e] = r);
                    const n = this.getTransition(e);
                    void 0 !== n && (t1[`${e}-transition`] = n);
                }
                return t1;
            }
            transitioned(t1, e) {
                const r = new tl(this._properties);
                for (const n of Object.keys(this._values))r._values[n] = this._values[n].transitioned(t1, e._values[n]);
                return r;
            }
            untransitioned() {
                const t1 = new tl(this._properties);
                for (const e of Object.keys(this._values))t1._values[e] = this._values[e].untransitioned();
                return t1;
            }
        }
        class Qo {
            constructor(t1, e, r, n, i){
                const s = n.delay || 0, a = n.duration || 0;
                i = i || 0, this.property = t1, this.value = e, this.begin = i + s, this.end = this.begin + a, t1.specification.transition && (n.delay || n.duration) && (this.prior = r);
            }
            possiblyEvaluate(t1, e, r) {
                const n = t1.now || 0, i = this.value.possiblyEvaluate(t1, e, r), s = this.prior;
                if (s) {
                    if (n > this.end) return this.prior = null, i;
                    if (this.value.isDataDriven()) return this.prior = null, i;
                    if (n < this.begin) return s.possiblyEvaluate(t1, e, r);
                    {
                        const a = (n - this.begin) / (this.end - this.begin);
                        return this.property.interpolate(s.possiblyEvaluate(t1, e, r), i, Xe(a));
                    }
                }
                return i;
            }
        }
        class tl {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t1, e, r) {
                const n = new nl(this._properties);
                for (const i of Object.keys(this._values))n._values[i] = this._values[i].possiblyEvaluate(t1, e, r);
                return n;
            }
            hasTransition() {
                for (const t1 of Object.keys(this._values))if (this._values[t1].prior) return !0;
                return !1;
            }
        }
        class el {
            constructor(t1, e, r){
                this._properties = t1, this._values = Object.create(t1.defaultPropertyValues), this._scope = e, this._options = r, this.isConfigDependent = !1;
            }
            getValue(t1) {
                return hr(this._values[t1].value);
            }
            setValue(t1, e) {
                this._values[t1] = new Ko(this._values[t1].property, null === e ? void 0 : hr(e), this._scope, this._options), this.isConfigDependent = this.isConfigDependent || this._values[t1].expression.isConfigDependent;
            }
            serialize() {
                const t1 = {};
                for (const e of Object.keys(this._values)){
                    const r = this.getValue(e);
                    void 0 !== r && (t1[e] = r);
                }
                return t1;
            }
            possiblyEvaluate(t1, e, r) {
                const n = new nl(this._properties);
                for (const i of Object.keys(this._values))n._values[i] = this._values[i].possiblyEvaluate(t1, e, r);
                return n;
            }
        }
        class rl {
            constructor(t1, e, r){
                this.property = t1, this.value = e, this.parameters = r;
            }
            isConstant() {
                return "constant" === this.value.kind;
            }
            constantOr(t1) {
                return "constant" === this.value.kind ? this.value.value : t1;
            }
            evaluate(t1, e, r, n) {
                return this.property.evaluate(this.value, this.parameters, t1, e, r, n);
            }
        }
        class nl {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultPossiblyEvaluatedValues);
            }
            get(t1) {
                return this._values[t1];
            }
        }
        class il {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e) {
                return t1.expression.evaluate(e);
            }
            interpolate(t1, e, r) {
                const n = Xn[this.specification.type];
                return n ? n(t1, e, r) : t1;
            }
        }
        class sl {
            constructor(t1, e){
                this.specification = t1, this.overrides = e;
            }
            possiblyEvaluate(t1, e, r, n) {
                return new rl(this, "constant" === t1.expression.kind || "camera" === t1.expression.kind ? {
                    kind: "constant",
                    value: t1.expression.evaluate(e, null, {}, r, n)
                } : t1.expression, e);
            }
            interpolate(t1, e, r) {
                if ("constant" !== t1.value.kind || "constant" !== e.value.kind) return t1;
                if (void 0 === t1.value.value || void 0 === e.value.value) return new rl(this, {
                    kind: "constant",
                    value: void 0
                }, t1.parameters);
                const n = Xn[this.specification.type];
                return n ? new rl(this, {
                    kind: "constant",
                    value: n(t1.value.value, e.value.value, r)
                }, t1.parameters) : t1;
            }
            evaluate(t1, e, r, n, i, s) {
                return "constant" === t1.kind ? t1.value : t1.evaluate(e, r, n, i, s);
            }
        }
        class al {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e, r, n) {
                return !!t1.expression.evaluate(e, null, {}, r, n);
            }
            interpolate() {
                return !1;
            }
        }
        class ol {
            constructor(t1){
                this.properties = t1, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
                const e = new Ho(0, {});
                for(const r in t1){
                    const n = t1[r];
                    n.specification.overridable && this.overridableProperties.push(r);
                    const i = this.defaultPropertyValues[r] = new Ko(n, void 0), s = this.defaultTransitionablePropertyValues[r] = new Wo(n);
                    this.defaultTransitioningPropertyValues[r] = s.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = i.possiblyEvaluate(e);
                }
            }
        }
        Mo(sl, "DataDrivenProperty"), Mo(il, "DataConstantProperty"), Mo(al, "ColorRampProperty");
        var ll = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"required":false,"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"camera":{"type":"camera"},"color-theme":{"type":"colorTheme"},"imports":{"type":"array","value":"import"},"schema":{"type":"schema"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"},"models":{"type":"models"}},"model":{"type":"string","required":true},"import":{"id":{"type":"string","required":true},"url":{"type":"string","required":true},"config":{"type":"config"},"data":{"type":"$root"}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","property-type":"data-constant","expression":{},"required":true},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string","required":true},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false,"expression":{},"property-type":"data-constant"},"shadow-intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"experimental":true,"type":{"required":true,"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":1}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":1}},"url":{"required":false,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"required":true,"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"raster-particle":{"experimental":true},"hillshade":{},"model":{"experimental":true},"background":{},"sky":{},"slot":{},"clip":{"experimental":true}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_clip","layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_clip":{"clip-layer-types":{"type":"array","value":"enum","values":{"model":1,"symbol":1},"default":[],"expression":{},"property-type":"data-constant","experimental":true}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","experimental":true,"private":true,"default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-z-offset":{"type":"number","experimental":true,"expression":{"parameters":["zoom","feature","line-progress"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective","property-type":"data-constant"}},"colorTheme":{"data":{"type":"string","property-type":"data-constant","expression":{}}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_raster-particle","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"property-type":"data-constant","type":"color","experimental":true,"default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"property-type":"data-constant","type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"property-type":"data-constant","type":"number","experimental":true,"default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"property-type":"data-constant","type":"boolean","default":true,"experimental":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"property-type":"constant"},"line-trim-fade-range":{"type":"array","value":"number","experimental":true,"length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-trim-color":{"type":"color","experimental":true,"default":"transparent","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-border-width":{"type":"number","private":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","private":true,"default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-occlusion-opacity":{"type":"number","default":0,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"property-type":"data-constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-image-cross-fade":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]},"property-type":"color-ramp"},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"raster-array-band":{"type":"string","required":false,"experimental":true,"property-type":"data-constant"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-particle-count":{"type":"number","default":512,"minimum":1,"property-type":"data-constant"},"raster-particle-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-particle-speed"]},"property-type":"color-ramp"},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1,"property-type":"data-constant"},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1,"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d","property-type":"data-constant"},"model-cast-shadows":{"type":"boolean","default":true,"expression":{},"property-type":"data-constant"},"model-receive-shadows":{"type":"boolean","default":true,"expression":{},"property-type":"data-constant"},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant","transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"model-front-cutoff":{"type":"array","private":true,"value":"number","property-type":"data-constant","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
        function ul(t1) {
            return t1 instanceof Number || t1 instanceof String || t1 instanceof Boolean ? t1.valueOf() : t1;
        }
        function cl(t1) {
            if (Array.isArray(t1)) return t1.map(cl);
            if (t1 instanceof Object && !(t1 instanceof Number || t1 instanceof String || t1 instanceof Boolean)) {
                const e = {};
                for(const r in t1)e[r] = cl(t1[r]);
                return e;
            }
            return ul(t1);
        }
        function hl(t1) {
            if (!0 === t1 || !1 === t1) return !0;
            if (!Array.isArray(t1) || 0 === t1.length) return !1;
            switch(t1[0]){
                case "has":
                    return t1.length >= 2 && "$id" !== t1[1] && "$type" !== t1[1];
                case "in":
                    return t1.length >= 3 && ("string" != typeof t1[1] || Array.isArray(t1[2]));
                case "!in":
                case "!has":
                case "none":
                    return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=":
                    return 3 !== t1.length || Array.isArray(t1[1]) || Array.isArray(t1[2]);
                case "any":
                case "all":
                    for (const e of t1.slice(1))if (!hl(e) && "boolean" != typeof e) return !1;
                    return !0;
                default:
                    return !0;
            }
        }
        function pl(t1, e = "fill") {
            if (null == t1) return {
                filter: ()=>!0,
                needGeometry: !1,
                needFeature: !1
            };
            hl(t1) || (t1 = bl(t1));
            const r = t1;
            let n = !0;
            try {
                n = function(t1) {
                    if (!ml(t1)) return t1;
                    let e = cl(t1);
                    return dl(e), e = fl(e), e;
                }(r);
            } catch (t1) {
                console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(r, null, 2)}\n        `);
            }
            const i = ll[`filter_${e}`], s = ho(n, i);
            let a = null;
            if ("error" === s.result) throw new Error(s.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
            a = (t1, e, r)=>s.value.evaluate(t1, e, {}, r);
            let o = null, l = null;
            if (n !== r) {
                const t1 = ho(r, i);
                if ("error" === t1.result) throw new Error(t1.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
                o = (e, r, n, i, s)=>t1.value.evaluate(e, r, {}, n, void 0, void 0, i, s), l = !Ys(t1.value.expression);
            }
            return {
                filter: a,
                dynamicFilter: o || void 0,
                needGeometry: xl(n),
                needFeature: !!l
            };
        }
        function fl(t1) {
            if (!Array.isArray(t1)) return t1;
            const e = function(t1) {
                if (yl.has(t1[0])) {
                    for(let e = 1; e < t1.length; e++)if (ml(t1[e])) return !0;
                }
                return t1;
            }(t1);
            return !0 === e ? e : e.map((t1)=>fl(t1));
        }
        function dl(t1) {
            let e = !1;
            const r = [];
            if ("case" === t1[0]) {
                for(let n = 1; n < t1.length - 1; n += 2)e = e || ml(t1[n]), r.push(t1[n + 1]);
                r.push(t1[t1.length - 1]);
            } else if ("match" === t1[0]) {
                e = e || ml(t1[1]);
                for(let e = 2; e < t1.length - 1; e += 2)r.push(t1[e + 1]);
                r.push(t1[t1.length - 1]);
            } else if ("step" === t1[0]) {
                e = e || ml(t1[1]);
                for(let e = 1; e < t1.length - 1; e += 2)r.push(t1[e + 1]);
            }
            e && (t1.length = 0, t1.push("any", ...r));
            for(let e = 1; e < t1.length; e++)dl(t1[e]);
        }
        function ml(t1) {
            if (!Array.isArray(t1)) return !1;
            if ("pitch" === (e = t1[0]) || "distance-from-center" === e) return !0;
            var e;
            for(let e = 1; e < t1.length; e++)if (ml(t1[e])) return !0;
            return !1;
        }
        const yl = new Set([
            "in",
            "==",
            "!=",
            ">",
            ">=",
            "<",
            "<=",
            "to-boolean"
        ]);
        function gl(t1, e) {
            return t1 < e ? -1 : t1 > e ? 1 : 0;
        }
        function xl(t1) {
            if (!Array.isArray(t1)) return !1;
            if ("within" === t1[0] || "distance" === t1[0]) return !0;
            for(let e = 1; e < t1.length; e++)if (xl(t1[e])) return !0;
            return !1;
        }
        function bl(t1) {
            if (!t1) return !0;
            const e = t1[0];
            var r;
            return t1.length <= 1 ? "any" !== e : "==" === e ? vl(t1[1], t1[2], "==") : "!=" === e ? Ml(vl(t1[1], t1[2], "==")) : "<" === e || ">" === e || "<=" === e || ">=" === e ? vl(t1[1], t1[2], e) : "any" === e ? (r = t1.slice(1), [
                "any"
            ].concat(r.map(bl))) : "all" === e ? [
                "all"
            ].concat(t1.slice(1).map(bl)) : "none" === e ? [
                "all"
            ].concat(t1.slice(1).map(bl).map(Ml)) : "in" === e ? _l(t1[1], t1.slice(2)) : "!in" === e ? Ml(_l(t1[1], t1.slice(2))) : "has" === e ? wl(t1[1]) : "!has" !== e || Ml(wl(t1[1]));
        }
        function vl(t1, e, r) {
            switch(t1){
                case "$type":
                    return [
                        `filter-type-${r}`,
                        e
                    ];
                case "$id":
                    return [
                        `filter-id-${r}`,
                        e
                    ];
                default:
                    return [
                        `filter-${r}`,
                        t1,
                        e
                    ];
            }
        }
        function _l(t1, e) {
            if (0 === e.length) return !1;
            switch(t1){
                case "$type":
                    return [
                        "filter-type-in",
                        [
                            "literal",
                            e
                        ]
                    ];
                case "$id":
                    return [
                        "filter-id-in",
                        [
                            "literal",
                            e
                        ]
                    ];
                default:
                    return e.length > 200 && !e.some((t1)=>typeof t1 != typeof e[0]) ? [
                        "filter-in-large",
                        t1,
                        [
                            "literal",
                            e.sort(gl)
                        ]
                    ] : [
                        "filter-in-small",
                        t1,
                        [
                            "literal",
                            e
                        ]
                    ];
            }
        }
        function wl(t1) {
            switch(t1){
                case "$type":
                    return !0;
                case "$id":
                    return [
                        "filter-has-id"
                    ];
                default:
                    return [
                        "filter-has",
                        t1
                    ];
            }
        }
        function Ml(t1) {
            return [
                "!",
                t1
            ];
        }
        const Al = "\x1f";
        function Sl(t1, e) {
            return e ? `${t1}${Al}${e}` : t1;
        }
        const Il = "-transition", Tl = new Set([
            "fill",
            "line",
            "background",
            "hillshade",
            "raster"
        ]);
        class kl extends Ln {
            constructor(t1, e, r, n, i){
                if (super(), this.id = t1.id, this.fqid = Sl(this.id, r), this.type = t1.type, this.scope = r, this.lut = n, this.options = i, this._featureFilter = {
                    filter: ()=>!0,
                    needGeometry: !1,
                    needFeature: !1
                }, this._filterCompiled = !1, this.isConfigDependent = !1, "custom" !== t1.type && (this.metadata = t1.metadata, this.minzoom = t1.minzoom, this.maxzoom = t1.maxzoom, "background" !== t1.type && "sky" !== t1.type && "slot" !== t1.type && (this.source = t1.source, this.sourceLayer = t1["source-layer"], this.filter = t1.filter), t1.slot && (this.slot = t1.slot), e.layout && (this._unevaluatedLayout = new el(e.layout, this.scope, i), this.isConfigDependent = this.isConfigDependent || this._unevaluatedLayout.isConfigDependent), e.paint)) {
                    this._transitionablePaint = new Jo(e.paint, this.scope, i);
                    for(const e in t1.paint)this.setPaintProperty(e, t1.paint[e]);
                    for(const e in t1.layout)this.setLayoutProperty(e, t1.layout[e]);
                    this.isConfigDependent = this.isConfigDependent || this._transitionablePaint.isConfigDependent, this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new nl(e.paint);
                }
            }
            onAdd(t1) {}
            onRemove(t1) {}
            isDraped(t1) {
                return Tl.has(this.type);
            }
            getLayoutProperty(t1) {
                return "visibility" === t1 ? this.visibility : this._unevaluatedLayout.getValue(t1);
            }
            setLayoutProperty(t1, e) {
                if ("custom" === this.type && "visibility" === t1) return void (this.visibility = e);
                const r = this._unevaluatedLayout;
                r._properties.properties[t1] && (r.setValue(t1, e), this.isConfigDependent = this.isConfigDependent || r.isConfigDependent, "visibility" === t1 && this.possiblyEvaluateVisibility());
            }
            possiblyEvaluateVisibility() {
                this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({
                    zoom: 0
                });
            }
            getPaintProperty(t1) {
                return lr(t1, Il) ? this._transitionablePaint.getTransition(t1.slice(0, -11)) : this._transitionablePaint.getValue(t1);
            }
            setPaintProperty(t1, e) {
                const r = this._transitionablePaint, n = r._properties.properties;
                if (lr(t1, Il)) {
                    const i = t1.slice(0, -11);
                    return n[i] && r.setTransition(i, e || void 0), !1;
                }
                if (!n[t1]) return !1;
                const i = r._values[t1], s = i.value.isDataDriven(), a = i.value;
                r.setValue(t1, e), this.isConfigDependent = this.isConfigDependent || r.isConfigDependent, this._handleSpecialPaintPropertyUpdate(t1);
                const o = r._values[t1].value, l = o.isDataDriven(), u = lr(t1, "pattern") || "line-dasharray" === t1;
                return l || s || u || this._handleOverridablePaintPropertyUpdate(t1, a, o);
            }
            _handleSpecialPaintPropertyUpdate(t1) {}
            getProgramIds() {
                return null;
            }
            getDefaultProgramParams(t1, e, r) {
                return null;
            }
            _handleOverridablePaintPropertyUpdate(t1, e, r) {
                return !1;
            }
            isHidden(t1) {
                return !!(this.minzoom && t1 < this.minzoom) || !!(this.maxzoom && t1 >= this.maxzoom) || "none" === this.visibility;
            }
            updateTransitions(t1) {
                this._transitioningPaint = this._transitionablePaint.transitioned(t1, this._transitioningPaint);
            }
            hasTransition() {
                return this._transitioningPaint.hasTransition();
            }
            recalculate(t1, e) {
                this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t1, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t1, void 0, e);
            }
            serialize() {
                return cr({
                    id: this.id,
                    type: this.type,
                    slot: this.slot,
                    source: this.source,
                    "source-layer": this.sourceLayer,
                    metadata: this.metadata,
                    minzoom: this.minzoom,
                    maxzoom: this.maxzoom,
                    filter: this.filter,
                    layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                    paint: this._transitionablePaint && this._transitionablePaint.serialize()
                }, (t1, e)=>!(void 0 === t1 || "layout" === e && !Object.keys(t1).length || "paint" === e && !Object.keys(t1).length));
            }
            is3D() {
                return !1;
            }
            isSky() {
                return !1;
            }
            isTileClipped() {
                return !1;
            }
            hasOffscreenPass() {
                return !1;
            }
            hasShadowPass() {
                return !1;
            }
            canCastShadows() {
                return !1;
            }
            hasLightBeamPass() {
                return !1;
            }
            cutoffRange() {
                return 0;
            }
            tileCoverLift() {
                return 0;
            }
            resize() {}
            isStateDependent() {
                for(const t1 in this.paint._values){
                    const e = this.paint.get(t1);
                    if (e instanceof rl && Wa(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent) return !0;
                }
                return !1;
            }
            compileFilter() {
                this._filterCompiled || (this._featureFilter = pl(this.filter), this._filterCompiled = !0);
            }
            invalidateCompiledFilter() {
                this._filterCompiled = !1;
            }
            dynamicFilter() {
                return this._featureFilter.dynamicFilter;
            }
            dynamicFilterNeedsFeature() {
                return this._featureFilter.needFeature;
            }
            getLayerRenderingStats() {
                return this._stats;
            }
            resetLayerRenderingStats(t1) {
                this._stats && ("shadow" === t1.renderPass ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);
            }
            queryRadius(t1) {}
            queryIntersectsFeature(t1, e, r, n, i, s, a, o, l) {}
            queryIntersectsMatchingFeature(t1, e, r, n) {}
        }
        const Pl = {
            Int8: Int8Array,
            Uint8: Uint8Array,
            Int16: Int16Array,
            Uint16: Uint16Array,
            Int32: Int32Array,
            Uint32: Uint32Array,
            Float32: Float32Array
        };
        class zl {
            constructor(t1, e){
                this._structArray = t1, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
        }
        class El {
            constructor(){
                this.isTransferred = !1, this.capacity = -1, this.resize(0);
            }
            static serialize(t1, e) {
                return t1._trim(), e && (t1.isTransferred = !0, e.add(t1.arrayBuffer)), {
                    length: t1.length,
                    arrayBuffer: t1.arrayBuffer
                };
            }
            static deserialize(t1) {
                const e = Object.create(this.prototype);
                return e.arrayBuffer = t1.arrayBuffer, e.length = t1.length, e.capacity = t1.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e;
            }
            _trim() {
                this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
                this.length = 0;
            }
            resize(t1) {
                this.reserve(t1), this.length = t1;
            }
            reserve(t1) {
                if (t1 > this.capacity) {
                    this.capacity = Math.max(t1, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                    const e = this.uint8;
                    this._refreshViews(), e && this.uint8.set(e);
                }
            }
            _refreshViews() {
                throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout");
            }
            emplace(...t1) {
                throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout");
            }
            emplaceBack(...t1) {
                throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout");
            }
            destroy() {
                this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
            }
        }
        function Bl(t1, e = 1) {
            let r = 0, n = 0;
            return {
                members: t1.map((t1)=>{
                    const i = Pl[t1.type].BYTES_PER_ELEMENT, s = r = Dl(r, Math.max(e, i)), a = t1.components || 1;
                    return n = Math.max(n, i), r += i * a, {
                        name: t1.name,
                        type: t1.type,
                        components: a,
                        offset: s
                    };
                }),
                size: Dl(r, Math.max(n, e)),
                alignment: e
            };
        }
        function Dl(t1, e) {
            return Math.ceil(t1 / e) * e;
        }
        class Cl extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e);
            }
            emplace(t1, e, r) {
                const n = 2 * t1;
                return this.int16[n + 0] = e, this.int16[n + 1] = r, t1;
            }
        }
        Cl.prototype.bytesPerElement = 4, Mo(Cl, "StructArrayLayout2i4");
        class Rl extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e, r);
            }
            emplace(t1, e, r, n) {
                const i = 3 * t1;
                return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t1;
            }
        }
        Rl.prototype.bytesPerElement = 6, Mo(Rl, "StructArrayLayout3i6");
        class Vl extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const s = 4 * t1;
                return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, t1;
            }
        }
        Vl.prototype.bytesPerElement = 8, Mo(Vl, "StructArrayLayout4i8");
        class Ll extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e, r, n, i);
            }
            emplace(t1, e, r, n, i, s) {
                const a = 5 * t1;
                return this.int16[a + 0] = e, this.int16[a + 1] = r, this.int16[a + 2] = n, this.int16[a + 3] = i, this.int16[a + 4] = s, t1;
            }
        }
        Ll.prototype.bytesPerElement = 10, Mo(Ll, "StructArrayLayout5i10");
        class Ol extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e, r, n, i, s, a);
            }
            emplace(t1, e, r, n, i, s, a, o) {
                const l = 6 * t1, u = 12 * t1, c = 3 * t1;
                return this.int16[l + 0] = e, this.int16[l + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = s, this.uint8[u + 7] = a, this.float32[c + 2] = o, t1;
            }
        }
        Ol.prototype.bytesPerElement = 12, Mo(Ol, "StructArrayLayout2i4ub1f12");
        class Fl extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const s = 4 * t1;
                return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, t1;
            }
        }
        Fl.prototype.bytesPerElement = 16, Mo(Fl, "StructArrayLayout4f16");
        class Ul extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e, r);
            }
            emplace(t1, e, r, n) {
                const i = 3 * t1;
                return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t1;
            }
        }
        Ul.prototype.bytesPerElement = 12, Mo(Ul, "StructArrayLayout3f12");
        class Nl extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e, r, n, i);
            }
            emplace(t1, e, r, n, i, s) {
                const a = 6 * t1, o = 3 * t1;
                return this.uint16[a + 0] = e, this.uint16[a + 1] = r, this.uint16[a + 2] = n, this.uint16[a + 3] = i, this.float32[o + 2] = s, t1;
            }
        }
        Nl.prototype.bytesPerElement = 12, Mo(Nl, "StructArrayLayout4ui1f12");
        class jl extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const s = 4 * t1;
                return this.uint16[s + 0] = e, this.uint16[s + 1] = r, this.uint16[s + 2] = n, this.uint16[s + 3] = i, t1;
            }
        }
        jl.prototype.bytesPerElement = 8, Mo(jl, "StructArrayLayout4ui8");
        class ql extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e, r, n, i, s);
            }
            emplace(t1, e, r, n, i, s, a) {
                const o = 6 * t1;
                return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = s, this.int16[o + 5] = a, t1;
            }
        }
        ql.prototype.bytesPerElement = 12, Mo(ql, "StructArrayLayout6i12");
        class $l extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a, o, l, u, c, h) {
                const p = this.length;
                return this.resize(p + 1), this.emplace(p, t1, e, r, n, i, s, a, o, l, u, c, h);
            }
            emplace(t1, e, r, n, i, s, a, o, l, u, c, h, p) {
                const f = 12 * t1;
                return this.int16[f + 0] = e, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.uint16[f + 4] = s, this.uint16[f + 5] = a, this.uint16[f + 6] = o, this.uint16[f + 7] = l, this.int16[f + 8] = u, this.int16[f + 9] = c, this.int16[f + 10] = h, this.int16[f + 11] = p, t1;
            }
        }
        $l.prototype.bytesPerElement = 24, Mo($l, "StructArrayLayout4i4ui4i24");
        class Gl extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e, r, n, i, s);
            }
            emplace(t1, e, r, n, i, s, a) {
                const o = 10 * t1, l = 5 * t1;
                return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.float32[l + 2] = i, this.float32[l + 3] = s, this.float32[l + 4] = a, t1;
            }
        }
        Gl.prototype.bytesPerElement = 20, Mo(Gl, "StructArrayLayout3i3f20");
        class Yl extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.uint32[1 * t1 + 0] = e, t1;
            }
        }
        Yl.prototype.bytesPerElement = 4, Mo(Yl, "StructArrayLayout1ul4");
        class Xl extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.float32[1 * t1 + 0] = e, t1;
            }
        }
        Xl.prototype.bytesPerElement = 4, Mo(Xl, "StructArrayLayout1f4");
        class Zl extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e);
            }
            emplace(t1, e, r) {
                const n = 2 * t1;
                return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t1;
            }
        }
        Zl.prototype.bytesPerElement = 4, Mo(Zl, "StructArrayLayout2ui4");
        class Hl extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a, o, l, u, c, h, p) {
                const f = this.length;
                return this.resize(f + 1), this.emplace(f, t1, e, r, n, i, s, a, o, l, u, c, h, p);
            }
            emplace(t1, e, r, n, i, s, a, o, l, u, c, h, p, f) {
                const d = 20 * t1, m = 10 * t1;
                return this.int16[d + 0] = e, this.int16[d + 1] = r, this.int16[d + 2] = n, this.int16[d + 3] = i, this.int16[d + 4] = s, this.float32[m + 3] = a, this.float32[m + 4] = o, this.float32[m + 5] = l, this.float32[m + 6] = u, this.int16[d + 14] = c, this.uint32[m + 8] = h, this.uint16[d + 18] = p, this.uint16[d + 19] = f, t1;
            }
        }
        Hl.prototype.bytesPerElement = 40, Mo(Hl, "StructArrayLayout5i4f1i1ul2ui40");
        class Kl extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e, r, n, i, s, a);
            }
            emplace(t1, e, r, n, i, s, a, o) {
                const l = 8 * t1;
                return this.int16[l + 0] = e, this.int16[l + 1] = r, this.int16[l + 2] = n, this.int16[l + 4] = i, this.int16[l + 5] = s, this.int16[l + 6] = a, this.int16[l + 7] = o, t1;
            }
        }
        Kl.prototype.bytesPerElement = 16, Mo(Kl, "StructArrayLayout3i2i2i16");
        class Wl extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e, r, n, i);
            }
            emplace(t1, e, r, n, i, s) {
                const a = 4 * t1, o = 8 * t1;
                return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.int16[o + 6] = i, this.int16[o + 7] = s, t1;
            }
        }
        Wl.prototype.bytesPerElement = 16, Mo(Wl, "StructArrayLayout2f1f2i16");
        class Jl extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const s = 12 * t1, a = 3 * t1;
                return this.uint8[s + 0] = e, this.uint8[s + 1] = r, this.float32[a + 1] = n, this.float32[a + 2] = i, t1;
            }
        }
        Jl.prototype.bytesPerElement = 12, Mo(Jl, "StructArrayLayout2ub2f12");
        class Ql extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e, r);
            }
            emplace(t1, e, r, n) {
                const i = 3 * t1;
                return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t1;
            }
        }
        Ql.prototype.bytesPerElement = 6, Mo(Ql, "StructArrayLayout3ui6");
        class tu extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g, x, b, v) {
                const _ = this.length;
                return this.resize(_ + 1), this.emplace(_, t1, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g, x, b, v);
            }
            emplace(t1, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g, x, b, v, _) {
                const w = 30 * t1, M = 15 * t1, A = 60 * t1;
                return this.int16[w + 0] = e, this.int16[w + 1] = r, this.int16[w + 2] = n, this.float32[M + 2] = i, this.float32[M + 3] = s, this.uint16[w + 8] = a, this.uint16[w + 9] = o, this.uint32[M + 5] = l, this.uint32[M + 6] = u, this.uint32[M + 7] = c, this.uint16[w + 16] = h, this.uint16[w + 17] = p, this.uint16[w + 18] = f, this.float32[M + 10] = d, this.float32[M + 11] = m, this.uint8[A + 48] = y, this.uint8[A + 49] = g, this.uint8[A + 50] = x, this.uint32[M + 13] = b, this.int16[w + 28] = v, this.uint8[A + 58] = _, t1;
            }
        }
        tu.prototype.bytesPerElement = 60, Mo(tu, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class eu extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g, x, b, v, _, w, M, A, S, I, T, k, P, z, E, B, D) {
                const C = this.length;
                return this.resize(C + 1), this.emplace(C, t1, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g, x, b, v, _, w, M, A, S, I, T, k, P, z, E, B, D);
            }
            emplace(t1, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g, x, b, v, _, w, M, A, S, I, T, k, P, z, E, B, D, C) {
                const R = 22 * t1, V = 44 * t1, L = 88 * t1;
                return this.float32[R + 0] = e, this.float32[R + 1] = r, this.int16[V + 4] = n, this.int16[V + 5] = i, this.int16[V + 6] = s, this.int16[V + 7] = a, this.int16[V + 8] = o, this.int16[V + 9] = l, this.int16[V + 10] = u, this.int16[V + 11] = c, this.int16[V + 12] = h, this.uint16[V + 13] = p, this.uint16[V + 14] = f, this.uint16[V + 15] = d, this.uint16[V + 16] = m, this.uint16[V + 17] = y, this.uint16[V + 18] = g, this.uint16[V + 19] = x, this.uint16[V + 20] = b, this.uint16[V + 21] = v, this.uint16[V + 22] = _, this.uint16[V + 23] = w, this.uint16[V + 24] = M, this.uint16[V + 25] = A, this.uint16[V + 26] = S, this.uint16[V + 27] = I, this.uint32[R + 14] = T, this.float32[R + 15] = k, this.float32[R + 16] = P, this.float32[R + 17] = z, this.float32[R + 18] = E, this.float32[R + 19] = B, this.float32[R + 20] = D, this.uint8[L + 84] = C, t1;
            }
        }
        eu.prototype.bytesPerElement = 88, Mo(eu, "StructArrayLayout2f9i15ui1ul6f1ub88");
        class ru extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e, r, n, i);
            }
            emplace(t1, e, r, n, i, s) {
                const a = 5 * t1;
                return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, this.float32[a + 4] = s, t1;
            }
        }
        ru.prototype.bytesPerElement = 20, Mo(ru, "StructArrayLayout5f20");
        class nu extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e, r, n, i, s, a);
            }
            emplace(t1, e, r, n, i, s, a, o) {
                const l = 7 * t1;
                return this.float32[l + 0] = e, this.float32[l + 1] = r, this.float32[l + 2] = n, this.float32[l + 3] = i, this.float32[l + 4] = s, this.float32[l + 5] = a, this.float32[l + 6] = o, t1;
            }
        }
        nu.prototype.bytesPerElement = 28, Mo(nu, "StructArrayLayout7f28");
        class iu extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e);
            }
            emplace(t1, e, r) {
                const n = 2 * t1;
                return this.float32[n + 0] = e, this.float32[n + 1] = r, t1;
            }
        }
        iu.prototype.bytesPerElement = 8, Mo(iu, "StructArrayLayout2f8");
        class su extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const s = 6 * t1;
                return this.uint32[3 * t1 + 0] = e, this.uint16[s + 2] = r, this.uint16[s + 3] = n, this.uint16[s + 4] = i, t1;
            }
        }
        su.prototype.bytesPerElement = 12, Mo(su, "StructArrayLayout1ul3ui12");
        class au extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.uint16[1 * t1 + 0] = e, t1;
            }
        }
        au.prototype.bytesPerElement = 2, Mo(au, "StructArrayLayout1ui2");
        class ou extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m) {
                const y = this.length;
                return this.resize(y + 1), this.emplace(y, t1, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m);
            }
            emplace(t1, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y) {
                const g = 16 * t1;
                return this.float32[g + 0] = e, this.float32[g + 1] = r, this.float32[g + 2] = n, this.float32[g + 3] = i, this.float32[g + 4] = s, this.float32[g + 5] = a, this.float32[g + 6] = o, this.float32[g + 7] = l, this.float32[g + 8] = u, this.float32[g + 9] = c, this.float32[g + 10] = h, this.float32[g + 11] = p, this.float32[g + 12] = f, this.float32[g + 13] = d, this.float32[g + 14] = m, this.float32[g + 15] = y, t1;
            }
        }
        ou.prototype.bytesPerElement = 64, Mo(ou, "StructArrayLayout16f64");
        class lu extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, s, a) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e, r, n, i, s, a);
            }
            emplace(t1, e, r, n, i, s, a, o) {
                const l = 10 * t1, u = 5 * t1;
                return this.uint16[l + 0] = e, this.uint16[l + 1] = r, this.uint16[l + 2] = n, this.uint16[l + 3] = i, this.float32[u + 2] = s, this.float32[u + 3] = a, this.float32[u + 4] = o, t1;
            }
        }
        lu.prototype.bytesPerElement = 20, Mo(lu, "StructArrayLayout4ui3f20");
        class uu extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.int16[1 * t1 + 0] = e, t1;
            }
        }
        uu.prototype.bytesPerElement = 2, Mo(uu, "StructArrayLayout1i2");
        class cu extends El {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.uint8[1 * t1 + 0] = e, t1;
            }
        }
        cu.prototype.bytesPerElement = 1, Mo(cu, "StructArrayLayout1ub1");
        class hu extends zl {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.int16[this._pos2 + 3];
            }
            get tileAnchorY() {
                return this._structArray.int16[this._pos2 + 4];
            }
            get x1() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get y1() {
                return this._structArray.float32[this._pos4 + 4];
            }
            get x2() {
                return this._structArray.float32[this._pos4 + 5];
            }
            get y2() {
                return this._structArray.float32[this._pos4 + 6];
            }
            get padding() {
                return this._structArray.int16[this._pos2 + 14];
            }
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 8];
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 19];
            }
        }
        hu.prototype.size = 40;
        class pu extends Hl {
            get(t1) {
                return new hu(this, t1);
            }
        }
        Mo(pu, "CollisionBoxArray");
        class fu extends zl {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 8];
            }
            get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 9];
            }
            get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 5];
            }
            get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 6];
            }
            get lineLength() {
                return this._structArray.uint32[this._pos4 + 7];
            }
            get segment() {
                return this._structArray.uint16[this._pos2 + 16];
            }
            get lowerSize() {
                return this._structArray.uint16[this._pos2 + 17];
            }
            get upperSize() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 10];
            }
            get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 11];
            }
            get writingMode() {
                return this._structArray.uint8[this._pos1 + 48];
            }
            get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 49];
            }
            set placedOrientation(t1) {
                this._structArray.uint8[this._pos1 + 49] = t1;
            }
            get hidden() {
                return this._structArray.uint8[this._pos1 + 50];
            }
            set hidden(t1) {
                this._structArray.uint8[this._pos1 + 50] = t1;
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 13];
            }
            set crossTileID(t1) {
                this._structArray.uint32[this._pos4 + 13] = t1;
            }
            get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 28];
            }
            get flipState() {
                return this._structArray.uint8[this._pos1 + 58];
            }
            set flipState(t1) {
                this._structArray.uint8[this._pos1 + 58] = t1;
            }
        }
        fu.prototype.size = 60;
        class du extends tu {
            get(t1) {
                return new fu(this, t1);
            }
        }
        Mo(du, "PlacedSymbolArray");
        class mu extends zl {
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 0];
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 1];
            }
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 4];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 5];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 6];
            }
            get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 7];
            }
            get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 8];
            }
            get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 9];
            }
            get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 10];
            }
            get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 11];
            }
            get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 12];
            }
            get key() {
                return this._structArray.uint16[this._pos2 + 13];
            }
            get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 14];
            }
            get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 15];
            }
            get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 16];
            }
            get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 17];
            }
            get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 19];
            }
            get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 20];
            }
            get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 21];
            }
            get featureIndex() {
                return this._structArray.uint16[this._pos2 + 22];
            }
            get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 23];
            }
            get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 24];
            }
            get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 25];
            }
            get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 26];
            }
            get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 27];
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 14];
            }
            set crossTileID(t1) {
                this._structArray.uint32[this._pos4 + 14] = t1;
            }
            get textOffset0() {
                return this._structArray.float32[this._pos4 + 15];
            }
            get textOffset1() {
                return this._structArray.float32[this._pos4 + 16];
            }
            get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 17];
            }
            get zOffset() {
                return this._structArray.float32[this._pos4 + 18];
            }
            set zOffset(t1) {
                this._structArray.float32[this._pos4 + 18] = t1;
            }
            get occlusionState() {
                return this._structArray.float32[this._pos4 + 19];
            }
            set occlusionState(t1) {
                this._structArray.float32[this._pos4 + 19] = t1;
            }
            get occlusionOpacity() {
                return this._structArray.float32[this._pos4 + 20];
            }
            set occlusionOpacity(t1) {
                this._structArray.float32[this._pos4 + 20] = t1;
            }
            get hasIconTextFit() {
                return this._structArray.uint8[this._pos1 + 84];
            }
        }
        mu.prototype.size = 88;
        class yu extends eu {
            get(t1) {
                return new mu(this, t1);
            }
        }
        Mo(yu, "SymbolInstanceArray");
        class gu extends Xl {
            getoffsetX(t1) {
                return this.float32[1 * t1 + 0];
            }
        }
        Mo(gu, "GlyphOffsetArray");
        class xu extends Cl {
            getx(t1) {
                return this.int16[2 * t1 + 0];
            }
            gety(t1) {
                return this.int16[2 * t1 + 1];
            }
        }
        Mo(xu, "SymbolLineVertexArray");
        class bu extends zl {
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3];
            }
            get layoutVertexArrayOffset() {
                return this._structArray.uint16[this._pos2 + 4];
            }
        }
        bu.prototype.size = 12;
        class vu extends su {
            get(t1) {
                return new bu(this, t1);
            }
        }
        Mo(vu, "FeatureIndexArray");
        class _u extends Zl {
            geta_centroid_pos0(t1) {
                return this.uint16[2 * t1 + 0];
            }
            geta_centroid_pos1(t1) {
                return this.uint16[2 * t1 + 1];
            }
        }
        Mo(_u, "FillExtrusionCentroidArray");
        const wu = Bl([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            }
        ], 4), Mu = Bl([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }
        ]);
        class Au {
            constructor(t1 = []){
                this.segments = t1;
            }
            _prepareSegment(t1, e, r, n) {
                let i = this.segments[this.segments.length - 1];
                return t1 > Au.MAX_VERTEX_ARRAY_LENGTH && fr(`Max vertices per segment is ${Au.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t1}`), (!i || i.vertexLength + t1 > Au.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {
                    vertexOffset: e,
                    primitiveOffset: r,
                    vertexLength: 0,
                    primitiveLength: 0
                }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;
            }
            prepareSegment(t1, e, r, n) {
                return this._prepareSegment(t1, e.length, r.length, n);
            }
            get() {
                return this.segments;
            }
            destroy() {
                for (const t1 of this.segments)for(const e in t1.vaos)t1.vaos[e].destroy();
            }
            static simpleSegment(t1, e, r, n) {
                return new Au([
                    {
                        vertexOffset: t1,
                        primitiveOffset: e,
                        vertexLength: r,
                        primitiveLength: n,
                        vaos: {},
                        sortKey: 0
                    }
                ]);
            }
        }
        function Su(t1, e) {
            return 256 * (t1 = Ke(Math.floor(t1), 0, 255)) + Ke(Math.floor(e), 0, 255);
        }
        Au.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Mo(Au, "SegmentVector");
        const Iu = Bl([
            {
                name: "a_pattern",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pixel_ratio",
                components: 1,
                type: "Float32"
            }
        ]), Tu = Bl([
            {
                name: "a_dash",
                components: 4,
                type: "Uint16"
            }
        ]);
        class ku {
            constructor(){
                this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = !1;
            }
            add(t1, e, r, n) {
                this.ids.push(Pu(t1)), this.positions.push(e, r, n);
            }
            eachPosition(t1, e) {
                const r = Pu(t1);
                let n = 0, i = this.ids.length - 1;
                for(; n < i;){
                    const t1 = n + i >> 1;
                    this.ids[t1] >= r ? i = t1 : n = t1 + 1;
                }
                for(; this.ids[n] === r;)e(this.positions[3 * n], this.positions[3 * n + 1], this.positions[3 * n + 2]), n++;
            }
            static serialize(t1, e) {
                const r = new Float64Array(t1.ids), n = new Uint32Array(t1.positions);
                return zu(r, n, 0, r.length - 1), e && (e.add(r.buffer), e.add(n.buffer)), {
                    ids: r,
                    positions: n
                };
            }
            static deserialize(t1) {
                const e = new ku;
                let r;
                e.ids = t1.ids, e.positions = t1.positions;
                for (const t1 of e.ids)t1 !== r && e.uniqueIds.push(t1), r = t1;
                return e.indexed = !0, e;
            }
        }
        function Pu(t1) {
            const e = +t1;
            return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : Bn(String(t1));
        }
        function zu(t1, e, r, n) {
            for(; r < n;){
                const i = t1[r + n >> 1];
                let s = r - 1, a = n + 1;
                for(;;){
                    do s++;
                    while (t1[s] < i);
                    do a--;
                    while (t1[a] > i);
                    if (s >= a) break;
                    Eu(t1, s, a), Eu(e, 3 * s, 3 * a), Eu(e, 3 * s + 1, 3 * a + 1), Eu(e, 3 * s + 2, 3 * a + 2);
                }
                a - r < n - a ? (zu(t1, e, r, a), r = a + 1) : (zu(t1, e, a + 1, n), n = a);
            }
        }
        function Eu(t1, e, r) {
            const n = t1[e];
            t1[e] = t1[r], t1[r] = n;
        }
        Mo(ku, "FeaturePositionMap");
        class Bu {
            constructor(t1){
                this.gl = t1.gl, this.initialized = !1;
            }
            fetchUniformLocation(t1, e) {
                return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t1, e), this.initialized = !0), !!this.location;
            }
            set(t1, e, r) {
                throw new Error("Uniform#set() must be implemented by each concrete Uniform");
            }
        }
        class Du extends Bu {
            constructor(t1){
                super(t1), this.current = 0;
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r));
            }
        }
        class Cu extends Bu {
            constructor(t1){
                super(t1), this.current = 0;
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && this.current !== r && (this.current = r, this.gl.uniform1f(this.location, r));
            }
        }
        class Ru extends Bu {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0
                ];
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && (r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1])));
            }
        }
        class Vu extends Bu {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0,
                    0
                ];
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2])));
            }
        }
        class Lu extends Bu {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0,
                    0,
                    0
                ];
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3] || (this.current = r, this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3])));
            }
        }
        class Ou extends Bu {
            constructor(t1){
                super(t1), this.current = qn.transparent.toRenderColor(null);
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && (r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a || (this.current = r, this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a)));
            }
        }
        const Fu = new Float32Array(16);
        class Uu extends Bu {
            constructor(t1){
                super(t1), this.current = Fu;
            }
            set(t1, e, r) {
                if (this.fetchUniformLocation(t1, e)) {
                    if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r);
                    for(let t1 = 1; t1 < 16; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }
        const Nu = new Float32Array(9), ju = new Float32Array(4);
        class qu extends Bu {
            constructor(t1){
                super(t1), this.current = ju;
            }
            set(t1, e, r) {
                if (this.fetchUniformLocation(t1, e)) {
                    for(let t1 = 0; t1 < 4; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix2fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }
        function $u(t1) {
            return [
                Su(255 * t1.r, 255 * t1.g),
                Su(255 * t1.b, 255 * t1.a)
            ];
        }
        class Gu {
            constructor(t1, e, r, n){
                this.value = t1, this.uniformNames = e.map((t1)=>`u_${t1}`), this.type = r, this.context = n;
            }
            setUniform(t1, e, r, n, i) {
                const s = n.constantOr(this.value);
                e.set(t1, i, s instanceof qn ? s.toRenderColor(this.context.lut) : s);
            }
            getBinding(t1, e) {
                return "color" === this.type ? new Ou(t1) : new Cu(t1);
            }
        }
        class Yu {
            constructor(t1, e){
                this.uniformNames = e.map((t1)=>`u_${t1}`), this.pattern = null, this.pixelRatio = 1;
            }
            setConstantPatternPositions(t1) {
                this.pixelRatio = t1.pixelRatio || 1, this.pattern = t1.tl.concat(t1.br);
            }
            setUniform(t1, e, r, n, i) {
                const s = "u_pattern" === i || "u_dash" === i ? this.pattern : "u_pixel_ratio" === i ? this.pixelRatio : null;
                s && e.set(t1, i, s);
            }
            getBinding(t1, e) {
                return "u_pattern" === e || "u_dash" === e ? new Lu(t1) : new Cu(t1);
            }
        }
        class Xu {
            constructor(t1, e, r, n){
                this.expression = t1, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map((t1)=>({
                        name: `a_${t1}`,
                        type: "Float32",
                        components: "color" === r ? 2 : 1,
                        offset: 0
                    })), this.paintVertexArray = new n;
            }
            populatePaintArray(t1, e, r, n, i, s, a) {
                const o = this.paintVertexArray.length, l = this.expression.evaluate(new Ho(0, {
                    brightness: s
                }), e, {}, i, n, a);
                this.paintVertexArray.resize(t1), this._setPaintValue(o, t1, l, this.context);
            }
            updatePaintArray(t1, e, r, n, i, s, a) {
                const o = this.expression.evaluate({
                    zoom: 0,
                    brightness: a
                }, r, n, void 0, i);
                this._setPaintValue(t1, e, o, this.context);
            }
            _setPaintValue(t1, e, r, n) {
                if ("color" === this.type) {
                    const i = $u(r.toRenderColor(n.lut));
                    for(let r = t1; r < e; r++)this.paintVertexArray.emplace(r, i[0], i[1]);
                } else {
                    for(let n = t1; n < e; n++)this.paintVertexArray.emplace(n, r);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r));
                }
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
        }
        class Zu {
            constructor(t1, e, r, n, i, s){
                this.expression = t1, this.uniformNames = e.map((t1)=>`u_${t1}_t`), this.type = r, this.useIntegerZoom = n, this.context = i, this.maxValue = 0, this.paintVertexAttributes = e.map((t1)=>({
                        name: `a_${t1}`,
                        type: "Float32",
                        components: "color" === r ? 4 : 2,
                        offset: 0
                    })), this.paintVertexArray = new s;
            }
            populatePaintArray(t1, e, r, n, i, s, a) {
                const o = this.expression.evaluate(new Ho(this.context.zoom, {
                    brightness: s
                }), e, {}, i, n, a), l = this.expression.evaluate(new Ho(this.context.zoom + 1, {
                    brightness: s
                }), e, {}, i, n, a), u = this.paintVertexArray.length;
                this.paintVertexArray.resize(t1), this._setPaintValue(u, t1, o, l, this.context);
            }
            updatePaintArray(t1, e, r, n, i, s, a) {
                const o = this.expression.evaluate({
                    zoom: this.context.zoom,
                    brightness: a
                }, r, n, void 0, i), l = this.expression.evaluate({
                    zoom: this.context.zoom + 1,
                    brightness: a
                }, r, n, void 0, i);
                this._setPaintValue(t1, e, o, l, this.context);
            }
            _setPaintValue(t1, e, r, n, i) {
                if ("color" === this.type) {
                    const n = $u(r.toRenderColor(i.lut)), s = $u(r.toRenderColor(i.lut));
                    for(let r = t1; r < e; r++)this.paintVertexArray.emplace(r, n[0], n[1], s[0], s[1]);
                } else {
                    for(let i = t1; i < e; i++)this.paintVertexArray.emplace(i, r, n);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));
                }
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t1, e, r, n, i) {
                const s = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom, a = Ke(this.expression.interpolationFactor(s, this.context.zoom, this.context.zoom + 1), 0, 1);
                e.set(t1, i, a);
            }
            getBinding(t1, e) {
                return new Cu(t1);
            }
        }
        class Hu {
            constructor(t1, e, r, n, i){
                this.expression = t1, this.layerId = i, this.paintVertexAttributes = ("array" === r ? Tu : Iu).members;
                for(let t1 = 0; t1 < e.length; ++t1);
                this.paintVertexArray = new n;
            }
            populatePaintArray(t1, e, r, n) {
                const i = this.paintVertexArray.length;
                this.paintVertexArray.resize(t1), this._setPaintValues(i, t1, e.patterns && e.patterns[this.layerId], r);
            }
            updatePaintArray(t1, e, r, n, i, s, a) {
                this._setPaintValues(t1, e, r.patterns && r.patterns[this.layerId], s);
            }
            _setPaintValues(t1, e, r, n) {
                if (!n || !r) return;
                const i = n[r];
                if (!i) return;
                const { tl: s, br: a, pixelRatio: o } = i;
                for(let r = t1; r < e; r++)this.paintVertexArray.emplace(r, s[0], s[1], a[0], a[1], o);
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
        }
        class Ku {
            constructor(t1, e, r = ()=>!0){
                this.binders = {}, this._buffers = [], this.context = e;
                const n = [];
                for(const i in t1.paint._values){
                    const s = t1.paint.get(i);
                    if (!r(i)) continue;
                    if (!(s instanceof rl && Wa(s.property.specification))) continue;
                    const a = Qu(i, t1.type), o = s.value, l = s.property.specification.type, u = !!s.property.useIntegerZoom, c = "line-dasharray" === i || i.endsWith("pattern"), h = "line-dasharray" === i && "constant" !== t1.layout.get("line-cap").value.kind;
                    if ("constant" !== o.kind || h) {
                        if ("source" === o.kind || h || c) {
                            const e = rc(i, l, "source");
                            this.binders[i] = c ? new Hu(o, a, l, e, t1.id) : new Xu(o, a, l, e), n.push(`/a_${i}`);
                        } else {
                            const t1 = rc(i, l, "composite");
                            this.binders[i] = new Zu(o, a, l, u, e, t1), n.push(`/z_${i}`);
                        }
                    } else this.binders[i] = c ? new Yu(o.value, a) : new Gu(o.value, a, l, e), n.push(`/u_${i}`);
                }
                this.cacheKey = n.sort().join("");
            }
            getMaxValue(t1) {
                const e = this.binders[t1];
                return e instanceof Xu || e instanceof Zu ? e.maxValue : 0;
            }
            populatePaintArrays(t1, e, r, n, i, s, a) {
                for(const o in this.binders){
                    const l = this.binders[o];
                    l.context = this.context, (l instanceof Xu || l instanceof Zu || l instanceof Hu) && l.populatePaintArray(t1, e, r, n, i, s, a);
                }
            }
            setConstantPatternPositions(t1) {
                for(const e in this.binders){
                    const r = this.binders[e];
                    r instanceof Yu && r.setConstantPatternPositions(t1);
                }
            }
            updatePaintArrays(t1, e, r, n, i, s, a, o) {
                let l = !1;
                const u = Object.keys(t1), c = 0 !== u.length, h = c ? u : e.uniqueIds;
                this.context.lut = i.lut;
                for(const u in this.binders){
                    const p = this.binders[u];
                    if (p.context = this.context, (p instanceof Xu || p instanceof Zu || p instanceof Hu) && (!0 === p.expression.isStateDependent || !1 === p.expression.isLightConstant)) {
                        const f = i.paint.get(u);
                        p.expression = f.value;
                        for (const r of h){
                            const i = t1[r.toString()];
                            e.eachPosition(r, (t1, e, r)=>{
                                const l = n.feature(t1);
                                p.updatePaintArray(e, r, l, i, s, a, o);
                            });
                        }
                        if (!c) for (const e of r.uniqueIds){
                            const i = t1[e.toString()];
                            r.eachPosition(e, (t1, e, r)=>{
                                const l = n.feature(t1);
                                p.updatePaintArray(e, r, l, i, s, a, o);
                            });
                        }
                        l = !0;
                    }
                }
                return l;
            }
            defines() {
                const t1 = [];
                for(const e in this.binders){
                    const r = this.binders[e];
                    (r instanceof Gu || r instanceof Yu) && t1.push(...r.uniformNames.map((t1)=>`#define HAS_UNIFORM_${t1}`));
                }
                return t1;
            }
            getBinderAttributes() {
                const t1 = [];
                for(const e in this.binders){
                    const r = this.binders[e];
                    if (r instanceof Xu || r instanceof Zu || r instanceof Hu) for(let e = 0; e < r.paintVertexAttributes.length; e++)t1.push(r.paintVertexAttributes[e].name);
                }
                return t1;
            }
            getBinderUniforms() {
                const t1 = [];
                for(const e in this.binders){
                    const r = this.binders[e];
                    if (r instanceof Gu || r instanceof Yu || r instanceof Zu) for (const e of r.uniformNames)t1.push(e);
                }
                return t1;
            }
            getPaintVertexBuffers() {
                return this._buffers;
            }
            getUniforms(t1) {
                const e = [];
                for(const r in this.binders){
                    const n = this.binders[r];
                    if (n instanceof Gu || n instanceof Yu || n instanceof Zu) for (const i of n.uniformNames)e.push({
                        name: i,
                        property: r,
                        binding: n.getBinding(t1, i)
                    });
                }
                return e;
            }
            setUniforms(t1, e, r, n, i) {
                for (const { name: e, property: s, binding: a } of r)this.binders[s].setUniform(t1, a, i, n.get(s), e);
            }
            updatePaintBuffers() {
                this._buffers = [];
                for(const t1 in this.binders){
                    const e = this.binders[t1];
                    (e instanceof Xu || e instanceof Zu || e instanceof Hu) && e.paintVertexBuffer && this._buffers.push(e.paintVertexBuffer);
                }
            }
            upload(t1) {
                for(const e in this.binders){
                    const r = this.binders[e];
                    (r instanceof Xu || r instanceof Zu || r instanceof Hu) && r.upload(t1);
                }
                this.updatePaintBuffers();
            }
            destroy() {
                for(const t1 in this.binders){
                    const e = this.binders[t1];
                    (e instanceof Xu || e instanceof Zu || e instanceof Hu) && e.destroy();
                }
            }
        }
        class Wu {
            constructor(t1, e, r = ()=>!0){
                this.programConfigurations = {};
                for (const n of t1)this.programConfigurations[n.id] = new Ku(n, e, r);
                this.needsUpload = !1, this._featureMap = new ku, this._featureMapWithoutIds = new ku, this._bufferOffset = 0, this._idlessCounter = 0;
            }
            populatePaintArrays(t1, e, r, n, i, s, a, o) {
                for(const r in this.programConfigurations)this.programConfigurations[r].populatePaintArrays(t1, e, n, i, s, a, o);
                void 0 !== e.id ? this._featureMap.add(e.id, r, this._bufferOffset, t1) : (this._featureMapWithoutIds.add(this._idlessCounter, r, this._bufferOffset, t1), this._idlessCounter += 1), this._bufferOffset = t1, this.needsUpload = !0;
            }
            updatePaintArrays(t1, e, r, n, i, s) {
                for (const a of r)this.needsUpload = this.programConfigurations[a.id].updatePaintArrays(t1, this._featureMap, this._featureMapWithoutIds, e, a, n, i, s || 0) || this.needsUpload;
            }
            get(t1) {
                return this.programConfigurations[t1];
            }
            upload(t1) {
                if (this.needsUpload) {
                    for(const e in this.programConfigurations)this.programConfigurations[e].upload(t1);
                    this.needsUpload = !1;
                }
            }
            destroy() {
                for(const t1 in this.programConfigurations)this.programConfigurations[t1].destroy();
            }
        }
        const Ju = {
            "text-opacity": [
                "opacity"
            ],
            "icon-opacity": [
                "opacity"
            ],
            "text-occlusion-opacity": [
                "occlusion_opacity"
            ],
            "icon-occlusion-opacity": [
                "occlusion_opacity"
            ],
            "text-color": [
                "fill_color"
            ],
            "icon-color": [
                "fill_color"
            ],
            "text-emissive-strength": [
                "emissive_strength"
            ],
            "icon-emissive-strength": [
                "emissive_strength"
            ],
            "text-halo-color": [
                "halo_color"
            ],
            "icon-halo-color": [
                "halo_color"
            ],
            "text-halo-blur": [
                "halo_blur"
            ],
            "icon-halo-blur": [
                "halo_blur"
            ],
            "text-halo-width": [
                "halo_width"
            ],
            "icon-halo-width": [
                "halo_width"
            ],
            "line-gap-width": [
                "gapwidth"
            ],
            "line-pattern": [
                "pattern",
                "pixel_ratio"
            ],
            "fill-pattern": [
                "pattern",
                "pixel_ratio"
            ],
            "fill-extrusion-pattern": [
                "pattern",
                "pixel_ratio"
            ],
            "line-dasharray": [
                "dash"
            ]
        };
        function Qu(t1, e) {
            return Ju[t1] || [
                t1.replace(`${e}-`, "").replace(/-/g, "_")
            ];
        }
        const tc = {
            "line-pattern": {
                source: Nl,
                composite: Nl
            },
            "fill-pattern": {
                source: Nl,
                composite: Nl
            },
            "fill-extrusion-pattern": {
                source: Nl,
                composite: Nl
            },
            "line-dasharray": {
                source: jl,
                composite: jl
            }
        }, ec = {
            color: {
                source: iu,
                composite: Fl
            },
            number: {
                source: Xl,
                composite: iu
            }
        };
        function rc(t1, e, r) {
            const n = tc[t1];
            return n && n[r] || ec[e][r];
        }
        Mo(Gu, "ConstantBinder"), Mo(Yu, "PatternConstantBinder"), Mo(Xu, "SourceExpressionBinder"), Mo(Hu, "PatternCompositeBinder"), Mo(Zu, "CompositeExpressionBinder"), Mo(Ku, "ProgramConfiguration", {
            omit: [
                "_buffers"
            ]
        }), Mo(Wu, "ProgramConfigurationSet");
        const nc = ps / Math.PI / 2, ic = 5, sc = 6, ac = 16383, oc = 64, lc = [
            oc,
            32,
            16
        ], uc = -nc, cc = nc;
        function hc(t1, e, r, n = nc) {
            return r = $e(r), [
                t1 * Math.sin(r) * n,
                -e * n,
                t1 * Math.cos(r) * n
            ];
        }
        function pc(t1, e, r) {
            return hc(Math.cos($e(t1)), Math.sin($e(t1)), e, r);
        }
        const fc = 6371008.8, dc = 2 * Math.PI * fc;
        class mc {
            constructor(t1, e){
                if (isNaN(t1) || isNaN(e)) throw new Error(`Invalid LngLat object: (${t1}, ${e})`);
                if (this.lng = +t1, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
                return new mc(Je(this.lng, -180, 180), this.lat);
            }
            toArray() {
                return [
                    this.lng,
                    this.lat
                ];
            }
            toString() {
                return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t1) {
                const e = Math.PI / 180, r = this.lat * e, n = t1.lat * e, i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t1.lng - this.lng) * e);
                return fc * Math.acos(Math.min(i, 1));
            }
            toBounds(t1 = 0) {
                const e = 360 * t1 / 40075017, r = e / Math.cos(Math.PI / 180 * this.lat);
                return new yc({
                    lng: this.lng - r,
                    lat: this.lat - e
                }, {
                    lng: this.lng + r,
                    lat: this.lat + e
                });
            }
            toEcef(t1) {
                return pc(this.lat, this.lng, nc + t1 * nc / fc);
            }
            static convert(t1) {
                if (t1 instanceof mc) return t1;
                if (Array.isArray(t1) && (2 === t1.length || 3 === t1.length)) return new mc(Number(t1[0]), Number(t1[1]));
                if (!Array.isArray(t1) && "object" == typeof t1 && null !== t1) return new mc(Number("lng" in t1 ? t1.lng : t1.lon), Number(t1.lat));
                throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
        }
        class yc {
            constructor(t1, e){
                if (t1) {
                    if (e) this.setSouthWest(t1).setNorthEast(e);
                    else if (4 === t1.length) {
                        const e = t1;
                        this.setSouthWest([
                            e[0],
                            e[1]
                        ]).setNorthEast([
                            e[2],
                            e[3]
                        ]);
                    } else {
                        const e = t1;
                        this.setSouthWest(e[0]).setNorthEast(e[1]);
                    }
                }
            }
            setNorthEast(t1) {
                return this._ne = t1 instanceof mc ? new mc(t1.lng, t1.lat) : mc.convert(t1), this;
            }
            setSouthWest(t1) {
                return this._sw = t1 instanceof mc ? new mc(t1.lng, t1.lat) : mc.convert(t1), this;
            }
            extend(t1) {
                const e = this._sw, r = this._ne;
                let n, i;
                if (t1 instanceof mc) n = t1, i = t1;
                else {
                    if (!(t1 instanceof yc)) return Array.isArray(t1) ? 4 === t1.length || t1.every(Array.isArray) ? this.extend(yc.convert(t1)) : this.extend(mc.convert(t1)) : "object" == typeof t1 && null !== t1 && t1.hasOwnProperty("lat") && (t1.hasOwnProperty("lon") || t1.hasOwnProperty("lng")) ? this.extend(mc.convert(t1)) : this;
                    if (n = t1._sw, i = t1._ne, !n || !i) return this;
                }
                return e || r ? (e.lng = Math.min(n.lng, e.lng), e.lat = Math.min(n.lat, e.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new mc(n.lng, n.lat), this._ne = new mc(i.lng, i.lat)), this;
            }
            getCenter() {
                return new mc((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
                return this._sw;
            }
            getNorthEast() {
                return this._ne;
            }
            getNorthWest() {
                return new mc(this.getWest(), this.getNorth());
            }
            getSouthEast() {
                return new mc(this.getEast(), this.getSouth());
            }
            getWest() {
                return this._sw.lng;
            }
            getSouth() {
                return this._sw.lat;
            }
            getEast() {
                return this._ne.lng;
            }
            getNorth() {
                return this._ne.lat;
            }
            toArray() {
                return [
                    this._sw.toArray(),
                    this._ne.toArray()
                ];
            }
            toString() {
                return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
                return !(this._sw && this._ne);
            }
            contains(t1) {
                const { lng: e, lat: r } = mc.convert(t1);
                let n = this._sw.lng <= e && e <= this._ne.lng;
                return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e && e >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;
            }
            static convert(t1) {
                return !t1 || t1 instanceof yc ? t1 : new yc(t1);
            }
        }
        var gc = {};
        !function(t1, e) {
            !function(t1) {
                function e(t1, e, n) {
                    var i = r(256 * t1, 256 * (e = Math.pow(2, n) - e - 1), n), s = r(256 * (t1 + 1), 256 * (e + 1), n);
                    return i[0] + "," + i[1] + "," + s[0] + "," + s[1];
                }
                function r(t1, e, r) {
                    var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
                    return [
                        t1 * n - 2 * Math.PI * 6378137 / 2,
                        e * n - 2 * Math.PI * 6378137 / 2
                    ];
                }
                t1.getURL = function(t1, r, n, i, s, a) {
                    return a = a || {}, t1 + "?" + [
                        "bbox=" + e(n, i, s),
                        "format=" + (a.format || "image/png"),
                        "service=" + (a.service || "WMS"),
                        "version=" + (a.version || "1.1.1"),
                        "request=" + (a.request || "GetMap"),
                        "srs=" + (a.srs || "EPSG:3857"),
                        "width=" + (a.width || 256),
                        "height=" + (a.height || 256),
                        "layers=" + r
                    ].join("&");
                }, t1.getTileBBox = e, t1.getMercCoords = r, Object.defineProperty(t1, "__esModule", {
                    value: !0
                });
            }(e);
        }(0, gc);
        var xc = gc;
        class bc {
            constructor(t1, e, r){
                this.z = t1, this.x = e, this.y = r, this.key = wc(0, t1, t1, e, r);
            }
            equals(t1) {
                return this.z === t1.z && this.x === t1.x && this.y === t1.y;
            }
            url(t1, e) {
                const r = xc.getTileBBox(this.x, this.y, this.z), n = function(t1, e, r) {
                    let n, i = "";
                    for(let s = t1; s > 0; s--)n = 1 << s - 1, i += (e & n ? 1 : 0) + (r & n ? 2 : 0);
                    return i;
                }(this.z, this.x, this.y);
                return t1[(this.x + this.y) % t1.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n).replace("{bbox-epsg-3857}", r);
            }
            toString() {
                return `${this.z}/${this.x}/${this.y}`;
            }
        }
        class vc {
            constructor(t1, e){
                this.wrap = t1, this.canonical = e, this.key = wc(t1, e.z, e.z, e.x, e.y);
            }
        }
        class _c {
            constructor(t1, e, r, n, i){
                this.overscaledZ = t1, this.wrap = e, this.canonical = new bc(r, +n, +i), this.key = 0 === e && t1 === r ? this.canonical.key : wc(e, t1, r, n, i);
            }
            equals(t1) {
                return this.overscaledZ === t1.overscaledZ && this.wrap === t1.wrap && this.canonical.equals(t1.canonical);
            }
            scaledTo(t1) {
                const e = this.canonical.z - t1;
                return t1 > this.canonical.z ? new _c(t1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new _c(t1, this.wrap, t1, this.canonical.x >> e, this.canonical.y >> e);
            }
            calculateScaledKey(t1, e = !0) {
                if (this.overscaledZ === t1 && e) return this.key;
                if (t1 > this.canonical.z) return wc(this.wrap * +e, t1, this.canonical.z, this.canonical.x, this.canonical.y);
                {
                    const r = this.canonical.z - t1;
                    return wc(this.wrap * +e, t1, t1, this.canonical.x >> r, this.canonical.y >> r);
                }
            }
            isChildOf(t1) {
                if (t1.wrap !== this.wrap) return !1;
                const e = this.canonical.z - t1.canonical.z;
                return 0 === t1.overscaledZ || t1.overscaledZ < this.overscaledZ && t1.canonical.z < this.canonical.z && t1.canonical.x === this.canonical.x >> e && t1.canonical.y === this.canonical.y >> e;
            }
            children(t1) {
                if (this.overscaledZ >= t1) return [
                    new _c(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
                ];
                const e = this.canonical.z + 1, r = 2 * this.canonical.x, n = 2 * this.canonical.y;
                return [
                    new _c(e, this.wrap, e, r, n),
                    new _c(e, this.wrap, e, r + 1, n),
                    new _c(e, this.wrap, e, r, n + 1),
                    new _c(e, this.wrap, e, r + 1, n + 1)
                ];
            }
            isLessThan(t1) {
                return this.wrap < t1.wrap || !(this.wrap > t1.wrap) && (this.overscaledZ < t1.overscaledZ || !(this.overscaledZ > t1.overscaledZ) && (this.canonical.x < t1.canonical.x || !(this.canonical.x > t1.canonical.x) && this.canonical.y < t1.canonical.y));
            }
            wrapped() {
                return new _c(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t1) {
                return new _c(this.overscaledZ, t1, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
                return new vc(this.wrap, this.canonical);
            }
            toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
        }
        function wc(t1, e, r, n, i) {
            const s = 1 << Math.min(r, 22);
            let a = s * (i % s) + n % s;
            return t1 && r < 22 && (a += s * s * ((t1 < 0 ? -2 * t1 - 1 : 2 * t1) % (1 << 2 * (22 - r)))), 16 * (32 * a + r) + (e - r);
        }
        const Mc = [
            (t1)=>{
                let e = t1.canonical.x - 1, r = t1.wrap;
                return e < 0 && (e = (1 << t1.canonical.z) - 1, r--), new _c(t1.overscaledZ, r, t1.canonical.z, e, t1.canonical.y);
            },
            (t1)=>{
                let e = t1.canonical.x + 1, r = t1.wrap;
                return e === 1 << t1.canonical.z && (e = 0, r++), new _c(t1.overscaledZ, r, t1.canonical.z, e, t1.canonical.y);
            },
            (t1)=>new _c(t1.overscaledZ, t1.wrap, t1.canonical.z, t1.canonical.x, (0 === t1.canonical.y ? 1 << t1.canonical.z : t1.canonical.y) - 1),
            (t1)=>new _c(t1.overscaledZ, t1.wrap, t1.canonical.z, t1.canonical.x, t1.canonical.y === (1 << t1.canonical.z) - 1 ? 0 : t1.canonical.y + 1)
        ];
        Mo(bc, "CanonicalTileID"), Mo(_c, "OverscaledTileID", {
            omit: [
                "projMatrix",
                "expandedProjMatrix"
            ]
        });
        const Ac = 0, Sc = 25.5;
        function Ic(t1) {
            return dc * Math.cos(t1 * Math.PI / 180);
        }
        function Tc(t1) {
            return (180 + t1) / 360;
        }
        function kc(t1) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t1 * Math.PI / 360))) / 360;
        }
        function Pc(t1, e) {
            return t1 / Ic(e);
        }
        function zc(t1) {
            return 360 * t1 - 180;
        }
        function Ec(t1) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t1) * Math.PI / 180)) - 90;
        }
        function Bc(t1, e) {
            return t1 * Ic(Ec(e));
        }
        const Dc = 85.051129;
        function Cc(t1) {
            return Math.cos($e(Ke(t1, -Dc, Dc)));
        }
        function Rc(t1, e) {
            const r = Ke(e, Ac, Sc), n = Math.pow(2, r);
            return Cc(t1) * dc / (512 * n);
        }
        function Vc(t1) {
            return 1 / Math.cos(t1 * Math.PI / 180);
        }
        function Lc(t1, e = 0) {
            const r = Math.exp(Math.PI * (1 - (t1.y + e / ps) / (1 << t1.z) * 2));
            return 80150034 * r / (r * r + 1) / ps / (1 << t1.z);
        }
        class Oc {
            constructor(t1, e, r = 0){
                this.x = +t1, this.y = +e, this.z = +r;
            }
            static fromLngLat(t1, e = 0) {
                const r = mc.convert(t1);
                return new Oc(Tc(r.lng), kc(r.lat), Pc(e, r.lat));
            }
            toLngLat() {
                return new mc(zc(this.x), Ec(this.y));
            }
            toAltitude() {
                return Bc(this.z, this.y);
            }
            meterInMercatorCoordinateUnits() {
                return 1 / dc * Vc(Ec(this.y));
            }
        }
        function Fc(t1, e, r, n, i, s, a, o, l) {
            const u = (e + n) / 2, c = (r + i) / 2, h = new Ne(u, c);
            o(h), function(t1, e, r, n, i, s) {
                const a = r - i, o = n - s;
                return Math.abs((n - e) * a - (r - t1) * o) / Math.hypot(a, o);
            }(h.x, h.y, s.x, s.y, a.x, a.y) >= l ? (Fc(t1, e, r, u, c, s, h, o, l), Fc(t1, u, c, n, i, h, a, o, l)) : t1.push(a);
        }
        function Uc(t1, e, r) {
            let n = t1[0], i = n.x, s = n.y;
            e(n);
            const a = [
                n
            ];
            for(let o = 1; o < t1.length; o++){
                const l = t1[o], { x: u, y: c } = l;
                e(l), Fc(a, i, s, u, c, n, l, e, r), i = u, s = c, n = l;
            }
            return a;
        }
        function Nc(t1, e, r, n) {
            if (n(e, r)) {
                const i = e.add(r)._mult(.5);
                Nc(t1, e, i, n), Nc(t1, i, r, n);
            } else t1.push(r);
        }
        function jc(t1, e) {
            let r = t1[0];
            const n = [
                r
            ];
            for(let i = 1; i < t1.length; i++){
                const s = t1[i];
                Nc(n, r, s, e), r = s;
            }
            return n;
        }
        const qc = Math.pow(2, 14) - 1, $c = -qc - 1;
        function Gc(t1, e) {
            const r = Math.round(t1.x * e), n = Math.round(t1.y * e);
            return t1.x = Ke(r, $c, qc), t1.y = Ke(n, $c, qc), (r < t1.x || r > t1.x + 1 || n < t1.y || n > t1.y + 1) && fr("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t1;
        }
        function Yc(t1, e, r) {
            const n = t1.loadGeometry(), i = t1.extent, s = ps / i;
            if (e && r && r.projection.isReprojectedInTileSpace) {
                const s = 1 << e.z, { scale: a, x: o, y: l, projection: u } = r, c = (t1)=>{
                    const r = zc((e.x + t1.x / i) / s), n = Ec((e.y + t1.y / i) / s), c = u.project(r, n);
                    t1.x = (c.x * a - o) * i, t1.y = (c.y * a - l) * i;
                };
                for(let e = 0; e < n.length; e++)if (1 !== t1.type) n[e] = Uc(n[e], c, 1);
                else {
                    const t1 = [];
                    for (const r of n[e])r.x < 0 || r.x >= i || r.y < 0 || r.y >= i || (c(r), t1.push(r));
                    n[e] = t1;
                }
            }
            for (const t1 of n)for (const e of t1)Gc(e, s);
            return n;
        }
        function Xc(t1, e) {
            return {
                type: t1.type,
                id: t1.id,
                properties: t1.properties,
                geometry: e ? Yc(t1) : []
            };
        }
        function Zc(t1, e, r, n, i) {
            t1.emplaceBack(2 * e + (n + 1) / 2, 2 * r + (i + 1) / 2);
        }
        function Hc(t1, e, r) {
            const n = 16384;
            t1.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);
        }
        class Kc {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.projection = t1.projection, this.layoutVertexArray = new Cl, this.indexArray = new Ql, this.segments = new Au, this.programConfigurations = new Wu(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id);
            }
            updateFootprints(t1, e) {}
            populate(t1, e, r, n) {
                const i = this.layers[0], s = [];
                let a = null;
                "circle" === i.type && (a = i.layout.get("circle-sort-key"));
                for (const { feature: e, id: i, index: o, sourceLayerIndex: l } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, u = Xc(e, t1);
                    if (!this.layers[0]._featureFilter.filter(new Ho(this.zoom), u, r)) continue;
                    const c = a ? a.evaluate(u, {}, r) : void 0, h = {
                        id: i,
                        properties: e.properties,
                        type: e.type,
                        sourceLayerIndex: l,
                        index: o,
                        geometry: t1 ? u.geometry : Yc(e, r, n),
                        patterns: {},
                        sortKey: c
                    };
                    s.push(h);
                }
                a && s.sort((t1, e)=>t1.sortKey - e.sortKey);
                let o = null;
                "globe" === n.projection.name && (this.globeExtVertexArray = new ql, o = n.projection);
                for (const n of s){
                    const { geometry: i, index: s, sourceLayerIndex: a } = n, l = t1[s].feature;
                    this.addFeature(n, i, s, e.availableImages, r, o, e.brightness), e.featureIndex.insert(l, i, s, a, this.index);
                }
            }
            update(t1, e, r, n, i) {
                const s = 0 !== Object.keys(t1).length;
                s && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t1, e, s ? this.stateDependentLayers : this.layers, r, n, i);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, wu.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t1.createVertexBuffer(this.globeExtVertexArray, Mu.members))), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
            }
            addFeature(t1, e, r, n, i, s, a) {
                for (const r of e)for (const e of r){
                    const r = e.x, n = e.y;
                    if (r < 0 || r >= ps || n < 0 || n >= ps) continue;
                    if (s) {
                        const t1 = s.projectTilePoint(r, n, i), e = s.upVector(i, r, n), a = this.globeExtVertexArray;
                        Hc(a, t1, e), Hc(a, t1, e), Hc(a, t1, e), Hc(a, t1, e);
                    }
                    const a = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t1.sortKey), o = a.vertexLength;
                    Zc(this.layoutVertexArray, r, n, -1, -1), Zc(this.layoutVertexArray, r, n, 1, -1), Zc(this.layoutVertexArray, r, n, 1, 1), Zc(this.layoutVertexArray, r, n, -1, 1), this.indexArray.emplaceBack(o, o + 1, o + 2), this.indexArray.emplaceBack(o, o + 2, o + 3), a.vertexLength += 4, a.primitiveLength += 2;
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, {}, n, i, a);
            }
        }
        function Wc(t1, e) {
            for(let r = 0; r < t1.length; r++)if (ah(e, t1[r])) return !0;
            for(let r = 0; r < e.length; r++)if (ah(t1, e[r])) return !0;
            return !!eh(t1, e);
        }
        function Jc(t1, e, r) {
            return !!ah(t1, e) || !!nh(e, t1, r);
        }
        function Qc(t1, e) {
            if (1 === t1.length) return sh(e, t1[0]);
            for(let r = 0; r < e.length; r++){
                const n = e[r];
                for(let e = 0; e < n.length; e++)if (ah(t1, n[e])) return !0;
            }
            for(let r = 0; r < t1.length; r++)if (sh(e, t1[r])) return !0;
            for(let r = 0; r < e.length; r++)if (eh(t1, e[r])) return !0;
            return !1;
        }
        function th(t1, e, r) {
            if (t1.length > 1) {
                if (eh(t1, e)) return !0;
                for(let n = 0; n < e.length; n++)if (nh(e[n], t1, r)) return !0;
            }
            for(let n = 0; n < t1.length; n++)if (nh(t1[n], e, r)) return !0;
            return !1;
        }
        function eh(t1, e) {
            if (0 === t1.length || 0 === e.length) return !1;
            for(let r = 0; r < t1.length - 1; r++){
                const n = t1[r], i = t1[r + 1];
                for(let t1 = 0; t1 < e.length - 1; t1++)if (rh(n, i, e[t1], e[t1 + 1])) return !0;
            }
            return !1;
        }
        function rh(t1, e, r, n) {
            return dr(t1, r, n) !== dr(e, r, n) && dr(t1, e, r) !== dr(t1, e, n);
        }
        function nh(t1, e, r) {
            const n = r * r;
            if (1 === e.length) return t1.distSqr(e[0]) < n;
            for(let r = 1; r < e.length; r++)if (ih(t1, e[r - 1], e[r]) < n) return !0;
            return !1;
        }
        function ih(t1, e, r) {
            const n = e.distSqr(r);
            if (0 === n) return t1.distSqr(e);
            const i = ((t1.x - e.x) * (r.x - e.x) + (t1.y - e.y) * (r.y - e.y)) / n;
            return t1.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));
        }
        function sh(t1, e) {
            let r, n, i, s = !1;
            for(let a = 0; a < t1.length; a++){
                r = t1[a];
                for(let t1 = 0, a = r.length - 1; t1 < r.length; a = t1++)n = r[t1], i = r[a], n.y > e.y != i.y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (s = !s);
            }
            return s;
        }
        function ah(t1, e) {
            let r = !1;
            for(let n = 0, i = t1.length - 1; n < t1.length; i = n++){
                const s = t1[n], a = t1[i];
                s.y > e.y != a.y > e.y && e.x < (a.x - s.x) * (e.y - s.y) / (a.y - s.y) + s.x && (r = !r);
            }
            return r;
        }
        function oh(t1, e, r, n, i) {
            for (const s of t1)if (e <= s.x && r <= s.y && n >= s.x && i >= s.y) return !0;
            const s = [
                new Ne(e, r),
                new Ne(e, i),
                new Ne(n, i),
                new Ne(n, r)
            ];
            if (t1.length > 2) {
                for (const e of s)if (ah(t1, e)) return !0;
            }
            for(let e = 0; e < t1.length - 1; e++)if (lh(t1[e], t1[e + 1], s)) return !0;
            return !1;
        }
        function lh(t1, e, r) {
            const n = r[0], i = r[2];
            if (t1.x < n.x && e.x < n.x || t1.x > i.x && e.x > i.x || t1.y < n.y && e.y < n.y || t1.y > i.y && e.y > i.y) return !1;
            const s = dr(t1, e, r[0]);
            return s !== dr(t1, e, r[1]) || s !== dr(t1, e, r[2]) || s !== dr(t1, e, r[3]);
        }
        function uh(t1, e, r, n, i, s) {
            let a = e.y - t1.y, o = t1.x - e.x;
            if (s = s || 0) {
                const t1 = a * a + o * o;
                if (0 === t1) return !0;
                const e = Math.sqrt(t1);
                a /= e, o /= e;
            }
            return !((r.x - t1.x) * a + (r.y - t1.y) * o - s < 0 || (n.x - t1.x) * a + (n.y - t1.y) * o - s < 0 || (i.x - t1.x) * a + (i.y - t1.y) * o - s < 0);
        }
        function ch(t1, e, r, n, i, s, a) {
            return !(uh(t1, e, n, i, s, a) || uh(e, r, n, i, s, a) || uh(r, t1, n, i, s, a) || uh(n, i, t1, e, r, a) || uh(i, s, t1, e, r, a) || uh(s, n, t1, e, r, a));
        }
        function hh(t1, e, r) {
            const n = e.paint.get(t1).value;
            return "constant" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t1);
        }
        function ph(t1) {
            return Math.sqrt(t1[0] * t1[0] + t1[1] * t1[1]);
        }
        function fh(t1, e, r, n, i) {
            if (!e[0] && !e[1]) return t1;
            const s = Ne.convert(e)._mult(i);
            "viewport" === r && s._rotate(-n);
            const a = [];
            for(let e = 0; e < t1.length; e++)a.push(t1[e].sub(s));
            return a;
        }
        function dh(t1, e, r, n) {
            const i = Ne.convert(t1)._mult(n);
            return "viewport" === e && i._rotate(-r), i;
        }
        Mo(Kc, "CircleBucket", {
            omit: [
                "layers"
            ]
        });
        const mh = new ol({
            "circle-sort-key": new sl(ll.layout_circle["circle-sort-key"]),
            visibility: new il(ll.layout_circle.visibility)
        });
        var yh = {
            paint: new ol({
                "circle-radius": new sl(ll.paint_circle["circle-radius"]),
                "circle-color": new sl(ll.paint_circle["circle-color"]),
                "circle-blur": new sl(ll.paint_circle["circle-blur"]),
                "circle-opacity": new sl(ll.paint_circle["circle-opacity"]),
                "circle-translate": new il(ll.paint_circle["circle-translate"]),
                "circle-translate-anchor": new il(ll.paint_circle["circle-translate-anchor"]),
                "circle-pitch-scale": new il(ll.paint_circle["circle-pitch-scale"]),
                "circle-pitch-alignment": new il(ll.paint_circle["circle-pitch-alignment"]),
                "circle-stroke-width": new sl(ll.paint_circle["circle-stroke-width"]),
                "circle-stroke-color": new sl(ll.paint_circle["circle-stroke-color"]),
                "circle-stroke-opacity": new sl(ll.paint_circle["circle-stroke-opacity"]),
                "circle-emissive-strength": new il(ll.paint_circle["circle-emissive-strength"])
            }),
            layout: mh
        };
        class gh {
            constructor(t1, e){
                this.pos = t1, this.dir = e;
            }
            intersectsPlane(e, r, n) {
                const i = t1._.dot(r, this.dir);
                if (Math.abs(i) < 1e-6) return !1;
                const s = ((e[0] - this.pos[0]) * r[0] + (e[1] - this.pos[1]) * r[1] + (e[2] - this.pos[2]) * r[2]) / i;
                return n[0] = this.pos[0] + this.dir[0] * s, n[1] = this.pos[1] + this.dir[1] * s, n[2] = this.pos[2] + this.dir[2] * s, !0;
            }
            closestPointOnSphere(e, r, n) {
                if (t1._.equals(this.pos, e) || 0 === r) return n[0] = n[1] = n[2] = 0, !1;
                const [i, s, a] = this.dir, o = this.pos[0] - e[0], l = this.pos[1] - e[1], u = this.pos[2] - e[2], c = i * i + s * s + a * a, h = 2 * (o * i + l * s + u * a), p = h * h - 4 * c * (o * o + l * l + u * u - r * r);
                if (p < 0) {
                    const t1 = Math.max(-h / 2, 0), e = o + i * t1, c = l + s * t1, p = u + a * t1, f = Math.hypot(e, c, p);
                    return n[0] = e * r / f, n[1] = c * r / f, n[2] = p * r / f, !1;
                }
                {
                    const t1 = (-h - Math.sqrt(p)) / (2 * c);
                    if (t1 < 0) {
                        const t1 = Math.hypot(o, l, u);
                        return n[0] = o * r / t1, n[1] = l * r / t1, n[2] = u * r / t1, !1;
                    }
                    return n[0] = o + i * t1, n[1] = l + s * t1, n[2] = u + a * t1, !0;
                }
            }
        }
        class xh {
            constructor(t1, e, r, n, i){
                this.TL = t1, this.TR = e, this.BR = r, this.BL = n, this.horizon = i;
            }
            static fromInvProjectionMatrix(e, r, n) {
                const i = [
                    -1,
                    1,
                    1
                ], s = [
                    1,
                    1,
                    1
                ], a = [
                    1,
                    -1,
                    1
                ], o = [
                    -1,
                    -1,
                    1
                ], l = t1._.transformMat4(i, i, e), u = t1._.transformMat4(s, s, e), c = t1._.transformMat4(a, a, e), h = t1._.transformMat4(o, o, e);
                return new xh(l, u, c, h, r / n);
            }
        }
        function bh(e, r, n) {
            let i = 1 / 0, s = -1 / 0;
            const a = [];
            for (const o of e){
                t1._.sub(a, o, r);
                const e = t1._.dot(a, n);
                i = Math.min(i, e), s = Math.max(s, e);
            }
            return [
                i,
                s
            ];
        }
        function vh(e, r) {
            let n = !0;
            for(let i = 0; i < e.planes.length; i++){
                const s = e.planes[i];
                let a = 0;
                for(let e = 0; e < r.length; e++)a += t1._.dot(s, r[e]) + s[3] >= 0;
                if (0 === a) return 0;
                a !== r.length && (n = !1);
            }
            return n ? 2 : 1;
        }
        function _h(t1, e) {
            for (const r of t1.projections){
                const n = bh(e, t1.points[0], r.axis);
                if (r.projection[1] < n[0] || r.projection[0] > n[1]) return 0;
            }
            return 1;
        }
        function wh(e, r) {
            let n = 0;
            const i = [
                0,
                0,
                0,
                0
            ];
            for(let s = 0; s < e.length; s++)i[0] = e[s][0], i[1] = e[s][1], i[2] = e[s][2], i[3] = 1, t1.aA.dot(i, r) >= 0 && n++;
            return n;
        }
        class Mh {
            constructor(e, r){
                this.points = e || new Array(8).fill([
                    0,
                    0,
                    0
                ]), this.planes = r || new Array(6).fill([
                    0,
                    0,
                    0,
                    0
                ]), this.bounds = Ah.fromPoints(this.points), this.projections = [], this.frustumEdges = [
                    t1._.sub([], this.points[2], this.points[3]),
                    t1._.sub([], this.points[0], this.points[3]),
                    t1._.sub([], this.points[4], this.points[0]),
                    t1._.sub([], this.points[5], this.points[1]),
                    t1._.sub([], this.points[6], this.points[2]),
                    t1._.sub([], this.points[7], this.points[3])
                ];
                for (const t1 of this.frustumEdges){
                    const e = [
                        0,
                        -t1[2],
                        t1[1]
                    ], r = [
                        t1[2],
                        0,
                        -t1[0]
                    ];
                    this.projections.push({
                        axis: e,
                        projection: bh(this.points, this.points[0], e)
                    }), this.projections.push({
                        axis: r,
                        projection: bh(this.points, this.points[0], r)
                    });
                }
            }
            static fromInvProjectionMatrix(e, r, n, i) {
                const s = Math.pow(2, n), a = [
                    [
                        -1,
                        1,
                        -1,
                        1
                    ],
                    [
                        1,
                        1,
                        -1,
                        1
                    ],
                    [
                        1,
                        -1,
                        -1,
                        1
                    ],
                    [
                        -1,
                        -1,
                        -1,
                        1
                    ],
                    [
                        -1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        -1,
                        1,
                        1
                    ],
                    [
                        -1,
                        -1,
                        1,
                        1
                    ]
                ].map((n)=>{
                    const a = t1.aA.transformMat4([], n, e), o = 1 / a[3] / r * s;
                    return t1.aA.mul(a, a, [
                        o,
                        o,
                        i ? 1 / a[3] : o,
                        o
                    ]);
                }), o = [
                    [
                        0,
                        1,
                        2
                    ],
                    [
                        6,
                        5,
                        4
                    ],
                    [
                        0,
                        3,
                        7
                    ],
                    [
                        2,
                        1,
                        5
                    ],
                    [
                        3,
                        2,
                        6
                    ],
                    [
                        0,
                        4,
                        5
                    ]
                ].map((e)=>{
                    const r = t1._.sub([], a[e[0]], a[e[1]]), n = t1._.sub([], a[e[2]], a[e[1]]), i = t1._.normalize([], t1._.cross([], r, n)), s = -t1._.dot(i, a[e[1]]);
                    return i.concat(s);
                }), l = [];
                for(let t1 = 0; t1 < a.length; t1++)l.push([
                    a[t1][0],
                    a[t1][1],
                    a[t1][2]
                ]);
                return new Mh(l, o);
            }
            intersectsPrecise(e, r, n) {
                for(let t1 = 0; t1 < r.length; t1++)if (!wh(e, r[t1])) return 0;
                for(let t1 = 0; t1 < this.planes.length; t1++)if (!wh(e, this.planes[t1])) return 0;
                for (const r of n)for (const n of this.frustumEdges){
                    const i = t1._.cross([], r, n), s = t1._.length(i);
                    if (0 === s) continue;
                    t1._.scale(i, i, 1 / s);
                    const a = bh(this.points, this.points[0], i), o = bh(e, this.points[0], i);
                    if (a[0] > o[1] || o[0] > a[1]) return 0;
                }
                return 1;
            }
        }
        class Ah {
            static fromPoints(e) {
                const r = [
                    1 / 0,
                    1 / 0,
                    1 / 0
                ], n = [
                    -1 / 0,
                    -1 / 0,
                    -1 / 0
                ];
                for (const i of e)t1._.min(r, r, i), t1._.max(n, n, i);
                return new Ah(r, n);
            }
            static fromTileIdAndHeight(t1, e, r) {
                const n = 1 << t1.canonical.z, i = t1.canonical.x, s = t1.canonical.y;
                return new Ah([
                    i / n,
                    s / n,
                    e
                ], [
                    (i + 1) / n,
                    (s + 1) / n,
                    r
                ]);
            }
            static applyTransform(e, r) {
                const n = e.getCorners();
                for(let e = 0; e < n.length; ++e)t1._.transformMat4(n[e], n[e], r);
                return Ah.fromPoints(n);
            }
            static applyTransformFast(t1, e) {
                const r = [
                    e[12],
                    e[13],
                    e[14]
                ], n = [
                    ...r
                ];
                for(let i = 0; i < 3; i++)for(let s = 0; s < 3; s++){
                    const a = e[4 * s + i], o = a * t1.min[s], l = a * t1.max[s];
                    r[i] += Math.min(o, l), n[i] += Math.max(o, l);
                }
                return new Ah(r, n);
            }
            static projectAabbCorners(e, r) {
                const n = e.getCorners();
                for(let e = 0; e < n.length; ++e)t1._.transformMat4(n[e], n[e], r);
                return n;
            }
            constructor(e, r){
                this.min = e, this.max = r, this.center = t1._.scale([], t1._.add([], this.min, this.max), .5);
            }
            quadrant(e) {
                const r = [
                    e % 2 == 0,
                    e < 2
                ], n = t1._.clone(this.min), i = t1._.clone(this.max);
                for(let t1 = 0; t1 < r.length; t1++)n[t1] = r[t1] ? this.min[t1] : this.center[t1], i[t1] = r[t1] ? this.center[t1] : this.max[t1];
                return i[2] = this.max[2], new Ah(n, i);
            }
            distanceX(t1) {
                return Math.max(Math.min(this.max[0], t1[0]), this.min[0]) - t1[0];
            }
            distanceY(t1) {
                return Math.max(Math.min(this.max[1], t1[1]), this.min[1]) - t1[1];
            }
            distanceZ(t1) {
                return Math.max(Math.min(this.max[2], t1[2]), this.min[2]) - t1[2];
            }
            getCorners() {
                const t1 = this.min, e = this.max;
                return [
                    [
                        t1[0],
                        t1[1],
                        t1[2]
                    ],
                    [
                        e[0],
                        t1[1],
                        t1[2]
                    ],
                    [
                        e[0],
                        e[1],
                        t1[2]
                    ],
                    [
                        t1[0],
                        e[1],
                        t1[2]
                    ],
                    [
                        t1[0],
                        t1[1],
                        e[2]
                    ],
                    [
                        e[0],
                        t1[1],
                        e[2]
                    ],
                    [
                        e[0],
                        e[1],
                        e[2]
                    ],
                    [
                        t1[0],
                        e[1],
                        e[2]
                    ]
                ];
            }
            intersects(t1) {
                return this.intersectsAabb(t1.bounds) ? vh(t1, this.getCorners()) : 0;
            }
            intersectsFlat(t1) {
                return this.intersectsAabb(t1.bounds) ? vh(t1, [
                    [
                        this.min[0],
                        this.min[1],
                        0
                    ],
                    [
                        this.max[0],
                        this.min[1],
                        0
                    ],
                    [
                        this.max[0],
                        this.max[1],
                        0
                    ],
                    [
                        this.min[0],
                        this.max[1],
                        0
                    ]
                ]) : 0;
            }
            intersectsPrecise(t1, e) {
                return e || this.intersects(t1) ? _h(t1, this.getCorners()) : 0;
            }
            intersectsPreciseFlat(t1, e) {
                return e || this.intersectsFlat(t1) ? _h(t1, [
                    [
                        this.min[0],
                        this.min[1],
                        0
                    ],
                    [
                        this.max[0],
                        this.min[1],
                        0
                    ],
                    [
                        this.max[0],
                        this.max[1],
                        0
                    ],
                    [
                        this.min[0],
                        this.max[1],
                        0
                    ]
                ]) : 0;
            }
            intersectsAabb(t1) {
                for(let e = 0; e < 3; ++e)if (this.min[e] > t1.max[e] || t1.min[e] > this.max[e]) return !1;
                return !0;
            }
            intersectsAabbXY(t1) {
                return !(this.min[0] > t1.max[0] || t1.min[0] > this.max[0] || this.min[1] > t1.max[1] || t1.min[1] > this.max[1]);
            }
            encapsulate(t1) {
                for(let e = 0; e < 3; e++)this.min[e] = Math.min(this.min[e], t1.min[e]), this.max[e] = Math.max(this.max[e], t1.max[e]);
            }
            encapsulatePoint(t1) {
                for(let e = 0; e < 3; e++)this.min[e] = Math.min(this.min[e], t1[e]), this.max[e] = Math.max(this.max[e], t1[e]);
            }
            closestPoint(t1) {
                return [
                    Math.max(Math.min(this.max[0], t1[0]), this.min[0]),
                    Math.max(Math.min(this.max[1], t1[1]), this.min[1]),
                    Math.max(Math.min(this.max[2], t1[2]), this.min[2])
                ];
            }
        }
        Mo(Ah, "Aabb");
        const Sh = Bl([
            {
                type: "Float32",
                name: "a_globe_pos",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            }
        ]), { members: Ih } = Sh, Th = Bl([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            }
        ]);
        var kh = Bl([
            {
                name: "a_pos",
                type: "Int16",
                components: 2
            }
        ]);
        function Ph(t1) {
            return t1 * nc / fc;
        }
        const zh = [
            new Ah([
                uc,
                uc,
                uc
            ], [
                cc,
                cc,
                cc
            ]),
            new Ah([
                uc,
                uc,
                uc
            ], [
                0,
                0,
                cc
            ]),
            new Ah([
                0,
                uc,
                uc
            ], [
                cc,
                0,
                cc
            ]),
            new Ah([
                uc,
                0,
                uc
            ], [
                0,
                cc,
                cc
            ]),
            new Ah([
                0,
                0,
                uc
            ], [
                cc,
                cc,
                cc
            ])
        ];
        function Eh(e, r, n, i = !0) {
            const s = t1._.scale([], e._camera.position, e.worldSize), a = [
                r,
                n,
                1,
                1
            ];
            t1.aA.transformMat4(a, a, e.pixelMatrixInverse), t1.aA.scale(a, a, 1 / a[3]);
            const o = t1._.sub([], a, s), l = t1._.normalize([], o), u = e.globeMatrix, c = [
                u[12],
                u[13],
                u[14]
            ], h = t1._.sub([], c, s), p = t1._.length(h), f = t1._.normalize([], h), d = e.worldSize / (2 * Math.PI), m = t1._.dot(f, l), y = Math.asin(d / p);
            if (y < Math.acos(m)) {
                if (!i) return null;
                const e = [], r = [];
                t1._.scale(e, l, p / m), t1._.normalize(r, t1._.sub(r, e, h)), t1._.normalize(l, t1._.add(l, h, t1._.scale(l, r, Math.tan(y) * p)));
            }
            const g = [];
            new gh(s, l).closestPointOnSphere(c, d, g);
            const x = t1._.normalize([], Tr(u, 0)), b = t1._.normalize([], Tr(u, 1)), v = t1._.normalize([], Tr(u, 2)), _ = t1._.dot(x, g), w = t1._.dot(b, g), M = t1._.dot(v, g), A = Ge(Math.asin(-w / d));
            let S = Ge(Math.atan2(_, M));
            S = e.center.lng + function(t1, e) {
                const r = (e - t1 + 180) % 360 - 180;
                return r < -180 ? r + 360 : r;
            }(e.center.lng, S);
            const I = Tc(S), T = Ke(kc(A), 0, 1);
            return new Oc(I, T);
        }
        class Bh {
            constructor(e, r, n){
                this.a = t1._.sub([], e, n), this.b = t1._.sub([], r, n), this.center = n;
                const i = t1._.normalize([], this.a), s = t1._.normalize([], this.b);
                this.angle = Math.acos(t1._.dot(i, s));
            }
        }
        function Dh(t1, e) {
            if (0 === t1.angle) return null;
            let r;
            return r = 0 === t1.a[e] ? 1 / t1.angle * .5 * Math.PI : 1 / t1.angle * Math.atan(t1.b[e] / t1.a[e] / Math.sin(t1.angle) - 1 / Math.tan(t1.angle)), r < 0 || r > 1 ? null : function(t1, e, r, n) {
                const i = Math.sin(r);
                return t1 * (Math.sin((1 - n) * r) / i) + e * (Math.sin(n * r) / i);
            }(t1.a[e], t1.b[e], t1.angle, Ke(r, 0, 1)) + t1.center[e];
        }
        function Ch(t1) {
            if (t1.z <= 1) return zh[t1.z + 2 * t1.y + t1.x];
            const e = Uh(Fh(t1));
            return Ah.fromPoints(e);
        }
        function Rh(e, r, n) {
            return t1._.scale(e, e, 1 - n), t1._.scaleAndAdd(e, e, r, n);
        }
        function Vh(e, r) {
            const n = Hh(r.zoom);
            if (0 === n) return Ch(e);
            const i = Fh(e), s = Uh(i), a = Tc(i.getWest()) * r.worldSize, o = Tc(i.getEast()) * r.worldSize, l = kc(i.getNorth()) * r.worldSize, u = kc(i.getSouth()) * r.worldSize, c = [
                a,
                l,
                0
            ], h = [
                o,
                l,
                0
            ], p = [
                a,
                u,
                0
            ], f = [
                o,
                u,
                0
            ], d = t1.ad.invert([], r.globeMatrix);
            return t1._.transformMat4(c, c, d), t1._.transformMat4(h, h, d), t1._.transformMat4(p, p, d), t1._.transformMat4(f, f, d), s[0] = Rh(s[0], p, n), s[1] = Rh(s[1], f, n), s[2] = Rh(s[2], h, n), s[3] = Rh(s[3], c, n), Ah.fromPoints(s);
        }
        function Lh(e, r, n) {
            for (const i of e)t1._.transformMat4(i, i, r), t1._.scale(i, i, n);
        }
        function Oh(e, r, n, i) {
            const s = r / e.worldSize, a = e.globeMatrix;
            if (n.z <= 1) {
                const t1 = Ch(n).getCorners();
                return Lh(t1, a, s), Ah.fromPoints(t1);
            }
            const o = Fh(n, i), l = Uh(o, nc + Ph(e._tileCoverLift));
            Lh(l, a, s);
            const u = Number.MAX_VALUE, c = [
                -u,
                -u,
                -u
            ], h = [
                u,
                u,
                u
            ];
            if (o.contains(e.center)) {
                for (const e of l)t1._.min(h, h, e), t1._.max(c, c, e);
                c[2] = 0;
                const r = e.point, n = [
                    r.x * s,
                    r.y * s,
                    0
                ];
                return t1._.min(h, h, n), t1._.max(c, c, n), new Ah(h, c);
            }
            if (e._tileCoverLift > 0) {
                for (const e of l)t1._.min(h, h, e), t1._.max(c, c, e);
                return new Ah(h, c);
            }
            const p = [
                a[12] * s,
                a[13] * s,
                a[14] * s
            ], f = o.getCenter(), d = Ke(e.center.lat, -Dc, Dc), m = Ke(f.lat, -Dc, Dc), y = Tc(e.center.lng), g = kc(d);
            let x = y - Tc(f.lng);
            const b = g - kc(m);
            x > .5 ? x -= 1 : x < -0.5 && (x += 1);
            let v = 0;
            if (Math.abs(x) > Math.abs(b)) v = x >= 0 ? 1 : 3;
            else {
                v = b >= 0 ? 0 : 2;
                const e = [
                    a[4] * s,
                    a[5] * s,
                    a[6] * s
                ], r = -Math.sin($e(b >= 0 ? o.getSouth() : o.getNorth())) * nc;
                t1._.scaleAndAdd(p, p, e, r);
            }
            const _ = l[v], w = l[(v + 1) % 4], M = new Bh(_, w, p), A = [
                Dh(M, 0) || _[0],
                Dh(M, 1) || _[1],
                Dh(M, 2) || _[2]
            ], S = Hh(e.zoom);
            if (S > 0) {
                const i = function({ x: t1, y: e, z: r }, n, i, s, a) {
                    const o = 1 / (1 << r);
                    let l = t1 * o, u = l + o, c = e * o, h = c + o, p = 0;
                    const f = (l + u) / 2 - s;
                    return f > .5 ? p = -1 : f < -0.5 && (p = 1), l = ((l + p) * n - (s *= n)) * i + s, u = ((u + p) * n - s) * i + s, c = (c * n - (a *= n)) * i + a, h = (h * n - a) * i + a, [
                        [
                            l,
                            h,
                            0
                        ],
                        [
                            u,
                            h,
                            0
                        ],
                        [
                            u,
                            c,
                            0
                        ],
                        [
                            l,
                            c,
                            0
                        ]
                    ];
                }(n, r, e._pixelsPerMercatorPixel, y, g);
                for(let t1 = 0; t1 < l.length; t1++)Rh(l[t1], i[t1], S);
                const s = t1._.add([], i[v], i[(v + 1) % 4]);
                t1._.scale(s, s, .5), Rh(A, s, S);
            }
            for (const e of l)t1._.min(h, h, e), t1._.max(c, c, e);
            return h[2] = Math.min(_[2], w[2]), t1._.min(h, h, A), t1._.max(c, c, A), new Ah(h, c);
        }
        function Fh({ x: t1, y: e, z: r }, n = !1) {
            const i = 1 / (1 << r), s = new mc(zc(t1 * i), e === (1 << r) - 1 && n ? -90 : Ec((e + 1) * i)), a = new mc(zc((t1 + 1) * i), 0 === e && n ? 90 : Ec(e * i));
            return new yc(s, a);
        }
        function Uh(t1, e = nc) {
            const r = $e(t1.getNorth()), n = $e(t1.getSouth()), i = Math.cos(r), s = Math.cos(n), a = Math.sin(r), o = Math.sin(n), l = t1.getWest(), u = t1.getEast();
            return [
                hc(s, o, l, e),
                hc(s, o, u, e),
                hc(i, a, u, e),
                hc(i, a, l, e)
            ];
        }
        function Nh(t1, e, r, n) {
            const i = 1 << r.z, s = (t1 / ps + r.x) / i;
            return pc(Ec((e / ps + r.y) / i), zc(s), n);
        }
        function jh({ min: t1, max: e }) {
            return ac / Math.max(e[0] - t1[0], e[1] - t1[1], e[2] - t1[2]);
        }
        const qh = new Float64Array(16);
        function $h(e) {
            const r = jh(e), n = t1.ad.fromScaling(qh, [
                r,
                r,
                r
            ]);
            return t1.ad.translate(n, n, t1._.negate([], e.min));
        }
        function Gh(e) {
            const r = t1.ad.fromTranslation(qh, e.min), n = 1 / jh(e);
            return t1.ad.scale(r, r, [
                n,
                n,
                n
            ]);
        }
        function Yh(t1) {
            const e = ps / (2 * Math.PI);
            return t1 / (2 * Math.PI) / e;
        }
        function Xh(t1, e) {
            return ps / (512 * Math.pow(2, t1)) * jh(Ch(e));
        }
        function Zh(e, r, n, i, s) {
            const a = Yh(n), o = [
                e,
                r,
                -n / (2 * Math.PI)
            ], l = t1.ad.identity(new Float64Array(16));
            return t1.ad.translate(l, l, o), t1.ad.scale(l, l, [
                a,
                a,
                a
            ]), t1.ad.rotateX(l, l, $e(-s)), t1.ad.rotateY(l, l, $e(-i)), l;
        }
        function Hh(t1) {
            return We(ic, sc, t1);
        }
        function Kh(e, r) {
            const n = pc(r.lat, r.lng), i = function(e) {
                const r = pc(e._center.lat, e._center.lng), n = t1._.fromValues(0, 1, 0);
                let i = t1._.cross([], n, r);
                const s = t1.ad.fromRotation([], -e.angle, r);
                i = t1._.transformMat4(i, i, s), t1.ad.fromRotation(s, -e._pitch, i);
                const a = t1._.normalize([], r);
                return t1._.scale(a, a, Ph(e.cameraToCenterDistance / e.pixelsPerMeter)), t1._.transformMat4(a, a, s), t1._.add([], r, a);
            }(e), s = t1._.subtract([], i, n);
            return t1._.angle(s, n);
        }
        function Wh(t1, e) {
            return Kh(t1, e) > Math.PI / 2 * 1.01;
        }
        const Jh = $e(85), Qh = Math.cos(Jh), tp = Math.sin(Jh), ep = t1.ad.create(), rp = (t1)=>{
            const e = [];
            return "map" === t1.paint.get("circle-pitch-alignment") && e.push("PITCH_WITH_MAP"), "map" === t1.paint.get("circle-pitch-scale") && e.push("SCALE_WITH_MAP"), e;
        };
        function np(e, r, n, i, s, a, o, l, u) {
            if (a && e.queryGeometry.isAboveHorizon) return !1;
            a && (u *= e.pixelToTileUnitsFactor);
            const c = e.tileID.canonical, h = n.projection.upVectorScale(c, n.center.lat, n.worldSize).metersToTile;
            for (const p of r)for (const r of p){
                const p = r.add(l), f = s && n.elevation ? n.elevation.exaggeration() * s.getElevationAt(p.x, p.y, !0) : 0, d = n.projection.projectTilePoint(p.x, p.y, c);
                if (f > 0) {
                    const t1 = n.projection.upVector(c, p.x, p.y);
                    d.x += t1[0] * h * f, d.y += t1[1] * h * f, d.z += t1[2] * h * f;
                }
                const m = a ? p : ip(d.x, d.y, d.z, i), y = a ? e.tilespaceRays.map((t1)=>op(t1, f)) : e.queryGeometry.screenGeometry, g = t1.aA.transformMat4([], [
                    d.x,
                    d.y,
                    d.z,
                    1
                ], i);
                if (!o && a ? u *= g[3] / n.cameraToCenterDistance : o && !a && (u *= n.cameraToCenterDistance / g[3]), a) {
                    const t1 = Ec((r.y / ps + c.y) / (1 << c.z));
                    u /= n.projection.pixelsPerMeter(t1, 1) / Pc(1, t1);
                }
                if (Jc(y, m, u)) return !0;
            }
            return !1;
        }
        function ip(e, r, n, i) {
            const s = t1.aA.transformMat4([], [
                e,
                r,
                n,
                1
            ], i);
            return new Ne(s[0] / s[3], s[1] / s[3]);
        }
        const sp = t1._.fromValues(0, 0, 0), ap = t1._.fromValues(0, 0, 1);
        function op(e, r) {
            const n = t1._.create();
            return sp[2] = r, e.intersectsPlane(sp, ap, n), new Ne(n[0], n[1]);
        }
        class lp extends Kc {
        }
        function up(t1, { width: e, height: r }, n, i) {
            if (i) {
                if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);
                else if (i.length !== e * r * n) throw new RangeError("mismatched image size");
            } else i = new Uint8Array(e * r * n);
            return t1.width = e, t1.height = r, t1.data = i, t1;
        }
        function cp(t1, e, r) {
            const { width: n, height: i } = e;
            n === t1.width && i === t1.height || (hp(t1, e, {
                x: 0,
                y: 0
            }, {
                x: 0,
                y: 0
            }, {
                width: Math.min(t1.width, n),
                height: Math.min(t1.height, i)
            }, r, null), t1.width = n, t1.height = i, t1.data = e.data);
        }
        function hp(t1, e, r, n, i, s, a, o) {
            if (0 === i.width || 0 === i.height) return e;
            if (i.width > t1.width || i.height > t1.height || r.x > t1.width - i.width || r.y > t1.height - i.height) throw new RangeError("out of range source coordinates for image copy");
            if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError("out of range destination coordinates for image copy");
            const l = t1.data, u = e.data, c = 4 === s && o;
            for(let o = 0; o < i.height; o++){
                const h = ((r.y + o) * t1.width + r.x) * s, p = ((n.y + o) * e.width + n.x) * s;
                if (c) for(let t1 = 0; t1 < i.width; t1++){
                    const e = h + t1 * s + 3, r = p + t1 * s;
                    u[r + 0] = 255, u[r + 1] = 255, u[r + 2] = 255, u[r + 3] = l[e];
                }
                else if (a) for(let t1 = 0; t1 < i.width; t1++){
                    const e = h + t1 * s, r = p + t1 * s, n = l[e + 3], i = new qn(l[e + 0] / 255 * n, l[e + 1] / 255 * n, l[e + 2] / 255 * n, n).toRenderColor(a).toArray();
                    u[r + 0] = i[0], u[r + 1] = i[1], u[r + 2] = i[2], u[r + 3] = i[3];
                }
                else for(let t1 = 0; t1 < i.width * s; t1++)u[p + t1] = l[h + t1];
            }
            return e;
        }
        Mo(lp, "HeatmapBucket", {
            omit: [
                "layers"
            ]
        });
        class pp {
            constructor(t1, e){
                up(this, t1, 1, e);
            }
            resize(t1) {
                cp(this, new pp(t1), 1);
            }
            clone() {
                return new pp({
                    width: this.width,
                    height: this.height
                }, new Uint8Array(this.data));
            }
            static copy(t1, e, r, n, i) {
                hp(t1, e, r, n, i, 1, null);
            }
        }
        class fp {
            constructor(t1, e){
                up(this, t1, 4, e);
            }
            resize(t1) {
                cp(this, new fp(t1), 4);
            }
            replace(t1, e) {
                e ? this.data.set(t1) : this.data = t1 instanceof Uint8ClampedArray ? new Uint8Array(t1.buffer) : t1;
            }
            clone() {
                return new fp({
                    width: this.width,
                    height: this.height
                }, new Uint8Array(this.data));
            }
            static copy(t1, e, r, n, i, s, a) {
                hp(t1, e, r, n, i, 4, s, a);
            }
        }
        class dp {
            constructor(t1, e){
                this.width = t1.width, this.height = t1.height, this.data = e instanceof Uint8Array ? new Float32Array(e.buffer) : e;
            }
        }
        Mo(pp, "AlphaImage"), Mo(fp, "RGBAImage");
        const mp = new ol({
            visibility: new il(ll.layout_heatmap.visibility)
        });
        var yp = {
            paint: new ol({
                "heatmap-radius": new sl(ll.paint_heatmap["heatmap-radius"]),
                "heatmap-weight": new sl(ll.paint_heatmap["heatmap-weight"]),
                "heatmap-intensity": new il(ll.paint_heatmap["heatmap-intensity"]),
                "heatmap-color": new al(ll.paint_heatmap["heatmap-color"]),
                "heatmap-opacity": new il(ll.paint_heatmap["heatmap-opacity"])
            }),
            layout: mp
        };
        function gp(t1) {
            const e = {}, r = t1.resolution || 256, n = t1.clips ? t1.clips.length : 1, i = t1.image || new fp({
                width: r,
                height: n
            }), s = (r, n, s)=>{
                e[t1.evaluationKey] = s;
                const a = t1.expression.evaluate(e);
                a && (i.data[r + n + 0] = Math.floor(255 * a.r / a.a), i.data[r + n + 1] = Math.floor(255 * a.g / a.a), i.data[r + n + 2] = Math.floor(255 * a.b / a.a), i.data[r + n + 3] = Math.floor(255 * a.a));
            };
            if (t1.clips) for(let e = 0, i = 0; e < n; ++e, i += 4 * r)for(let n = 0, a = 0; n < r; n++, a += 4){
                const o = n / (r - 1), { start: l, end: u } = t1.clips[e];
                s(i, a, l * (1 - o) + u * o);
            }
            else for(let t1 = 0, e = 0; t1 < r; t1++, e += 4)s(0, e, t1 / (r - 1));
            return i;
        }
        const xp = new ol({
            visibility: new il(ll.layout_hillshade.visibility)
        });
        var bp = {
            paint: new ol({
                "hillshade-illumination-direction": new il(ll.paint_hillshade["hillshade-illumination-direction"]),
                "hillshade-illumination-anchor": new il(ll.paint_hillshade["hillshade-illumination-anchor"]),
                "hillshade-exaggeration": new il(ll.paint_hillshade["hillshade-exaggeration"]),
                "hillshade-shadow-color": new il(ll.paint_hillshade["hillshade-shadow-color"]),
                "hillshade-highlight-color": new il(ll.paint_hillshade["hillshade-highlight-color"]),
                "hillshade-accent-color": new il(ll.paint_hillshade["hillshade-accent-color"]),
                "hillshade-emissive-strength": new il(ll.paint_hillshade["hillshade-emissive-strength"])
            }),
            layout: xp
        };
        const vp = Bl([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            }
        ], 4), { members: _p } = vp;
        function wp(t1, e, r = 2) {
            const n = e && e.length, i = n ? e[0] * r : t1.length;
            let s = Mp(t1, 0, i, r, !0);
            const a = [];
            if (!s || s.next === s.prev) return a;
            let o, l, u;
            if (n && (s = function(t1, e, r, n) {
                const i = [];
                for(let r = 0, s = e.length; r < s; r++){
                    const a = Mp(t1, e[r] * n, r < s - 1 ? e[r + 1] * n : t1.length, n, !1);
                    a === a.next && (a.steiner = !0), i.push(Cp(a));
                }
                i.sort(zp);
                for(let t1 = 0; t1 < i.length; t1++)r = Ep(i[t1], r);
                return r;
            }(t1, e, s, r)), t1.length > 80 * r) {
                o = 1 / 0, l = 1 / 0;
                let e = -1 / 0, n = -1 / 0;
                for(let s = r; s < i; s += r){
                    const r = t1[s], i = t1[s + 1];
                    r < o && (o = r), i < l && (l = i), r > e && (e = r), i > n && (n = i);
                }
                u = Math.max(e - o, n - l), u = 0 !== u ? 32767 / u : 0;
            }
            return Sp(s, a, r, o, l, u, 0), a;
        }
        function Mp(t1, e, r, n, i) {
            let s;
            if (i === function(t1, e, r, n) {
                let i = 0;
                for(let s = e, a = r - n; s < r; s += n)i += (t1[a] - t1[s]) * (t1[s + 1] + t1[a + 1]), a = s;
                return i;
            }(t1, e, r, n) > 0) for(let i = e; i < r; i += n)s = $p(i / n | 0, t1[i], t1[i + 1], s);
            else for(let i = r - n; i >= e; i -= n)s = $p(i / n | 0, t1[i], t1[i + 1], s);
            return s && Op(s, s.next) && (Gp(s), s = s.next), s;
        }
        function Ap(t1, e) {
            if (!t1) return t1;
            e || (e = t1);
            let r, n = t1;
            do if (r = !1, n.steiner || !Op(n, n.next) && 0 !== Lp(n.prev, n, n.next)) n = n.next;
            else {
                if (Gp(n), n = e = n.prev, n === n.next) break;
                r = !0;
            }
            while (r || n !== e);
            return e;
        }
        function Sp(t1, e, r, n, i, s, a) {
            if (!t1) return;
            !a && s && function(t1, e, r, n) {
                let i = t1;
                do 0 === i.z && (i.z = Dp(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
                while (i !== t1);
                i.prevZ.nextZ = null, i.prevZ = null, function(t1) {
                    let e, r = 1;
                    do {
                        let n, i = t1;
                        t1 = null;
                        let s = null;
                        for(e = 0; i;){
                            e++;
                            let a = i, o = 0;
                            for(let t1 = 0; t1 < r && (o++, a = a.nextZ, a); t1++);
                            let l = r;
                            for(; o > 0 || l > 0 && a;)0 !== o && (0 === l || !a || i.z <= a.z) ? (n = i, i = i.nextZ, o--) : (n = a, a = a.nextZ, l--), s ? s.nextZ = n : t1 = n, n.prevZ = s, s = n;
                            i = a;
                        }
                        s.nextZ = null, r *= 2;
                    }while (e > 1);
                }(i);
            }(t1, n, i, s);
            let o = t1;
            for(; t1.prev !== t1.next;){
                const l = t1.prev, u = t1.next;
                if (s ? Tp(t1, n, i, s) : Ip(t1)) e.push(l.i, t1.i, u.i), Gp(t1), t1 = u.next, o = u.next;
                else if ((t1 = u) === o) {
                    a ? 1 === a ? Sp(t1 = kp(Ap(t1), e), e, r, n, i, s, 2) : 2 === a && Pp(t1, e, r, n, i, s) : Sp(Ap(t1), e, r, n, i, s, 1);
                    break;
                }
            }
        }
        function Ip(t1) {
            const e = t1.prev, r = t1, n = t1.next;
            if (Lp(e, r, n) >= 0) return !1;
            const i = e.x, s = r.x, a = n.x, o = e.y, l = r.y, u = n.y, c = i < s ? i < a ? i : a : s < a ? s : a, h = o < l ? o < u ? o : u : l < u ? l : u, p = i > s ? i > a ? i : a : s > a ? s : a, f = o > l ? o > u ? o : u : l > u ? l : u;
            let d = n.next;
            for(; d !== e;){
                if (d.x >= c && d.x <= p && d.y >= h && d.y <= f && Rp(i, o, s, l, a, u, d.x, d.y) && Lp(d.prev, d, d.next) >= 0) return !1;
                d = d.next;
            }
            return !0;
        }
        function Tp(t1, e, r, n) {
            const i = t1.prev, s = t1, a = t1.next;
            if (Lp(i, s, a) >= 0) return !1;
            const o = i.x, l = s.x, u = a.x, c = i.y, h = s.y, p = a.y, f = o < l ? o < u ? o : u : l < u ? l : u, d = c < h ? c < p ? c : p : h < p ? h : p, m = o > l ? o > u ? o : u : l > u ? l : u, y = c > h ? c > p ? c : p : h > p ? h : p, g = Dp(f, d, e, r, n), x = Dp(m, y, e, r, n);
            let b = t1.prevZ, v = t1.nextZ;
            for(; b && b.z >= g && v && v.z <= x;){
                if (b.x >= f && b.x <= m && b.y >= d && b.y <= y && b !== i && b !== a && Rp(o, c, l, h, u, p, b.x, b.y) && Lp(b.prev, b, b.next) >= 0) return !1;
                if (b = b.prevZ, v.x >= f && v.x <= m && v.y >= d && v.y <= y && v !== i && v !== a && Rp(o, c, l, h, u, p, v.x, v.y) && Lp(v.prev, v, v.next) >= 0) return !1;
                v = v.nextZ;
            }
            for(; b && b.z >= g;){
                if (b.x >= f && b.x <= m && b.y >= d && b.y <= y && b !== i && b !== a && Rp(o, c, l, h, u, p, b.x, b.y) && Lp(b.prev, b, b.next) >= 0) return !1;
                b = b.prevZ;
            }
            for(; v && v.z <= x;){
                if (v.x >= f && v.x <= m && v.y >= d && v.y <= y && v !== i && v !== a && Rp(o, c, l, h, u, p, v.x, v.y) && Lp(v.prev, v, v.next) >= 0) return !1;
                v = v.nextZ;
            }
            return !0;
        }
        function kp(t1, e) {
            let r = t1;
            do {
                const n = r.prev, i = r.next.next;
                !Op(n, i) && Fp(n, r, r.next, i) && jp(n, i) && jp(i, n) && (e.push(n.i, r.i, i.i), Gp(r), Gp(r.next), r = t1 = i), r = r.next;
            }while (r !== t1);
            return Ap(r);
        }
        function Pp(t1, e, r, n, i, s) {
            let a = t1;
            do {
                let t1 = a.next.next;
                for(; t1 !== a.prev;){
                    if (a.i !== t1.i && Vp(a, t1)) {
                        let o = qp(a, t1);
                        return a = Ap(a, a.next), o = Ap(o, o.next), Sp(a, e, r, n, i, s, 0), void Sp(o, e, r, n, i, s, 0);
                    }
                    t1 = t1.next;
                }
                a = a.next;
            }while (a !== t1);
        }
        function zp(t1, e) {
            return t1.x - e.x;
        }
        function Ep(t1, e) {
            const r = function(t1, e) {
                let r = e;
                const n = t1.x, i = t1.y;
                let s, a = -1 / 0;
                do {
                    if (i <= r.y && i >= r.next.y && r.next.y !== r.y) {
                        const t1 = r.x + (i - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                        if (t1 <= n && t1 > a && (a = t1, s = r.x < r.next.x ? r : r.next, t1 === n)) return s;
                    }
                    r = r.next;
                }while (r !== e);
                if (!s) return null;
                const o = s, l = s.x, u = s.y;
                let c = 1 / 0;
                r = s;
                do {
                    if (n >= r.x && r.x >= l && n !== r.x && Rp(i < u ? n : a, i, l, u, i < u ? a : n, i, r.x, r.y)) {
                        const e = Math.abs(i - r.y) / (n - r.x);
                        jp(r, t1) && (e < c || e === c && (r.x > s.x || r.x === s.x && Bp(s, r))) && (s = r, c = e);
                    }
                    r = r.next;
                }while (r !== o);
                return s;
            }(t1, e);
            if (!r) return e;
            const n = qp(r, t1);
            return Ap(n, n.next), Ap(r, r.next);
        }
        function Bp(t1, e) {
            return Lp(t1.prev, t1, e.prev) < 0 && Lp(e.next, t1, t1.next) < 0;
        }
        function Dp(t1, e, r, n, i) {
            return (t1 = 1431655765 & ((t1 = 858993459 & ((t1 = 252645135 & ((t1 = 16711935 & ((t1 = (t1 - r) * i | 0) | t1 << 8)) | t1 << 4)) | t1 << 2)) | t1 << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
        }
        function Cp(t1) {
            let e = t1, r = t1;
            do (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;
            while (e !== t1);
            return r;
        }
        function Rp(t1, e, r, n, i, s, a, o) {
            return (i - a) * (e - o) >= (t1 - a) * (s - o) && (t1 - a) * (n - o) >= (r - a) * (e - o) && (r - a) * (s - o) >= (i - a) * (n - o);
        }
        function Vp(t1, e) {
            return t1.next.i !== e.i && t1.prev.i !== e.i && !function(t1, e) {
                let r = t1;
                do {
                    if (r.i !== t1.i && r.next.i !== t1.i && r.i !== e.i && r.next.i !== e.i && Fp(r, r.next, t1, e)) return !0;
                    r = r.next;
                }while (r !== t1);
                return !1;
            }(t1, e) && (jp(t1, e) && jp(e, t1) && function(t1, e) {
                let r = t1, n = !1;
                const i = (t1.x + e.x) / 2, s = (t1.y + e.y) / 2;
                do r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;
                while (r !== t1);
                return n;
            }(t1, e) && (Lp(t1.prev, t1, e.prev) || Lp(t1, e.prev, e)) || Op(t1, e) && Lp(t1.prev, t1, t1.next) > 0 && Lp(e.prev, e, e.next) > 0);
        }
        function Lp(t1, e, r) {
            return (e.y - t1.y) * (r.x - e.x) - (e.x - t1.x) * (r.y - e.y);
        }
        function Op(t1, e) {
            return t1.x === e.x && t1.y === e.y;
        }
        function Fp(t1, e, r, n) {
            const i = Np(Lp(t1, e, r)), s = Np(Lp(t1, e, n)), a = Np(Lp(r, n, t1)), o = Np(Lp(r, n, e));
            return i !== s && a !== o || !(0 !== i || !Up(t1, r, e)) || !(0 !== s || !Up(t1, n, e)) || !(0 !== a || !Up(r, t1, n)) || !(0 !== o || !Up(r, e, n));
        }
        function Up(t1, e, r) {
            return e.x <= Math.max(t1.x, r.x) && e.x >= Math.min(t1.x, r.x) && e.y <= Math.max(t1.y, r.y) && e.y >= Math.min(t1.y, r.y);
        }
        function Np(t1) {
            return t1 > 0 ? 1 : t1 < 0 ? -1 : 0;
        }
        function jp(t1, e) {
            return Lp(t1.prev, t1, t1.next) < 0 ? Lp(t1, e, t1.next) >= 0 && Lp(t1, t1.prev, e) >= 0 : Lp(t1, e, t1.prev) < 0 || Lp(t1, t1.next, e) < 0;
        }
        function qp(t1, e) {
            const r = Yp(t1.i, t1.x, t1.y), n = Yp(e.i, e.x, e.y), i = t1.next, s = e.prev;
            return t1.next = e, e.prev = t1, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n;
        }
        function $p(t1, e, r, n) {
            const i = Yp(t1, e, r);
            return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
        }
        function Gp(t1) {
            t1.next.prev = t1.prev, t1.prev.next = t1.next, t1.prevZ && (t1.prevZ.nextZ = t1.nextZ), t1.nextZ && (t1.nextZ.prevZ = t1.prevZ);
        }
        function Yp(t1, e, r) {
            return {
                i: t1,
                x: e,
                y: r,
                prev: null,
                next: null,
                z: 0,
                prevZ: null,
                nextZ: null,
                steiner: !1
            };
        }
        function Xp(t1, e) {
            const r = t1.length;
            if (r <= 1) return [
                t1
            ];
            const n = [];
            let i, s;
            for(let e = 0; e < r; e++){
                const r = mr(t1[e]);
                0 !== r && (t1[e].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [
                    t1[e]
                ]) : i.push(t1[e]));
            }
            if (i && n.push(i), e > 1) for(let t1 = 0; t1 < n.length; t1++)n[t1].length <= e || (Ri(n[t1], e, 1, n[t1].length - 1, Zp), n[t1] = n[t1].slice(0, e));
            return n;
        }
        function Zp(t1, e) {
            return e.area - t1.area;
        }
        function Hp(t1, e, r) {
            const n = r.patternDependencies;
            let i = !1;
            for (const r of e){
                const e = r.paint.get(`${t1}-pattern`);
                e.isConstant() || (i = !0);
                const s = e.constantOr(null);
                s && (i = !0, n[s] = !0);
            }
            return i;
        }
        function Kp(t1, e, r, n, i) {
            const s = i.patternDependencies;
            for (const a of e){
                const e = a.paint.get(`${t1}-pattern`).value;
                if ("constant" !== e.kind) {
                    let t1 = e.evaluate({
                        zoom: n
                    }, r, {}, i.availableImages);
                    t1 = t1 && t1.name ? t1.name : t1, s[t1] = !0, r.patterns[a.id] = t1;
                }
            }
            return r;
        }
        class Wp {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Cl, this.indexArray = new Ql, this.indexArray2 = new Zl, this.programConfigurations = new Wu(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }), this.segments = new Au, this.segments2 = new Au, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.projection = t1.projection;
            }
            updateFootprints(t1, e) {}
            populate(t1, e, r, n) {
                this.hasPattern = Hp("fill", this.layers, e);
                const i = this.layers[0].layout.get("fill-sort-key"), s = [];
                for (const { feature: a, id: o, index: l, sourceLayerIndex: u } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, c = Xc(a, t1);
                    if (!this.layers[0]._featureFilter.filter(new Ho(this.zoom), c, r)) continue;
                    const h = i ? i.evaluate(c, {}, r, e.availableImages) : void 0, p = {
                        id: o,
                        properties: a.properties,
                        type: a.type,
                        sourceLayerIndex: u,
                        index: l,
                        geometry: t1 ? c.geometry : Yc(a, r, n),
                        patterns: {},
                        sortKey: h
                    };
                    s.push(p);
                }
                i && s.sort((t1, e)=>t1.sortKey - e.sortKey);
                for (const n of s){
                    const { geometry: i, index: s, sourceLayerIndex: a } = n;
                    if (this.hasPattern) {
                        const t1 = Kp("fill", this.layers, n, this.zoom, e);
                        this.patternFeatures.push(t1);
                    } else this.addFeature(n, i, s, r, {}, e.availableImages, e.brightness);
                    e.featureIndex.insert(t1[s].feature, i, s, a, this.index);
                }
            }
            update(t1, e, r, n, i) {
                const s = 0 !== Object.keys(t1).length;
                s && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t1, e, s ? this.stateDependentLayers : this.layers, r, n, i);
            }
            addFeatures(t1, e, r, n, i, s) {
                for (const t1 of this.patternFeatures)this.addFeature(t1, t1.geometry, t1.index, e, r, n, s);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, _p), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.indexBuffer2 = t1.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
            }
            addFeature(t1, e, r, n, i, s = [], a) {
                for (const t1 of Xp(e, 500)){
                    let e = 0;
                    for (const r of t1)e += r.length;
                    const r = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray), n = r.vertexLength, i = [], s = [];
                    for (const e of t1){
                        if (0 === e.length) continue;
                        e !== t1[0] && s.push(i.length / 2);
                        const r = this.segments2.prepareSegment(e.length, this.layoutVertexArray, this.indexArray2), n = r.vertexLength;
                        this.layoutVertexArray.emplaceBack(e[0].x, e[0].y), this.indexArray2.emplaceBack(n + e.length - 1, n), i.push(e[0].x), i.push(e[0].y);
                        for(let t1 = 1; t1 < e.length; t1++)this.layoutVertexArray.emplaceBack(e[t1].x, e[t1].y), this.indexArray2.emplaceBack(n + t1 - 1, n + t1), i.push(e[t1].x), i.push(e[t1].y);
                        r.vertexLength += e.length, r.primitiveLength += e.length;
                    }
                    const a = wp(i, s);
                    for(let t1 = 0; t1 < a.length; t1 += 3)this.indexArray.emplaceBack(n + a[t1], n + a[t1 + 1], n + a[t1 + 2]);
                    r.vertexLength += e, r.primitiveLength += a.length / 3;
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, s, n, a);
            }
        }
        Mo(Wp, "FillBucket", {
            omit: [
                "layers",
                "patternFeatures"
            ]
        });
        const Jp = new ol({
            "fill-sort-key": new sl(ll.layout_fill["fill-sort-key"]),
            visibility: new il(ll.layout_fill.visibility)
        });
        var Qp = {
            paint: new ol({
                "fill-antialias": new il(ll.paint_fill["fill-antialias"]),
                "fill-opacity": new sl(ll.paint_fill["fill-opacity"]),
                "fill-color": new sl(ll.paint_fill["fill-color"]),
                "fill-outline-color": new sl(ll.paint_fill["fill-outline-color"]),
                "fill-translate": new il(ll.paint_fill["fill-translate"]),
                "fill-translate-anchor": new il(ll.paint_fill["fill-translate-anchor"]),
                "fill-pattern": new sl(ll.paint_fill["fill-pattern"]),
                "fill-emissive-strength": new il(ll.paint_fill["fill-emissive-strength"])
            }),
            layout: Jp
        };
        class tf {
            constructor(t1, e, r, n){
                if (this.triangleCount = e.length / 3, this.min = new Ne(0, 0), this.max = new Ne(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === t1.length) return;
                const [i, s] = [
                    t1[0].clone(),
                    t1[0].clone()
                ];
                for(let e = 1; e < t1.length; ++e){
                    const r = t1[e];
                    i.x = Math.min(i.x, r.x), i.y = Math.min(i.y, r.y), s.x = Math.max(s.x, r.x), s.y = Math.max(s.y, r.y);
                }
                if (n) {
                    const t1 = Math.ceil(Math.max(s.x - i.x, s.y - i.y) / n);
                    r = Math.max(r, t1);
                }
                if (0 === r) return;
                this.min = i, this.max = s;
                const a = this.max.sub(this.min);
                a.x = Math.max(a.x, 1), a.y = Math.max(a.y, 1);
                const o = Math.max(a.x, a.y) / r;
                this.cellsX = Math.max(1, Math.ceil(a.x / o)), this.cellsY = Math.max(1, Math.ceil(a.y / o)), this.xScale = 1 / o, this.yScale = 1 / o;
                const l = [];
                for(let r = 0; r < this.triangleCount; r++){
                    const n = t1[e[3 * r + 0]].sub(this.min), i = t1[e[3 * r + 1]].sub(this.min), s = t1[e[3 * r + 2]].sub(this.min), a = ef(Math.floor(Math.min(n.x, i.x, s.x)), this.xScale, this.cellsX), u = ef(Math.floor(Math.max(n.x, i.x, s.x)), this.xScale, this.cellsX), c = ef(Math.floor(Math.min(n.y, i.y, s.y)), this.yScale, this.cellsY), h = ef(Math.floor(Math.max(n.y, i.y, s.y)), this.yScale, this.cellsY), p = new Ne(0, 0), f = new Ne(0, 0), d = new Ne(0, 0), m = new Ne(0, 0);
                    for(let t1 = c; t1 <= h; ++t1){
                        p.y = f.y = t1 * o, d.y = m.y = (t1 + 1) * o;
                        for(let e = a; e <= u; ++e)p.x = d.x = e * o, f.x = m.x = (e + 1) * o, (ch(n, i, s, p, f, m) || ch(n, i, s, p, m, d)) && l.push({
                            cellIdx: t1 * this.cellsX + e,
                            triIdx: r
                        });
                    }
                }
                if (0 === l.length) return;
                l.sort((t1, e)=>t1.cellIdx - e.cellIdx || t1.triIdx - e.triIdx);
                let u = 0;
                for(; u < l.length;){
                    const t1 = l[u].cellIdx, e = {
                        start: this.payload.length,
                        len: 0
                    };
                    for(; u < l.length && l[u].cellIdx === t1;)++e.len, this.payload.push(l[u++].triIdx);
                    this.cells[t1] = e;
                }
            }
            _lazyInitLookup() {
                this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0);
            }
            queryPoint(t1, e) {
                if (0 === this.triangleCount || 0 === this.cells.length) return;
                if (t1.x > this.max.x || this.min.x > t1.x || t1.y > this.max.y || this.min.y > t1.y) return;
                const r = ef(t1.x - this.min.x, this.xScale, this.cellsX), n = ef(t1.y - this.min.y, this.yScale, this.cellsY), i = this.cells[n * this.cellsX + r];
                if (i) {
                    this._lazyInitLookup();
                    for(let t1 = 0; t1 < i.len; t1++){
                        const r = this.payload[i.start + t1], n = Math.floor(r / 8), s = 1 << r % 8;
                        if (!(this.lookup[n] & s) && (this.lookup[n] |= s, e.push(r), e.length === this.triangleCount)) return;
                    }
                }
            }
            query(t1, e, r) {
                if (0 === this.triangleCount || 0 === this.cells.length) return;
                if (t1.x > this.max.x || this.min.x > e.x) return;
                if (t1.y > this.max.y || this.min.y > e.y) return;
                this._lazyInitLookup();
                const n = ef(t1.x - this.min.x, this.xScale, this.cellsX), i = ef(e.x - this.min.x, this.xScale, this.cellsX), s = ef(t1.y - this.min.y, this.yScale, this.cellsY), a = ef(e.y - this.min.y, this.yScale, this.cellsY);
                for(let t1 = s; t1 <= a; t1++)for(let e = n; e <= i; e++){
                    const n = this.cells[t1 * this.cellsX + e];
                    if (n) for(let t1 = 0; t1 < n.len; t1++){
                        const e = this.payload[n.start + t1], i = Math.floor(e / 8), s = 1 << e % 8;
                        if (!(this.lookup[i] & s) && (this.lookup[i] |= s, r.push(e), r.length === this.triangleCount)) return;
                    }
                }
            }
        }
        function ef(t1, e, r) {
            return Math.max(0, Math.min(r - 1, Math.floor(t1 * e)));
        }
        Mo(tf, "TriangleGridIndex");
        class rf {
            constructor(t1){
                this.zoom = t1.zoom, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.footprints = [];
            }
            updateFootprints(t1, e) {
                for (const r of this.footprints)e.push({
                    footprint: r,
                    id: t1
                });
            }
            populate(t1, e, r, n) {
                const i = [];
                for (const { feature: e, id: s, index: a, sourceLayerIndex: o } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, l = Xc(e, t1);
                    if (!this.layers[0]._featureFilter.filter(new Ho(this.zoom), l, r)) continue;
                    const u = {
                        id: s,
                        properties: e.properties,
                        type: e.type,
                        sourceLayerIndex: o,
                        index: a,
                        geometry: t1 ? l.geometry : Yc(e, r, n),
                        patterns: {}
                    };
                    i.push(u);
                }
                for (const n of i){
                    const { geometry: i, index: s, sourceLayerIndex: a } = n;
                    this.addFeature(n, i, s, r, {}, e.availableImages, e.brightness), e.featureIndex.insert(t1[s].feature, i, s, a, this.index);
                }
            }
            isEmpty() {
                return 0 === this.footprints.length;
            }
            uploadPending() {
                return !1;
            }
            upload(t1) {}
            update(t1, e, r, n, i) {}
            destroy() {}
            addFeature(t1, e, r, n, i, s = [], a) {
                for (const t1 of Xp(e, 2)){
                    const e = [], r = [], n = [], i = new Ne(1 / 0, 1 / 0), s = new Ne(-1 / 0, -1 / 0);
                    for (const a of t1)if (0 !== a.length) {
                        a !== t1[0] && n.push(r.length / 2);
                        for(let t1 = 0; t1 < a.length; t1++)r.push(a[t1].x), r.push(a[t1].y), e.push(a[t1]), i.x = Math.min(i.x, a[t1].x), i.y = Math.min(i.y, a[t1].y), s.x = Math.max(s.x, a[t1].x), s.y = Math.max(s.y, a[t1].y);
                    }
                    const a = wp(r, n), o = new tf(e, a, 8, 256);
                    this.footprints.push({
                        vertices: e,
                        indices: a,
                        grid: o,
                        min: i,
                        max: s
                    });
                }
            }
        }
        Mo(rf, "ClipBucket", {
            omit: [
                "layers"
            ]
        });
        const nf = new ol({
            "clip-layer-types": new il(ll.layout_clip["clip-layer-types"])
        });
        var sf = {
            paint: new ol({}),
            layout: nf
        };
        const af = Bl([
            {
                name: "a_pos_normal_ed",
                components: 4,
                type: "Int16"
            }
        ]), of = Bl([
            {
                name: "a_pos_end",
                components: 4,
                type: "Int16"
            },
            {
                name: "a_angular_offset_factor",
                components: 1,
                type: "Int16"
            }
        ]), lf = Bl([
            {
                name: "a_centroid_pos",
                components: 2,
                type: "Uint16"
            }
        ]), uf = Bl([
            {
                name: "a_hidden_by_landmark",
                components: 1,
                type: "Uint8"
            }
        ]), cf = Bl([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }
        ]), { members: hf } = af;
        var pf = {}, ff = Fe, df = mf;
        function mf(t1, e, r, n, i) {
            this.properties = {}, this.extent = r, this.type = 0, this._pbf = t1, this._geometry = -1, this._keys = n, this._values = i, t1.readFields(yf, this, e);
        }
        function yf(t1, e, r) {
            1 == t1 ? e.id = r.readVarint() : 2 == t1 ? function(t1, e) {
                for(var r = t1.readVarint() + t1.pos; t1.pos < r;){
                    var n = e._keys[t1.readVarint()], i = e._values[t1.readVarint()];
                    e.properties[n] = i;
                }
            }(r, e) : 3 == t1 ? e.type = r.readVarint() : 4 == t1 && (e._geometry = r.pos);
        }
        function gf(t1) {
            for(var e, r, n = 0, i = 0, s = t1.length, a = s - 1; i < s; a = i++)n += ((r = t1[a]).x - (e = t1[i]).x) * (e.y + r.y);
            return n;
        }
        mf.types = [
            "Unknown",
            "Point",
            "LineString",
            "Polygon"
        ], mf.prototype.loadGeometry = function() {
            var t1 = this._pbf;
            t1.pos = this._geometry;
            for(var e, r = t1.readVarint() + t1.pos, n = 1, i = 0, s = 0, a = 0, o = []; t1.pos < r;){
                if (i <= 0) {
                    var l = t1.readVarint();
                    n = 7 & l, i = l >> 3;
                }
                if (i--, 1 === n || 2 === n) s += t1.readSVarint(), a += t1.readSVarint(), 1 === n && (e && o.push(e), e = []), e.push(new ff(s, a));
                else {
                    if (7 !== n) throw new Error("unknown command " + n);
                    e && e.push(e[0].clone());
                }
            }
            return e && o.push(e), o;
        }, mf.prototype.bbox = function() {
            var t1 = this._pbf;
            t1.pos = this._geometry;
            for(var e = t1.readVarint() + t1.pos, r = 1, n = 0, i = 0, s = 0, a = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0; t1.pos < e;){
                if (n <= 0) {
                    var c = t1.readVarint();
                    r = 7 & c, n = c >> 3;
                }
                if (n--, 1 === r || 2 === r) (i += t1.readSVarint()) < a && (a = i), i > o && (o = i), (s += t1.readSVarint()) < l && (l = s), s > u && (u = s);
                else if (7 !== r) throw new Error("unknown command " + r);
            }
            return [
                a,
                l,
                o,
                u
            ];
        }, mf.prototype.toGeoJSON = function(t1, e, r) {
            var n, i, s = this.extent * Math.pow(2, r), a = this.extent * t1, o = this.extent * e, l = this.loadGeometry(), u = mf.types[this.type];
            function c(t1) {
                for(var e = 0; e < t1.length; e++){
                    var r = t1[e];
                    t1[e] = [
                        360 * (r.x + a) / s - 180,
                        360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + o) / s) * Math.PI / 180)) - 90
                    ];
                }
            }
            switch(this.type){
                case 1:
                    var h = [];
                    for(n = 0; n < l.length; n++)h[n] = l[n][0];
                    c(l = h);
                    break;
                case 2:
                    for(n = 0; n < l.length; n++)c(l[n]);
                    break;
                case 3:
                    for(l = function(t1) {
                        var e = t1.length;
                        if (e <= 1) return [
                            t1
                        ];
                        for(var r, n, i = [], s = 0; s < e; s++){
                            var a = gf(t1[s]);
                            0 !== a && (void 0 === n && (n = a < 0), n === a < 0 ? (r && i.push(r), r = [
                                t1[s]
                            ]) : r.push(t1[s]));
                        }
                        return r && i.push(r), i;
                    }(l), n = 0; n < l.length; n++)for(i = 0; i < l[n].length; i++)c(l[n][i]);
            }
            1 === l.length ? l = l[0] : u = "Multi" + u;
            var p = {
                type: "Feature",
                geometry: {
                    type: u,
                    coordinates: l
                },
                properties: this.properties
            };
            return "id" in this && (p.id = this.id), p;
        };
        var xf = df, bf = vf;
        function vf(t1, e) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t1, this._keys = [], this._values = [], this._features = [], t1.readFields(_f, this, e), this.length = this._features.length;
        }
        function _f(t1, e, r) {
            15 === t1 ? e.version = r.readVarint() : 1 === t1 ? e.name = r.readString() : 5 === t1 ? e.extent = r.readVarint() : 2 === t1 ? e._features.push(r.pos) : 3 === t1 ? e._keys.push(r.readString()) : 4 === t1 && e._values.push(function(t1) {
                for(var e = null, r = t1.readVarint() + t1.pos; t1.pos < r;){
                    var n = t1.readVarint() >> 3;
                    e = 1 === n ? t1.readString() : 2 === n ? t1.readFloat() : 3 === n ? t1.readDouble() : 4 === n ? t1.readVarint64() : 5 === n ? t1.readVarint() : 6 === n ? t1.readSVarint() : 7 === n ? t1.readBoolean() : null;
                }
                return e;
            }(r));
        }
        vf.prototype.feature = function(t1) {
            if (t1 < 0 || t1 >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t1];
            var e = this._pbf.readVarint() + this._pbf.pos;
            return new xf(this._pbf, e, this.extent, this._keys, this._values);
        };
        var wf = bf;
        function Mf(t1, e, r) {
            if (3 === t1) {
                var n = new wf(r, r.readVarint() + r.pos);
                n.length && (e[n.name] = n);
            }
        }
        var Af = pf.VectorTile = function(t1, e) {
            this.layers = t1.readFields(Mf, {}, e);
        }, Sf = pf.VectorTileFeature = df;
        pf.VectorTileLayer = bf;
        class If extends Ne {
            constructor(t1, e, r){
                super(t1, e), this.z = r;
            }
        }
        class Tf extends If {
            constructor(t1, e, r, n){
                super(t1, e, r), this.w = n;
            }
        }
        function kf(t1, e, r, n) {
            const i = [], s = 0 === n ? (t1, e, r, n, i, s)=>{
                t1.push(new Ne(s, r + (s - e) / (n - e) * (i - r)));
            } : (t1, e, r, n, i, s)=>{
                t1.push(new Ne(e + (s - r) / (i - r) * (n - e), s));
            };
            for (const a of t1){
                const t1 = [];
                for (const i of a){
                    if (i.length <= 2) continue;
                    const a = [];
                    for(let t1 = 0; t1 < i.length - 1; t1++){
                        const o = i[t1].x, l = i[t1].y, u = i[t1 + 1].x, c = i[t1 + 1].y, h = 0 === n ? o : l, p = 0 === n ? u : c;
                        h < e ? p > e && s(a, o, l, u, c, e) : h > r ? p < r && s(a, o, l, u, c, r) : a.push(i[t1]), p < e && h >= e && s(a, o, l, u, c, e), p > r && h <= r && s(a, o, l, u, c, r);
                    }
                    let o = i[i.length - 1];
                    const l = 0 === n ? o.x : o.y;
                    l >= e && l <= r && a.push(o), a.length && (o = a[a.length - 1], a[0].x === o.x && a[0].y === o.y || a.push(a[0]), t1.push(a));
                }
                t1.length && i.push(t1);
            }
            return i;
        }
        function Pf(t1, e, r, n) {
            const i = "x" === r ? "y" : "x", s = (n - t1[r]) / (e[r] - t1[r]);
            t1[i] = t1[i] + (e[i] - t1[i]) * s, t1[r] = n, t1.hasOwnProperty("z") && (t1.z = Gn(t1.z, e.z, s)), t1.hasOwnProperty("w") && (t1.w = Gn(t1.w, e.w, s));
        }
        function zf(t1, e, r, n) {
            const i = r, s = n;
            for (const r of [
                "x",
                "y"
            ]){
                let n = t1, a = e;
                n[r] >= a[r] && (n = e, a = t1), n[r] < i && a[r] > i && Pf(n, a, r, i), n[r] < s && a[r] > s && Pf(a, n, r, s);
            }
        }
        function Ef(t1, e) {
            return t1.x - e.x || t1.y - e.y;
        }
        function Bf(t1, e) {
            return 0 === Ef(t1.min, e.min) && 0 === Ef(t1.max, e.max);
        }
        function Df(t1, e) {
            return !(t1.min.x > e.max.x || t1.max.x < e.min.x || t1.min.y > e.max.y || t1.max.y < e.min.y);
        }
        function Cf(t1, e) {
            if (t1.length !== e.length) return !1;
            for(let r = 0; r < t1.length; r++)if (t1[r].sourceId !== e[r].sourceId || !Bf(t1[r], e[r]) || t1[r].order !== e[r].order || t1[r].clipMask !== e[r].clipMask) return !1;
            return !0;
        }
        function Rf(t1, e, r) {
            const n = 1 / ps, i = 1 / (1 << r.canonical.z), s = (e.x * n + r.canonical.x) * i + r.wrap, a = (e.y * n + r.canonical.y) * i;
            return {
                min: new Ne((t1.x * n + r.canonical.x) * i + r.wrap, (t1.y * n + r.canonical.y) * i),
                max: new Ne(s, a)
            };
        }
        function Vf(t1, e, r) {
            const n = 1 << r.canonical.z, i = ((e.x - r.wrap) * n - r.canonical.x) * ps, s = (e.y * n - r.canonical.y) * ps;
            return {
                min: new Ne(((t1.x - r.wrap) * n - r.canonical.x) * ps, (t1.y * n - r.canonical.y) * ps),
                max: new Ne(i, s)
            };
        }
        function Lf(t1, e, r, n, i, s, a) {
            const o = t1.indices, l = t1.vertices, u = [];
            for(let c = n; c < n + i; c += 3){
                const n = e[r[c + 0] + s], i = e[r[c + 1] + s], h = e[r[c + 2] + s], p = Math.min(n.x, i.x, h.x), f = Math.max(n.x, i.x, h.x), d = Math.min(n.y, i.y, h.y), m = Math.max(n.y, i.y, h.y);
                u.length = 0, t1.grid.query(new Ne(p, d), new Ne(f, m), u);
                for(let t1 = 0; t1 < u.length; t1++){
                    const e = u[t1];
                    if (ch(l[o[3 * e + 0]], l[o[3 * e + 1]], l[o[3 * e + 2]], n, i, h, a)) return !0;
                }
            }
            return !1;
        }
        function Of(t1, e, r, n) {
            if (!t1 || !r) return !1;
            let i = t1.vertices;
            if (!e.canonical.equals(n.canonical) || e.wrap !== n.wrap) {
                if (r.vertices.length < t1.vertices.length) return Of(r, n, t1, e);
                const s = e.canonical, a = n.canonical, o = Math.pow(2, a.z - s.z);
                i = t1.vertices.map((t1)=>new Ne((t1.x + s.x * ps) * o - a.x * ps, (t1.y + s.y * ps) * o - a.y * ps));
            }
            return Lf(r, i, t1.indices, 0, t1.indices.length, 0, 0);
        }
        function Ff(t1, e, r, n) {
            const i = Math.pow(2, n.z - r.z);
            return new Ne((t1 + r.x * ps) * i - n.x * ps, (e + r.y * ps) * i - n.y * ps);
        }
        function Uf(t1, e) {
            const r = [];
            e.footprint.grid.queryPoint(t1, r);
            const n = e.footprint.indices, i = e.footprint.vertices;
            for(let e = 0; e < r.length; e++){
                const s = r[e];
                if (ah([
                    i[n[3 * s + 0]],
                    i[n[3 * s + 1]],
                    i[n[3 * s + 2]]
                ], t1)) return !0;
            }
            return !1;
        }
        class Nf {
            constructor(t1){
                this.size = t1, this.minimums = [], this.maximums = [], this.leaves = [];
            }
            getElevation(t1, e) {
                const r = this.toIdx(t1, e);
                return {
                    min: this.minimums[r],
                    max: this.maximums[r]
                };
            }
            isLeaf(t1, e) {
                return this.leaves[this.toIdx(t1, e)];
            }
            toIdx(t1, e) {
                return e * this.size + t1;
            }
        }
        function jf(t1, e, r, n) {
            let i = 0, s = Number.MAX_VALUE;
            for(let a = 0; a < 3; a++)if (Math.abs(n[a]) < 1e-15) {
                if (r[a] < t1[a] || r[a] > e[a]) return null;
            } else {
                const o = 1 / n[a];
                let l = (t1[a] - r[a]) * o, u = (e[a] - r[a]) * o;
                if (l > u) {
                    const t1 = l;
                    l = u, u = t1;
                }
                if (l > i && (i = l), u < s && (s = u), i > s) return null;
            }
            return i;
        }
        function qf(t1, e, r, n, i, s, a, o, l, u, c) {
            const h = n - t1, p = i - e, f = s - r, d = a - t1, m = o - e, y = l - r, g = c[1] * y - c[2] * m, x = c[2] * d - c[0] * y, b = c[0] * m - c[1] * d, v = h * g + p * x + f * b;
            if (Math.abs(v) < 1e-15) return null;
            const _ = 1 / v, w = u[0] - t1, M = u[1] - e, A = u[2] - r, S = (w * g + M * x + A * b) * _;
            if (S < 0 || S > 1) return null;
            const I = M * f - A * p, T = A * h - w * f, k = w * p - M * h, P = (c[0] * I + c[1] * T + c[2] * k) * _;
            return P < 0 || S + P > 1 ? null : (d * I + m * T + y * k) * _;
        }
        function $f(t1, e, r) {
            return (t1 - e) / (r - e);
        }
        function Gf(t1, e, r, n, i, s, a, o, l) {
            const u = 1 << r, c = s - n, h = a - i, p = (t1 + 1) / u * c + n, f = (e + 0) / u * h + i, d = (e + 1) / u * h + i;
            o[0] = (t1 + 0) / u * c + n, o[1] = f, l[0] = p, l[1] = d;
        }
        class Yf {
            constructor(t1){
                if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t1, this._siblingOffset = [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        1
                    ]
                ], !this.dem) return;
                const e = function(t1) {
                    const e = Math.ceil(Math.log2(t1.dim / 8)), r = [];
                    let n = Math.ceil(Math.pow(2, e));
                    const i = 1 / n, s = (t1, e, r, n, i)=>{
                        const s = n ? 1 : 0, a = (t1 + 1) * r - s, o = e * r, l = (e + 1) * r - s;
                        i[0] = t1 * r, i[1] = o, i[2] = a, i[3] = l;
                    };
                    let a = new Nf(n);
                    const o = [];
                    for(let e = 0; e < n * n; e++){
                        s(e % n, Math.floor(e / n), i, !1, o);
                        const r = Zf(o[0], o[1], t1), l = Zf(o[2], o[1], t1), u = Zf(o[2], o[3], t1), c = Zf(o[0], o[3], t1);
                        a.minimums.push(Math.min(r, l, u, c)), a.maximums.push(Math.max(r, l, u, c)), a.leaves.push(1);
                    }
                    for(r.push(a), n /= 2; n >= 1; n /= 2){
                        const t1 = r[r.length - 1];
                        a = new Nf(n);
                        for(let e = 0; e < n * n; e++){
                            s(e % n, Math.floor(e / n), 2, !0, o);
                            const r = t1.getElevation(o[0], o[1]), i = t1.getElevation(o[2], o[1]), l = t1.getElevation(o[2], o[3]), u = t1.getElevation(o[0], o[3]), c = t1.isLeaf(o[0], o[1]), h = t1.isLeaf(o[2], o[1]), p = t1.isLeaf(o[2], o[3]), f = t1.isLeaf(o[0], o[3]), d = Math.min(r.min, i.min, l.min, u.min), m = Math.max(r.max, i.max, l.max, u.max), y = c && h && p && f;
                            a.maximums.push(m), a.minimums.push(d), a.leaves.push(m - d <= 5 && y ? 1 : 0);
                        }
                        r.push(a);
                    }
                    return r;
                }(this.dem), r = e.length - 1, n = e[r];
                this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(e, 0, 0, r, 0);
            }
            raycastRoot(t1, e, r, n, i, s, a = 1) {
                return jf([
                    t1,
                    e,
                    -100
                ], [
                    r,
                    n,
                    this.maximums[0] * a
                ], i, s);
            }
            raycast(e, r, n, i, s, a, o = 1) {
                if (!this.nodeCount) return null;
                const l = this.raycastRoot(e, r, n, i, s, a, o);
                if (null == l) return null;
                const u = [], c = [], h = [], p = [], f = [
                    {
                        idx: 0,
                        t: l,
                        nodex: 0,
                        nodey: 0,
                        depth: 0
                    }
                ];
                for(; f.length > 0;){
                    const { idx: l, t: d, nodex: m, nodey: y, depth: g } = f.pop();
                    if (this.leaves[l]) {
                        Gf(m, y, g, e, r, n, i, h, p);
                        const l = 1 << g, u = (m + 0) / l, c = (m + 1) / l, f = (y + 0) / l, x = (y + 1) / l, b = Zf(u, f, this.dem) * o, v = Zf(c, f, this.dem) * o, _ = Zf(c, x, this.dem) * o, w = Zf(u, x, this.dem) * o, M = qf(h[0], h[1], b, p[0], h[1], v, p[0], p[1], _, s, a), A = qf(p[0], p[1], _, h[0], p[1], w, h[0], h[1], b, s, a), S = Math.min(null !== M ? M : Number.MAX_VALUE, null !== A ? A : Number.MAX_VALUE);
                        if (S !== Number.MAX_VALUE) return S;
                        {
                            const e = t1._.scaleAndAdd([], s, a, d);
                            if (Xf(b, v, w, _, $f(e[0], h[0], p[0]), $f(e[1], h[1], p[1])) >= e[2]) return d;
                        }
                        continue;
                    }
                    let x = 0;
                    for(let t1 = 0; t1 < this._siblingOffset.length; t1++){
                        Gf((m << 1) + this._siblingOffset[t1][0], (y << 1) + this._siblingOffset[t1][1], g + 1, e, r, n, i, h, p), h[2] = -100, p[2] = this.maximums[this.childOffsets[l] + t1] * o;
                        const f = jf(h, p, s, a);
                        if (null != f) {
                            const e = f;
                            u[t1] = e;
                            let r = !1;
                            for(let n = 0; n < x && !r; n++)e >= u[c[n]] && (c.splice(n, 0, t1), r = !0);
                            r || (c[x] = t1), x++;
                        }
                    }
                    for(let t1 = 0; t1 < x; t1++){
                        const e = c[t1];
                        f.push({
                            idx: this.childOffsets[l] + e,
                            t: u[e],
                            nodex: (m << 1) + this._siblingOffset[e][0],
                            nodey: (y << 1) + this._siblingOffset[e][1],
                            depth: g + 1
                        });
                    }
                }
                return null;
            }
            _addNode(t1, e, r) {
                return this.minimums.push(t1), this.maximums.push(e), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;
            }
            _construct(t1, e, r, n, i) {
                if (1 === t1[n].isLeaf(e, r)) return;
                this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);
                const s = n - 1, a = t1[s];
                let o = 0, l = 0;
                for(let t1 = 0; t1 < this._siblingOffset.length; t1++){
                    const n = 2 * e + this._siblingOffset[t1][0], i = 2 * r + this._siblingOffset[t1][1], s = a.getElevation(n, i), u = a.isLeaf(n, i), c = this._addNode(s.min, s.max, u);
                    u && (o |= 1 << t1), l || (l = c);
                }
                for(let n = 0; n < this._siblingOffset.length; n++)o & 1 << n || this._construct(t1, 2 * e + this._siblingOffset[n][0], 2 * r + this._siblingOffset[n][1], s, l + n);
            }
        }
        function Xf(t1, e, r, n, i, s) {
            return Gn(Gn(t1, r, s), Gn(e, n, s), i);
        }
        function Zf(t1, e, r) {
            const n = r.dim, i = Ke(t1 * n - .5, 0, n - 1), s = Ke(e * n - .5, 0, n - 1), a = Math.floor(i), o = Math.floor(s), l = Math.min(a + 1, n - 1), u = Math.min(o + 1, n - 1);
            return Xf(r.get(a, o), r.get(l, o), r.get(a, u), r.get(l, u), i - a, s - o);
        }
        const Hf = {
            mapbox: [
                6553.6,
                25.6,
                .1,
                1e4
            ],
            terrarium: [
                256,
                1,
                1 / 256,
                32768
            ]
        };
        function Kf(t1, e, r) {
            return (256 * t1 * 256 + 256 * e + r) / 10 - 1e4;
        }
        function Wf(t1, e, r) {
            return 256 * t1 + e + r / 256 - 32768;
        }
        class Jf {
            get tree() {
                return this._tree || this._buildQuadTree(), this._tree;
            }
            constructor(t1, e, r, n = !1){
                if (this.uid = t1, e.height !== e.width) throw new RangeError("DEM tiles must be square");
                if (r && "mapbox" !== r && "terrarium" !== r) return fr(`"${r}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
                this.stride = e.height;
                const i = this.dim = e.height - 2, s = new Uint32Array(e.data.buffer);
                if (this.pixels = new Uint8Array(e.data.buffer), this.floatView = new Float32Array(e.data.buffer), this.borderReady = n, this._modifiedForSources = {}, !n) {
                    for(let t1 = 0; t1 < i; t1++)s[this._idx(-1, t1)] = s[this._idx(0, t1)], s[this._idx(i, t1)] = s[this._idx(i - 1, t1)], s[this._idx(t1, -1)] = s[this._idx(t1, 0)], s[this._idx(t1, i)] = s[this._idx(t1, i - 1)];
                    s[this._idx(-1, -1)] = s[this._idx(0, 0)], s[this._idx(i, -1)] = s[this._idx(i - 1, 0)], s[this._idx(-1, i)] = s[this._idx(0, i - 1)], s[this._idx(i, i)] = s[this._idx(i - 1, i - 1)];
                }
                const a = "terrarium" === r ? Wf : Kf;
                for(let t1 = 0; t1 < s.length; ++t1){
                    const e = 4 * t1;
                    this.floatView[t1] = a(this.pixels[e], this.pixels[e + 1], this.pixels[e + 2]);
                }
                this._timestamp = Dr.now();
            }
            _buildQuadTree() {
                this._tree = new Yf(this);
            }
            get(t1, e, r = !1) {
                r && (t1 = Ke(t1, -1, this.dim), e = Ke(e, -1, this.dim));
                const n = this._idx(t1, e);
                return this.floatView[n];
            }
            set(t1, e, r) {
                const n = this._idx(t1, e), i = this.floatView[n];
                return this.floatView[n] = r, r - i;
            }
            static getUnpackVector(t1) {
                return Hf[t1];
            }
            _idx(t1, e) {
                if (t1 < -1 || t1 >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
                return (e + 1) * this.stride + (t1 + 1);
            }
            static pack(t1, e) {
                const r = [
                    0,
                    0,
                    0,
                    0
                ], n = Jf.getUnpackVector(e);
                let i = Math.floor((t1 + n[3]) / n[2]);
                return r[2] = i % 256, i = Math.floor(i / 256), r[1] = i % 256, i = Math.floor(i / 256), r[0] = i, r;
            }
            getPixels() {
                return new dp({
                    width: this.stride,
                    height: this.stride
                }, this.pixels);
            }
            backfillBorder(t1, e, r) {
                if (this.dim !== t1.dim) throw new Error("dem dimension mismatch");
                let n = e * this.dim, i = e * this.dim + this.dim, s = r * this.dim, a = r * this.dim + this.dim;
                switch(e){
                    case -1:
                        n = i - 1;
                        break;
                    case 1:
                        i = n + 1;
                }
                switch(r){
                    case -1:
                        s = a - 1;
                        break;
                    case 1:
                        a = s + 1;
                }
                const o = -e * this.dim, l = -r * this.dim;
                for(let e = s; e < a; e++)for(let r = n; r < i; r++){
                    const n = 4 * this._idx(r, e), i = 4 * this._idx(r + o, e + l);
                    this.pixels[n + 0] = t1.pixels[i + 0], this.pixels[n + 1] = t1.pixels[i + 1], this.pixels[n + 2] = t1.pixels[i + 2], this.pixels[n + 3] = t1.pixels[i + 3];
                }
            }
            onDeserialize() {
                this._tree && (this._tree.dem = this);
            }
        }
        Mo(Jf, "DEMData"), Mo(Yf, "DemMinMaxQuadTree", {
            omit: [
                "dem"
            ]
        });
        class Qf {
            constructor(t1, e, r){
                this._demTile = t1, this._dem = this._demTile.dem, this._scale = e, this._offset = r;
            }
            static create(t1, e, r) {
                const n = r || t1.findDEMTileFor(e);
                if (!n || !n.dem) return;
                const i = n.dem, s = n.tileID, a = 1 << e.canonical.z - s.canonical.z;
                return new Qf(n, i.dim / ps / a, [
                    (e.canonical.x / a - s.canonical.x) * i.dim,
                    (e.canonical.y / a - s.canonical.y) * i.dim
                ]);
            }
            tileCoordToPixel(t1, e) {
                const r = e * this._scale + this._offset[1], n = Math.floor(t1 * this._scale + this._offset[0]), i = Math.floor(r);
                return new Ne(n, i);
            }
            getElevationAt(t1, e, r, n) {
                const i = t1 * this._scale + this._offset[0], s = e * this._scale + this._offset[1], a = Math.floor(i), o = Math.floor(s), l = this._dem;
                return n = !!n, r ? Gn(Gn(l.get(a, o, n), l.get(a, o + 1, n), s - o), Gn(l.get(a + 1, o, n), l.get(a + 1, o + 1, n), s - o), i - a) : l.get(a, o, n);
            }
            getElevationAtPixel(t1, e, r) {
                return this._dem.get(t1, e, !!r);
            }
            getMeterToDEM(t1) {
                return (1 << this._demTile.tileID.canonical.z) * Pc(1, t1) * this._dem.stride;
            }
        }
        const td = {
            None: 0,
            Model: 1,
            Symbol: 2,
            FillExtrusion: 4,
            All: 7
        }, ed = Sf.types, rd = [
            "fill-extrusion-base",
            "fill-extrusion-height",
            "fill-extrusion-color",
            "fill-extrusion-pattern",
            "fill-extrusion-flood-light-wall-radius"
        ], nd = [
            "fill-extrusion-flood-light-ground-radius"
        ], id = Math.pow(2, 13), sd = Math.pow(2, 15) - 1, ad = new Ne(0, 1), od = 2147483648;
        function ld(t1, e, r, n, i, s, a, o) {
            t1.emplaceBack((e << 1) + a, (r << 1) + s, (Math.floor(n * id) << 1) + i, Math.round(o));
        }
        function ud(t1, e, r, n, i, s) {
            t1.emplaceBack(e.x, e.y, (r.x << 1) + n, (r.y << 1) + i, s);
        }
        function cd(t1, e, r) {
            const n = 16384;
            t1.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);
        }
        class hd {
            constructor(){
                this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
            }
        }
        class pd {
            constructor(){
                this.centroidXY = new Ne(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new Ne(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new Ne(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0;
            }
            span() {
                return new Ne(this.max.x - this.min.x, this.max.y - this.min.y);
            }
        }
        class fd {
            constructor(){
                this.acc = new Ne(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
            }
            startRing(t1, e) {
                t1.min.x === Number.MAX_VALUE && (t1.min.x = t1.max.x = e.x, t1.min.y = t1.max.y = e.y);
            }
            appendEdge(t1, e, r) {
                this.accCount++, this.acc._add(e);
                let n = !!this.borders;
                e.x < t1.min.x ? (t1.min.x = e.x, n = !0) : e.x > t1.max.x && (t1.max.x = e.x, n = !0), e.y < t1.min.y ? (t1.min.y = e.y, n = !0) : e.y > t1.max.y && (t1.max.y = e.y, n = !0), ((0 === e.x || e.x === ps) && e.x === r.x) != ((0 === e.y || e.y === ps) && e.y === r.y) && this.processBorderOverlap(e, r), n && this.checkBorderIntersection(e, r);
            }
            checkBorderIntersection(t1, e) {
                e.x < 0 != t1.x < 0 && this.addBorderIntersection(0, Gn(e.y, t1.y, (0 - e.x) / (t1.x - e.x))), e.x > ps != t1.x > ps && this.addBorderIntersection(1, Gn(e.y, t1.y, (ps - e.x) / (t1.x - e.x))), e.y < 0 != t1.y < 0 && this.addBorderIntersection(2, Gn(e.x, t1.x, (0 - e.y) / (t1.y - e.y))), e.y > ps != t1.y > ps && this.addBorderIntersection(3, Gn(e.x, t1.x, (ps - e.y) / (t1.y - e.y)));
            }
            addBorderIntersection(t1, e) {
                this.borders || (this.borders = [
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ]
                ]);
                const r = this.borders[t1];
                e < r[0] && (r[0] = e), e > r[1] && (r[1] = e);
            }
            processBorderOverlap(t1, e) {
                if (t1.x === e.x) {
                    if (t1.y === e.y) return;
                    const r = 0 === t1.x ? 0 : 1;
                    this.addBorderIntersection(r, e.y), this.addBorderIntersection(r, t1.y);
                } else {
                    const r = 0 === t1.y ? 2 : 3;
                    this.addBorderIntersection(r, e.x), this.addBorderIntersection(r, t1.x);
                }
            }
            centroid() {
                return 0 === this.accCount ? new Ne(0, 0) : new Ne(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
            }
            intersectsCount() {
                return this.borders ? this.borders.reduce((t1, e)=>t1 + +(e[0] !== Number.MAX_VALUE), 0) : 0;
            }
        }
        function dd(t1, e) {
            const r = t1.add(e)._unit(), n = Ke(t1.x * r.x + t1.y * r.y, -1, 1);
            var i, s, a;
            return i = Math.acos(n), Math.min(4, Math.max(-4, Math.tan(i))) / 4 * sd * ((s = t1).x * (a = e).y - s.y * a.x < 0 ? -1 : 1);
        }
        const md = [
            (t1)=>t1.x < 0,
            (t1)=>t1.x > ps,
            (t1)=>t1.y < 0,
            (t1)=>t1.y > ps
        ];
        function yd(t1, e, r, n) {
            const i = [
                4
            ];
            if (0 === n) return i;
            r._mult(n);
            const s = t1.sub(r), a = e.sub(r), o = [
                t1,
                e,
                s,
                a
            ];
            for(let t1 = 0; t1 < 4; t1++)for (const e of o)if (md[t1](e)) {
                i.push(t1);
                break;
            }
            return i;
        }
        class gd {
            constructor(t1){
                this.vertexArray = new Ll, this.indexArray = new Ql, this.programConfigurations = new Wu(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }, (t1)=>nd.includes(t1)), this._segments = new Au, this.hiddenByLandmarkVertexArray = new cu, this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [
                    0,
                    0,
                    0,
                    0,
                    0
                ], this.regionSegments = {}, this.regionSegments[4] = new Au;
            }
            getDefaultSegment() {
                return this.regionSegments[4];
            }
            hasData() {
                return 0 !== this.vertexArray.length;
            }
            addData(t1, e, r, n = !1) {
                const i = t1.length;
                if (i > 2) {
                    let s = Math.max(0, this._segments.get().length - 1);
                    const a = this._segments._prepareSegment(4 * i, this.vertexArray.length, 2 * this._segmentToGroundQuads[s].length);
                    let o;
                    s !== this._segments.get().length - 1 && (s++, this._segmentToGroundQuads[s] = [], this._segmentToRegionTriCounts[s] = [
                        0,
                        0,
                        0,
                        0,
                        0
                    ]);
                    {
                        const e = t1[0], r = t1[1];
                        o = dd(e.sub(t1[i - 1])._perp()._unit(), r.sub(e)._perp()._unit());
                    }
                    for(let l = 0; l < i; l++){
                        const u = l === i - 1 ? 0 : l + 1, c = t1[l], h = t1[u], p = t1[u === i - 1 ? 0 : u + 1], f = h.sub(c)._perp()._unit(), d = dd(f, p.sub(h)._perp()._unit()), m = o, y = d;
                        if (wd(c, h, e) || n && Md(c, e) && Md(h, e)) {
                            o = d;
                            continue;
                        }
                        const g = a.vertexLength;
                        ud(this.vertexArray, c, h, 1, 1, m), ud(this.vertexArray, c, h, 1, 0, m), ud(this.vertexArray, c, h, 0, 1, y), ud(this.vertexArray, c, h, 0, 0, y), a.vertexLength += 4;
                        const x = yd(c, h, f, r);
                        for (const t1 of x)this._segmentToGroundQuads[s].push({
                            id: g,
                            region: t1
                        }), this._segmentToRegionTriCounts[s][t1] += 2, a.primitiveLength += 2;
                        o = d;
                    }
                }
            }
            prepareBorderSegments() {
                if (!this.hasData()) return;
                const t1 = this._segments.get(), e = t1.length;
                for(let t1 = 0; t1 < e; t1++)this._segmentToGroundQuads[t1].sort((t1, e)=>t1.region - e.region);
                for(let r = 0; r < e; r++){
                    const e = this._segmentToGroundQuads[r], n = t1[r], i = this._segmentToRegionTriCounts[r];
                    i.reduce((t1, e)=>t1 + e, 0);
                    let s = 0;
                    for(let t1 = 0; t1 <= 4; t1++){
                        const e = i[t1];
                        if (0 !== e) {
                            let r = this.regionSegments[t1];
                            r || (r = this.regionSegments[t1] = new Au);
                            const i = {
                                vertexOffset: n.vertexOffset,
                                primitiveOffset: n.primitiveOffset + s,
                                vertexLength: n.vertexLength,
                                primitiveLength: e
                            };
                            r.get().push(i);
                        }
                        s += e;
                    }
                    for(let t1 = 0; t1 < e.length; t1++){
                        const r = e[t1].id;
                        this.indexArray.emplaceBack(r, r + 1, r + 3), this.indexArray.emplaceBack(r, r + 3, r + 2);
                    }
                }
                this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
            }
            addPaintPropertiesData(t1, e, r, n, i, s) {
                this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t1, e, r, n, i, s);
            }
            upload(t1) {
                this.hasData() && (this.vertexBuffer = t1.createVertexBuffer(this.vertexArray, of.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray));
            }
            uploadPaintProperties(t1) {
                this.hasData() && this.programConfigurations.upload(t1);
            }
            update(t1, e, r, n, i, s) {
                this.hasData() && this.programConfigurations.updatePaintArrays(t1, e, r, n, i, s);
            }
            updateHiddenByLandmark(t1) {
                if (!this.hasData()) return;
                const e = t1.groundVertexCount + t1.groundVertexArrayOffset;
                if (0 === t1.groundVertexCount) return;
                const r = t1.flags & od ? 1 : 0;
                for(let n = t1.groundVertexArrayOffset; n < e; ++n)this.hiddenByLandmarkVertexArray.emplace(n, r);
                this._needsHiddenByLandmarkUpdate = !0;
            }
            uploadHiddenByLandmark(t1) {
                this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = t1.createVertexBuffer(this.hiddenByLandmarkVertexArray, uf.members, !0) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = !1);
            }
            destroy() {
                if (this.vertexBuffer) {
                    this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
                    for(let t1 = 0; t1 <= 4; t1++){
                        const e = this.regionSegments[t1];
                        e && e.destroy();
                    }
                }
            }
        }
        class xd {
            constructor(t1){
                this.zoom = t1.zoom, this.canonical = t1.canonical, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = t1.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new Ql, this.footprintVertices = new Cl, this.footprintSegments = [], this.layoutVertexArray = new Vl, this.centroidVertexArray = new _u, this.indexArray = new Ql, this.programConfigurations = new Wu(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }, (t1)=>rd.includes(t1)), this.segments = new Au, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.groundEffect = new gd(t1), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [];
            }
            updateFootprints(t1, e) {}
            populate(t1, e, r, n) {
                this.features = [], this.hasPattern = Hp("fill-extrusion", this.layers, e), this.featuresOnBorder = [], this.borderFeatureIndices = [
                    [],
                    [],
                    [],
                    []
                ], this.borderDoneWithNeighborZ = [
                    -1,
                    -1,
                    -1,
                    -1
                ], this.tileToMeter = Lc(r), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
                for (const { feature: i, id: s, index: a, sourceLayerIndex: o } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, l = Xc(i, t1);
                    if (!this.layers[0]._featureFilter.filter(new Ho(this.zoom), l, r)) continue;
                    const u = {
                        id: s,
                        sourceLayerIndex: o,
                        index: a,
                        geometry: t1 ? l.geometry : Yc(i, r, n),
                        properties: i.properties,
                        type: i.type,
                        patterns: {}
                    }, c = this.layoutVertexArray.length;
                    this.hasPattern ? this.features.push(Kp("fill-extrusion", this.layers, u, this.zoom, e)) : this.addFeature(u, u.geometry, a, r, {}, e.availableImages, n, e.brightness), e.featureIndex.insert(i, u.geometry, a, o, this.index, c);
                }
                this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
            }
            addFeatures(t1, e, r, n, i, s) {
                for (const t1 of this.features){
                    const { geometry: a } = t1;
                    this.addFeature(t1, a, t1.index, e, r, n, i, s);
                }
                this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles();
            }
            update(t1, e, r, n, i) {
                const s = 0 !== Object.keys(t1).length;
                if (s && !this.stateDependentLayers.length) return;
                const a = s ? this.stateDependentLayers : this.layers;
                this.programConfigurations.updatePaintArrays(t1, e, a, r, n, i), this.groundEffect.update(t1, e, a, r, n, i);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, hf), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t1.createVertexBuffer(this.layoutVertexExtArray, cf.members, !0)), this.groundEffect.upload(t1)), this.groundEffect.uploadPaintProperties(t1), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            uploadCentroid(t1) {
                this.groundEffect.uploadHiddenByLandmark(t1), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = t1.createVertexBuffer(this.centroidVertexArray, lf.members, !0) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = !1);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t1, e, r, n, i, s, a, o) {
                const l = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(t1, {}) / this.tileToMeter, u = [
                    new Ne(0, 0),
                    new Ne(ps, ps)
                ], c = a.projection, h = "globe" === c.name, p = "Polygon" === ed[t1.type], f = new fd;
                f.centroidDataIndex = this.centroidData.length;
                const d = new pd, m = this.layers[0].paint.get("fill-extrusion-base").evaluate(t1, {}, n) <= 0, y = this.layers[0].paint.get("fill-extrusion-height").evaluate(t1, {}, n);
                d.height = y, d.vertexArrayOffset = this.layoutVertexArray.length, d.groundVertexArrayOffset = this.groundEffect.vertexArray.length, h && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new ql);
                const g = Xp(e, 500);
                for(let t1 = g.length - 1; t1 >= 0; t1--){
                    const e = g[t1];
                    (0 === e.length || (x = e[0]).every((t1)=>t1.x <= 0) || x.every((t1)=>t1.x >= ps) || x.every((t1)=>t1.y <= 0) || x.every((t1)=>t1.y >= ps)) && g.splice(t1, 1);
                }
                var x;
                let b;
                if (h) b = Td(g, u, n);
                else {
                    b = [];
                    for (const t1 of g)b.push({
                        polygon: t1,
                        bounds: u
                    });
                }
                const v = p ? this.edgeRadius : 0, _ = v > 0 && this.zoom < 17, w = (t1, e)=>{
                    if (0 === t1.length) return !1;
                    const r = t1[t1.length - 1];
                    return e.x === r.x && e.y === r.y;
                };
                for (const { polygon: t1, bounds: e } of b){
                    let r = 0, i = 0;
                    for (const e of t1)p && !e[0].equals(e[e.length - 1]) && e.push(e[0]), i += p ? e.length - 1 : e.length;
                    const s = this.segments.prepareSegment((p ? 5 : 4) * i, this.layoutVertexArray, this.indexArray);
                    d.footprintSegIdx < 0 && (d.footprintSegIdx = this.footprintSegments.length), d.polygonSegIdx < 0 && (d.polygonSegIdx = this.polygonSegments.length);
                    const a = {
                        triangleArrayOffset: this.indexArray.length,
                        triangleCount: 0,
                        triangleSegIdx: this.segments.segments.length - 1
                    }, o = new hd;
                    if (o.vertexOffset = this.footprintVertices.length, o.indexOffset = 3 * this.footprintIndices.length, o.ringIndices = [], p) {
                        const i = [], a = [];
                        r = s.vertexLength;
                        for(let r = 0; r < t1.length; r++){
                            const u = t1[r];
                            u.length && 0 !== r && a.push(i.length / 2);
                            const p = [];
                            let f, d;
                            f = u[1].sub(u[0])._perp()._unit(), o.ringIndices.push(u.length - 1);
                            for(let t1 = 1; t1 < u.length; t1++){
                                const e = u[t1], r = u[t1 === u.length - 1 ? 1 : t1 + 1], a = e.clone();
                                if (v) {
                                    d = r.sub(e)._perp()._unit();
                                    const t1 = f.add(d)._unit(), n = v * Math.min(4, 1 / (f.x * t1.x + f.y * t1.y));
                                    a.x += n * t1.x, a.y += n * t1.y, a.x = Math.round(a.x), a.y = Math.round(a.y), f = d;
                                }
                                !m || 0 !== v && !_ || w(p, a) || p.push(a), ld(this.layoutVertexArray, a.x, a.y, 0, 0, 1, 1, 0), s.vertexLength++, this.footprintVertices.emplaceBack(e.x, e.y), i.push(e.x, e.y), h && cd(this.layoutVertexExtArray, c.projectTilePoint(a.x, a.y, n), c.upVector(n, a.x, a.y));
                            }
                            m && (0 === v || _) && (0 !== p.length && w(p, p[0]) && p.pop(), this.groundEffect.addData(p, e, l));
                        }
                        const u = wp(i, a);
                        for(let t1 = 0; t1 < u.length; t1 += 3)this.footprintIndices.emplaceBack(o.vertexOffset + u[t1 + 0], o.vertexOffset + u[t1 + 1], o.vertexOffset + u[t1 + 2]), this.indexArray.emplaceBack(r + u[t1], r + u[t1 + 2], r + u[t1 + 1]), s.primitiveLength++;
                        o.indexCount += u.length, o.vertexCount += this.footprintVertices.length - o.vertexOffset;
                    }
                    for(let i = 0; i < t1.length; i++){
                        const a = t1[i];
                        f.startRing(d, a[0]);
                        let o = a.length > 4 && Ad(a[a.length - 2], a[0], a[1]), u = v ? vd(a[a.length - 2], a[0], a[1], v) : 0;
                        const y = [];
                        let g, x, b;
                        x = a[1].sub(a[0])._perp()._unit();
                        let _ = !0;
                        for(let t1 = 1, i = 0; t1 < a.length; t1++){
                            let l = a[t1 - 1], p = a[t1];
                            const M = a[t1 === a.length - 1 ? 1 : t1 + 1];
                            if (f.appendEdge(d, p, l), wd(p, l, e)) {
                                v && (x = M.sub(p)._perp()._unit(), _ = !_);
                                continue;
                            }
                            const A = p.sub(l)._perp(), S = A.x / (Math.abs(A.x) + Math.abs(A.y)), I = A.y > 0 ? 1 : 0, T = l.dist(p);
                            if (i + T > 32768 && (i = 0), v) {
                                b = M.sub(p)._perp()._unit();
                                let t1 = _d(l, p, M, bd(x, b), v);
                                isNaN(t1) && (t1 = 0);
                                const e = p.sub(l)._unit();
                                l = l.add(e.mult(u))._round(), p = p.add(e.mult(-t1))._round(), u = t1, x = b, m && this.zoom >= 17 && (w(y, l) || y.push(l), w(y, p) || y.push(p));
                            }
                            const k = s.vertexLength, P = a.length > 4 && Ad(l, p, M);
                            let z = Sd(i, o, _);
                            if (ld(this.layoutVertexArray, l.x, l.y, S, I, 0, 0, z), ld(this.layoutVertexArray, l.x, l.y, S, I, 0, 1, z), i += T, z = Sd(i, P, !_), o = P, ld(this.layoutVertexArray, p.x, p.y, S, I, 0, 0, z), ld(this.layoutVertexArray, p.x, p.y, S, I, 0, 1, z), s.vertexLength += 4, this.indexArray.emplaceBack(k + 0, k + 1, k + 2), this.indexArray.emplaceBack(k + 1, k + 3, k + 2), s.primitiveLength += 2, v) {
                                const n = r + (1 === t1 ? a.length - 2 : t1 - 2), i = 1 === t1 ? r : n + 1;
                                if (this.indexArray.emplaceBack(k + 1, n, k + 3), this.indexArray.emplaceBack(n, i, k + 3), s.primitiveLength += 2, void 0 === g && (g = k), !wd(M, a[t1], e)) {
                                    const e = t1 === a.length - 1 ? g : s.vertexLength;
                                    this.indexArray.emplaceBack(k + 2, k + 3, e), this.indexArray.emplaceBack(k + 3, e + 1, e), this.indexArray.emplaceBack(k + 3, i, e + 1), s.primitiveLength += 3;
                                }
                                _ = !_;
                            }
                            if (h) {
                                const t1 = this.layoutVertexExtArray, e = c.projectTilePoint(l.x, l.y, n), r = c.projectTilePoint(p.x, p.y, n), i = c.upVector(n, l.x, l.y), s = c.upVector(n, p.x, p.y);
                                cd(t1, e, i), cd(t1, e, i), cd(t1, r, s), cd(t1, r, s);
                            }
                        }
                        p && (r += a.length - 1), m && v && this.zoom >= 17 && (0 !== y.length && w(y, y[0]) && y.pop(), this.groundEffect.addData(y, e, l, v > 0));
                    }
                    this.footprintSegments.push(o), a.triangleCount = this.indexArray.length - a.triangleArrayOffset, this.polygonSegments.push(a), ++d.footprintSegLen, ++d.polygonSegLen;
                }
                if (d.vertexCount = this.layoutVertexArray.length - d.vertexArrayOffset, d.groundVertexCount = this.groundEffect.vertexArray.length - d.groundVertexArrayOffset, 0 !== d.vertexCount) {
                    if (d.centroidXY = f.borders ? ad : this.encodeCentroid(f, d), this.centroidData.push(d), f.borders) {
                        this.featuresOnBorder.push(f);
                        const t1 = this.featuresOnBorder.length - 1;
                        for(let e = 0; e < f.borders.length; e++)f.borders[e][0] !== Number.MAX_VALUE && this.borderFeatureIndices[e].push(t1);
                    }
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, s, n, o), this.groundEffect.addPaintPropertiesData(t1, r, i, s, n, o), this.maxHeight = Math.max(this.maxHeight, y);
                }
            }
            sortBorders() {
                for(let t1 = 0; t1 < this.borderFeatureIndices.length; t1++)this.borderFeatureIndices[t1].sort((e, r)=>this.featuresOnBorder[e].borders[t1][0] - this.featuresOnBorder[r].borders[t1][0]);
            }
            splitToSubtiles() {
                const t1 = [];
                for(let e = 0; e < this.centroidData.length; e++){
                    const r = this.centroidData[e], n = +(r.min.y + r.max.y > ps), i = 2 * n + (+(r.min.x + r.max.x > ps) ^ n);
                    for(let n = 0; n < r.polygonSegLen; n++){
                        const s = r.polygonSegIdx + n;
                        t1.push({
                            centroidIdx: e,
                            subtile: i,
                            polygonSegmentIdx: s,
                            triangleSegmentIdx: this.polygonSegments[s].triangleSegIdx
                        });
                    }
                }
                const e = new Ql;
                t1.sort((t1, e)=>t1.triangleSegmentIdx === e.triangleSegmentIdx ? t1.subtile - e.subtile : t1.triangleSegmentIdx - e.triangleSegmentIdx);
                let r = 0, n = 0, i = 0;
                for (const e of t1){
                    if (e.triangleSegmentIdx !== r) break;
                    i++;
                }
                const s = t1.length;
                for(; n !== t1.length;){
                    r = t1[n].triangleSegmentIdx;
                    let a = 0, o = n, l = n;
                    for(let e = o; e < i && t1[e].subtile === a; e++)l++;
                    for(; o !== i;){
                        const n = t1[o];
                        a = n.subtile;
                        const s = this.centroidData[n.centroidIdx].min.clone(), u = this.centroidData[n.centroidIdx].max.clone(), c = {
                            vertexOffset: this.segments.segments[r].vertexOffset,
                            primitiveOffset: e.length,
                            vertexLength: this.segments.segments[r].vertexLength,
                            primitiveLength: 0,
                            sortKey: void 0,
                            vaos: {}
                        };
                        for(let r = o; r < l; r++){
                            const n = t1[r], i = this.polygonSegments[n.polygonSegmentIdx], a = this.centroidData[n.centroidIdx].min, o = this.centroidData[n.centroidIdx].max, l = this.indexArray.uint16;
                            for(let t1 = i.triangleArrayOffset; t1 < i.triangleArrayOffset + i.triangleCount; t1++)e.emplaceBack(l[3 * t1], l[3 * t1 + 1], l[3 * t1 + 2]);
                            c.primitiveLength += i.triangleCount, s.x = Math.min(s.x, a.x), s.y = Math.min(s.y, a.y), u.x = Math.max(u.x, o.x), u.y = Math.max(u.y, o.y);
                        }
                        c.primitiveLength > 0 && this.triangleSubSegments.push({
                            segment: c,
                            min: s,
                            max: u
                        }), o = l;
                        for(let e = o; e < i && t1[e].subtile === t1[o].subtile; e++)l++;
                    }
                    n = i;
                    for(let e = n; e < s && t1[e].triangleSegmentIdx === t1[n].triangleSegmentIdx; e++)i++;
                }
                e._trim(), this.indexArray = e;
            }
            getVisibleSegments(t1, e, r) {
                let n = 0, i = 0;
                const s = 1 << t1.canonical.z;
                if (e) {
                    const r = e.getMinMaxForTile(t1);
                    r && (n = r.min, i = r.max);
                }
                i += this.maxHeight;
                const a = t1.toUnwrapped();
                let o;
                const l = [
                    a.canonical.x / s + a.wrap,
                    a.canonical.y / s
                ], u = [
                    (a.canonical.x + 1) / s + a.wrap,
                    (a.canonical.y + 1) / s
                ], c = new Au, h = (t1, e, r)=>[
                        t1[0] * (1 - r[0]) + e[0] * r[0],
                        t1[1] * (1 - r[1]) + e[1] * r[1]
                    ], p = [], f = [];
                for (const t1 of this.triangleSubSegments){
                    p[0] = t1.min.x / ps, p[1] = t1.min.y / ps, f[0] = t1.max.x / ps, f[1] = t1.max.y / ps;
                    const e = h(l, u, p), s = h(l, u, f);
                    if (0 === new Ah([
                        e[0],
                        e[1],
                        n
                    ], [
                        s[0],
                        s[1],
                        i
                    ]).intersectsPrecise(r)) {
                        o && (c.segments.push(o), o = void 0);
                        continue;
                    }
                    const a = t1.segment;
                    o && o.vertexOffset !== a.vertexOffset && (c.segments.push(o), o = void 0), o ? (o.vertexLength += a.vertexLength, o.primitiveLength += a.primitiveLength) : o = {
                        vertexOffset: a.vertexOffset,
                        primitiveLength: a.primitiveLength,
                        vertexLength: a.vertexLength,
                        primitiveOffset: a.primitiveOffset,
                        sortKey: void 0,
                        vaos: {}
                    };
                }
                return o && c.segments.push(o), c;
            }
            encodeCentroid(t1, e) {
                const r = t1.centroid(), n = e.span(), i = Math.min(7, Math.round(n.x * this.tileToMeter / 10)), s = Math.min(7, Math.round(n.y * this.tileToMeter / 10));
                return new Ne(Ke(r.x, 1, ps - 1) << 3 | i, Ke(r.y, 1, ps - 1) << 3 | s);
            }
            encodeBorderCentroid(t1) {
                if (!t1.borders) return new Ne(0, 0);
                const e = t1.borders, r = Number.MAX_VALUE;
                if (e[0][0] !== r || e[1][0] !== r) {
                    const t1 = e[0][0] !== r ? 0 : 1;
                    return new Ne(6 | (e[0][0] !== r ? 0 : 65528), (e[t1][0] + e[t1][1]) / 2 << 3 | 6);
                }
                {
                    const t1 = e[2][0] !== r ? 2 : 3;
                    return new Ne((e[t1][0] + e[t1][1]) / 2 << 3 | 6, 6 | (e[2][0] !== r ? 0 : 65528));
                }
            }
            showCentroid(t1) {
                const e = this.centroidData[t1.centroidDataIndex];
                e.flags &= od, e.centroidXY.x = 0, e.centroidXY.y = 0, this.writeCentroidToBuffer(e);
            }
            writeCentroidToBuffer(t1) {
                this.groundEffect.updateHiddenByLandmark(t1);
                const e = t1.vertexArrayOffset, r = t1.vertexCount + t1.vertexArrayOffset, n = t1.flags & od ? ad : t1.centroidXY, i = this.centroidVertexArray.geta_centroid_pos0(e);
                if (this.centroidVertexArray.geta_centroid_pos1(e) !== n.y || i !== n.x) {
                    for(let t1 = e; t1 < r; ++t1)this.centroidVertexArray.emplace(t1, n.x, n.y);
                    this.needsCentroidUpdate = !0;
                }
            }
            createCentroidsBuffer() {
                this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
                for (const t1 of this.centroidData)this.writeCentroidToBuffer(t1);
            }
            updateReplacement(t1, e, r) {
                if (e.updateTime === this.replacementUpdateTime) return;
                this.replacementUpdateTime = e.updateTime;
                const n = e.getReplacementRegionsForTile(t1.toUnwrapped());
                if (Cf(this.activeReplacements, n)) return;
                if (this.activeReplacements = n, 0 === this.centroidVertexArray.length) this.createCentroidsBuffer();
                else for (const t1 of this.centroidData)t1.flags &= 2147483647;
                const i = [];
                for (const e of this.activeReplacements){
                    if (e.order < r) continue;
                    const n = Math.pow(2, e.footprintTileId.canonical.z - t1.canonical.z);
                    for (const r of this.centroidData)if (!(r.flags & od || e.min.x > r.max.x || r.min.x > e.max.x || e.min.y > r.max.y || r.min.y > e.max.y)) for(let s = 0; s < r.footprintSegLen; s++){
                        const a = this.footprintSegments[r.footprintSegIdx + s];
                        if (i.length = 0, kd(this.footprintVertices, a.vertexOffset, a.vertexCount, e.footprintTileId.canonical, t1.canonical, i), Lf(e.footprint, i, this.footprintIndices.uint16, a.indexOffset, a.indexCount, -a.vertexOffset, -n)) {
                            r.flags |= od;
                            break;
                        }
                    }
                }
                for (const t1 of this.centroidData)this.writeCentroidToBuffer(t1);
                this.borderDoneWithNeighborZ = [
                    -1,
                    -1,
                    -1,
                    -1
                ];
            }
            footprintContainsPoint(t1, e, r) {
                let n = !1;
                for(let i = 0; i < r.footprintSegLen; i++){
                    const s = this.footprintSegments[r.footprintSegIdx + i];
                    let a = 0;
                    for (const r of s.ringIndices){
                        for(let i = a, o = r + a - 1; i < r + a; o = i++){
                            const r = this.footprintVertices.int16[2 * (i + s.vertexOffset) + 0], a = this.footprintVertices.int16[2 * (i + s.vertexOffset) + 1], l = this.footprintVertices.int16[2 * (o + s.vertexOffset) + 1];
                            a > e != l > e && t1 < (this.footprintVertices.int16[2 * (o + s.vertexOffset) + 0] - r) * (e - a) / (l - a) + r && (n = !n);
                        }
                        a = r;
                    }
                }
                return n;
            }
            getHeightAtTileCoord(t1, e) {
                let r = Number.NEGATIVE_INFINITY, n = !0;
                const i = 4 * (t1 + ps) * ps + (e + ps);
                if (this.partLookup.hasOwnProperty(i)) {
                    const t1 = this.partLookup[i];
                    return t1 ? {
                        height: t1.height,
                        hidden: !!(t1.flags & od)
                    } : void 0;
                }
                for (const s of this.centroidData)t1 > s.max.x || s.min.x > t1 || e > s.max.y || s.min.y > e || this.footprintContainsPoint(t1, e, s) && s && s.height > r && (r = s.height, this.partLookup[i] = s, n = !!(s.flags & od));
                if (r !== Number.NEGATIVE_INFINITY) return {
                    height: r,
                    hidden: n
                };
                this.partLookup[i] = void 0;
            }
        }
        function bd(t1, e) {
            const r = t1.add(e)._unit();
            return t1.x * r.x + t1.y * r.y;
        }
        function vd(t1, e, r, n) {
            const i = e.sub(t1)._perp()._unit(), s = r.sub(e)._perp()._unit();
            return _d(t1, e, r, bd(i, s), n);
        }
        function _d(t1, e, r, n, i) {
            const s = Math.sqrt(1 - n * n);
            return Math.min(t1.dist(e) / 3, e.dist(r) / 3, i * s / n);
        }
        function wd(t1, e, r) {
            return t1.x < r[0].x && e.x < r[0].x || t1.x > r[1].x && e.x > r[1].x || t1.y < r[0].y && e.y < r[0].y || t1.y > r[1].y && e.y > r[1].y;
        }
        function Md(t1, e) {
            return t1.x < e[0].x || t1.x > e[1].x || t1.y < e[0].y || t1.y > e[1].y;
        }
        function Ad(t1, e, r) {
            if (t1.x < 0 || t1.x >= ps || e.x < 0 || e.x >= ps || r.x < 0 || r.x >= ps) return !1;
            const n = r.sub(e), i = n.perp(), s = t1.sub(e);
            return (n.x * s.x + n.y * s.y) / Math.sqrt((n.x * n.x + n.y * n.y) * (s.x * s.x + s.y * s.y)) > -0.866 && i.x * s.x + i.y * s.y < 0;
        }
        function Sd(t1, e, r) {
            const n = e ? 2 | t1 : -3 & t1;
            return r ? 1 | n : -2 & n;
        }
        function Id() {
            const t1 = Math.PI / 32, e = Math.tan(t1), r = fc;
            return r * Math.sqrt(1 + 2 * e * e) - r;
        }
        function Td(t1, e, r) {
            const n = 1 << r.z, i = zc(r.x / n), s = zc((r.x + 1) / n), a = Ec(r.y / n), o = Ec((r.y + 1) / n);
            return function(t1, e, r, n, i = 0, s) {
                const a = [];
                if (!t1.length || !r || !n) return a;
                const o = (t1, e)=>{
                    for (const r of t1)a.push({
                        polygon: r,
                        bounds: e
                    });
                }, l = Math.ceil(Math.log2(r)), u = Math.ceil(Math.log2(n)), c = l - u, h = [];
                for(let t1 = 0; t1 < Math.abs(c); t1++)h.push(c > 0 ? 0 : 1);
                for(let t1 = 0; t1 < Math.min(l, u); t1++)h.push(0), h.push(1);
                let p = t1;
                if (p = kf(p, e[0].y - i, e[1].y + i, 1), p = kf(p, e[0].x - i, e[1].x + i, 0), !p.length) return a;
                const f = [];
                for(h.length ? f.push({
                    polygons: p,
                    bounds: e,
                    depth: 0
                }) : o(p, e); f.length;){
                    const t1 = f.pop(), e = t1.depth, r = h[e], n = t1.bounds[0], a = t1.bounds[1], l = 0 === r ? n.x : n.y, u = 0 === r ? a.x : a.y, c = s ? s(r, l, u) : .5 * (l + u), p = kf(t1.polygons, l - i, c + i, r), d = kf(t1.polygons, c - i, u + i, r);
                    if (p.length) {
                        const t1 = [
                            n,
                            new Ne(0 === r ? c : a.x, 1 === r ? c : a.y)
                        ];
                        h.length > e + 1 ? f.push({
                            polygons: p,
                            bounds: t1,
                            depth: e + 1
                        }) : o(p, t1);
                    }
                    if (d.length) {
                        const t1 = [
                            new Ne(0 === r ? c : n.x, 1 === r ? c : n.y),
                            a
                        ];
                        h.length > e + 1 ? f.push({
                            polygons: d,
                            bounds: t1,
                            depth: e + 1
                        }) : o(d, t1);
                    }
                }
                return a;
            }(t1, e, Math.ceil((s - i) / 11.25), Math.ceil((a - o) / 11.25), 1, (t1, e, i)=>{
                if (0 === t1) return .5 * (e + i);
                {
                    const t1 = Ec((r.y + e / ps) / n);
                    return (kc(.5 * (Ec((r.y + i / ps) / n) + t1)) * n - r.y) * ps;
                }
            });
        }
        function kd(t1, e, r, n, i, s) {
            const a = Math.pow(2, n.z - i.z);
            for(let o = 0; o < r; o++){
                let r = t1.int16[2 * (o + e) + 0], l = t1.int16[2 * (o + e) + 1];
                r = (r + i.x * ps) * a - n.x * ps, l = (l + i.y * ps) * a - n.y * ps, s.push(new Ne(r, l));
            }
        }
        Mo(xd, "FillExtrusionBucket", {
            omit: [
                "layers",
                "features"
            ]
        }), Mo(pd, "PartData"), Mo(hd, "FootprintSegment"), Mo(fd, "BorderCentroidData"), Mo(gd, "GroundEffect");
        const Pd = new ol({
            visibility: new il(ll["layout_fill-extrusion"].visibility),
            "fill-extrusion-edge-radius": new il(ll["layout_fill-extrusion"]["fill-extrusion-edge-radius"])
        });
        var zd = {
            paint: new ol({
                "fill-extrusion-opacity": new il(ll["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                "fill-extrusion-color": new sl(ll["paint_fill-extrusion"]["fill-extrusion-color"]),
                "fill-extrusion-translate": new il(ll["paint_fill-extrusion"]["fill-extrusion-translate"]),
                "fill-extrusion-translate-anchor": new il(ll["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                "fill-extrusion-pattern": new sl(ll["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                "fill-extrusion-height": new sl(ll["paint_fill-extrusion"]["fill-extrusion-height"]),
                "fill-extrusion-base": new sl(ll["paint_fill-extrusion"]["fill-extrusion-base"]),
                "fill-extrusion-vertical-gradient": new il(ll["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),
                "fill-extrusion-ambient-occlusion-intensity": new il(ll["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),
                "fill-extrusion-ambient-occlusion-radius": new il(ll["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]),
                "fill-extrusion-ambient-occlusion-wall-radius": new il(ll["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]),
                "fill-extrusion-ambient-occlusion-ground-radius": new il(ll["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]),
                "fill-extrusion-ambient-occlusion-ground-attenuation": new il(ll["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]),
                "fill-extrusion-flood-light-color": new il(ll["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]),
                "fill-extrusion-flood-light-intensity": new il(ll["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]),
                "fill-extrusion-flood-light-wall-radius": new sl(ll["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]),
                "fill-extrusion-flood-light-ground-radius": new sl(ll["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]),
                "fill-extrusion-flood-light-ground-attenuation": new il(ll["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]),
                "fill-extrusion-vertical-scale": new il(ll["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]),
                "fill-extrusion-rounded-roof": new il(ll["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]),
                "fill-extrusion-cutoff-fade-range": new il(ll["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]),
                "fill-extrusion-emissive-strength": new il(ll["paint_fill-extrusion"]["fill-extrusion-emissive-strength"])
            }),
            layout: Pd
        };
        function Ed(t1, e) {
            return t1.x * e.x + t1.y * e.y;
        }
        function Bd(t1, e) {
            if (1 === t1.length) {
                let r = 0;
                const n = e[r++];
                let i;
                for(; !i || n.equals(i);)if (i = e[r++], !i) return 1 / 0;
                for(; r < e.length; r++){
                    const s = e[r], a = t1[0], o = i.sub(n), l = s.sub(n), u = a.sub(n), c = Ed(o, o), h = Ed(o, l), p = Ed(l, l), f = Ed(u, o), d = Ed(u, l), m = c * p - h * h, y = (p * f - h * d) / m, g = (c * d - h * f) / m, x = n.z * (1 - y - g) + i.z * y + s.z * g;
                    if (isFinite(x)) return x;
                }
                return 1 / 0;
            }
            {
                let t1 = 1 / 0;
                for (const r of e)t1 = Math.min(t1, r.z);
                return t1;
            }
        }
        function Dd(t1, e, r, n, i, s, a, o) {
            const l = a * i.getElevationAt(t1, e, !0, !0), u = 0 !== s[0], c = u ? 0 === s[1] ? a * (s[0] / 7 - 450) : a * function(t1, e, r) {
                const n = Math.floor(e[0] / 8), i = Math.floor(e[1] / 8), s = 10 * (e[0] - 8 * n), a = 10 * (e[1] - 8 * i), o = t1.getElevationAt(n, i, !0, !0), l = t1.getMeterToDEM(r), u = Math.floor(.5 * (s * l - 1)), c = Math.floor(.5 * (a * l - 1)), h = t1.tileCoordToPixel(n, i), p = 2 * u + 1, f = 2 * c + 1, d = function(t1, e, r, n, i) {
                    return [
                        t1.getElevationAtPixel(e, r, !0),
                        t1.getElevationAtPixel(e + i, r, !0),
                        t1.getElevationAtPixel(e, r + i, !0),
                        t1.getElevationAtPixel(e + n, r + i, !0)
                    ];
                }(t1, h.x - u, h.y - c, p, f), m = Math.abs(d[0] - d[1]), y = Math.abs(d[2] - d[3]), g = Math.abs(d[0] - d[2]) + Math.abs(d[1] - d[3]), x = Math.min(.25, .5 * l * (m + y) / p), b = Math.min(.25, .5 * l * g / f);
                return o + Math.max(x * s, b * a);
            }(i, s, o) : l;
            return {
                base: l + (0 === r) ? -1 : r,
                top: u ? Math.max(c + n, l + r + 2) : l + n
            };
        }
        const Cd = Bl([
            {
                name: "a_pos_normal",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_data",
                components: 4,
                type: "Uint8"
            },
            {
                name: "a_linesofar",
                components: 1,
                type: "Float32"
            }
        ], 4), { members: Rd } = Cd, Vd = Bl([
            {
                name: "a_packed",
                components: 4,
                type: "Float32"
            }
        ]), { members: Ld } = Vd, Od = Bl([
            {
                name: "a_pattern_data",
                components: 3,
                type: "Float32"
            }
        ]), { members: Fd } = Od, Ud = Bl([
            {
                name: "a_pos_offset",
                components: 4,
                type: "Int16"
            },
            {
                name: "a_tex_size",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pixeloffset",
                components: 4,
                type: "Int16"
            }
        ], 4), Nd = Bl([
            {
                name: "a_globe_anchor",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_globe_normal",
                components: 3,
                type: "Float32"
            }
        ], 4), jd = Bl([
            {
                name: "a_projected_pos",
                components: 4,
                type: "Float32"
            }
        ], 4);
        Bl([
            {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint32"
            }
        ], 4);
        const qd = Bl([
            {
                name: "a_occlusion_query_opacity",
                components: 1,
                type: "Float32"
            }
        ], 4), $d = Bl([
            {
                name: "a_z_offset",
                components: 1,
                type: "Float32"
            }
        ], 4), Gd = Bl([
            {
                name: "a_texb",
                components: 2,
                type: "Uint16"
            }
        ]), Yd = Bl([
            {
                name: "a_placed",
                components: 2,
                type: "Uint8"
            },
            {
                name: "a_shift",
                components: 2,
                type: "Float32"
            }
        ]), Xd = Bl([
            {
                name: "a_size_scale",
                components: 1,
                type: "Float32"
            },
            {
                name: "a_padding",
                components: 2,
                type: "Float32"
            },
            {
                name: "a_z_offset",
                components: 1,
                type: "Float32"
            }
        ]);
        Bl([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Int16",
                name: "tileAnchorX"
            },
            {
                type: "Int16",
                name: "tileAnchorY"
            },
            {
                type: "Float32",
                name: "x1"
            },
            {
                type: "Float32",
                name: "y1"
            },
            {
                type: "Float32",
                name: "x2"
            },
            {
                type: "Float32",
                name: "y2"
            },
            {
                type: "Int16",
                name: "padding"
            },
            {
                type: "Uint32",
                name: "featureIndex"
            },
            {
                type: "Uint16",
                name: "sourceLayerIndex"
            },
            {
                type: "Uint16",
                name: "bucketIndex"
            }
        ]);
        const Zd = Bl([
            {
                name: "a_pos",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_anchor_pos",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_extrude",
                components: 2,
                type: "Int16"
            }
        ], 4), Hd = Bl([
            {
                name: "a_pos_2f",
                components: 2,
                type: "Float32"
            },
            {
                name: "a_radius",
                components: 1,
                type: "Float32"
            },
            {
                name: "a_flags",
                components: 2,
                type: "Int16"
            }
        ], 4);
        Bl([
            {
                name: "triangle",
                components: 3,
                type: "Uint16"
            }
        ]), Bl([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Float32",
                name: "tileAnchorX"
            },
            {
                type: "Float32",
                name: "tileAnchorY"
            },
            {
                type: "Uint16",
                name: "glyphStartIndex"
            },
            {
                type: "Uint16",
                name: "numGlyphs"
            },
            {
                type: "Uint32",
                name: "vertexStartIndex"
            },
            {
                type: "Uint32",
                name: "lineStartIndex"
            },
            {
                type: "Uint32",
                name: "lineLength"
            },
            {
                type: "Uint16",
                name: "segment"
            },
            {
                type: "Uint16",
                name: "lowerSize"
            },
            {
                type: "Uint16",
                name: "upperSize"
            },
            {
                type: "Float32",
                name: "lineOffsetX"
            },
            {
                type: "Float32",
                name: "lineOffsetY"
            },
            {
                type: "Uint8",
                name: "writingMode"
            },
            {
                type: "Uint8",
                name: "placedOrientation"
            },
            {
                type: "Uint8",
                name: "hidden"
            },
            {
                type: "Uint32",
                name: "crossTileID"
            },
            {
                type: "Int16",
                name: "associatedIconIndex"
            },
            {
                type: "Uint8",
                name: "flipState"
            }
        ]), Bl([
            {
                type: "Float32",
                name: "tileAnchorX"
            },
            {
                type: "Float32",
                name: "tileAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Int16",
                name: "rightJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "centerJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "leftJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "verticalPlacedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "placedIconSymbolIndex"
            },
            {
                type: "Int16",
                name: "verticalPlacedIconSymbolIndex"
            },
            {
                type: "Uint16",
                name: "key"
            },
            {
                type: "Uint16",
                name: "textBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "textBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "verticalTextBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "verticalTextBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "iconBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "iconBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "verticalIconBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "verticalIconBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "featureIndex"
            },
            {
                type: "Uint16",
                name: "numHorizontalGlyphVertices"
            },
            {
                type: "Uint16",
                name: "numVerticalGlyphVertices"
            },
            {
                type: "Uint16",
                name: "numIconVertices"
            },
            {
                type: "Uint16",
                name: "numVerticalIconVertices"
            },
            {
                type: "Uint16",
                name: "useRuntimeCollisionCircles"
            },
            {
                type: "Uint32",
                name: "crossTileID"
            },
            {
                type: "Float32",
                components: 2,
                name: "textOffset"
            },
            {
                type: "Float32",
                name: "collisionCircleDiameter"
            },
            {
                type: "Float32",
                name: "zOffset"
            },
            {
                type: "Float32",
                name: "occlusionState"
            },
            {
                type: "Float32",
                name: "occlusionOpacity"
            },
            {
                type: "Uint8",
                name: "hasIconTextFit"
            }
        ]), Bl([
            {
                type: "Float32",
                name: "offsetX"
            }
        ]), Bl([
            {
                type: "Int16",
                name: "x"
            },
            {
                type: "Int16",
                name: "y"
            }
        ]);
        class Kd {
            constructor(t1, e){
                this.width = t1, this.height = e, this.nextRow = 0, this.image = new pp({
                    width: t1,
                    height: e
                }), this.positions = {}, this.uploaded = !1;
            }
            getDash(t1, e) {
                const r = this.getKey(t1, e);
                return this.positions[r];
            }
            trim() {
                const t1 = this.width, e = this.height = sr(this.nextRow);
                this.image.resize({
                    width: t1,
                    height: e
                });
            }
            getKey(t1, e) {
                return t1.join(",") + e;
            }
            getDashRanges(t1, e, r) {
                const n = [];
                let i = t1.length % 2 == 1 ? -t1[t1.length - 1] * r : 0, s = t1[0] * r, a = !0;
                n.push({
                    left: i,
                    right: s,
                    isDash: a,
                    zeroLength: 0 === t1[0]
                });
                let o = t1[0];
                for(let e = 1; e < t1.length; e++){
                    a = !a;
                    const l = t1[e];
                    i = o * r, o += l, s = o * r, n.push({
                        left: i,
                        right: s,
                        isDash: a,
                        zeroLength: 0 === l
                    });
                }
                return n;
            }
            addRoundDash(t1, e, r) {
                const n = e / 2;
                for(let e = -r; e <= r; e++){
                    const i = this.width * (this.nextRow + r + e);
                    let s = 0, a = t1[s];
                    for(let o = 0; o < this.width; o++){
                        o / a.right > 1 && (a = t1[++s]);
                        const l = Math.abs(o - a.left), u = Math.abs(o - a.right), c = Math.min(l, u);
                        let h;
                        const p = e / r * (n + 1);
                        if (a.isDash) {
                            const t1 = n - Math.abs(p);
                            h = Math.sqrt(c * c + t1 * t1);
                        } else h = n - Math.sqrt(c * c + p * p);
                        this.image.data[i + o] = Math.max(0, Math.min(255, h + 128));
                    }
                }
            }
            addRegularDash(t1, e) {
                for(let e = t1.length - 1; e >= 0; --e){
                    const r = t1[e], n = t1[e + 1];
                    r.zeroLength ? t1.splice(e, 1) : n && n.isDash === r.isDash && (n.left = r.left, t1.splice(e, 1));
                }
                const r = t1[0], n = t1[t1.length - 1];
                r.isDash === n.isDash && (r.left = n.left - this.width, n.right = r.right + this.width);
                const i = this.width * this.nextRow;
                let s = 0, a = t1[s];
                for(let r = 0; r < this.width; r++){
                    r / a.right > 1 && (a = t1[++s]);
                    const n = Math.abs(r - a.left), o = Math.abs(r - a.right), l = Math.min(n, o);
                    this.image.data[i + r] = Math.max(0, Math.min(255, (a.isDash ? l : -l) + e + 128));
                }
            }
            addDash(t1, e) {
                const r = this.getKey(t1, e);
                if (this.positions[r]) return this.positions[r];
                const n = "round" === e, i = n ? 7 : 0, s = 2 * i + 1;
                if (this.nextRow + s > this.height) return fr("LineAtlas out of space"), null;
                0 === t1.length && t1.push(1);
                let a = 0;
                for(let e = 0; e < t1.length; e++)t1[e] < 0 && (fr("Negative value is found in line dasharray, replacing values with 0"), t1[e] = 0), a += t1[e];
                if (0 !== a) {
                    const r = this.width / a, s = this.getDashRanges(t1, this.width, r);
                    n ? this.addRoundDash(s, r, i) : this.addRegularDash(s, "square" === e ? .5 * r : 0);
                }
                const o = this.nextRow + i;
                this.nextRow += s;
                const l = {
                    tl: [
                        o,
                        i
                    ],
                    br: [
                        a,
                        0
                    ]
                };
                return this.positions[r] = l, l;
            }
        }
        Mo(Kd, "LineAtlas");
        const Wd = Sf.types, Jd = Math.cos(Math.PI / 180 * 37.5), Qd = Math.cos(Math.PI / 180 * 5);
        class tm {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.projection = t1.projection, this.hasPattern = !1, this.hasZOffset = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t1)=>{
                    this.gradients[t1.id] = {};
                }), this.layoutVertexArray = new Ol, this.layoutVertexArray2 = new Fl, this.patternVertexArray = new Ul, this.indexArray = new Ql, this.programConfigurations = new Wu(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }), this.segments = new Au, this.maxLineLength = 0, this.zOffsetVertexArray = new Xl, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.tessellationStep = t1.tessellationStep ? t1.tessellationStep : ps / 64;
            }
            updateFootprints(t1, e) {}
            populate(t1, e, r, n) {
                this.hasPattern = Hp("line", this.layers, e);
                const i = this.layers[0].layout.get("line-sort-key"), s = this.layers[0].layout.get("line-z-offset");
                this.hasZOffset = !s.isConstant() || !!s.constantOr(0);
                const a = [];
                for (const { feature: e, id: s, index: o, sourceLayerIndex: l } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, u = Xc(e, t1);
                    if (!this.layers[0]._featureFilter.filter(new Ho(this.zoom), u, r)) continue;
                    const c = i ? i.evaluate(u, {}, r) : void 0, h = {
                        id: s,
                        properties: e.properties,
                        type: e.type,
                        sourceLayerIndex: l,
                        index: o,
                        geometry: t1 ? u.geometry : Yc(e, r, n),
                        patterns: {},
                        sortKey: c
                    };
                    a.push(h);
                }
                i && a.sort((t1, e)=>t1.sortKey - e.sortKey);
                const { lineAtlas: o, featureIndex: l } = e, u = this.addConstantDashes(o);
                for (const n of a){
                    const { geometry: i, index: s, sourceLayerIndex: a } = n;
                    if (u && this.addFeatureDashes(n, o), this.hasPattern) {
                        const t1 = Kp("line", this.layers, n, this.zoom, e);
                        this.patternFeatures.push(t1);
                    } else this.addFeature(n, i, s, r, o.positions, e.availableImages, e.brightness);
                    l.insert(t1[s].feature, i, s, a, this.index);
                }
            }
            addConstantDashes(t1) {
                let e = !1;
                for (const r of this.layers){
                    const n = r.paint.get("line-dasharray").value, i = r.layout.get("line-cap").value;
                    if ("constant" !== n.kind || "constant" !== i.kind) e = !0;
                    else {
                        const e = i.value, r = n.value;
                        if (!r) continue;
                        t1.addDash(r, e);
                    }
                }
                return e;
            }
            addFeatureDashes(t1, e) {
                const r = this.zoom;
                for (const n of this.layers){
                    const i = n.paint.get("line-dasharray").value, s = n.layout.get("line-cap").value;
                    if ("constant" === i.kind && "constant" === s.kind) continue;
                    let a, o;
                    if ("constant" === i.kind) {
                        if (a = i.value, !a) continue;
                    } else a = i.evaluate({
                        zoom: r
                    }, t1);
                    o = "constant" === s.kind ? s.value : s.evaluate({
                        zoom: r
                    }, t1), e.addDash(a, o), t1.patterns[n.id] = e.getKey(a, o);
                }
            }
            update(t1, e, r, n, i) {
                const s = 0 !== Object.keys(t1).length;
                s && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t1, e, s ? this.stateDependentLayers : this.layers, r, n, i);
            }
            addFeatures(t1, e, r, n, i, s) {
                for (const t1 of this.patternFeatures)this.addFeature(t1, t1.geometry, t1.index, e, r, n, s);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t1.createVertexBuffer(this.layoutVertexArray2, Ld)), 0 !== this.patternVertexArray.length && (this.patternVertexBuffer = t1.createVertexBuffer(this.patternVertexArray, Fd)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = t1.createVertexBuffer(this.zOffsetVertexArray, $d.members, !0)), this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Rd), this.indexBuffer = t1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t1) {
                if (t1.properties && t1.properties.hasOwnProperty("mapbox_clip_start") && t1.properties.hasOwnProperty("mapbox_clip_end")) return {
                    start: +t1.properties.mapbox_clip_start,
                    end: +t1.properties.mapbox_clip_end
                };
            }
            addFeature(t1, e, r, n, i, s, a) {
                const o = this.layers[0].layout, l = o.get("line-join").evaluate(t1, {}), u = o.get("line-cap").evaluate(t1, {}), c = o.get("line-miter-limit"), h = o.get("line-round-limit");
                this.lineClips = this.lineFeatureClips(t1);
                for (const r of e)this.addLine(r, t1, n, l, u, c, h);
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, s, n, a);
            }
            addLine(t1, e, r, n, i, s, a) {
                this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.currentVertex = void 0;
                const o = {
                    zoom: this.zoom,
                    lineProgress: void 0
                }, l = this.layers[0].layout, u = "none" === n;
                if (this.patternJoinNone = this.hasPattern && u, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [], this.lineClips) {
                    this.lineClipsArray.push(this.lineClips);
                    for(let e = 0; e < t1.length - 1; e++)this.totalDistance += t1[e].dist(t1[e + 1]);
                    this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
                }
                const c = "Polygon" === Wd[e.type];
                let h = t1.length;
                for(; h >= 2 && t1[h - 1].equals(t1[h - 2]);)h--;
                let p = 0;
                for(; p < h - 1 && t1[p].equals(t1[p + 1]);)p++;
                if (h < (c ? 3 : 2)) return;
                "bevel" === n && (s = 1.05);
                const f = this.overscaling <= 16 ? 15 * ps / (512 * this.overscaling) : 0, d = this.segments.prepareSegment(10 * h, this.layoutVertexArray, this.indexArray);
                let m, y, g, x, b, v;
                this.e1 = this.e2 = -1, c && (m = t1[h - 2], b = t1[p].sub(m)._unit()._perp());
                for(let r = p; r < h; r++){
                    if (g = r === h - 1 ? c ? t1[p + 1] : void 0 : t1[r + 1], g && t1[r].equals(g)) continue;
                    if (b && (x = b), m && (y = m), m = t1[r], this.hasZOffset) {
                        const t1 = l.get("line-z-offset").value;
                        if ("constant" === t1.kind) v = t1.value;
                        else {
                            if (this.lineClips) {
                                const t1 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
                                o.lineProgress = (t1 * this.lineClips.start + this.distance + (y ? y.dist(m) : 0)) / t1;
                            } else fr(`line-z-offset evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`), o.lineProgress = 0;
                            v = t1.evaluate(o, e);
                        }
                        v = v || 0;
                    }
                    b = g ? g.sub(m)._unit()._perp() : x, x = x || b;
                    const _ = y && g;
                    let w = _ ? n : c || u ? "butt" : i;
                    const M = x.x * b.x + x.y * b.y;
                    if (u) {
                        const t1 = function(t1) {
                            if (t1.patternJoinNone) {
                                const e = t1.segmentPoints.length / 2, r = t1.lineSoFar - t1.segmentStart;
                                for(let n = 0; n < e; ++n){
                                    const e = t1.segmentPoints[2 * n + 1], i = Math.round(t1.segmentPoints[2 * n]) + .5 + .25 * e;
                                    t1.patternVertexArray.emplaceBack(i, r, t1.segmentStart), t1.patternVertexArray.emplaceBack(i, r, t1.segmentStart);
                                }
                                t1.segmentPoints.length = 0;
                            }
                            t1.e1 = t1.e2 = -1;
                        };
                        if (_ && M < Qd) {
                            this.updateDistance(y, m), this.addCurrentVertex(m, x, 1, 1, d, v), t1(this), this.addCurrentVertex(m, b, -1, -1, d, v);
                            continue;
                        }
                        if (y) {
                            if (!g) {
                                this.updateDistance(y, m), this.addCurrentVertex(m, x, 1, 1, d, v), t1(this);
                                continue;
                            }
                            w = "miter";
                        }
                    }
                    let A = x.add(b);
                    0 === A.x && 0 === A.y || A._unit();
                    const S = A.x * b.x + A.y * b.y, I = 0 !== S ? 1 / S : 1 / 0, T = 2 * Math.sqrt(2 - 2 * S), k = S < Jd && y && g, P = x.x * b.y - x.y * b.x > 0;
                    if (k && r > p) {
                        const t1 = m.dist(y);
                        if (t1 > 2 * f) {
                            const e = m.sub(m.sub(y)._mult(f / t1)._round());
                            this.updateDistance(y, e), this.addCurrentVertex(e, x, 0, 0, d, v), y = e;
                        }
                    }
                    if (_ && "round" === w && (I < a ? w = "miter" : I <= 2 && (w = "fakeround")), "miter" === w && I > s && (w = "bevel"), "bevel" === w && (I > 2 && (w = "flipbevel"), I < s && (w = "miter")), y && this.updateDistance(y, m), "miter" === w) A._mult(I), this.addCurrentVertex(m, A, 0, 0, d, v);
                    else if ("flipbevel" === w) {
                        if (I > 100) A = b.mult(-1);
                        else {
                            const t1 = I * x.add(b).mag() / x.sub(b).mag();
                            A._perp()._mult(t1 * (P ? -1 : 1));
                        }
                        this.addCurrentVertex(m, A, 0, 0, d, v), this.addCurrentVertex(m, A.mult(-1), 0, 0, d, v);
                    } else if ("bevel" === w || "fakeround" === w) {
                        const t1 = -Math.sqrt(I * I - 1), e = P ? t1 : 0, r = P ? 0 : t1;
                        if (y && this.addCurrentVertex(m, x, e, r, d, v), "fakeround" === w) {
                            const t1 = Math.round(180 * T / Math.PI / 20);
                            for(let e = 1; e < t1; e++){
                                let r = e / t1;
                                if (.5 !== r) {
                                    const t1 = r - .5;
                                    r += r * t1 * (r - 1) * ((1.0904 + M * (M * (3.55645 - 1.43519 * M) - 3.2452)) * t1 * t1 + (.848013 + M * (.215638 * M - 1.06021)));
                                }
                                const n = b.sub(x)._mult(r)._add(x)._unit()._mult(P ? -1 : 1);
                                this.addHalfVertex(m, n.x, n.y, !1, P, 0, d, v);
                            }
                        }
                        g && this.addCurrentVertex(m, b, -e, -r, d, v);
                    } else "butt" === w ? this.addCurrentVertex(m, A, 0, 0, d, v) : "square" === w ? (y || this.addCurrentVertex(m, A, -1, -1, d, v), this.addCurrentVertex(m, A, 0, 0, d, v), y && this.addCurrentVertex(m, A, 1, 1, d, v)) : "round" === w && (y && (this.addCurrentVertex(m, x, 0, 0, d, v), this.addCurrentVertex(m, x, 1, 1, d, v, !0)), g && (this.addCurrentVertex(m, b, -1, -1, d, v, !0), this.addCurrentVertex(m, b, 0, 0, d, v)));
                    if (k && r < h - 1) {
                        const t1 = m.dist(g);
                        if (t1 > 2 * f) {
                            const e = m.add(g.sub(m)._mult(f / t1)._round());
                            this.updateDistance(m, e), this.addCurrentVertex(e, b, 0, 0, d, v), m = e;
                        }
                    }
                }
            }
            addVerticesTo(t1, e, r, n, i, s, a, o, l, u) {
                const c = (e.w - t1.w) / this.tessellationStep | 0;
                if (c > 1) {
                    this.lineSoFar = t1.w;
                    const h = (e.x - t1.x) / c, p = (e.y - t1.y) / c, f = (e.z - t1.z) / c, d = (e.w - t1.w) / c;
                    for(let e = 1; e < c; ++e)t1.x += h, t1.y += p, t1.z += f, this.lineSoFar += d, this.addHalfVertex(t1, r, n, u, !1, a, l, t1.z), this.addHalfVertex(t1, i, s, u, !0, -o, l, t1.z);
                }
                this.lineSoFar = e.w, this.addHalfVertex(e, r, n, u, !1, a, l, e.z), this.addHalfVertex(e, i, s, u, !0, -o, l, e.z);
            }
            addCurrentVertex(t1, e, r, n, i, s, a = !1) {
                const o = e.x + e.y * r, l = e.y - e.x * r, u = e.y * n - e.x, c = -e.y - e.x * n;
                if (null != s) {
                    const e = -10, h = ps + 10, p = s, f = new Tf(t1.x, t1.y, p, this.lineSoFar), d = em(t1, e, h), m = this.lineSoFar;
                    if (this.currentVertex) {
                        if (d) {
                            const s = this.currentVertexIsOutside, f = this.currentVertex, d = new Tf(t1.x, t1.y, p, this.lineSoFar);
                            zf(f, d, e, h), em(d, e, h) || (s && (this.e1 = this.e2 = -1, this.lineSoFar = f.w, this.addHalfVertex(f, o, l, a, !1, r, i, f.z), this.addHalfVertex(f, u, c, a, !0, -n, i, f.z)), this.addVerticesTo(f, d, o, l, u, c, r, n, i, a));
                        } else {
                            const t1 = this.currentVertex;
                            this.currentVertexIsOutside && (zf(t1, f, e, h), this.e1 = this.e2 = -1, this.lineSoFar = t1.w, this.addHalfVertex(t1, o, l, a, !1, r, i, t1.z), this.addHalfVertex(t1, u, c, a, !0, -n, i, t1.z)), this.addVerticesTo(t1, f, o, l, u, c, r, n, i, a);
                        }
                    } else d || (this.addHalfVertex(t1, o, l, a, !1, r, i, s), this.addHalfVertex(t1, u, c, a, !0, -n, i, s));
                    this.currentVertex = f, this.currentVertexIsOutside = d, this.lineSoFar = m;
                } else this.addHalfVertex(t1, o, l, a, !1, r, i, s), this.addHalfVertex(t1, u, c, a, !0, -n, i, s);
            }
            addHalfVertex({ x: t1, y: e }, r, n, i, s, a, o, l) {
                this.patternJoinNone && (0 === this.segmentPoints.length && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), s || this.segmentPoints.push(this.lineSoFar - this.segmentStart, a)), this.layoutVertexArray.emplaceBack((t1 << 1) + (i ? 1 : 0), (e << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
                const u = o.vertexLength++;
                this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u), o.primitiveLength++), s ? this.e2 = u : this.e1 = u, null != l && this.zOffsetVertexArray.emplaceBack(l);
            }
            updateScaledDistance() {
                if (this.lineClips) {
                    const t1 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
                    this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t1 * this.lineClips.start + this.distance;
                } else this.lineSoFar = this.distance;
            }
            updateDistance(t1, e) {
                this.distance += t1.dist(e), this.updateScaledDistance();
            }
        }
        function em(t1, e, r) {
            return t1.x < e || t1.x > r || t1.y < e || t1.y > r;
        }
        Mo(tm, "LineBucket", {
            omit: [
                "layers",
                "patternFeatures",
                "currentVertex",
                "currentVertexIsOutside"
            ]
        });
        const rm = new ol({
            "line-cap": new sl(ll.layout_line["line-cap"]),
            "line-join": new sl(ll.layout_line["line-join"]),
            "line-miter-limit": new il(ll.layout_line["line-miter-limit"]),
            "line-round-limit": new il(ll.layout_line["line-round-limit"]),
            "line-sort-key": new sl(ll.layout_line["line-sort-key"]),
            "line-z-offset": new sl(ll.layout_line["line-z-offset"]),
            visibility: new il(ll.layout_line.visibility)
        });
        var nm = {
            paint: new ol({
                "line-opacity": new sl(ll.paint_line["line-opacity"]),
                "line-color": new sl(ll.paint_line["line-color"]),
                "line-translate": new il(ll.paint_line["line-translate"]),
                "line-translate-anchor": new il(ll.paint_line["line-translate-anchor"]),
                "line-width": new sl(ll.paint_line["line-width"]),
                "line-gap-width": new sl(ll.paint_line["line-gap-width"]),
                "line-offset": new sl(ll.paint_line["line-offset"]),
                "line-blur": new sl(ll.paint_line["line-blur"]),
                "line-dasharray": new sl(ll.paint_line["line-dasharray"]),
                "line-pattern": new sl(ll.paint_line["line-pattern"]),
                "line-gradient": new al(ll.paint_line["line-gradient"]),
                "line-trim-offset": new il(ll.paint_line["line-trim-offset"]),
                "line-trim-fade-range": new il(ll.paint_line["line-trim-fade-range"]),
                "line-trim-color": new il(ll.paint_line["line-trim-color"]),
                "line-emissive-strength": new il(ll.paint_line["line-emissive-strength"]),
                "line-border-width": new sl(ll.paint_line["line-border-width"]),
                "line-border-color": new sl(ll.paint_line["line-border-color"]),
                "line-occlusion-opacity": new il(ll.paint_line["line-occlusion-opacity"])
            }),
            layout: rm
        };
        function im(t1, e, r) {
            return e * (ps / (t1.tileSize * Math.pow(2, r - t1.tileID.overscaledZ)));
        }
        function sm(t1, e) {
            return 1 / im(t1, 1, e.tileZoom);
        }
        function am(t1, e, r, n) {
            return t1.translatePosMatrix(n || e.tileID.projMatrix, e, r.paint.get("line-translate"), r.paint.get("line-translate-anchor"));
        }
        const om = (t1)=>{
            const e = [];
            lm(t1) && e.push("RENDER_LINE_DASH"), t1.paint.get("line-gradient") && e.push("RENDER_LINE_GRADIENT");
            const r = t1.paint.get("line-trim-offset");
            0 === r[0] && 0 === r[1] || e.push("RENDER_LINE_TRIM_OFFSET"), 0 !== t1.paint.get("line-border-width").constantOr(1) && e.push("RENDER_LINE_BORDER");
            const n = "none" === t1.layout.get("line-join").constantOr("miter"), i = !!t1.paint.get("line-pattern").constantOr(1);
            return n && i && e.push("LINE_JOIN_NONE"), e;
        };
        function lm(t1) {
            const e = t1.paint.get("line-dasharray").value;
            return e.value || "constant" !== e.kind;
        }
        class um {
            constructor(t1){
                this._stringToNumber = {}, this._numberToString = [];
                for(let e = 0; e < t1.length; e++){
                    const r = t1[e];
                    this._stringToNumber[r] = e, this._numberToString[e] = r;
                }
            }
            encode(t1) {
                return this._stringToNumber[t1];
            }
            decode(t1) {
                return this._numberToString[t1];
            }
        }
        var cm = {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ read: function(t1, e, r, n, i) {
                var s, a, o = 8 * i - n - 1, l = (1 << o) - 1, u = l >> 1, c = -7, h = r ? i - 1 : 0, p = r ? -1 : 1, f = t1[e + h];
                for(h += p, s = f & (1 << -c) - 1, f >>= -c, c += o; c > 0; s = 256 * s + t1[e + h], h += p, c -= 8);
                for(a = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; a = 256 * a + t1[e + h], h += p, c -= 8);
                if (0 === s) s = 1 - u;
                else {
                    if (s === l) return a ? NaN : 1 / 0 * (f ? -1 : 1);
                    a += Math.pow(2, n), s -= u;
                }
                return (f ? -1 : 1) * a * Math.pow(2, s - n);
            },
            write: function(t1, e, r, n, i, s) {
                var a, o, l, u = 8 * s - i - 1, c = (1 << u) - 1, h = c >> 1, p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n ? 0 : s - 1, d = n ? 1 : -1, m = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
                for(e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (e += a + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (a++, l /= 2), a + h >= c ? (o = 0, a = c) : a + h >= 1 ? (o = (e * l - 1) * Math.pow(2, i), a += h) : (o = e * Math.pow(2, h - 1) * Math.pow(2, i), a = 0)); i >= 8; t1[r + f] = 255 & o, f += d, o /= 256, i -= 8);
                for(a = a << i | o, u += i; u > 0; t1[r + f] = 255 & a, f += d, a /= 256, u -= 8);
                t1[r + f - d] |= 128 * m;
            }
        }, hm = fm, pm = cm;
        function fm(t1) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t1) ? t1 : new Uint8Array(t1 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        fm.Varint = 0, fm.Fixed64 = 1, fm.Bytes = 2, fm.Fixed32 = 5;
        var dm = 4294967296, mm = 1 / dm, ym = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function gm(t1) {
            return t1.type === fm.Bytes ? t1.readVarint() + t1.pos : t1.pos + 1;
        }
        function xm(t1, e, r) {
            return r ? 4294967296 * e + (t1 >>> 0) : 4294967296 * (e >>> 0) + (t1 >>> 0);
        }
        function bm(t1, e, r) {
            var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
            r.realloc(n);
            for(var i = r.pos - 1; i >= t1; i--)r.buf[i + n] = r.buf[i];
        }
        function vm(t1, e) {
            for(var r = 0; r < t1.length; r++)e.writeVarint(t1[r]);
        }
        function _m(t1, e) {
            for(var r = 0; r < t1.length; r++)e.writeSVarint(t1[r]);
        }
        function wm(t1, e) {
            for(var r = 0; r < t1.length; r++)e.writeFloat(t1[r]);
        }
        function Mm(t1, e) {
            for(var r = 0; r < t1.length; r++)e.writeDouble(t1[r]);
        }
        function Am(t1, e) {
            for(var r = 0; r < t1.length; r++)e.writeBoolean(t1[r]);
        }
        function Sm(t1, e) {
            for(var r = 0; r < t1.length; r++)e.writeFixed32(t1[r]);
        }
        function Im(t1, e) {
            for(var r = 0; r < t1.length; r++)e.writeSFixed32(t1[r]);
        }
        function Tm(t1, e) {
            for(var r = 0; r < t1.length; r++)e.writeFixed64(t1[r]);
        }
        function km(t1, e) {
            for(var r = 0; r < t1.length; r++)e.writeSFixed64(t1[r]);
        }
        function Pm(t1, e) {
            return (t1[e] | t1[e + 1] << 8 | t1[e + 2] << 16) + 16777216 * t1[e + 3];
        }
        function zm(t1, e, r) {
            t1[r] = e, t1[r + 1] = e >>> 8, t1[r + 2] = e >>> 16, t1[r + 3] = e >>> 24;
        }
        function Em(t1, e) {
            return (t1[e] | t1[e + 1] << 8 | t1[e + 2] << 16) + (t1[e + 3] << 24);
        }
        fm.prototype = {
            destroy: function() {
                this.buf = null;
            },
            readFields: function(t1, e, r) {
                for(r = r || this.length; this.pos < r;){
                    var n = this.readVarint(), i = n >> 3, s = this.pos;
                    this.type = 7 & n, t1(i, e, this), this.pos === s && this.skip(n);
                }
                return e;
            },
            readMessage: function(t1, e) {
                return this.readFields(t1, e, this.readVarint() + this.pos);
            },
            readFixed32: function() {
                var t1 = Pm(this.buf, this.pos);
                return this.pos += 4, t1;
            },
            readSFixed32: function() {
                var t1 = Em(this.buf, this.pos);
                return this.pos += 4, t1;
            },
            readFixed64: function() {
                var t1 = Pm(this.buf, this.pos) + Pm(this.buf, this.pos + 4) * dm;
                return this.pos += 8, t1;
            },
            readSFixed64: function() {
                var t1 = Pm(this.buf, this.pos) + Em(this.buf, this.pos + 4) * dm;
                return this.pos += 8, t1;
            },
            readFloat: function() {
                var t1 = pm.read(this.buf, this.pos, !0, 23, 4);
                return this.pos += 4, t1;
            },
            readDouble: function() {
                var t1 = pm.read(this.buf, this.pos, !0, 52, 8);
                return this.pos += 8, t1;
            },
            readVarint: function(t1) {
                var e, r, n = this.buf;
                return e = 127 & (r = n[this.pos++]), r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e : function(t1, e, r) {
                    var n, i, s = r.buf;
                    if (n = (112 & (i = s[r.pos++])) >> 4, i < 128) return xm(t1, n, e);
                    if (n |= (127 & (i = s[r.pos++])) << 3, i < 128) return xm(t1, n, e);
                    if (n |= (127 & (i = s[r.pos++])) << 10, i < 128) return xm(t1, n, e);
                    if (n |= (127 & (i = s[r.pos++])) << 17, i < 128) return xm(t1, n, e);
                    if (n |= (127 & (i = s[r.pos++])) << 24, i < 128) return xm(t1, n, e);
                    if (n |= (1 & (i = s[r.pos++])) << 31, i < 128) return xm(t1, n, e);
                    throw new Error("Expected varint not more than 10 bytes");
                }(e |= (15 & (r = n[this.pos])) << 28, t1, this))));
            },
            readVarint64: function() {
                return this.readVarint(!0);
            },
            readSVarint: function() {
                var t1 = this.readVarint();
                return t1 % 2 == 1 ? (t1 + 1) / -2 : t1 / 2;
            },
            readBoolean: function() {
                return Boolean(this.readVarint());
            },
            readString: function() {
                var t1 = this.readVarint() + this.pos, e = this.pos;
                return this.pos = t1, t1 - e >= 12 && ym ? function(t1, e, r) {
                    return ym.decode(t1.subarray(e, r));
                }(this.buf, e, t1) : function(t1, e, r) {
                    for(var n = "", i = e; i < r;){
                        var s, a, o, l = t1[i], u = null, c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                        if (i + c > r) break;
                        1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (s = t1[i + 1])) && (u = (31 & l) << 6 | 63 & s) <= 127 && (u = null) : 3 === c ? (a = t1[i + 2], 128 == (192 & (s = t1[i + 1])) && 128 == (192 & a) && ((u = (15 & l) << 12 | (63 & s) << 6 | 63 & a) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (a = t1[i + 2], o = t1[i + 3], 128 == (192 & (s = t1[i + 1])) && 128 == (192 & a) && 128 == (192 & o) && ((u = (15 & l) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, n += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), n += String.fromCharCode(u), i += c;
                    }
                    return n;
                }(this.buf, e, t1);
            },
            readBytes: function() {
                var t1 = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, t1);
                return this.pos = t1, e;
            },
            readPackedVarint: function(t1, e) {
                if (this.type !== fm.Bytes) return t1.push(this.readVarint(e));
                var r = gm(this);
                for(t1 = t1 || []; this.pos < r;)t1.push(this.readVarint(e));
                return t1;
            },
            readPackedSVarint: function(t1) {
                if (this.type !== fm.Bytes) return t1.push(this.readSVarint());
                var e = gm(this);
                for(t1 = t1 || []; this.pos < e;)t1.push(this.readSVarint());
                return t1;
            },
            readPackedBoolean: function(t1) {
                if (this.type !== fm.Bytes) return t1.push(this.readBoolean());
                var e = gm(this);
                for(t1 = t1 || []; this.pos < e;)t1.push(this.readBoolean());
                return t1;
            },
            readPackedFloat: function(t1) {
                if (this.type !== fm.Bytes) return t1.push(this.readFloat());
                var e = gm(this);
                for(t1 = t1 || []; this.pos < e;)t1.push(this.readFloat());
                return t1;
            },
            readPackedDouble: function(t1) {
                if (this.type !== fm.Bytes) return t1.push(this.readDouble());
                var e = gm(this);
                for(t1 = t1 || []; this.pos < e;)t1.push(this.readDouble());
                return t1;
            },
            readPackedFixed32: function(t1) {
                if (this.type !== fm.Bytes) return t1.push(this.readFixed32());
                var e = gm(this);
                for(t1 = t1 || []; this.pos < e;)t1.push(this.readFixed32());
                return t1;
            },
            readPackedSFixed32: function(t1) {
                if (this.type !== fm.Bytes) return t1.push(this.readSFixed32());
                var e = gm(this);
                for(t1 = t1 || []; this.pos < e;)t1.push(this.readSFixed32());
                return t1;
            },
            readPackedFixed64: function(t1) {
                if (this.type !== fm.Bytes) return t1.push(this.readFixed64());
                var e = gm(this);
                for(t1 = t1 || []; this.pos < e;)t1.push(this.readFixed64());
                return t1;
            },
            readPackedSFixed64: function(t1) {
                if (this.type !== fm.Bytes) return t1.push(this.readSFixed64());
                var e = gm(this);
                for(t1 = t1 || []; this.pos < e;)t1.push(this.readSFixed64());
                return t1;
            },
            skip: function(t1) {
                var e = 7 & t1;
                if (e === fm.Varint) for(; this.buf[this.pos++] > 127;);
                else if (e === fm.Bytes) this.pos = this.readVarint() + this.pos;
                else if (e === fm.Fixed32) this.pos += 4;
                else {
                    if (e !== fm.Fixed64) throw new Error("Unimplemented type: " + e);
                    this.pos += 8;
                }
            },
            writeTag: function(t1, e) {
                this.writeVarint(t1 << 3 | e);
            },
            realloc: function(t1) {
                for(var e = this.length || 16; e < this.pos + t1;)e *= 2;
                if (e !== this.length) {
                    var r = new Uint8Array(e);
                    r.set(this.buf), this.buf = r, this.length = e;
                }
            },
            finish: function() {
                return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
            },
            writeFixed32: function(t1) {
                this.realloc(4), zm(this.buf, t1, this.pos), this.pos += 4;
            },
            writeSFixed32: function(t1) {
                this.realloc(4), zm(this.buf, t1, this.pos), this.pos += 4;
            },
            writeFixed64: function(t1) {
                this.realloc(8), zm(this.buf, -1 & t1, this.pos), zm(this.buf, Math.floor(t1 * mm), this.pos + 4), this.pos += 8;
            },
            writeSFixed64: function(t1) {
                this.realloc(8), zm(this.buf, -1 & t1, this.pos), zm(this.buf, Math.floor(t1 * mm), this.pos + 4), this.pos += 8;
            },
            writeVarint: function(t1) {
                (t1 = +t1 || 0) > 268435455 || t1 < 0 ? function(t1, e) {
                    var r, n;
                    if (t1 >= 0 ? (r = t1 % 4294967296 | 0, n = t1 / 4294967296 | 0) : (n = ~(-t1 / 4294967296), 4294967295 ^ (r = ~(-t1 % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t1 >= 0x10000000000000000 || t1 < -18446744073709552000) throw new Error("Given varint doesn't fit into 10 bytes");
                    e.realloc(10), function(t1, e, r) {
                        r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, r.buf[r.pos] = 127 & (t1 >>>= 7);
                    }(r, 0, e), function(t1, e) {
                        var r = (7 & t1) << 4;
                        e.buf[e.pos++] |= r | ((t1 >>>= 3) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1)))));
                    }(n, e);
                }(t1, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t1 | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = 127 & (t1 >>>= 7) | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = 127 & (t1 >>>= 7) | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = t1 >>> 7 & 127))));
            },
            writeSVarint: function(t1) {
                this.writeVarint(t1 < 0 ? 2 * -t1 - 1 : 2 * t1);
            },
            writeBoolean: function(t1) {
                this.writeVarint(Boolean(t1));
            },
            writeString: function(t1) {
                t1 = String(t1), this.realloc(4 * t1.length), this.pos++;
                var e = this.pos;
                this.pos = function(t1, e, r) {
                    for(var n, i, s = 0; s < e.length; s++){
                        if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {
                            if (!i) {
                                n > 56319 || s + 1 === e.length ? (t1[r++] = 239, t1[r++] = 191, t1[r++] = 189) : i = n;
                                continue;
                            }
                            if (n < 56320) {
                                t1[r++] = 239, t1[r++] = 191, t1[r++] = 189, i = n;
                                continue;
                            }
                            n = i - 55296 << 10 | n - 56320 | 65536, i = null;
                        } else i && (t1[r++] = 239, t1[r++] = 191, t1[r++] = 189, i = null);
                        n < 128 ? t1[r++] = n : (n < 2048 ? t1[r++] = n >> 6 | 192 : (n < 65536 ? t1[r++] = n >> 12 | 224 : (t1[r++] = n >> 18 | 240, t1[r++] = n >> 12 & 63 | 128), t1[r++] = n >> 6 & 63 | 128), t1[r++] = 63 & n | 128);
                    }
                    return r;
                }(this.buf, t1, this.pos);
                var r = this.pos - e;
                r >= 128 && bm(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;
            },
            writeFloat: function(t1) {
                this.realloc(4), pm.write(this.buf, t1, this.pos, !0, 23, 4), this.pos += 4;
            },
            writeDouble: function(t1) {
                this.realloc(8), pm.write(this.buf, t1, this.pos, !0, 52, 8), this.pos += 8;
            },
            writeBytes: function(t1) {
                var e = t1.length;
                this.writeVarint(e), this.realloc(e);
                for(var r = 0; r < e; r++)this.buf[this.pos++] = t1[r];
            },
            writeRawMessage: function(t1, e) {
                this.pos++;
                var r = this.pos;
                t1(e, this);
                var n = this.pos - r;
                n >= 128 && bm(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;
            },
            writeMessage: function(t1, e, r) {
                this.writeTag(t1, fm.Bytes), this.writeRawMessage(e, r);
            },
            writePackedVarint: function(t1, e) {
                e.length && this.writeMessage(t1, vm, e);
            },
            writePackedSVarint: function(t1, e) {
                e.length && this.writeMessage(t1, _m, e);
            },
            writePackedBoolean: function(t1, e) {
                e.length && this.writeMessage(t1, Am, e);
            },
            writePackedFloat: function(t1, e) {
                e.length && this.writeMessage(t1, wm, e);
            },
            writePackedDouble: function(t1, e) {
                e.length && this.writeMessage(t1, Mm, e);
            },
            writePackedFixed32: function(t1, e) {
                e.length && this.writeMessage(t1, Sm, e);
            },
            writePackedSFixed32: function(t1, e) {
                e.length && this.writeMessage(t1, Im, e);
            },
            writePackedFixed64: function(t1, e) {
                e.length && this.writeMessage(t1, Tm, e);
            },
            writePackedSFixed64: function(t1, e) {
                e.length && this.writeMessage(t1, km, e);
            },
            writeBytesField: function(t1, e) {
                this.writeTag(t1, fm.Bytes), this.writeBytes(e);
            },
            writeFixed32Field: function(t1, e) {
                this.writeTag(t1, fm.Fixed32), this.writeFixed32(e);
            },
            writeSFixed32Field: function(t1, e) {
                this.writeTag(t1, fm.Fixed32), this.writeSFixed32(e);
            },
            writeFixed64Field: function(t1, e) {
                this.writeTag(t1, fm.Fixed64), this.writeFixed64(e);
            },
            writeSFixed64Field: function(t1, e) {
                this.writeTag(t1, fm.Fixed64), this.writeSFixed64(e);
            },
            writeVarintField: function(t1, e) {
                this.writeTag(t1, fm.Varint), this.writeVarint(e);
            },
            writeSVarintField: function(t1, e) {
                this.writeTag(t1, fm.Varint), this.writeSVarint(e);
            },
            writeStringField: function(t1, e) {
                this.writeTag(t1, fm.Bytes), this.writeString(e);
            },
            writeFloatField: function(t1, e) {
                this.writeTag(t1, fm.Fixed32), this.writeFloat(e);
            },
            writeDoubleField: function(t1, e) {
                this.writeTag(t1, fm.Fixed64), this.writeDouble(e);
            },
            writeBooleanField: function(t1, e) {
                this.writeVarintField(t1, Boolean(e));
            }
        };
        var Bm = p(hm);
        const Dm = [
            "id",
            "tile",
            "layer",
            "source",
            "sourceLayer",
            "state"
        ];
        class Cm {
            constructor(t1, e, r, n, i){
                this.type = "Feature", this._vectorTileFeature = t1, this._z = e, this._x = r, this._y = n, this.properties = t1.properties, this.id = i;
            }
            get geometry() {
                return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
            }
            set geometry(t1) {
                this._geometry = t1;
            }
            toJSON() {
                const t1 = {
                    type: "Feature",
                    state: void 0,
                    geometry: this.geometry,
                    properties: this.properties
                };
                for (const e of Dm)void 0 !== this[e] && (t1[e] = this[e]);
                return t1;
            }
        }
        class Rm {
            constructor(){
                this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(t1, e, r) {
                const n = String(e);
                if (this.stateChanges[t1] = this.stateChanges[t1] || {}, this.stateChanges[t1][n] = this.stateChanges[t1][n] || {}, er(this.stateChanges[t1][n], r), null === this.deletedStates[t1]) {
                    this.deletedStates[t1] = {};
                    for(const e in this.state[t1])e !== n && (this.deletedStates[t1][e] = null);
                } else if (this.deletedStates[t1] && null === this.deletedStates[t1][n]) {
                    this.deletedStates[t1][n] = {};
                    for(const e in this.state[t1][n])r[e] || (this.deletedStates[t1][n][e] = null);
                } else for(const e in r)this.deletedStates[t1] && this.deletedStates[t1][n] && null === this.deletedStates[t1][n][e] && delete this.deletedStates[t1][n][e];
            }
            removeFeatureState(t1, e, r) {
                if (null === this.deletedStates[t1]) return;
                const n = String(e);
                if (this.deletedStates[t1] = this.deletedStates[t1] || {}, r && void 0 !== e) null !== this.deletedStates[t1][n] && (this.deletedStates[t1][n] = this.deletedStates[t1][n] || {}, this.deletedStates[t1][n][r] = null);
                else if (void 0 !== e) {
                    if (this.stateChanges[t1] && this.stateChanges[t1][n]) for(r in this.deletedStates[t1][n] = {}, this.stateChanges[t1][n])this.deletedStates[t1][n][r] = null;
                    else this.deletedStates[t1][n] = null;
                } else this.deletedStates[t1] = null;
            }
            getState(t1, e) {
                const r = String(e), n = er({}, (this.state[t1] || {})[r], (this.stateChanges[t1] || {})[r]);
                if (null === this.deletedStates[t1]) return {};
                if (this.deletedStates[t1]) {
                    const r = this.deletedStates[t1][e];
                    if (null === r) return {};
                    for(const t1 in r)delete n[t1];
                }
                return n;
            }
            initializeTileState(t1, e) {
                t1.setFeatureState(this.state, e);
            }
            coalesceChanges(t1, e) {
                const r = {};
                for(const t1 in this.stateChanges){
                    this.state[t1] = this.state[t1] || {};
                    const e = {};
                    for(const r in this.stateChanges[t1])this.state[t1][r] || (this.state[t1][r] = {}), er(this.state[t1][r], this.stateChanges[t1][r]), e[r] = this.state[t1][r];
                    r[t1] = e;
                }
                for(const t1 in this.deletedStates){
                    this.state[t1] = this.state[t1] || {};
                    const e = {};
                    if (null === this.deletedStates[t1]) for(const r in this.state[t1])e[r] = {}, this.state[t1][r] = {};
                    else for(const r in this.deletedStates[t1]){
                        if (null === this.deletedStates[t1][r]) this.state[t1][r] = {};
                        else if (this.state[t1][r]) for (const e of Object.keys(this.deletedStates[t1][r]))delete this.state[t1][r][e];
                        e[r] = this.state[t1][r];
                    }
                    r[t1] = r[t1] || {}, er(r[t1], e);
                }
                if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r).length) for(const n in t1)t1[n].setFeatureState(r, e);
            }
        }
        class Vm {
            constructor(t1, e){
                this.tileID = t1, this.x = t1.canonical.x, this.y = t1.canonical.y, this.z = t1.canonical.z, this.grid = new _o(ps, 16, 0), this.featureIndexArray = new vu, this.promoteId = e, this.is3DTile = !1;
            }
            insert(t1, e, r, n, i, s = 0, a = 0) {
                const o = this.featureIndexArray.length;
                this.featureIndexArray.emplaceBack(r, n, i, s);
                const l = this.grid;
                for(let t1 = 0; t1 < e.length; t1++){
                    const r = e[t1], n = [
                        1 / 0,
                        1 / 0,
                        -1 / 0,
                        -1 / 0
                    ];
                    for(let t1 = 0; t1 < r.length; t1++){
                        const e = r[t1];
                        n[0] = Math.min(n[0], e.x), n[1] = Math.min(n[1], e.y), n[2] = Math.max(n[2], e.x), n[3] = Math.max(n[3], e.y);
                    }
                    0 !== a && (n[0] -= a, n[1] -= a, n[2] += a, n[3] += a), n[0] < ps && n[1] < ps && n[2] >= 0 && n[3] >= 0 && l.insert(o, n[0], n[1], n[2], n[3]);
                }
            }
            loadVTLayers() {
                if (!this.vtLayers) {
                    this.vtLayers = new Af(new Bm(this.rawTileData)).layers, this.sourceLayerCoder = new um(this.vtLayers ? Object.keys(this.vtLayers).sort() : [
                        "_geojsonTileLayer"
                    ]), this.vtFeatures = {};
                    for(const t1 in this.vtLayers)this.vtFeatures[t1] = [];
                }
                return this.vtLayers;
            }
            query(t1, e, r, n) {
                this.loadVTLayers();
                const i = t1.params || {}, s = pl(i.filter), a = t1.tileResult, o = t1.transform, l = a.bufferedTilespaceBounds, u = this.grid.query(l.min.x, l.min.y, l.max.x, l.max.y, (t1, e, r, n)=>oh(a.bufferedTilespaceGeometry, t1, e, r, n));
                u.sort(Om);
                let c = null;
                o.elevation && u.length > 0 && (c = Qf.create(o.elevation, this.tileID));
                const h = {};
                let p;
                for(let l = 0; l < u.length; l++){
                    const f = u[l];
                    if (f === p) continue;
                    p = f;
                    const d = this.featureIndexArray.get(f);
                    let m = null;
                    if (this.is3DTile) {
                        const t1 = this.bucketLayerIDs[0][0], r = e[t1];
                        if ("model" !== r.type) continue;
                        const { queryFeature: n, intersectionZ: i } = r.queryIntersectsMatchingFeature(a, d.featureIndex, s, o);
                        n && this.appendToResult(h, t1, d.featureIndex, n, i);
                    } else this.loadMatchingFeature(h, d, s, i.layers, i.availableImages, e, r, n, (e, r, n, i = 0)=>(m || (m = Yc(e, this.tileID.canonical, t1.tileTransform)), r.queryIntersectsFeature(a, e, n, m, this.z, t1.transform, t1.pixelPosMatrix, c, i)));
                }
                return h;
            }
            loadMatchingFeature(t1, e, r, n, i, s, a, o, l) {
                const { featureIndex: u, bucketIndex: c, sourceLayerIndex: h, layoutVertexArrayOffset: p } = e, f = this.bucketLayerIDs[c];
                if (n && !function(t1, e) {
                    for(let r = 0; r < t1.length; r++)if (e.indexOf(t1[r]) >= 0) return !0;
                    return !1;
                }(n, f)) return;
                const d = this.sourceLayerCoder.decode(h), m = this.vtLayers[d].feature(u);
                if (r.needGeometry) {
                    const t1 = Xc(m, !0);
                    if (!r.filter(new Ho(this.tileID.overscaledZ), t1, this.tileID.canonical)) return;
                } else if (!r.filter(new Ho(this.tileID.overscaledZ), m)) return;
                const y = this.getId(m, d);
                for(let e = 0; e < f.length; e++){
                    const r = f[e];
                    if (n && n.indexOf(r) < 0) continue;
                    const c = s[r];
                    if (!c) continue;
                    let h = {};
                    void 0 !== y && o && (h = o.getState(c.sourceLayer || "_geojsonTileLayer", y));
                    const d = !l || l(m, c, h, p);
                    if (!d) continue;
                    const g = new Cm(m, this.z, this.x, this.y, y), x = er({}, a[r]);
                    x.paint = Lm(x.paint, c.paint, m, h, i), x.layout = Lm(x.layout, c.layout, m, h, i), g.layer = x, this.appendToResult(t1, r, u, g, d);
                }
            }
            appendToResult(t1, e, r, n, i) {
                let s = t1[e];
                void 0 === s && (s = t1[e] = []), s.push({
                    featureIndex: r,
                    feature: n,
                    intersectionZ: i
                });
            }
            lookupSymbolFeatures(t1, e, r, n, i, s, a, o) {
                const l = {};
                this.loadVTLayers();
                const u = pl(i);
                for (const i of t1)this.loadMatchingFeature(l, {
                    bucketIndex: r,
                    sourceLayerIndex: n,
                    featureIndex: i,
                    layoutVertexArrayOffset: 0
                }, u, s, a, o, e);
                return l;
            }
            loadFeature(t1) {
                const { featureIndex: e, sourceLayerIndex: r } = t1;
                this.loadVTLayers();
                const n = this.sourceLayerCoder.decode(r), i = this.vtFeatures[n];
                if (i[e]) return i[e];
                const s = this.vtLayers[n].feature(e);
                return i[e] = s, s;
            }
            hasLayer(t1) {
                for (const e of this.bucketLayerIDs)for (const r of e)if (t1 === r) return !0;
                return !1;
            }
            getId(t1, e) {
                let r = t1.id;
                if (this.promoteId) {
                    const n = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e];
                    null != n && (r = t1.properties[n]), "boolean" == typeof r && (r = Number(r));
                }
                return r;
            }
        }
        function Lm(t1, e, r, n, i) {
            return ur(t1, (t1, s)=>{
                const a = e instanceof nl ? e.get(s) : null;
                return a && a.evaluate ? a.evaluate(r, n, i) : a;
            });
        }
        function Om(t1, e) {
            return e - t1;
        }
        Mo(Vm, "FeatureIndex", {
            omit: [
                "rawTileData",
                "sourceLayerCoder"
            ]
        });
        var Fm = 24;
        const Um = 128;
        function Nm(t1, e) {
            const { expression: r } = e;
            if ("constant" === r.kind) return {
                kind: "constant",
                layoutSize: r.evaluate(new Ho(t1 + 1))
            };
            if ("source" === r.kind) return {
                kind: "source"
            };
            {
                const { zoomStops: e, interpolationType: n } = r;
                let i = 0;
                for(; i < e.length && e[i] <= t1;)i++;
                i = Math.max(0, i - 1);
                let s = i;
                for(; s < e.length && e[s] < t1 + 1;)s++;
                s = Math.min(e.length - 1, s);
                const a = e[i], o = e[s];
                return "composite" === r.kind ? {
                    kind: "composite",
                    minZoom: a,
                    maxZoom: o,
                    interpolationType: n
                } : {
                    kind: "camera",
                    minZoom: a,
                    maxZoom: o,
                    minSize: r.evaluate(new Ho(a)),
                    maxSize: r.evaluate(new Ho(o)),
                    interpolationType: n
                };
            }
        }
        function jm(t1, { uSize: e, uSizeT: r }, { lowerSize: n, upperSize: i }) {
            return "source" === t1.kind ? n / Um : "composite" === t1.kind ? Gn(n / Um, i / Um, r) : e;
        }
        function qm(t1, e) {
            let r = 0, n = 0;
            if ("constant" === t1.kind) n = t1.layoutSize;
            else if ("source" !== t1.kind) {
                const { interpolationType: i, minZoom: s, maxZoom: a } = t1, o = i ? Ke(va.interpolationFactor(i, e, s, a), 0, 1) : 0;
                "camera" === t1.kind ? n = Gn(t1.minSize, t1.maxSize, o) : r = o;
            }
            return {
                uSizeT: r,
                uSize: n
            };
        }
        var $m = Object.freeze({
            __proto__: null,
            SIZE_PACK_FACTOR: Um,
            evaluateSizeForFeature: jm,
            evaluateSizeForZoom: qm,
            getSizeData: Nm
        });
        function Gm(t1, e, r) {
            return t1.sections.forEach((t1)=>{
                t1.text = function(t1, e, r) {
                    const n = e.layout.get("text-transform").evaluate(r, {});
                    return "uppercase" === n ? t1 = t1.toLocaleUpperCase() : "lowercase" === n && (t1 = t1.toLocaleLowerCase()), Zo.applyArabicShaping && (t1 = Zo.applyArabicShaping(t1)), t1;
                }(t1.text, e, r);
            }), t1;
        }
        const Ym = {
            "!": "\uFE15",
            "#": "\uFF03",
            $: "\uFF04",
            "%": "\uFF05",
            "&": "\uFF06",
            "(": "\uFE35",
            ")": "\uFE36",
            "*": "\uFF0A",
            "+": "\uFF0B",
            ",": "\uFE10",
            "-": "\uFE32",
            ".": "\u30FB",
            "/": "\uFF0F",
            ":": "\uFE13",
            ";": "\uFE14",
            "<": "\uFE3F",
            "=": "\uFF1D",
            ">": "\uFE40",
            "?": "\uFE16",
            "@": "\uFF20",
            "[": "\uFE47",
            "\\": "\uFF3C",
            "]": "\uFE48",
            "^": "\uFF3E",
            _: "\uFE33",
            "`": "\uFF40",
            "{": "\uFE37",
            "|": "\u2015",
            "}": "\uFE38",
            "~": "\uFF5E",
            "\xa2": "\uFFE0",
            "\xa3": "\uFFE1",
            "\xa5": "\uFFE5",
            "\xa6": "\uFFE4",
            "\xac": "\uFFE2",
            "\xaf": "\uFFE3",
            "\u2013": "\uFE32",
            "\u2014": "\uFE31",
            "\u2018": "\uFE43",
            "\u2019": "\uFE44",
            "\u201C": "\uFE41",
            "\u201D": "\uFE42",
            "\u2026": "\uFE19",
            "\u2027": "\u30FB",
            "\u20A9": "\uFFE6",
            "\u3001": "\uFE11",
            "\u3002": "\uFE12",
            "\u3008": "\uFE3F",
            "\u3009": "\uFE40",
            "\u300A": "\uFE3D",
            "\u300B": "\uFE3E",
            "\u300C": "\uFE41",
            "\u300D": "\uFE42",
            "\u300E": "\uFE43",
            "\u300F": "\uFE44",
            "\u3010": "\uFE3B",
            "\u3011": "\uFE3C",
            "\u3014": "\uFE39",
            "\u3015": "\uFE3A",
            "\u3016": "\uFE17",
            "\u3017": "\uFE18",
            "\uFF01": "\uFE15",
            "\uFF08": "\uFE35",
            "\uFF09": "\uFE36",
            "\uFF0C": "\uFE10",
            "\uFF0D": "\uFE32",
            "\uFF0E": "\u30FB",
            "\uFF1A": "\uFE13",
            "\uFF1B": "\uFE14",
            "\uFF1C": "\uFE3F",
            "\uFF1E": "\uFE40",
            "\uFF1F": "\uFE16",
            "\uFF3B": "\uFE47",
            "\uFF3D": "\uFE48",
            "\uFF3F": "\uFE33",
            "\uFF5B": "\uFE37",
            "\uFF5C": "\u2015",
            "\uFF5D": "\uFE38",
            "\uFF5F": "\uFE35",
            "\uFF60": "\uFE36",
            "\uFF61": "\uFE12",
            "\uFF62": "\uFE41",
            "\uFF63": "\uFE42",
            "\u2190": "\u2191",
            "\u2192": "\u2193"
        };
        function Xm(t1) {
            return "\uFE36" === t1 || "\uFE48" === t1 || "\uFE38" === t1 || "\uFE44" === t1 || "\uFE42" === t1 || "\uFE3E" === t1 || "\uFE3C" === t1 || "\uFE3A" === t1 || "\uFE18" === t1 || "\uFE40" === t1 || "\uFE10" === t1 || "\uFE13" === t1 || "\uFE14" === t1 || "\uFF40" === t1 || "\uFFE3" === t1 || "\uFE11" === t1 || "\uFE12" === t1;
        }
        function Zm(t1) {
            return "\uFE35" === t1 || "\uFE47" === t1 || "\uFE37" === t1 || "\uFE43" === t1 || "\uFE41" === t1 || "\uFE3D" === t1 || "\uFE3B" === t1 || "\uFE39" === t1 || "\uFE17" === t1 || "\uFE3F" === t1;
        }
        const Hm = 3;
        function Km(t1, e, r) {
            e.glyphs = [], 1 === t1 && r.readMessage(Wm, e);
        }
        function Wm(t1, e, r) {
            if (3 === t1) {
                const { id: t1, bitmap: n, width: i, height: s, left: a, top: o, advance: l } = r.readMessage(Jm, {});
                e.glyphs.push({
                    id: t1,
                    bitmap: new pp({
                        width: i + 2 * Hm,
                        height: s + 2 * Hm
                    }, n),
                    metrics: {
                        width: i,
                        height: s,
                        left: a,
                        top: o,
                        advance: l
                    }
                });
            } else 4 === t1 ? e.ascender = r.readSVarint() : 5 === t1 && (e.descender = r.readSVarint());
        }
        function Jm(t1, e, r) {
            1 === t1 ? e.id = r.readVarint() : 2 === t1 ? e.bitmap = r.readBytes() : 3 === t1 ? e.width = r.readVarint() : 4 === t1 ? e.height = r.readVarint() : 5 === t1 ? e.left = r.readSVarint() : 6 === t1 ? e.top = r.readSVarint() : 7 === t1 && (e.advance = r.readVarint());
        }
        const Qm = Hm, ty = {
            horizontal: 1,
            vertical: 2,
            horizontalOnly: 3
        };
        class ey {
            constructor(){
                this.scale = 1, this.fontStack = "", this.imageName = null;
            }
            static forText(t1, e) {
                const r = new ey;
                return r.scale = t1 || 1, r.fontStack = e, r;
            }
            static forImage(t1) {
                const e = new ey;
                return e.imageName = t1, e;
            }
        }
        class ry {
            constructor(){
                this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t1, e) {
                const r = new ry;
                for(let n = 0; n < t1.sections.length; n++){
                    const i = t1.sections[n];
                    i.image ? r.addImageSection(i) : r.addTextSection(i, e);
                }
                return r;
            }
            length() {
                return this.text.length;
            }
            getSection(t1) {
                return this.sections[this.sectionIndex[t1]];
            }
            getSections() {
                return this.sections;
            }
            getSectionIndex(t1) {
                return this.sectionIndex[t1];
            }
            getCodePoint(t1) {
                return this.text.codePointAt(t1);
            }
            verticalizePunctuation(t1) {
                this.text = function(t1, e) {
                    let r = "";
                    for(let n = 0; n < t1.length; n++){
                        const i = t1.charCodeAt(n + 1) || null, s = t1.charCodeAt(n - 1) || null;
                        r += !e && (i && Do(i) && !Ym[t1[n + 1]] || s && Do(s) && !Ym[t1[n - 1]]) || !Ym[t1[n]] ? t1[n] : Ym[t1[n]];
                    }
                    return r;
                }(this.text, t1);
            }
            trim() {
                let t1 = 0;
                for(let e = 0; e < this.text.length && iy[this.text.charCodeAt(e)]; e++)t1++;
                let e = this.text.length;
                for(let r = this.text.length - 1; r >= 0 && r >= t1 && iy[this.text.charCodeAt(r)]; r--)e--;
                this.text = this.text.substring(t1, e), this.sectionIndex = this.sectionIndex.slice(t1, e);
            }
            substring(t1, e) {
                const r = new ry;
                return r.text = this.text.substring(t1, e), r.sectionIndex = this.sectionIndex.slice(t1, e), r.sections = this.sections, r;
            }
            toString() {
                return this.text;
            }
            getMaxScale() {
                return this.sectionIndex.reduce((t1, e)=>Math.max(t1, this.sections[e].scale), 0);
            }
            addTextSection(t1, e) {
                this.text += t1.text, this.sections.push(ey.forText(t1.scale, t1.fontStack || e));
                const r = this.sections.length - 1;
                for(let e = 0; e < t1.text.length; ++e)this.sectionIndex.push(r);
            }
            addImageSection(t1) {
                const e = t1.image ? t1.image.namePrimary : "";
                if (0 === e.length) return void fr("Can't add FormattedSection with an empty image.");
                const r = this.getNextImageSectionCharCode();
                r ? (this.text += String.fromCodePoint(r), this.sections.push(ey.forImage(e)), this.sectionIndex.push(this.sections.length - 1)) : fr("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
                return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
        }
        function ny(t1, e, r, n, i, s, a, o, l, u, c, h, p, f, d) {
            const m = ry.fromFeature(t1, i);
            h === ty.vertical && m.verticalizePunctuation(p);
            let y = [];
            const g = function(t1, e, r, n, i, s) {
                if (!t1) return [];
                const a = [], o = function(t1, e, r, n, i, s) {
                    let a = 0;
                    for(let r = 0; r < t1.length(); r++){
                        const o = t1.getSection(r);
                        a += ay(t1.getCodePoint(r), o, n, i, e, s);
                    }
                    return a / Math.max(1, Math.ceil(a / r));
                }(t1, e, r, n, i, s), l = t1.text.indexOf("\u200B") >= 0;
                let u = 0;
                for(let r = 0; r < t1.length(); r++){
                    const h = t1.getSection(r), p = t1.getCodePoint(r);
                    if (iy[p] || (u += ay(p, h, n, i, e, s)), r < t1.length() - 1) {
                        const e = !((c = p) < 11904 || !(ko["Bopomofo Extended"](c) || ko.Bopomofo(c) || ko["CJK Compatibility Forms"](c) || ko["CJK Compatibility Ideographs"](c) || ko["CJK Compatibility"](c) || ko["CJK Radicals Supplement"](c) || ko["CJK Strokes"](c) || ko["CJK Symbols and Punctuation"](c) || ko["CJK Unified Ideographs Extension A"](c) || ko["CJK Unified Ideographs"](c) || ko["Enclosed CJK Letters and Months"](c) || ko["Halfwidth and Fullwidth Forms"](c) || ko.Hiragana(c) || ko["Ideographic Description Characters"](c) || ko["Kangxi Radicals"](c) || ko["Katakana Phonetic Extensions"](c) || ko.Katakana(c) || ko["Vertical Forms"](c) || ko["Yi Radicals"](c) || ko["Yi Syllables"](c)));
                        (sy[p] || e || h.imageName) && a.push(uy(r + 1, u, o, a, ly(p, t1.getCodePoint(r + 1), e && l), !1));
                    }
                }
                var c;
                return cy(uy(t1.length(), u, o, a, 0, !0));
            }(m, u, s, e, n, f), { processBidirectionalText: x, processStyledBidirectionalText: b } = Zo;
            if (x && 1 === m.sections.length) {
                const t1 = x(m.toString(), g);
                for (const e of t1){
                    const t1 = new ry;
                    t1.text = e, t1.sections = m.sections;
                    for(let r = 0; r < e.length; r++)t1.sectionIndex.push(0);
                    y.push(t1);
                }
            } else if (b) {
                const t1 = b(m.text, m.sectionIndex, g);
                for (const e of t1){
                    const t1 = new ry;
                    t1.text = e[0], t1.sectionIndex = e[1], t1.sections = m.sections, y.push(t1);
                }
            } else y = function(t1, e) {
                const r = [], n = t1.text;
                let i = 0;
                for (const n of e)r.push(t1.substring(i, n)), i = n;
                return i < n.length && r.push(t1.substring(i, n.length)), r;
            }(m, g);
            const v = [], _ = {
                positionedLines: v,
                text: m.toString(),
                top: c[1],
                bottom: c[1],
                left: c[0],
                right: c[0],
                writingMode: h,
                iconsInText: !1,
                verticalizable: !1,
                hasBaseline: !1
            };
            return function(t1, e, r, n, i, s, a, o, l, u, c, h) {
                let p = 0, f = 0, d = 0;
                const m = "right" === o ? 1 : "left" === o ? 0 : .5;
                let y = !1;
                for (const t1 of i){
                    const r = t1.getSections();
                    for (const t1 of r){
                        if (t1.imageName) continue;
                        const r = e[t1.fontStack];
                        if (r && (y = void 0 !== r.ascender && void 0 !== r.descender, !y)) break;
                    }
                    if (!y) break;
                }
                let g = 0;
                for (const a of i){
                    a.trim();
                    const i = a.getMaxScale(), o = (i - 1) * Fm, b = {
                        positionedGlyphs: [],
                        lineOffset: 0
                    };
                    t1.positionedLines[g] = b;
                    const v = b.positionedGlyphs;
                    let _ = 0;
                    if (!a.length()) {
                        f += s, ++g;
                        continue;
                    }
                    let w = 0, M = 0;
                    for(let s = 0; s < a.length(); s++){
                        const o = a.getSection(s), d = a.getSectionIndex(s), m = a.getCodePoint(s);
                        let g = o.scale, b = null, A = null, S = null, I = Fm, T = 0;
                        const k = !(l === ty.horizontal || !c && !Bo(m) || c && (iy[m] || (x = m, ko.Arabic(x) || ko["Arabic Supplement"](x) || ko["Arabic Extended-A"](x) || ko["Arabic Presentation Forms-A"](x) || ko["Arabic Presentation Forms-B"](x))));
                        if (o.imageName) {
                            const e = n[o.imageName];
                            if (!e) continue;
                            S = o.imageName, t1.iconsInText = t1.iconsInText || !0, A = e.paddedRect;
                            const r = e.displaySize;
                            g = g * Fm / h, b = {
                                width: r[0],
                                height: r[1],
                                left: 0,
                                top: -Qm,
                                advance: k ? r[1] : r[0],
                                localGlyph: !1
                            }, T = y ? -b.height * g : i * Fm - 17 - r[1] * g, I = b.advance;
                            const s = (k ? r[0] : r[1]) * g - Fm * i;
                            s > 0 && s > _ && (_ = s);
                        } else {
                            const t1 = r[o.fontStack];
                            if (!t1) continue;
                            t1[m] && (A = t1[m]);
                            const n = e[o.fontStack];
                            if (!n) continue;
                            const s = n.glyphs[m];
                            if (!s) continue;
                            if (b = s.metrics, I = 8203 !== m ? Fm : 0, y) {
                                const t1 = void 0 !== n.ascender ? Math.abs(n.ascender) : 0, e = void 0 !== n.descender ? Math.abs(n.descender) : 0, r = (t1 + e) * g;
                                w < r && (w = r, M = (t1 - e) / 2 * g), T = -t1 * g;
                            } else T = (i - g) * Fm - 17;
                        }
                        k ? (t1.verticalizable = !0, v.push({
                            glyph: m,
                            imageName: S,
                            x: p,
                            y: f + T,
                            vertical: k,
                            scale: g,
                            localGlyph: b.localGlyph,
                            fontStack: o.fontStack,
                            sectionIndex: d,
                            metrics: b,
                            rect: A
                        }), p += I * g + u) : (v.push({
                            glyph: m,
                            imageName: S,
                            x: p,
                            y: f + T,
                            vertical: k,
                            scale: g,
                            localGlyph: b.localGlyph,
                            fontStack: o.fontStack,
                            sectionIndex: d,
                            metrics: b,
                            rect: A
                        }), p += b.advance * g + u);
                    }
                    0 !== v.length && (d = Math.max(p - u, d), y ? py(v, m, _, M, s * i / 2) : py(v, m, _, 0, s / 2)), p = 0;
                    const A = s * i + _;
                    b.lineOffset = Math.max(_, o), f += A, ++g;
                }
                var x;
                const b = f, { horizontalAlign: v, verticalAlign: _ } = hy(a);
                (function(t1, e, r, n, i, s) {
                    const a = (e - r) * i, o = -s * n;
                    for (const e of t1)for (const t1 of e.positionedGlyphs)t1.x += a, t1.y += o;
                })(t1.positionedLines, m, v, _, d, b), t1.top += -_ * b, t1.bottom = t1.top + b, t1.left += -v * d, t1.right = t1.left + d, t1.hasBaseline = y;
            }(_, e, r, n, y, a, o, l, h, u, p, d), !function(t1) {
                for (const e of t1)if (0 !== e.positionedGlyphs.length) return !1;
                return !0;
            }(v) && _;
        }
        const iy = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
        }, sy = {
            10: !0,
            32: !0,
            38: !0,
            40: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
        };
        function ay(t1, e, r, n, i, s) {
            if (e.imageName) {
                const t1 = n[e.imageName];
                return t1 ? t1.displaySize[0] * e.scale * Fm / s + i : 0;
            }
            {
                const n = r[e.fontStack], s = n && n.glyphs[t1];
                return s ? s.metrics.advance * e.scale + i : 0;
            }
        }
        function oy(t1, e, r, n) {
            const i = Math.pow(t1 - e, 2);
            return n ? t1 < e ? i / 2 : 2 * i : i + Math.abs(r) * r;
        }
        function ly(t1, e, r) {
            let n = 0;
            return 10 === t1 && (n -= 1e4), r && (n += 150), 40 !== t1 && 65288 !== t1 || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;
        }
        function uy(t1, e, r, n, i, s) {
            let a = null, o = oy(e, r, i, s);
            for (const t1 of n){
                const n = oy(e - t1.x, r, i, s) + t1.badness;
                n <= o && (a = t1, o = n);
            }
            return {
                index: t1,
                x: e,
                priorBreak: a,
                badness: o
            };
        }
        function cy(t1) {
            return t1 ? cy(t1.priorBreak).concat(t1.index) : [];
        }
        function hy(t1) {
            let e = .5, r = .5;
            switch(t1){
                case "right":
                case "top-right":
                case "bottom-right":
                    e = 1;
                    break;
                case "left":
                case "top-left":
                case "bottom-left":
                    e = 0;
            }
            switch(t1){
                case "bottom":
                case "bottom-right":
                case "bottom-left":
                    r = 1;
                    break;
                case "top":
                case "top-right":
                case "top-left":
                    r = 0;
            }
            return {
                horizontalAlign: e,
                verticalAlign: r
            };
        }
        function py(t1, e, r, n, i) {
            if (!(e || r || n || i)) return;
            const s = t1.length - 1, a = t1[s], o = (a.x + a.metrics.advance * a.scale) * e;
            for(let e = 0; e <= s; e++)t1[e].x -= o, t1[e].y += r + n + i;
        }
        function fy(t1, e, r, n) {
            const { horizontalAlign: i, verticalAlign: s } = hy(n), a = r[0] - t1.displaySize[0] * i, o = r[1] - t1.displaySize[1] * s;
            return {
                imagePrimary: t1,
                imageSecondary: e,
                top: o,
                bottom: o + t1.displaySize[1],
                left: a,
                right: a + t1.displaySize[0]
            };
        }
        function dy(t1, e, r, n, i, s) {
            const a = t1.imagePrimary;
            let o;
            if (a.content) {
                const t1 = a.content, e = a.pixelRatio || 1;
                o = [
                    t1[0] / e,
                    t1[1] / e,
                    a.displaySize[0] - t1[2] / e,
                    a.displaySize[1] - t1[3] / e
                ];
            }
            const l = e.left * s, u = e.right * s;
            let c, h, p, f;
            "width" === r || "both" === r ? (f = i[0] + l - n[3], h = i[0] + u + n[1]) : (f = i[0] + (l + u - a.displaySize[0]) / 2, h = f + a.displaySize[0]);
            const d = e.top * s, m = e.bottom * s;
            return "height" === r || "both" === r ? (c = i[1] + d - n[0], p = i[1] + m + n[2]) : (c = i[1] + (d + m - a.displaySize[1]) / 2, p = c + a.displaySize[1]), {
                imagePrimary: a,
                imageSecondary: void 0,
                top: c,
                right: h,
                bottom: p,
                left: f,
                collisionPadding: o
            };
        }
        class my extends Ne {
            constructor(t1, e, r, n, i){
                super(t1, e), this.angle = n, this.z = r, void 0 !== i && (this.segment = i);
            }
            clone() {
                return new my(this.x, this.y, this.z, this.angle, this.segment);
            }
        }
        function yy(t1, e, r, n, i) {
            if (void 0 === e.segment) return !0;
            let s = e, a = e.segment + 1, o = 0;
            for(; o > -r / 2;){
                if (a--, a < 0) return !1;
                o -= t1[a].dist(s), s = t1[a];
            }
            o += t1[a].dist(t1[a + 1]), a++;
            const l = [];
            let u = 0;
            for(; o < r / 2;){
                const e = t1[a], r = t1[a + 1];
                if (!r) return !1;
                let s = t1[a - 1].angleTo(e) - e.angleTo(r);
                for(s = Math.abs((s + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({
                    distance: o,
                    angleDelta: s
                }), u += s; o - l[0].distance > n;)u -= l.shift().angleDelta;
                if (u > i) return !1;
                a++, o += e.dist(r);
            }
            return !0;
        }
        function gy(t1) {
            let e = 0;
            for(let r = 0; r < t1.length - 1; r++)e += t1[r].dist(t1[r + 1]);
            return e;
        }
        function xy(t1, e, r) {
            return t1 ? .6 * e * r : 0;
        }
        function by(t1, e) {
            return Math.max(t1 ? t1.right - t1.left : 0, e ? e.right - e.left : 0);
        }
        function vy(t1, e, r, n, i, s) {
            const a = xy(r, i, s), o = by(r, n) * s;
            let l = 0;
            const u = gy(t1) / 2;
            for(let r = 0; r < t1.length - 1; r++){
                const n = t1[r], i = t1[r + 1], s = n.dist(i);
                if (l + s > u) {
                    const c = (u - l) / s, h = Gn(n.x, i.x, c), p = Gn(n.y, i.y, c), f = new my(h, p, 0, i.angleTo(n), r);
                    return !a || yy(t1, f, o, a, e) ? f : void 0;
                }
                l += s;
            }
        }
        function _y(t1, e, r, n, i, s, a, o, l) {
            const u = xy(n, s, a), c = by(n, i), h = c * a, p = 0 === t1[0].x || t1[0].x === l || 0 === t1[0].y || t1[0].y === l;
            return e - h < e / 4 && (e = h + e / 4), wy(t1, p ? e / 2 * o % e : (c / 2 + 2 * s) * a * o % e, e, u, r, h, p, !1, l);
        }
        function wy(t1, e, r, n, i, s, a, o, l) {
            const u = s / 2, c = gy(t1);
            let h = 0, p = e - r, f = [];
            for(let e = 0; e < t1.length - 1; e++){
                const a = t1[e], o = t1[e + 1], d = a.dist(o), m = o.angleTo(a);
                for(; p + r < h + d;){
                    p += r;
                    const y = (p - h) / d, g = Gn(a.x, o.x, y), x = Gn(a.y, o.y, y);
                    if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {
                        const r = new my(g, x, 0, m, e);
                        n && !yy(t1, r, s, n, i) || f.push(r);
                    }
                }
                h += d;
            }
            return o || f.length || a || (f = wy(t1, h / 2, r, n, i, s, a, !0, l)), f;
        }
        function My(t1, e, r, n, i) {
            const s = [];
            for(let a = 0; a < t1.length; a++){
                const o = t1[a];
                let l;
                for(let t1 = 0; t1 < o.length - 1; t1++){
                    let a = o[t1], u = o[t1 + 1];
                    a.x < e && u.x < e || (a.x < e ? a = new Ne(e, a.y + (e - a.x) / (u.x - a.x) * (u.y - a.y))._round() : u.x < e && (u = new Ne(e, a.y + (e - a.x) / (u.x - a.x) * (u.y - a.y))._round()), a.y < r && u.y < r || (a.y < r ? a = new Ne(a.x + (r - a.y) / (u.y - a.y) * (u.x - a.x), r)._round() : u.y < r && (u = new Ne(a.x + (r - a.y) / (u.y - a.y) * (u.x - a.x), r)._round()), a.x >= n && u.x >= n || (a.x >= n ? a = new Ne(n, a.y + (n - a.x) / (u.x - a.x) * (u.y - a.y))._round() : u.x >= n && (u = new Ne(n, a.y + (n - a.x) / (u.x - a.x) * (u.y - a.y))._round()), a.y >= i && u.y >= i || (a.y >= i ? a = new Ne(a.x + (i - a.y) / (u.y - a.y) * (u.x - a.x), i)._round() : u.y >= i && (u = new Ne(a.x + (i - a.y) / (u.y - a.y) * (u.x - a.x), i)._round()), l && a.equals(l[l.length - 1]) || (l = [
                        a
                    ], s.push(l)), l.push(u)))));
                }
            }
            return s;
        }
        function Ay(t1) {
            let e = 0, r = 0;
            for (const n of t1)e += n.w * n.h, r = Math.max(r, n.w);
            t1.sort((t1, e)=>e.h - t1.h);
            const n = [
                {
                    x: 0,
                    y: 0,
                    w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),
                    h: 1 / 0
                }
            ];
            let i = 0, s = 0;
            for (const e of t1)for(let t1 = n.length - 1; t1 >= 0; t1--){
                const r = n[t1];
                if (!(e.w > r.w || e.h > r.h)) {
                    if (e.x = r.x, e.y = r.y, s = Math.max(s, e.y + e.h), i = Math.max(i, e.x + e.w), e.w === r.w && e.h === r.h) {
                        const e = n.pop();
                        t1 < n.length && (n[t1] = e);
                    } else e.h === r.h ? (r.x += e.w, r.w -= e.w) : e.w === r.w ? (r.y += e.h, r.h -= e.h) : (n.push({
                        x: r.x + e.w,
                        y: r.y,
                        w: r.w - e.w,
                        h: e.h
                    }), r.y += e.h, r.h -= e.h);
                    break;
                }
            }
            return {
                w: i,
                h: s,
                fill: e / (i * s) || 0
            };
        }
        Mo(my, "Anchor");
        const Sy = 1;
        class Iy {
            constructor(t1, { pixelRatio: e, version: r, stretchX: n, stretchY: i, content: s }){
                this.paddedRect = t1, this.pixelRatio = e, this.stretchX = n, this.stretchY = i, this.content = s, this.version = r;
            }
            get tl() {
                return [
                    this.paddedRect.x + Sy,
                    this.paddedRect.y + Sy
                ];
            }
            get br() {
                return [
                    this.paddedRect.x + this.paddedRect.w - Sy,
                    this.paddedRect.y + this.paddedRect.h - Sy
                ];
            }
            get displaySize() {
                return [
                    (this.paddedRect.w - 2 * Sy) / this.pixelRatio,
                    (this.paddedRect.h - 2 * Sy) / this.pixelRatio
                ];
            }
        }
        class Ty {
            constructor(t1, e, r){
                const n = {}, i = {};
                this.haveRenderCallbacks = [];
                const s = [];
                this.addImages(t1, n, s), this.addImages(e, i, s);
                const { w: a, h: o } = Ay(s), l = new fp({
                    width: a || 1,
                    height: o || 1
                });
                for(const e in t1){
                    const i = t1[e], s = n[e].paddedRect;
                    fp.copy(i.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: s.x + Sy,
                        y: s.y + Sy
                    }, i.data, r, i.sdf);
                }
                for(const t1 in e){
                    const n = e[t1], s = i[t1].paddedRect, a = s.x + Sy, o = s.y + Sy, u = n.data.width, c = n.data.height;
                    fp.copy(n.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: a,
                        y: o
                    }, n.data, r), fp.copy(n.data, l, {
                        x: 0,
                        y: c - 1
                    }, {
                        x: a,
                        y: o - 1
                    }, {
                        width: u,
                        height: 1
                    }, r), fp.copy(n.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: a,
                        y: o + c
                    }, {
                        width: u,
                        height: 1
                    }, r), fp.copy(n.data, l, {
                        x: u - 1,
                        y: 0
                    }, {
                        x: a - 1,
                        y: o
                    }, {
                        width: 1,
                        height: c
                    }, r), fp.copy(n.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: a + u,
                        y: o
                    }, {
                        width: 1,
                        height: c
                    }, r);
                }
                this.image = l, this.iconPositions = n, this.patternPositions = i;
            }
            addImages(t1, e, r) {
                for(const n in t1){
                    const i = t1[n], s = {
                        x: 0,
                        y: 0,
                        w: i.data.width + 2 * Sy,
                        h: i.data.height + 2 * Sy
                    };
                    r.push(s), e[n] = new Iy(s, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n);
                }
            }
            patchUpdatedImages(t1, e, r) {
                this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e)=>t1.hasImage(e, r)), t1.dispatchRenderCallbacks(this.haveRenderCallbacks, r);
                for(const n in t1.getUpdatedImages(r))this.patchUpdatedImage(this.iconPositions[n], t1.getImage(n, r), e), this.patchUpdatedImage(this.patternPositions[n], t1.getImage(n, r), e);
            }
            patchUpdatedImage(t1, e, r) {
                if (!t1 || !e) return;
                if (t1.version === e.version) return;
                t1.version = e.version;
                const [n, i] = t1.tl, s = !!Object.keys(this.patternPositions).length;
                r.update(e.data, {
                    useMipmap: s
                }, {
                    x: n,
                    y: i
                });
            }
        }
        Mo(Iy, "ImagePosition"), Mo(Ty, "ImageAtlas");
        const ky = 1e20;
        function Py(t1, e, r, n, i, s, a, o, l) {
            for(let u = e; u < e + n; u++)zy(t1, r * s + u, s, i, a, o, l);
            for(let u = r; u < r + i; u++)zy(t1, u * s + e, 1, n, a, o, l);
        }
        function zy(t1, e, r, n, i, s, a) {
            s[0] = 0, a[0] = -ky, a[1] = ky, i[0] = t1[e];
            for(let o = 1, l = 0, u = 0; o < n; o++){
                i[o] = t1[e + o * r];
                const n = o * o;
                do {
                    const t1 = s[l];
                    u = (i[o] - i[t1] + n - t1 * t1) / (o - t1) / 2;
                }while (u <= a[l] && --l > -1);
                l++, s[l] = o, a[l] = u, a[l + 1] = ky;
            }
            for(let o = 0, l = 0; o < n; o++){
                for(; a[l + 1] < o;)l++;
                const n = s[l], u = o - n;
                t1[e + o * r] = i[n] + u * u;
            }
        }
        const Ey = 2, By = {
            none: 0,
            ideographs: 1,
            all: 2
        };
        class Dy {
            constructor(t1, e, r){
                this.requestManager = t1, this.localGlyphMode = e, this.localFontFamily = r, this.urls = {}, this.entries = {}, this.localGlyphs = {
                    200: {},
                    400: {},
                    500: {},
                    900: {}
                };
            }
            setURL(t1, e) {
                this.urls[e] = t1;
            }
            getGlyphs(t1, e, r) {
                const i = [], s = this.urls[e] || n.GLYPHS_URL;
                for(const e in t1)for (const r of t1[e])i.push({
                    stack: e,
                    id: r
                });
                Qe(i, ({ stack: t1, id: e }, r)=>{
                    let n = this.entries[t1];
                    n || (n = this.entries[t1] = {
                        glyphs: {},
                        requests: {},
                        ranges: {},
                        ascender: void 0,
                        descender: void 0
                    });
                    let i = n.glyphs[e];
                    if (void 0 !== i) return void r(null, {
                        stack: t1,
                        id: e,
                        glyph: i
                    });
                    if (i = this._tinySDF(n, t1, e), i) return n.glyphs[e] = i, void r(null, {
                        stack: t1,
                        id: e,
                        glyph: i
                    });
                    const a = Math.floor(e / 256);
                    if (256 * a > 65535) return void r(new Error("glyphs > 65535 not supported"));
                    if (n.ranges[a]) return void r(null, {
                        stack: t1,
                        id: e,
                        glyph: i
                    });
                    let o = n.requests[a];
                    o || (o = n.requests[a] = [], Dy.loadGlyphRange(t1, a, s, this.requestManager, (t1, e)=>{
                        if (e) {
                            n.ascender = e.ascender, n.descender = e.descender;
                            for(const t1 in e.glyphs)this._doesCharSupportLocalGlyph(+t1) || (n.glyphs[+t1] = e.glyphs[+t1]);
                            n.ranges[a] = !0;
                        }
                        for (const r of o)r(t1, e);
                        delete n.requests[a];
                    })), o.push((n, i)=>{
                        n ? r(n) : i && r(null, {
                            stack: t1,
                            id: e,
                            glyph: i.glyphs[e] || null
                        });
                    });
                }, (t1, e)=>{
                    if (t1) r(t1);
                    else if (e) {
                        const t1 = {};
                        for (const { stack: r, id: n, glyph: i } of e)void 0 === t1[r] && (t1[r] = {}), void 0 === t1[r].glyphs && (t1[r].glyphs = {}), t1[r].glyphs[n] = i && {
                            id: i.id,
                            bitmap: i.bitmap.clone(),
                            metrics: i.metrics
                        }, t1[r].ascender = this.entries[r].ascender, t1[r].descender = this.entries[r].descender;
                        r(null, t1);
                    }
                });
            }
            _doesCharSupportLocalGlyph(t1) {
                return this.localGlyphMode !== By.none && (this.localGlyphMode === By.all ? !!this.localFontFamily : !!this.localFontFamily && (ko["CJK Unified Ideographs"](t1) || ko["Hangul Syllables"](t1) || ko.Hiragana(t1) || ko.Katakana(t1) || ko["CJK Symbols and Punctuation"](t1) || ko["CJK Unified Ideographs Extension A"](t1) || ko["CJK Unified Ideographs Extension B"](t1)));
            }
            _tinySDF(t1, e, r) {
                const n = this.localFontFamily;
                if (!n || !this._doesCharSupportLocalGlyph(r)) return;
                let i = t1.tinySDF;
                if (!i) {
                    let r = "400";
                    /bold/i.test(e) ? r = "900" : /medium/i.test(e) ? r = "500" : /light/i.test(e) && (r = "200"), i = t1.tinySDF = new Dy.TinySDF({
                        fontFamily: n,
                        fontWeight: r,
                        fontSize: 24 * Ey,
                        buffer: 3 * Ey,
                        radius: 8 * Ey
                    }), i.fontWeight = r;
                }
                if (this.localGlyphs[i.fontWeight][r]) return this.localGlyphs[i.fontWeight][r];
                const s = String.fromCodePoint(r), { data: a, width: o, height: l, glyphWidth: u, glyphHeight: c, glyphLeft: h, glyphTop: p, glyphAdvance: f } = i.draw(s);
                return this.localGlyphs[i.fontWeight][r] = {
                    id: r,
                    bitmap: new pp({
                        width: o,
                        height: l
                    }, a),
                    metrics: {
                        width: u / Ey,
                        height: c / Ey,
                        left: h / Ey,
                        top: p / Ey - 27,
                        advance: f / Ey,
                        localGlyph: !0
                    }
                };
            }
        }
        Dy.loadGlyphRange = function(t1, e, r, n, i) {
            const s = 256 * e, a = s + 255, o = n.transformRequest(n.normalizeGlyphsURL(r).replace("{fontstack}", t1).replace("{range}", `${s}-${a}`), Wr.Glyphs);
            en(o, (t1, e)=>{
                if (t1) i(t1);
                else if (e) {
                    const t1 = {}, r = function(t1) {
                        return new Bm(t1).readFields(Km, {});
                    }(e);
                    for (const e of r.glyphs)t1[e.id] = e;
                    i(null, {
                        glyphs: t1,
                        ascender: r.ascender,
                        descender: r.descender
                    });
                }
            });
        }, Dy.TinySDF = class {
            constructor({ fontSize: t1 = 24, buffer: e = 3, radius: r = 8, cutoff: n = .25, fontFamily: i = "sans-serif", fontWeight: s = "normal", fontStyle: a = "normal" } = {}){
                this.buffer = e, this.cutoff = n, this.radius = r;
                const o = this.size = t1 + 4 * e, l = this._createCanvas(o), u = this.ctx = l.getContext("2d", {
                    willReadFrequently: !0
                });
                u.font = `${a} ${s} ${t1}px ${i}`, u.textBaseline = "alphabetic", u.textAlign = "left", u.fillStyle = "black", this.gridOuter = new Float64Array(o * o), this.gridInner = new Float64Array(o * o), this.f = new Float64Array(o), this.z = new Float64Array(o + 1), this.v = new Uint16Array(o);
            }
            _createCanvas(t1) {
                const e = document.createElement("canvas");
                return e.width = e.height = t1, e;
            }
            draw(t1) {
                const { width: e, actualBoundingBoxAscent: r, actualBoundingBoxDescent: n, actualBoundingBoxLeft: i, actualBoundingBoxRight: s } = this.ctx.measureText(t1), a = Math.ceil(r), o = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s - i))), l = Math.min(this.size - this.buffer, a + Math.ceil(n)), u = o + 2 * this.buffer, c = l + 2 * this.buffer, h = Math.max(u * c, 0), p = new Uint8ClampedArray(h), f = {
                    data: p,
                    width: u,
                    height: c,
                    glyphWidth: o,
                    glyphHeight: l,
                    glyphTop: a,
                    glyphLeft: 0,
                    glyphAdvance: e
                };
                if (0 === o || 0 === l) return f;
                const { ctx: d, buffer: m, gridInner: y, gridOuter: g } = this;
                d.clearRect(m, m, o, l), d.fillText(t1, m, m + a);
                const x = d.getImageData(m, m, o, l);
                g.fill(ky, 0, h), y.fill(0, 0, h);
                for(let t1 = 0; t1 < l; t1++)for(let e = 0; e < o; e++){
                    const r = x.data[4 * (t1 * o + e) + 3] / 255;
                    if (0 === r) continue;
                    const n = (t1 + m) * u + e + m;
                    if (1 === r) g[n] = 0, y[n] = ky;
                    else {
                        const t1 = .5 - r;
                        g[n] = t1 > 0 ? t1 * t1 : 0, y[n] = t1 < 0 ? t1 * t1 : 0;
                    }
                }
                Py(g, 0, 0, u, c, u, this.f, this.v, this.z), Py(y, m, m, o, l, u, this.f, this.v, this.z);
                for(let t1 = 0; t1 < h; t1++){
                    const e = Math.sqrt(g[t1]) - Math.sqrt(y[t1]);
                    p[t1] = Math.round(255 - 255 * (e / this.radius + this.cutoff));
                }
                return f;
            }
        };
        const Cy = Sy;
        function Ry(t1, e, r, n) {
            const i = [], s = t1.imagePrimary, a = s.pixelRatio, o = s.paddedRect.w - 2 * Cy, l = s.paddedRect.h - 2 * Cy, u = t1.right - t1.left, c = t1.bottom - t1.top, h = s.stretchX || [
                [
                    0,
                    o
                ]
            ], p = s.stretchY || [
                [
                    0,
                    l
                ]
            ], f = (t1, e)=>t1 + e[1] - e[0], d = h.reduce(f, 0), m = p.reduce(f, 0), y = o - d, g = l - m;
            let x = 0, b = d, v = 0, _ = m, w = 0, M = y, A = 0, S = g;
            if (s.content && n) {
                const t1 = s.content;
                x = Vy(h, 0, t1[0]), v = Vy(p, 0, t1[1]), b = Vy(h, t1[0], t1[2]), _ = Vy(p, t1[1], t1[3]), w = t1[0] - x, A = t1[1] - v, M = t1[2] - t1[0] - b, S = t1[3] - t1[1] - _;
            }
            const I = (n, i, o, l)=>{
                const h = Oy(n.stretch - x, b, u, t1.left), p = Fy(n.fixed - w, M, n.stretch, d), f = Oy(i.stretch - v, _, c, t1.top), y = Fy(i.fixed - A, S, i.stretch, m), g = Oy(o.stretch - x, b, u, t1.left), I = Fy(o.fixed - w, M, o.stretch, d), T = Oy(l.stretch - v, _, c, t1.top), k = Fy(l.fixed - A, S, l.stretch, m), P = new Ne(h, f), z = new Ne(g, f), E = new Ne(g, T), B = new Ne(h, T), D = new Ne(p / a, y / a), C = new Ne(I / a, k / a), R = e * Math.PI / 180;
                if (R) {
                    const t1 = Math.sin(R), e = Math.cos(R), r = [
                        e,
                        -t1,
                        t1,
                        e
                    ];
                    P._matMult(r), z._matMult(r), B._matMult(r), E._matMult(r);
                }
                const V = n.stretch + n.fixed, L = o.stretch + o.fixed, O = i.stretch + i.fixed, F = l.stretch + l.fixed, U = t1.imageSecondary;
                return {
                    tl: P,
                    tr: z,
                    bl: B,
                    br: E,
                    texPrimary: {
                        x: s.paddedRect.x + Cy + V,
                        y: s.paddedRect.y + Cy + O,
                        w: L - V,
                        h: F - O
                    },
                    texSecondary: U ? {
                        x: U.paddedRect.x + Cy + V,
                        y: U.paddedRect.y + Cy + O,
                        w: L - V,
                        h: F - O
                    } : void 0,
                    writingMode: void 0,
                    glyphOffset: [
                        0,
                        0
                    ],
                    sectionIndex: 0,
                    pixelOffsetTL: D,
                    pixelOffsetBR: C,
                    minFontScaleX: M / a / u,
                    minFontScaleY: S / a / c,
                    isSDF: r
                };
            };
            if (n && (s.stretchX || s.stretchY)) {
                const t1 = Ly(h, y, d), e = Ly(p, g, m);
                for(let r = 0; r < t1.length - 1; r++){
                    const n = t1[r], s = t1[r + 1];
                    for(let t1 = 0; t1 < e.length - 1; t1++)i.push(I(n, e[t1], s, e[t1 + 1]));
                }
            } else i.push(I({
                fixed: 0,
                stretch: -1
            }, {
                fixed: 0,
                stretch: -1
            }, {
                fixed: 0,
                stretch: o + 1
            }, {
                fixed: 0,
                stretch: l + 1
            }));
            return i;
        }
        function Vy(t1, e, r) {
            let n = 0;
            for (const i of t1)n += Math.max(e, Math.min(r, i[1])) - Math.max(e, Math.min(r, i[0]));
            return n;
        }
        function Ly(t1, e, r) {
            const n = [
                {
                    fixed: -Cy,
                    stretch: 0
                }
            ];
            for (const [e, r] of t1){
                const t1 = n[n.length - 1];
                n.push({
                    fixed: e - t1.stretch,
                    stretch: t1.stretch
                }), n.push({
                    fixed: e - t1.stretch,
                    stretch: t1.stretch + (r - e)
                });
            }
            return n.push({
                fixed: e + Cy,
                stretch: r
            }), n;
        }
        function Oy(t1, e, r, n) {
            return t1 / e * r + n;
        }
        function Fy(t1, e, r, n) {
            return t1 - e * r / n;
        }
        function Uy(t1, e, r, n) {
            const i = e + t1.positionedLines[n].lineOffset;
            return 0 === n ? r + i / 2 : r + (i + (e + t1.positionedLines[n - 1].lineOffset)) / 2;
        }
        function Ny(t1, e = 1, r = !1) {
            let n = 1 / 0, i = 1 / 0, s = -1 / 0, a = -1 / 0;
            const o = t1[0];
            for(let t1 = 0; t1 < o.length; t1++){
                const e = o[t1];
                (!t1 || e.x < n) && (n = e.x), (!t1 || e.y < i) && (i = e.y), (!t1 || e.x > s) && (s = e.x), (!t1 || e.y > a) && (a = e.y);
            }
            const l = Math.min(s - n, a - i);
            let u = l / 2;
            const c = new hs([], jy);
            if (0 === l) return new Ne(n, i);
            for(let e = n; e < s; e += l)for(let r = i; r < a; r += l)c.push(new qy(e + u, r + u, u, t1));
            let h = function(t1) {
                let e = 0, r = 0, n = 0;
                const i = t1[0];
                for(let t1 = 0, s = i.length, a = s - 1; t1 < s; a = t1++){
                    const s = i[t1], o = i[a], l = s.x * o.y - o.x * s.y;
                    r += (s.x + o.x) * l, n += (s.y + o.y) * l, e += 3 * l;
                }
                return new qy(r / e, n / e, 0, t1);
            }(t1), p = c.length;
            for(; c.length;){
                const n = c.pop();
                (n.d > h.d || !h.d) && (h = n, r && console.log("found best %d after %d probes", Math.round(1e4 * n.d) / 1e4, p)), n.max - h.d <= e || (u = n.h / 2, c.push(new qy(n.p.x - u, n.p.y - u, u, t1)), c.push(new qy(n.p.x + u, n.p.y - u, u, t1)), c.push(new qy(n.p.x - u, n.p.y + u, u, t1)), c.push(new qy(n.p.x + u, n.p.y + u, u, t1)), p += 4);
            }
            return r && (console.log(`num probes: ${p}`), console.log(`best distance: ${h.d}`)), h.p;
        }
        function jy(t1, e) {
            return e.max - t1.max;
        }
        class qy {
            constructor(t1, e, r, n){
                this.p = new Ne(t1, e), this.h = r, this.d = function(t1, e) {
                    let r = !1, n = 1 / 0;
                    for(let i = 0; i < e.length; i++){
                        const s = e[i];
                        for(let e = 0, i = s.length, a = i - 1; e < i; a = e++){
                            const i = s[e], o = s[a];
                            i.y > t1.y != o.y > t1.y && t1.x < (o.x - i.x) * (t1.y - i.y) / (o.y - i.y) + i.x && (r = !r), n = Math.min(n, ih(t1, i, o));
                        }
                    }
                    return (r ? 1 : -1) * Math.sqrt(n);
                }(this.p, n), this.max = this.d + this.h * Math.SQRT2;
            }
        }
        const $y = Number.POSITIVE_INFINITY, Gy = Math.sqrt(2);
        function Yy(t1, [e, r]) {
            let n = 0, i = 0;
            if (r === $y) {
                e < 0 && (e = 0);
                const r = e / Gy;
                switch(t1){
                    case "top-right":
                    case "top-left":
                        i = r - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                        i = 7 - r;
                        break;
                    case "bottom":
                        i = 7 - e;
                        break;
                    case "top":
                        i = e - 7;
                }
                switch(t1){
                    case "top-right":
                    case "bottom-right":
                        n = -r;
                        break;
                    case "top-left":
                    case "bottom-left":
                        n = r;
                        break;
                    case "left":
                        n = e;
                        break;
                    case "right":
                        n = -e;
                }
            } else {
                switch(e = Math.abs(e), r = Math.abs(r), t1){
                    case "top-right":
                    case "top-left":
                    case "top":
                        i = r - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                    case "bottom":
                        i = 7 - r;
                }
                switch(t1){
                    case "top-right":
                    case "bottom-right":
                    case "right":
                        n = -e;
                        break;
                    case "top-left":
                    case "bottom-left":
                    case "left":
                        n = e;
                }
            }
            return [
                n,
                i
            ];
        }
        function Xy(t1) {
            switch(t1){
                case "right":
                case "top-right":
                case "bottom-right":
                    return "right";
                case "left":
                case "top-left":
                case "bottom-left":
                    return "left";
            }
            return "center";
        }
        function Zy(t1, e, r, n, i, s, a, o, l, u, c, h, p, f, d) {
            let m = s.textMaxSize.evaluate(e, {}, h);
            void 0 === m && (m = a);
            const y = t1.layers[0].layout, g = y.get("icon-offset").evaluate(e, {}, h), x = Jy(r.horizontal) || r.vertical, b = "globe" === p.name, v = Fm, _ = a / v, w = t1.tilePixelRatio * m / v, M = (E = t1.overscaling, t1.zoom > 18 && E > 2 && (E >>= 1), Math.max(ps / (512 * E), 1) * y.get("symbol-spacing")), A = y.get("text-padding") * t1.tilePixelRatio, S = y.get("icon-padding") * t1.tilePixelRatio, I = $e(y.get("text-max-angle")), T = "map" === y.get("text-rotation-alignment") && "point" !== y.get("symbol-placement"), k = "map" === y.get("icon-rotation-alignment") && "point" !== y.get("symbol-placement"), P = y.get("symbol-placement"), z = M / 2;
            var E;
            const B = y.get("icon-text-fit").evaluate(e, {}, h), D = y.get("icon-text-fit-padding").evaluate(e, {}, h), C = "none" !== B;
            let R;
            !1 === t1.hasAnyIconTextFit && C && (t1.hasAnyIconTextFit = !0), n && C && (t1.allowVerticalPlacement && r.vertical && (R = dy(n, r.vertical, B, D, g, _)), x && (n = dy(n, x, B, D, g, _)));
            const V = (a, o, m)=>{
                if (o.x < 0 || o.x >= ps || o.y < 0 || o.y >= ps) return;
                let y = null;
                if (b) {
                    const { x: t1, y: e, z: r } = p.projectTilePoint(o.x, o.y, m);
                    y = {
                        anchor: new my(t1, e, r, 0, void 0),
                        up: p.upVector(m, o.x, o.y)
                    };
                }
                !function(t1, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g, x, b, v, _, w, M, A, S, I) {
                    const T = t1.addToLineVertexArray(e, n);
                    let k, P, z, E, B, D, C, R = 0, V = 0, L = 0, O = 0, F = -1, U = -1;
                    const N = {};
                    let j = Bn("");
                    const q = r ? r.anchor : e, $ = "none" !== l.layout.get("icon-text-fit").evaluate(v, {}, A);
                    let G = 0, Y = 0;
                    if (void 0 === l._unevaluatedLayout.getValue("text-radial-offset") ? [G, Y] = l.layout.get("text-offset").evaluate(v, {}, A).map((t1)=>t1 * Fm) : (G = l.layout.get("text-radial-offset").evaluate(v, {}, A) * Fm, Y = $y), t1.allowVerticalPlacement && i.vertical) {
                        const t1 = i.vertical;
                        if (d) D = tg(t1), o && (C = tg(o));
                        else {
                            const r = l.layout.get("text-rotate").evaluate(v, {}, A) + 90;
                            z = Qy(u, q, e, c, h, p, t1, f, r, m), o && (E = Qy(u, q, e, c, h, p, o, g, r));
                        }
                    }
                    if (s) {
                        const n = l.layout.get("icon-rotate").evaluate(v, {}, A), i = Ry(s, n, w, $), a = o ? Ry(o, n, w, $) : void 0;
                        P = Qy(u, q, e, c, h, p, s, g, n), R = 4 * i.length;
                        const f = t1.iconSizeData;
                        let d = null;
                        "source" === f.kind ? (d = [
                            Um * l.layout.get("icon-size").evaluate(v, {}, A)
                        ], d[0] > Ky && fr(`${t1.layerIds[0]}: Value for "icon-size" is >= ${Hy}. Reduce your "icon-size".`)) : "composite" === f.kind && (d = [
                            Um * _.compositeIconSizes[0].evaluate(v, {}, A),
                            Um * _.compositeIconSizes[1].evaluate(v, {}, A)
                        ], (d[0] > Ky || d[1] > Ky) && fr(`${t1.layerIds[0]}: Value for "icon-size" is >= ${Hy}. Reduce your "icon-size".`)), t1.addSymbols(t1.icon, i, d, b, x, v, !1, r, e, T.lineStartIndex, T.lineLength, -1, M, A, S, I), F = t1.icon.placedSymbolArray.length - 1, a && (V = 4 * a.length, t1.addSymbols(t1.icon, a, d, b, x, v, ty.vertical, r, e, T.lineStartIndex, T.lineLength, -1, M, A, S, I), U = t1.icon.placedSymbolArray.length - 1);
                    }
                    for(const n in i.horizontal){
                        const s = i.horizontal[n];
                        k || (j = Bn(s.text), d ? B = tg(s) : k = Qy(u, q, e, c, h, p, s, f, l.layout.get("text-rotate").evaluate(v, {}, A), m));
                        const o = 1 === s.positionedLines.length;
                        if (L += Wy(t1, r, e, s, a, l, d, v, m, T, i.vertical ? ty.horizontal : ty.horizontalOnly, o ? Object.keys(i.horizontal) : [
                            n
                        ], N, F, _, M, A, S), o) break;
                    }
                    i.vertical && (O += Wy(t1, r, e, i.vertical, a, l, d, v, m, T, ty.vertical, [
                        "vertical"
                    ], N, U, _, M, A, S));
                    let X = -1;
                    const Z = (t1, e)=>t1 ? Math.max(t1, e) : e;
                    X = Z(B, X), X = Z(D, X), X = Z(C, X);
                    const H = X > -1 ? 1 : 0;
                    t1.glyphOffsetArray.length >= 65535 && fr("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== v.sortKey && t1.addToSortKeyRanges(t1.symbolInstances.length, v.sortKey), t1.symbolInstances.emplaceBack(e.x, e.y, q.x, q.y, q.z, N.right >= 0 ? N.right : -1, N.center >= 0 ? N.center : -1, N.left >= 0 ? N.left : -1, N.vertical >= 0 ? N.vertical : -1, F, U, j, void 0 !== k ? k : t1.collisionBoxArray.length, void 0 !== k ? k + 1 : t1.collisionBoxArray.length, void 0 !== z ? z : t1.collisionBoxArray.length, void 0 !== z ? z + 1 : t1.collisionBoxArray.length, void 0 !== P ? P : t1.collisionBoxArray.length, void 0 !== P ? P + 1 : t1.collisionBoxArray.length, E || t1.collisionBoxArray.length, E ? E + 1 : t1.collisionBoxArray.length, c, L, O, R, V, H, 0, G, Y, X, 0, 1, 1, $ ? 1 : 0);
                }(t1, o, y, a, r, n, i, R, t1.layers[0], t1.collisionBoxArray, e.index, e.sourceLayerIndex, t1.index, A, T, l, 0, S, k, g, e, s, u, c, h, f, d);
            };
            if ("line" === P) for (const i of My(e.geometry, 0, 0, ps, ps)){
                const e = _y(i, M, I, r.vertical || x, n, v, w, t1.overscaling, ps);
                for (const r of e)x && eg(t1, x.text, z, r) || V(i, r, h);
            }
            else if ("line-center" === P) {
                for (const t1 of e.geometry)if (t1.length > 1) {
                    const e = vy(t1, I, r.vertical || x, n, v, w);
                    e && V(t1, e, h);
                }
            } else if ("Polygon" === e.type) for (const t1 of Xp(e.geometry, 0)){
                const e = Ny(t1, 16);
                V(t1[0], new my(e.x, e.y, 0, 0, void 0), h);
            }
            else if ("LineString" === e.type) for (const t1 of e.geometry)V(t1, new my(t1[0].x, t1[0].y, 0, 0, void 0), h);
            else if ("Point" === e.type) for (const t1 of e.geometry)for (const e of t1)V([
                e
            ], new my(e.x, e.y, 0, 0, void 0), h);
        }
        const Hy = 255, Ky = Hy * Um;
        function Wy(t1, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g) {
            const x = function(t1, e, r, n, i, s, a, o) {
                const l = [];
                if (0 === e.positionedLines.length) return l;
                const u = n.layout.get("text-rotate").evaluate(s, {}) * Math.PI / 180, c = function(t1) {
                    const e = t1[0], r = t1[1], n = e * r;
                    return n > 0 ? [
                        e,
                        -r
                    ] : n < 0 ? [
                        -e,
                        r
                    ] : 0 === e ? [
                        r,
                        e
                    ] : [
                        r,
                        -e
                    ];
                }(r);
                let h = Math.abs(e.top - e.bottom);
                for (const t1 of e.positionedLines)h -= t1.lineOffset;
                const p = e.positionedLines.length, f = h / p;
                let d = e.top - r[1];
                for(let t1 = 0; t1 < p; ++t1){
                    const n = e.positionedLines[t1];
                    d = Uy(e, f, d, t1);
                    for (const t1 of n.positionedGlyphs){
                        if (!t1.rect) continue;
                        const n = t1.rect || {};
                        let s = Qm + 1, h = !0, p = 1, f = 0;
                        if (t1.imageName) {
                            const e = a[t1.imageName];
                            if (!e) continue;
                            if (e.sdf) {
                                fr("SDF images are not supported in formatted text and will be ignored.");
                                continue;
                            }
                            h = !1, p = e.pixelRatio, s = Sy / p;
                        }
                        const m = (i || o) && t1.vertical, y = t1.metrics.advance * t1.scale / 2, g = t1.metrics, x = t1.rect;
                        if (null === x) continue;
                        o && e.verticalizable && (f = t1.imageName ? y - t1.metrics.width * t1.scale / 2 : 0);
                        const b = i ? [
                            t1.x + y,
                            t1.y
                        ] : [
                            0,
                            0
                        ];
                        let v = [
                            0,
                            0
                        ], _ = [
                            0,
                            0
                        ], w = !1;
                        i || (m ? (_ = [
                            t1.x + y + c[0],
                            t1.y + c[1] - f
                        ], w = !0) : v = [
                            t1.x + y + r[0],
                            t1.y + r[1] - f
                        ]);
                        const M = x.w * t1.scale / (p * (t1.localGlyph ? Ey : 1)), A = x.h * t1.scale / (p * (t1.localGlyph ? Ey : 1));
                        let S, I, T, k;
                        if (m) {
                            const e = t1.y - d, r = new Ne(-y, y - e), n = -Math.PI / 2, i = new Ne(..._);
                            S = new Ne(-y + v[0], v[1]), S._rotateAround(n, r)._add(i), S.x += -e + y, S.y -= (g.left - s) * t1.scale;
                            const a = t1.imageName ? g.advance * t1.scale : Fm * t1.scale, o = String.fromCodePoint(t1.glyph);
                            Xm(o) ? S.x += (1 - s) * t1.scale : Zm(o) ? S.x += a - g.height * t1.scale + (-s - 1) * t1.scale : S.x += t1.imageName || g.width + 2 * s === x.w && g.height + 2 * s === x.h ? (a - A) / 2 : (a - (g.height + 2 * s) * t1.scale) / 2, I = new Ne(S.x, S.y - M), T = new Ne(S.x + A, S.y), k = new Ne(S.x + A, S.y - M);
                        } else {
                            const e = (g.left - s) * t1.scale - y + v[0], r = (-g.top - s) * t1.scale + v[1], n = e + M, i = r + A;
                            S = new Ne(e, r), I = new Ne(n, r), T = new Ne(e, i), k = new Ne(n, i);
                        }
                        if (u) {
                            let t1;
                            t1 = i ? new Ne(0, 0) : w ? new Ne(c[0], c[1]) : new Ne(r[0], r[1]), S._rotateAround(u, t1), I._rotateAround(u, t1), T._rotateAround(u, t1), k._rotateAround(u, t1);
                        }
                        const P = new Ne(0, 0), z = new Ne(0, 0);
                        l.push({
                            tl: S,
                            tr: I,
                            bl: T,
                            br: k,
                            texPrimary: n,
                            texSecondary: void 0,
                            writingMode: e.writingMode,
                            glyphOffset: b,
                            sectionIndex: t1.sectionIndex,
                            isSDF: h,
                            pixelOffsetTL: P,
                            pixelOffsetBR: z,
                            minFontScaleX: 0,
                            minFontScaleY: 0
                        });
                    }
                }
                return l;
            }(0, n, l, s, a, o, i, t1.allowVerticalPlacement), b = t1.textSizeData;
            let v = null;
            "source" === b.kind ? (v = [
                Um * s.layout.get("text-size").evaluate(o, {}, y)
            ], v[0] > Ky && fr(`${t1.layerIds[0]}: Value for "text-size" is >= ${Hy}. Reduce your "text-size".`)) : "composite" === b.kind && (v = [
                Um * d.compositeTextSizes[0].evaluate(o, {}, y),
                Um * d.compositeTextSizes[1].evaluate(o, {}, y)
            ], (v[0] > Ky || v[1] > Ky) && fr(`${t1.layerIds[0]}: Value for "text-size" is >= ${Hy}. Reduce your "text-size".`)), t1.addSymbols(t1.text, x, v, l, a, o, c, e, r, u.lineStartIndex, u.lineLength, f, m, y, g, !1);
            for (const e of h)p[e] = t1.text.placedSymbolArray.length - 1;
            return 4 * x.length;
        }
        function Jy(t1) {
            for(const e in t1)return t1[e];
            return null;
        }
        function Qy(t1, e, r, n, i, s, a, o, l, u) {
            let c = a.top, h = a.bottom, p = a.left, f = a.right;
            const d = a.collisionPadding;
            if (d && (p -= d[0], c -= d[1], f += d[2], h += d[3]), l) {
                const t1 = new Ne(p, c), e = new Ne(f, c), r = new Ne(p, h), n = new Ne(f, h), i = $e(l);
                let s = new Ne(0, 0);
                u && (s = new Ne(u[0], u[1])), t1._rotateAround(i, s), e._rotateAround(i, s), r._rotateAround(i, s), n._rotateAround(i, s), p = Math.min(t1.x, e.x, r.x, n.x), f = Math.max(t1.x, e.x, r.x, n.x), c = Math.min(t1.y, e.y, r.y, n.y), h = Math.max(t1.y, e.y, r.y, n.y);
            }
            return t1.emplaceBack(e.x, e.y, e.z, r.x, r.y, p, c, f, h, o, n, i, s), t1.length - 1;
        }
        function tg(t1) {
            t1.collisionPadding && (t1.top -= t1.collisionPadding[1], t1.bottom += t1.collisionPadding[3]);
            const e = t1.bottom - t1.top;
            return e > 0 ? Math.max(10, e) : null;
        }
        function eg(t1, e, r, n) {
            const i = t1.compareText;
            if (e in i) {
                const t1 = i[e];
                for(let e = t1.length - 1; e >= 0; e--)if (n.dist(t1[e]) < r) return !0;
            } else i[e] = [];
            return i[e].push(n), !1;
        }
        function rg(t1, e) {
            const r = t1.fovAboveCenter, n = t1.elevation ? t1.elevation.getMinElevationBelowMSL() * e : 0, i = (t1._camera.position[2] * t1.worldSize - n) / Math.cos(t1._pitch), s = Math.sin(r) * i / Math.sin(Math.max(Math.PI / 2 - t1._pitch - r, .01)), a = Math.sin(t1._pitch) * s + i;
            return Math.min(1.01 * a, i * (1 / t1._horizonShift));
        }
        function ng(t1, e) {
            if (!e.isReprojectedInTileSpace) return {
                scale: 1 << t1.z,
                x: t1.x,
                y: t1.y,
                x2: t1.x + 1,
                y2: t1.y + 1,
                projection: e
            };
            const r = Math.pow(2, -t1.z), n = t1.x * r, i = (t1.x + 1) * r, s = t1.y * r, a = (t1.y + 1) * r, o = zc(n), l = zc(i), u = Ec(s), c = Ec(a), h = e.project(o, u), p = e.project(l, u), f = e.project(l, c), d = e.project(o, c);
            let m = Math.min(h.x, p.x, f.x, d.x), y = Math.min(h.y, p.y, f.y, d.y), g = Math.max(h.x, p.x, f.x, d.x), x = Math.max(h.y, p.y, f.y, d.y);
            const b = r / 16;
            function v(t1, r, n, i, s, a) {
                const o = (n + s) / 2, l = (i + a) / 2, u = e.project(zc(o), Ec(l)), c = Math.max(0, m - u.x, y - u.y, u.x - g, u.y - x);
                m = Math.min(m, u.x), g = Math.max(g, u.x), y = Math.min(y, u.y), x = Math.max(x, u.y), c > b && (v(t1, u, n, i, o, l), v(u, r, o, l, s, a));
            }
            v(h, p, n, s, i, s), v(p, f, i, s, i, a), v(f, d, i, a, n, a), v(d, h, n, a, n, s), m -= b, y -= b, g += b, x += b;
            const _ = 1 / Math.max(g - m, x - y);
            return {
                scale: _,
                x: m * _,
                y: y * _,
                x2: g * _,
                y2: x * _,
                projection: e
            };
        }
        function ig(t1, { x: e, y: r }, n = 0) {
            return new Ne(((e - n) * t1.scale - t1.x) * ps, (r * t1.scale - t1.y) * ps);
        }
        const sg = t1.ad.identity(new Float32Array(16));
        class ag {
            constructor(t1){
                this.spec = t1, this.name = t1.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = [
                    "custom"
                ], this.center = [
                    0,
                    0
                ], this.range = [
                    3.5,
                    7
                ];
            }
            project(t1, e) {
                return {
                    x: 0,
                    y: 0,
                    z: 0
                };
            }
            unproject(t1, e) {
                return new mc(0, 0);
            }
            projectTilePoint(t1, e, r) {
                return {
                    x: t1,
                    y: e,
                    z: 0
                };
            }
            locationPoint(t1, e, r = !0) {
                return t1._coordinatePoint(t1.locationCoordinate(e), r);
            }
            pixelsPerMeter(t1, e) {
                return Pc(1, t1) * e;
            }
            pixelSpaceConversion(t1, e, r) {
                return 1;
            }
            farthestPixelDistance(t1) {
                return rg(t1, t1.pixelsPerMeter);
            }
            pointCoordinate(t1, e, r, n) {
                const i = t1.horizonLineFromTop(!1), s = new Ne(e, Math.max(i, r));
                return t1.rayIntersectionCoordinate(t1.pointRayIntersection(s, n));
            }
            pointCoordinate3D(t1, e, r) {
                const n = new Ne(e, r);
                if (t1.elevation) return t1.elevation.pointCoordinate(n);
                {
                    const e = this.pointCoordinate(t1, n.x, n.y, 0);
                    return [
                        e.x,
                        e.y,
                        e.z
                    ];
                }
            }
            isPointAboveHorizon(t1, e) {
                if (t1.elevation && t1.elevation.visibleDemTiles.length) return !this.pointCoordinate3D(t1, e.x, e.y);
                const r = t1.horizonLineFromTop();
                return e.y < r;
            }
            createInversionMatrix(t1, e) {
                return sg;
            }
            createTileMatrix(e, r, n) {
                let i, s, a;
                const o = n.canonical, l = t1.ad.identity(new Float64Array(16));
                if (this.isReprojectedInTileSpace) {
                    const u = ng(o, this);
                    i = 1, s = u.x + n.wrap * u.scale, a = u.y, t1.ad.scale(l, l, [
                        i / u.scale,
                        i / u.scale,
                        e.pixelsPerMeter / r
                    ]);
                } else i = r / e.zoomScale(o.z), s = (o.x + Math.pow(2, o.z) * n.wrap) * i, a = o.y * i;
                return t1.ad.translate(l, l, [
                    s,
                    a,
                    0
                ]), t1.ad.scale(l, l, [
                    i / ps,
                    i / ps,
                    1
                ]), l;
            }
            upVector(t1, e, r) {
                return [
                    0,
                    0,
                    1
                ];
            }
            upVectorScale(t1, e, r) {
                return {
                    metersToTile: 1
                };
            }
        }
        class og extends ag {
            constructor(t1){
                super(t1), this.range = [
                    4,
                    7
                ], this.center = t1.center || [
                    -96,
                    37.5
                ];
                const [e, r] = this.parallels = t1.parallels || [
                    29.5,
                    45.5
                ], n = Math.sin($e(e));
                this.n = (n + Math.sin($e(r))) / 2, this.c = 1 + n * (2 * this.n - n), this.r0 = Math.sqrt(this.c) / this.n;
            }
            project(t1, e) {
                const { n: r, c: n, r0: i } = this, s = $e(t1 - this.center[0]), a = $e(e), o = Math.sqrt(n - 2 * r * Math.sin(a)) / r;
                return {
                    x: o * Math.sin(s * r),
                    y: o * Math.cos(s * r) - i,
                    z: 0
                };
            }
            unproject(t1, e) {
                const { n: r, c: n, r0: i } = this, s = i + e;
                let a = Math.atan2(t1, Math.abs(s)) * Math.sign(s);
                s * r < 0 && (a -= Math.PI * Math.sign(t1) * Math.sign(s));
                const o = $e(this.center[0]) * r;
                a = Je(a, -Math.PI - o, Math.PI - o);
                const l = Ke(Ge(a / r) + this.center[0], -180, 180), u = Math.asin(Ke((n - (t1 * t1 + s * s) * r * r) / (2 * r), -1, 1)), c = Ke(Ge(u), -Dc, Dc);
                return new mc(l, c);
            }
        }
        const lg = 1.340264, ug = -0.081106, cg = 893e-6, hg = .003796, pg = Math.sqrt(3) / 2;
        class fg extends ag {
            project(t1, e) {
                e = e / 180 * Math.PI, t1 = t1 / 180 * Math.PI;
                const r = Math.asin(pg * Math.sin(e)), n = r * r, i = n * n * n;
                return {
                    x: .5 * (t1 * Math.cos(r) / (pg * (lg + 3 * ug * n + i * (7 * cg + 9 * hg * n))) / Math.PI + .5),
                    y: 1 - .5 * (r * (lg + ug * n + i * (cg + hg * n)) / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e) {
                t1 = (2 * t1 - .5) * Math.PI;
                let r = e = (2 * (1 - e) - 1) * Math.PI, n = r * r, i = n * n * n;
                for(let t1, s, a, o = 0; o < 12 && (s = r * (lg + ug * n + i * (cg + hg * n)) - e, a = lg + 3 * ug * n + i * (7 * cg + 9 * hg * n), t1 = s / a, r = Ke(r - t1, -Math.PI / 3, Math.PI / 3), n = r * r, i = n * n * n, !(Math.abs(t1) < 1e-12)); ++o);
                const s = pg * t1 * (lg + 3 * ug * n + i * (7 * cg + 9 * hg * n)) / Math.cos(r), a = Math.asin(Math.sin(r) / pg), o = Ke(180 * s / Math.PI, -180, 180), l = Ke(180 * a / Math.PI, -Dc, Dc);
                return new mc(o, l);
            }
        }
        class dg extends ag {
            constructor(t1){
                super(t1), this.wrap = !0, this.supportsWorldCopies = !0;
            }
            project(t1, e) {
                return {
                    x: .5 + t1 / 360,
                    y: .5 - e / 360,
                    z: 0
                };
            }
            unproject(t1, e) {
                const r = 360 * (t1 - .5), n = Ke(360 * (.5 - e), -Dc, Dc);
                return new mc(r, n);
            }
        }
        const mg = Math.PI / 2;
        function yg(t1) {
            return Math.tan((mg + t1) / 2);
        }
        class gg extends ag {
            constructor(t1){
                super(t1), this.center = t1.center || [
                    0,
                    30
                ];
                const [e, r] = this.parallels = t1.parallels || [
                    30,
                    30
                ];
                let n = $e(e), i = $e(r);
                this.southernCenter = n + i < 0, this.southernCenter && (n = -n, i = -i);
                const s = Math.cos(n), a = yg(n);
                this.n = n === i ? Math.sin(n) : Math.log(s / Math.cos(i)) / Math.log(yg(i) / a), this.f = s * Math.pow(yg(n), this.n) / this.n;
            }
            project(t1, e) {
                e = $e(e), this.southernCenter && (e = -e), t1 = $e(t1 - this.center[0]);
                const r = 1e-6, { n, f: i } = this;
                i > 0 ? e < -mg + r && (e = -mg + r) : e > mg - r && (e = mg - r);
                const s = i / Math.pow(yg(e), n);
                let a = s * Math.sin(n * t1), o = i - s * Math.cos(n * t1);
                return a = .5 * (a / Math.PI + .5), o = .5 * (o / Math.PI + .5), {
                    x: a,
                    y: this.southernCenter ? o : 1 - o,
                    z: 0
                };
            }
            unproject(t1, e) {
                t1 = (2 * t1 - .5) * Math.PI, this.southernCenter && (e = 1 - e), e = (2 * (1 - e) - .5) * Math.PI;
                const { n: r, f: n } = this, i = n - e, s = Math.sign(i), a = Math.sign(r) * Math.sqrt(t1 * t1 + i * i);
                let o = Math.atan2(t1, Math.abs(i)) * s;
                i * r < 0 && (o -= Math.PI * Math.sign(t1) * s);
                const l = Ke(Ge(o / r) + this.center[0], -180, 180), u = Ke(Ge(2 * Math.atan(Math.pow(n / a, 1 / r)) - mg), -Dc, Dc);
                return new mc(l, this.southernCenter ? -u : u);
            }
        }
        class xg extends ag {
            constructor(t1){
                super(t1), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;
            }
            project(t1, e) {
                return {
                    x: Tc(t1),
                    y: kc(e),
                    z: 0
                };
            }
            unproject(t1, e) {
                const r = zc(t1), n = Ec(e);
                return new mc(r, n);
            }
        }
        const bg = $e(Dc);
        class vg extends ag {
            project(t1, e) {
                const r = (e = $e(e)) * e, n = r * r;
                return {
                    x: .5 * ((t1 = $e(t1)) * (.8707 - .131979 * r + n * (n * (.003971 * r - .001529 * n) - .013791)) / Math.PI + .5),
                    y: 1 - .5 * (e * (1.007226 + r * (.015085 + n * (.028874 * r - .044475 - .005916 * n))) / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e) {
                t1 = (2 * t1 - .5) * Math.PI;
                let r = e = (2 * (1 - e) - 1) * Math.PI, n = 25, i = 0, s = r * r;
                do {
                    s = r * r;
                    const t1 = s * s;
                    i = (r * (1.007226 + s * (.015085 + t1 * (.028874 * s - .044475 - .005916 * t1))) - e) / (1.007226 + s * (.045255 + t1 * (.259866 * s - .311325 - .005916 * 11 * t1))), r = Ke(r - i, -bg, bg);
                }while (Math.abs(i) > 1e-6 && --n > 0);
                s = r * r;
                const a = Ke(Ge(t1 / (.8707 + s * (s * (s * s * s * (.003971 - .001529 * s) - .013791) - .131979))), -180, 180), o = Ge(r);
                return new mc(a, o);
            }
        }
        const _g = $e(Dc);
        class wg extends ag {
            project(t1, e) {
                e = $e(e), t1 = $e(t1);
                const r = Math.cos(e), n = 2 / Math.PI, i = Math.acos(r * Math.cos(t1 / 2)), s = Math.sin(i) / i, a = .5 * (t1 * n + 2 * r * Math.sin(t1 / 2) / s) || 0, o = .5 * (e + Math.sin(e) / s) || 0;
                return {
                    x: .5 * (a / Math.PI + .5),
                    y: 1 - .5 * (o / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e) {
                let r = t1 = (2 * t1 - .5) * Math.PI, n = e = (2 * (1 - e) - 1) * Math.PI, i = 25;
                const s = 1e-6;
                let a = 0, o = 0;
                do {
                    const i = Math.cos(n), s = Math.sin(n), l = 2 * s * i, u = s * s, c = i * i, h = Math.cos(r / 2), p = Math.sin(r / 2), f = 2 * h * p, d = p * p, m = 1 - c * h * h, y = m ? 1 / m : 0, g = m ? Math.acos(i * h) * Math.sqrt(1 / m) : 0, x = .5 * (2 * g * i * p + 2 * r / Math.PI) - t1, b = .5 * (g * s + n) - e, v = .5 * y * (c * d + g * i * h * u) + 1 / Math.PI, _ = y * (f * l / 4 - g * s * p), w = .125 * y * (l * p - g * s * c * f), M = .5 * y * (u * h + g * d * i) + .5, A = _ * w - M * v;
                    a = (b * _ - x * M) / A, o = (x * w - b * v) / A, r = Ke(r - a, -Math.PI, Math.PI), n = Ke(n - o, -_g, _g);
                }while ((Math.abs(a) > s || Math.abs(o) > s) && --i > 0);
                return new mc(Ge(r), Ge(n));
            }
        }
        class Mg extends ag {
            constructor(t1){
                super(t1), this.center = t1.center || [
                    0,
                    0
                ], this.parallels = t1.parallels || [
                    0,
                    0
                ], this.cosPhi = Math.max(.01, Math.cos($e(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;
            }
            project(t1, e) {
                const { scale: r, cosPhi: n } = this;
                return {
                    x: $e(t1) * n * r + .5,
                    y: -Math.sin($e(e)) / n * r + .5,
                    z: 0
                };
            }
            unproject(t1, e) {
                const { scale: r, cosPhi: n } = this, i = -(e - .5) / r, s = Ke(Ge((t1 - .5) / r) / n, -180, 180), a = Math.asin(Ke(i * n, -1, 1)), o = Ke(Ge(a), -Dc, Dc);
                return new mc(s, o);
            }
        }
        class Ag extends xg {
            constructor(t1){
                super(t1), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = [
                    "debug"
                ], this.range = [
                    3,
                    5
                ];
            }
            projectTilePoint(e, r, n) {
                const i = Nh(e, r, n), s = $h(Ch(n));
                return t1._.transformMat4(i, i, s), {
                    x: i[0],
                    y: i[1],
                    z: i[2]
                };
            }
            locationPoint(e, r) {
                const n = pc(r.lat, r.lng), i = t1._.normalize([], n), s = e.elevation ? e.elevation.getAtPointOrZero(e.locationCoordinate(r), e._centerAltitude) : e._centerAltitude, a = Pc(1, 0) * ps * s;
                t1._.scaleAndAdd(n, n, i, a);
                const o = t1.ad.identity(new Float64Array(16));
                return t1.ad.multiply(o, e.pixelMatrix, e.globeMatrix), t1._.transformMat4(n, n, o), new Ne(n[0], n[1]);
            }
            pixelsPerMeter(t1, e) {
                return Pc(1, 0) * e;
            }
            pixelSpaceConversion(t1, e, r) {
                const n = Pc(1, t1) * e, i = Gn(Pc(1, 45) * e, n, r);
                return this.pixelsPerMeter(t1, e) / i;
            }
            createTileMatrix(e, r, n) {
                const i = Gh(Ch(n.canonical));
                return t1.ad.multiply(new Float64Array(16), e.globeMatrix, i);
            }
            createInversionMatrix(e, r) {
                const { center: n } = e, i = $h(Ch(r));
                return t1.ad.rotateY(i, i, $e(n.lng)), t1.ad.rotateX(i, i, $e(n.lat)), t1.ad.scale(i, i, [
                    e._pixelsPerMercatorPixel,
                    e._pixelsPerMercatorPixel,
                    1
                ]), Float32Array.from(i);
            }
            pointCoordinate(t1, e, r, n) {
                return Eh(t1, e, r, !0) || new Oc(0, 0);
            }
            pointCoordinate3D(t1, e, r) {
                const n = this.pointCoordinate(t1, e, r, 0);
                return [
                    n.x,
                    n.y,
                    n.z
                ];
            }
            isPointAboveHorizon(t1, e) {
                return !Eh(t1, e.x, e.y, !1);
            }
            farthestPixelDistance(e) {
                const r = function(e, r) {
                    const n = e.cameraToCenterDistance, i = e._centerAltitude * r, s = e._camera, a = e._camera.forward(), o = t1._.add([], t1._.scale([], a, -n), [
                        0,
                        0,
                        i
                    ]), l = e.worldSize / (2 * Math.PI), u = [
                        0,
                        0,
                        -l
                    ], c = e.width / e.height, h = Math.tan(e.fovAboveCenter), p = t1._.scale([], s.up(), h), f = t1._.scale([], s.right(), h * c), d = t1._.normalize([], t1._.add([], t1._.add([], a, p), f)), m = [];
                    let y;
                    if (new gh(o, d).closestPointOnSphere(u, l, m)) {
                        const r = t1._.add([], m, u), n = t1._.sub([], r, o);
                        y = Math.cos(e.fovAboveCenter) * t1._.length(n);
                    } else {
                        const e = t1._.sub([], o, u), r = t1._.sub([], u, o);
                        t1._.normalize(r, r);
                        const n = t1._.length(e) - l;
                        y = Math.sqrt(n * (n + 2 * l));
                        const i = Math.acos(y / (l + n)) - Math.acos(t1._.dot(a, r));
                        y *= Math.cos(i);
                    }
                    return 1.01 * y;
                }(e, this.pixelsPerMeter(e.center.lat, e.worldSize)), n = Hh(e.zoom);
                if (n > 0) {
                    const t1 = rg(e, Pc(1, e.center.lat) * e.worldSize), i = e.worldSize / (2 * Math.PI), s = Math.max(e.width, e.height) / e.worldSize * Math.PI;
                    return Gn(r, t1 + i * (1 - Math.cos(s)), Math.pow(n, 10));
                }
                return r;
            }
            upVector(t1, e, r) {
                return Nh(e, r, t1, 1);
            }
            upVectorScale(t1) {
                return {
                    metersToTile: Ph(jh(Ch(t1)))
                };
            }
        }
        function Sg(t1) {
            const e = t1.parallels, r = !!e && Math.abs(e[0] + e[1]) < .01;
            switch(t1.name){
                case "mercator":
                    return new xg(t1);
                case "equirectangular":
                    return new dg(t1);
                case "naturalEarth":
                    return new vg(t1);
                case "equalEarth":
                    return new fg(t1);
                case "winkelTripel":
                    return new wg(t1);
                case "albers":
                    return r ? new Mg(t1) : new og(t1);
                case "lambertConformalConic":
                    return r ? new Mg(t1) : new gg(t1);
                case "globe":
                    return new Ag(t1);
            }
            throw new Error(`Invalid projection name: ${t1.name}`);
        }
        class Ig {
            constructor(t1, e, r, n){
                this.id = Ig.uniqueIdxCounter, Ig.uniqueIdxCounter++, this.context = t1;
                const i = t1.gl;
                this.buffer = i.createBuffer(), this.dynamicDraw = Boolean(r), this.context.unbindVAO(), t1.bindElementBuffer.set(this.buffer), i.bufferData(i.ELEMENT_ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? i.DYNAMIC_DRAW : i.STATIC_DRAW), this.dynamicDraw || n || e.destroy();
            }
            bind() {
                this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(t1) {
                this.id = Ig.uniqueIdxCounter, Ig.uniqueIdxCounter++;
                const e = this.context.gl;
                this.context.unbindVAO(), this.bind(), e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, t1.arrayBuffer);
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }
        Ig.uniqueIdxCounter = 0;
        class Tg {
            constructor(t1, e, r){
                this.func = t1, this.mask = e, this.range = r;
            }
        }
        Tg.ReadOnly = !1, Tg.ReadWrite = !0, Tg.disabled = new Tg(519, Tg.ReadOnly, [
            0,
            1
        ]);
        const kg = 7680;
        class Pg {
            constructor(t1, e, r, n, i, s){
                this.test = t1, this.ref = e, this.mask = r, this.fail = n, this.depthFail = i, this.pass = s;
            }
        }
        Pg.disabled = new Pg({
            func: 519,
            mask: 0
        }, 0, 0, kg, kg, kg);
        const zg = 771;
        class Eg {
            constructor(t1, e, r, n){
                this.blendFunction = t1, this.blendColor = e, this.mask = r, this.blendEquation = n;
            }
        }
        Eg.Replace = [
            1,
            0,
            1,
            0
        ], Eg.disabled = new Eg(Eg.Replace, qn.transparent, [
            !1,
            !1,
            !1,
            !1
        ]), Eg.unblended = new Eg(Eg.Replace, qn.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), Eg.alphaBlended = new Eg([
            1,
            zg,
            1,
            zg
        ], qn.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), Eg.alphaBlendedNonPremultiplied = new Eg([
            770,
            zg,
            770,
            zg
        ], qn.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), Eg.multiply = new Eg([
            774,
            0,
            774,
            0
        ], qn.transparent, [
            !0,
            !0,
            !0,
            !0
        ]);
        const Bg = 1029, Dg = 2305;
        class Cg {
            constructor(t1, e, r){
                this.enable = t1, this.mode = e, this.frontFace = r;
            }
        }
        Cg.disabled = new Cg(!1, Bg, Dg), Cg.backCCW = new Cg(!0, Bg, Dg), Cg.backCW = new Cg(!0, Bg, 2304), Cg.frontCW = new Cg(!0, 1028, 2304), Cg.frontCCW = new Cg(!0, 1028, Dg);
        const Rg = Sf.types, Vg = [
            {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint8",
                offset: 0
            }
        ];
        function Lg(t1, e, r, n, i, s, a, o, l, u, c, h, p) {
            const f = o ? Math.min(Ky, Math.round(o[0])) : 0, d = o ? Math.min(Ky, Math.round(o[1])) : 0;
            t1.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), s, a, (f << 1) + (l ? 1 : 0), d, 16 * u, 16 * c, 256 * h, 256 * p);
        }
        function Og(t1, e, r) {
            t1.emplaceBack(e, r);
        }
        function Fg(t1, e, r, n, i, s, a) {
            t1.emplaceBack(e, r, n, i, s, a);
        }
        function Ug(t1, e, r, n, i) {
            t1.emplaceBack(e, r, n, i), t1.emplaceBack(e, r, n, i), t1.emplaceBack(e, r, n, i), t1.emplaceBack(e, r, n, i);
        }
        function Ng(t1) {
            for (const e of t1.sections)if (Vo(e.text)) return !0;
            return !1;
        }
        class jg {
            constructor(t1){
                this.layoutVertexArray = new $l, this.indexArray = new Ql, this.programConfigurations = t1, this.segments = new Au, this.dynamicLayoutVertexArray = new Fl, this.opacityVertexArray = new Yl, this.occlusionQueryOpacityVertexArray = new Xl, this.placedSymbolArray = new du, this.iconTransitioningVertexArray = new Zl, this.globeExtVertexArray = new Gl, this.zOffsetVertexArray = new Xl;
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;
            }
            upload(t1, e, r, n, i) {
                this.isEmpty() || (r && (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Ud.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t1.createVertexBuffer(this.dynamicLayoutVertexArray, jd.members, !0), this.opacityVertexBuffer = t1.createVertexBuffer(this.opacityVertexArray, Vg, !0), this.occlusionQueryOpacityVertexBuffer = t1.createVertexBuffer(this.occlusionQueryOpacityVertexArray, qd.members, !0), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t1.createVertexBuffer(this.iconTransitioningVertexArray, Gd.members, !0)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t1.createVertexBuffer(this.globeExtVertexArray, Nd.members, !0)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || i) && (this.zOffsetVertexBuffer = t1.createVertexBuffer(this.zOffsetVertexArray, $d.members, !0)), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t1));
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.occlusionQueryOpacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());
            }
        }
        Mo(jg, "SymbolBuffers");
        class qg {
            constructor(t1, e, r){
                this.layoutVertexArray = new t1, this.layoutAttributes = e, this.indexArray = new r, this.segments = new Au, this.collisionVertexArray = new Jl, this.collisionVertexArrayExt = new Fl;
            }
            upload(t1) {
                this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t1.createVertexBuffer(this.collisionVertexArray, Yd.members, !0), this.collisionVertexBufferExt = t1.createVertexBuffer(this.collisionVertexArrayExt, Xd.members, !0);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
            }
        }
        Mo(qg, "CollisionBuffers");
        class $g {
            constructor(e){
                this.queries = new Map, this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.lut = e.lut, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.hasAnyIconTextFit = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = t1.ad.identity([]), this.placementViewportMatrix = t1.ad.identity([]);
                const r = this.layers[0]._unevaluatedLayout._values;
                this.textSizeData = Nm(this.zoom, r["text-size"]), this.iconSizeData = Nm(this.zoom, r["icon-size"]);
                const n = this.layers[0].layout, i = n.get("symbol-sort-key"), s = n.get("symbol-z-order");
                this.canOverlap = n.get("text-allow-overlap") || n.get("icon-allow-overlap") || n.get("text-ignore-placement") || n.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s && void 0 !== i.constantOr(1), this.sortFeaturesByY = ("viewport-y" === s || "auto" === s && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = n.get("text-writing-mode").map((t1)=>ty[t1]), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.sourceID = e.sourceID, this.projection = e.projection, this.hasAnyZOffset = !1, this.zOffsetSortDirty = !1, this.zOffsetBuffersNeedUpload = n.get("symbol-z-elevate"), this.activeReplacements = [], this.replacementUpdateTime = 0;
            }
            createArrays() {
                this.text = new jg(new Wu(this.layers, {
                    zoom: this.zoom,
                    lut: this.lut
                }, (t1)=>/^text/.test(t1))), this.icon = new jg(new Wu(this.layers, {
                    zoom: this.zoom,
                    lut: this.lut
                }, (t1)=>/^icon/.test(t1))), this.glyphOffsetArray = new gu, this.lineVertexArray = new xu, this.symbolInstances = new yu;
            }
            calculateGlyphDependencies(t1, e, r, n, i) {
                for(let r = 0; r < t1.length; r++){
                    const s = t1.codePointAt(r);
                    if (void 0 === s) break;
                    if (e[s] = !0, n && i && s <= 65535) {
                        const n = Ym[t1.charAt(r)];
                        n && (e[n.charCodeAt(0)] = !0);
                    }
                }
            }
            updateFootprints(t1, e) {}
            updateReplacement(t1, e) {
                if (e.updateTime === this.replacementUpdateTime) return !1;
                this.replacementUpdateTime = e.updateTime;
                const r = e.getReplacementRegionsForTile(t1.toUnwrapped(), !0);
                return !Cf(this.activeReplacements, r) && (this.activeReplacements = r, !0);
            }
            populate(e, r, n, i) {
                const s = this.layers[0], a = s.layout, o = "globe" === this.projection.name, l = a.get("text-font"), u = a.get("text-field"), c = a.get("icon-image"), h = ("constant" !== u.value.kind || u.value.value instanceof mi && !u.value.value.isEmpty() || u.value.value.toString().length > 0) && ("constant" !== l.value.kind || l.value.value.length > 0), p = "constant" !== c.value.kind || !!c.value.value || Object.keys(c.parameters).length > 0, f = a.get("symbol-sort-key");
                if (this.features = [], !h && !p) return;
                const d = r.iconDependencies, m = r.glyphDependencies, y = r.availableImages, g = new Ho(this.zoom);
                for (const { feature: r, id: u, index: c, sourceLayerIndex: x } of e){
                    const e = s._featureFilter.needGeometry, b = Xc(r, e);
                    if (!s._featureFilter.filter(g, b, n)) continue;
                    if (e || (b.geometry = Yc(r, n, i)), o && 1 !== r.type && n.z <= 5) {
                        const e = b.geometry, r = .98078528056, i = (e, i)=>{
                            const s = Nh(e.x, e.y, n, 1), a = Nh(i.x, i.y, n, 1);
                            return t1._.dot(s, a) < r;
                        };
                        for(let t1 = 0; t1 < e.length; t1++)e[t1] = jc(e[t1], i);
                    }
                    let v, _;
                    if (h) {
                        const t1 = s.getValueAndResolveTokens("text-field", b, n, y), e = mi.factory(t1);
                        Ng(e) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === Yo() || this.hasRTLText && Zo.isParsed()) && (v = Gm(e, s, b));
                    }
                    if (p) {
                        const t1 = s.getValueAndResolveTokens("icon-image", b, n, y);
                        _ = t1 instanceof yi ? t1 : yi.fromString(t1);
                    }
                    if (!v && !_) continue;
                    const w = this.sortFeaturesByKey ? f.evaluate(b, {}, n) : void 0;
                    if (this.features.push({
                        id: u,
                        text: v,
                        icon: _,
                        index: c,
                        sourceLayerIndex: x,
                        geometry: b.geometry,
                        properties: r.properties,
                        type: Rg[r.type],
                        sortKey: w
                    }), _ && (d[_.namePrimary] = !0, _.nameSecondary && (d[_.nameSecondary] = !0)), v) {
                        const t1 = l.evaluate(b, {}, n).join(","), e = "map" === a.get("text-rotation-alignment") && "point" !== a.get("symbol-placement");
                        this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(ty.vertical) >= 0;
                        for (const r of v.sections)if (r.image) d[r.image.namePrimary] = !0;
                        else {
                            const n = Po(v.toString()), i = r.fontStack || t1, s = m[i] = m[i] || {};
                            this.calculateGlyphDependencies(r.text, s, e, this.allowVerticalPlacement, n);
                        }
                    }
                }
                "line" === a.get("symbol-placement") && (this.features = function(t1) {
                    const e = {}, r = {}, n = [];
                    let i = 0;
                    function s(e) {
                        n.push(t1[e]), i++;
                    }
                    function a(t1, e, i) {
                        const s = r[t1];
                        return delete r[t1], r[e] = s, n[s].geometry[0].pop(), n[s].geometry[0] = n[s].geometry[0].concat(i[0]), s;
                    }
                    function o(t1, r, i) {
                        const s = e[r];
                        return delete e[r], e[t1] = s, n[s].geometry[0].shift(), n[s].geometry[0] = i[0].concat(n[s].geometry[0]), s;
                    }
                    function l(t1, e, r) {
                        const n = r ? e[0][e[0].length - 1] : e[0][0];
                        return `${t1}:${n.x}:${n.y}`;
                    }
                    for(let u = 0; u < t1.length; u++){
                        const c = t1[u], h = c.geometry, p = c.text ? c.text.toString() : null;
                        if (!p) {
                            s(u);
                            continue;
                        }
                        const f = l(p, h), d = l(p, h, !0);
                        if (f in r && d in e && r[f] !== e[d]) {
                            const t1 = o(f, d, h), i = a(f, d, n[t1].geometry);
                            delete e[f], delete r[d], r[l(p, n[i].geometry, !0)] = i, n[t1].geometry = null;
                        } else f in r ? a(f, d, h) : d in e ? o(f, d, h) : (s(u), e[f] = i - 1, r[d] = i - 1);
                    }
                    return n.filter((t1)=>t1.geometry);
                }(this.features)), this.sortFeaturesByKey && this.features.sort((t1, e)=>t1.sortKey - e.sortKey);
            }
            update(t1, e, r, n, i) {
                const s = 0 !== Object.keys(t1).length;
                if (s && !this.stateDependentLayers.length) return;
                const a = s ? this.stateDependentLayers : this.layers;
                this.text.programConfigurations.updatePaintArrays(t1, e, a, r, n, i), this.icon.programConfigurations.updatePaintArrays(t1, e, a, r, n, i);
            }
            updateOcclusionOpacities(t1, e, r) {
                if (!e.useOcclusionQueries) return !1;
                const n = this;
                if ("globe" === n.projection.name) return !1;
                let i = !1;
                n.hasTextData() && (i = i || 0 !== n.text.occlusionQueryOpacityVertexArray.length), n.hasIconData() && (i = i || 0 !== n.icon.occlusionQueryOpacityVertexArray.length);
                const s = n.layers[0].paint, a = s.get("icon-occlusion-opacity").constantOr(0), o = s.get("text-occlusion-opacity").constantOr(0);
                if (!n.layers[0].hasInitialOcclusionOpacityProperties || 1 === a && 1 === o) return !1;
                let l = !i;
                for(let t1 = 0; t1 < n.symbolInstances.length; t1++){
                    const i = n.symbolInstances.get(t1), s = i.occlusionOpacity;
                    i.occlusionOpacity += (i.occlusionState > .5 ? 1 : -1) * e.fadeSpeed * r * .001, i.occlusionOpacity = Ke(i.occlusionOpacity, 0, 1), l = l || i.occlusionOpacity !== s;
                }
                if (!l) return !1;
                let u = 0, c = 0;
                const h = (t1, e, r, n)=>{
                    let i = 0, s = 0;
                    r ? (i = c, c += n, s = c) : (i = u, u += n, s = u), s > e.occlusionQueryOpacityVertexArray.length && e.occlusionQueryOpacityVertexArray.resize(s);
                    const a = t1.occlusionOpacity;
                    for(let t1 = 0; t1 < n; t1++)e.occlusionQueryOpacityVertexArray.emplace(t1 + i, a);
                };
                for(let t1 = 0; t1 < n.symbolInstances.length; t1++){
                    const e = n.symbolInstances.get(t1), { numHorizontalGlyphVertices: r, numVerticalGlyphVertices: i, numIconVertices: s } = e, a = s > 0;
                    if ((r > 0 || i > 0) && (h(e, n.text, !1, r), h(e, n.text, !1, i)), a) {
                        const { placedIconSymbolIndex: t1, verticalPlacedIconSymbolIndex: r } = e;
                        t1 >= 0 && h(e, n.icon, !0, s), r >= 0 && h(e, n.icon, !0, e.numVerticalIconVertices);
                    }
                }
                return n.hasTextData() && n.text.occlusionQueryOpacityVertexBuffer && (n.text.occlusionQueryOpacityVertexBuffer.length < n.text.occlusionQueryOpacityVertexArray.length ? n.text.occlusionQueryOpacityVertexBuffer = t1.createVertexBuffer(n.text.occlusionQueryOpacityVertexArray, qd.members, !0) : n.text.occlusionQueryOpacityVertexBuffer.updateData(n.text.occlusionQueryOpacityVertexArray)), n.hasIconData() && n.icon.occlusionQueryOpacityVertexBuffer && (n.icon.occlusionQueryOpacityVertexBuffer.length < n.icon.occlusionQueryOpacityVertexArray.length ? n.icon.occlusionQueryOpacityVertexBuffer = t1.createVertexBuffer(n.icon.occlusionQueryOpacityVertexArray, qd.members, !0) : n.icon.occlusionQueryOpacityVertexBuffer.updateData(n.icon.occlusionQueryOpacityVertexArray)), !0;
            }
            updateZOffset() {
                const t1 = (t1, e, n)=>{
                    r += e, r > t1.length && t1.resize(r);
                    for(let i = -e; i < 0; i++)t1.emplace(i + r, n);
                }, e = (t1, e, r)=>{
                    n += e, n > t1.length && t1.resize(n);
                    for(let i = -e; i < 0; i++)t1.emplace(i + n, r);
                };
                if (!this.zOffsetBuffersNeedUpload) return;
                this.zOffsetBuffersNeedUpload = !1;
                let r = 0, n = 0;
                for(let r = 0; r < this.symbolInstances.length; r++){
                    const n = this.symbolInstances.get(r), { numHorizontalGlyphVertices: i, numVerticalGlyphVertices: s, numIconVertices: a } = n, o = n.zOffset, l = a > 0;
                    if ((i > 0 || s > 0) && (t1(this.text.zOffsetVertexArray, i, o), t1(this.text.zOffsetVertexArray, s, o)), l) {
                        const { placedIconSymbolIndex: t1, verticalPlacedIconSymbolIndex: r } = n;
                        t1 >= 0 && e(this.icon.zOffsetVertexArray, a, o), r >= 0 && e(this.icon.zOffsetVertexArray, n.numVerticalIconVertices, o);
                    }
                }
                this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
            }
            isEmpty() {
                return 0 === this.symbolInstances.length && !this.hasRTLText;
            }
            uploadPending() {
                return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t1) {
                !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t1), this.iconCollisionBox.upload(t1)), this.text.upload(t1, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(t1, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = !0;
            }
            destroyDebugData() {
                this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            getProjection() {
                return this.projectionInstance || (this.projectionInstance = Sg(this.projection)), this.projectionInstance;
            }
            destroy() {
                this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
                for (const t1 of this.queries.values())t1.destroy();
            }
            addToLineVertexArray(t1, e) {
                const r = this.lineVertexArray.length;
                if (void 0 !== t1.segment) for (const { x: t1, y: r } of e)this.lineVertexArray.emplaceBack(t1, r);
                return {
                    lineStartIndex: r,
                    lineLength: this.lineVertexArray.length - r
                };
            }
            addSymbols(t1, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m) {
                const y = t1.indexArray, g = t1.layoutVertexArray, x = t1.globeExtVertexArray, b = t1.segments.prepareSegment(4 * e.length, g, y, this.canOverlap ? s.sortKey : void 0), v = this.glyphOffsetArray.length, _ = b.vertexLength, w = this.allowVerticalPlacement && a === ty.vertical ? Math.PI / 2 : 0, M = s.text && s.text.sections;
                for(let n = 0; n < e.length; n++){
                    const { tl: i, tr: a, bl: u, br: c, texPrimary: h, texSecondary: v, pixelOffsetTL: _, pixelOffsetBR: A, minFontScaleX: S, minFontScaleY: I, glyphOffset: T, isSDF: k, sectionIndex: P } = e[n], z = b.vertexLength, E = T[1];
                    if (Lg(g, l.x, l.y, i.x, E + i.y, h.x, h.y, r, k, _.x, _.y, S, I), Lg(g, l.x, l.y, a.x, E + a.y, h.x + h.w, h.y, r, k, A.x, _.y, S, I), Lg(g, l.x, l.y, u.x, E + u.y, h.x, h.y + h.h, r, k, _.x, A.y, S, I), Lg(g, l.x, l.y, c.x, E + c.y, h.x + h.w, h.y + h.h, r, k, A.x, A.y, S, I), o) {
                        const { x: e, y: r, z: n } = o.anchor, [i, s, a] = o.up;
                        Fg(x, e, r, n, i, s, a), Fg(x, e, r, n, i, s, a), Fg(x, e, r, n, i, s, a), Fg(x, e, r, n, i, s, a), Ug(t1.dynamicLayoutVertexArray, e, r, n, w);
                    } else Ug(t1.dynamicLayoutVertexArray, l.x, l.y, l.z, w);
                    if (m) {
                        const e = v || h;
                        Og(t1.iconTransitioningVertexArray, e.x, e.y), Og(t1.iconTransitioningVertexArray, e.x + e.w, e.y), Og(t1.iconTransitioningVertexArray, e.x, e.y + e.h), Og(t1.iconTransitioningVertexArray, e.x + e.w, e.y + e.h);
                    }
                    y.emplaceBack(z, z + 1, z + 2), y.emplaceBack(z + 1, z + 2, z + 3), b.vertexLength += 4, b.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(T[0]), n !== e.length - 1 && P === e[n + 1].sectionIndex || t1.programConfigurations.populatePaintArrays(g.length, s, s.index, {}, p, f, d, M && M[P]);
                }
                const A = o ? o.anchor : l;
                t1.placedSymbolArray.emplaceBack(A.x, A.y, A.z, l.x, l.y, v, this.glyphOffsetArray.length - v, _, u, c, l.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], a, 0, !1, 0, h, 0);
            }
            _commitLayoutVertex(t1, e, r, n, i, s, a) {
                t1.emplaceBack(e, r, n, i, s, Math.round(a.x), Math.round(a.y));
            }
            _addCollisionDebugVertices(t1, e, r, n, i, s, a) {
                const o = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray), l = o.vertexLength, u = a.tileAnchorX, c = a.tileAnchorY;
                for(let t1 = 0; t1 < 4; t1++)r.collisionVertexArray.emplaceBack(0, 0, 0, 0);
                this._commitDebugCollisionVertexUpdate(r.collisionVertexArrayExt, e, t1.padding, a.zOffset), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new Ne(t1.x1, t1.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new Ne(t1.x2, t1.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new Ne(t1.x2, t1.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new Ne(t1.x1, t1.y2)), o.vertexLength += 4;
                const h = r.indexArray;
                h.emplaceBack(l, l + 1), h.emplaceBack(l + 1, l + 2), h.emplaceBack(l + 2, l + 3), h.emplaceBack(l + 3, l), o.primitiveLength += 4;
            }
            _addTextDebugCollisionBoxes(t1, e, r, n, i, s) {
                for(let a = n; a < i; a++){
                    const n = r.get(a), i = this.getSymbolInstanceTextSize(t1, s, e, a);
                    this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
                }
            }
            _addIconDebugCollisionBoxes(t1, e, r, n, i, s) {
                for(let a = n; a < i; a++){
                    const n = r.get(a), i = this.getSymbolInstanceIconSize(t1, e, s.placedIconSymbolIndex);
                    this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
                }
            }
            generateCollisionDebugBuffers(t1, e) {
                this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new qg(Kl, Zd.members, Zl), this.iconCollisionBox = new qg(Kl, Zd.members, Zl);
                const r = qm(this.iconSizeData, t1), n = qm(this.textSizeData, t1);
                for(let i = 0; i < this.symbolInstances.length; i++){
                    const s = this.symbolInstances.get(i);
                    this._addTextDebugCollisionBoxes(n, t1, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._addTextDebugCollisionBoxes(n, t1, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t1, e, s.iconBoxStartIndex, s.iconBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t1, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);
                }
            }
            getSymbolInstanceTextSize(t1, e, r, n) {
                const i = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : n), s = jm(this.textSizeData, t1, i) / Fm;
                return this.tilePixelRatio * s;
            }
            getSymbolInstanceIconSize(t1, e, r) {
                const n = this.icon.placedSymbolArray.get(r), i = jm(this.iconSizeData, t1, n);
                return this.tilePixelRatio * i;
            }
            _commitDebugCollisionVertexUpdate(t1, e, r, n) {
                t1.emplaceBack(e, -r, -r, n), t1.emplaceBack(e, r, -r, n), t1.emplaceBack(e, r, r, n), t1.emplaceBack(e, -r, r, n);
            }
            _updateTextDebugCollisionBoxes(t1, e, r, n, i, s) {
                for(let a = n; a < i; a++){
                    const n = r.get(a), i = this.getSymbolInstanceTextSize(t1, s, e, a);
                    this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding, s.zOffset);
                }
            }
            _updateIconDebugCollisionBoxes(t1, e, r, n, i, s) {
                for(let a = n; a < i; a++){
                    const n = r.get(a), i = this.getSymbolInstanceIconSize(t1, e, s.placedIconSymbolIndex);
                    this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding, s.zOffset);
                }
            }
            updateCollisionDebugBuffers(t1, e) {
                if (!this.hasDebugData()) return;
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
                const r = qm(this.iconSizeData, t1), n = qm(this.textSizeData, t1);
                for(let i = 0; i < this.symbolInstances.length; i++){
                    const s = this.symbolInstances.get(i);
                    this._updateTextDebugCollisionBoxes(n, t1, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._updateTextDebugCollisionBoxes(n, t1, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._updateIconDebugCollisionBoxes(r, t1, e, s.iconBoxStartIndex, s.iconBoxEndIndex, s), this._updateIconDebugCollisionBoxes(r, t1, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);
                }
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
            }
            _deserializeCollisionBoxesForSymbol(t1, e, r, n, i, s, a, o, l) {
                const u = {};
                if (e < r) {
                    const { x1: r, y1: n, x2: i, y2: s, padding: a, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: f } = t1.get(e);
                    u.textBox = {
                        x1: r,
                        y1: n,
                        x2: i,
                        y2: s,
                        padding: a,
                        projectedAnchorX: o,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.textFeatureIndex = f;
                }
                if (n < i) {
                    const { x1: e, y1: r, x2: i, y2: s, padding: a, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: f } = t1.get(n);
                    u.verticalTextBox = {
                        x1: e,
                        y1: r,
                        x2: i,
                        y2: s,
                        padding: a,
                        projectedAnchorX: o,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.verticalTextFeatureIndex = f;
                }
                if (s < a) {
                    const { x1: e, y1: r, x2: n, y2: i, padding: a, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: f } = t1.get(s);
                    u.iconBox = {
                        x1: e,
                        y1: r,
                        x2: n,
                        y2: i,
                        padding: a,
                        projectedAnchorX: o,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.iconFeatureIndex = f;
                }
                if (o < l) {
                    const { x1: e, y1: r, x2: n, y2: i, padding: s, projectedAnchorX: a, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: f } = t1.get(o);
                    u.verticalIconBox = {
                        x1: e,
                        y1: r,
                        x2: n,
                        y2: i,
                        padding: s,
                        projectedAnchorX: a,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.verticalIconFeatureIndex = f;
                }
                return u;
            }
            deserializeCollisionBoxes(t1) {
                this.collisionArrays = [];
                for(let e = 0; e < this.symbolInstances.length; e++){
                    const r = this.symbolInstances.get(e);
                    this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t1, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));
                }
            }
            hasTextData() {
                return this.text.segments.get().length > 0;
            }
            hasIconData() {
                return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
                return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
                return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            hasIconTextFit() {
                return this.hasAnyIconTextFit;
            }
            addIndicesForPlacedSymbol(t1, e) {
                const r = t1.placedSymbolArray.get(e), n = r.vertexStartIndex + 4 * r.numGlyphs;
                for(let e = r.vertexStartIndex; e < n; e += 4)t1.indexArray.emplaceBack(e, e + 1, e + 2), t1.indexArray.emplaceBack(e + 1, e + 2, e + 3);
            }
            getSortedSymbolIndexes(t1) {
                if (this.sortedAngle === t1 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
                const e = Math.sin(t1), r = Math.cos(t1), n = [], i = [], s = [];
                for(let t1 = 0; t1 < this.symbolInstances.length; ++t1){
                    s.push(t1);
                    const a = this.symbolInstances.get(t1);
                    n.push(0 | Math.round(e * a.tileAnchorX + r * a.tileAnchorY)), i.push(a.featureIndex);
                }
                return s.sort((t1, e)=>n[t1] - n[e] || i[e] - i[t1]), s;
            }
            getSortedIndexesByZOffset() {
                if (!this.zOffsetSortDirty) return this.symbolInstanceIndexesSortedZOffset;
                if (!this.symbolInstanceIndexesSortedZOffset) {
                    this.symbolInstanceIndexesSortedZOffset = [];
                    for(let t1 = 0; t1 < this.symbolInstances.length; ++t1)this.symbolInstanceIndexesSortedZOffset.push(t1);
                }
                return this.zOffsetSortDirty = !1, this.symbolInstanceIndexesSortedZOffset.sort((t1, e)=>this.symbolInstances.get(e).zOffset - this.symbolInstances.get(t1).zOffset);
            }
            addToSortKeyRanges(t1, e) {
                const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                r && r.sortKey === e ? r.symbolInstanceEnd = t1 + 1 : this.sortKeyRanges.push({
                    sortKey: e,
                    symbolInstanceStart: t1,
                    symbolInstanceEnd: t1 + 1
                });
            }
            sortFeatures(t1) {
                if (this.sortFeaturesByY && this.sortedAngle !== t1 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                    this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t1), this.sortedAngle = t1, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                    for (const t1 of this.symbolInstanceIndexes){
                        const e = this.symbolInstances.get(t1);
                        this.featureSortOrder.push(e.featureIndex);
                        const { rightJustifiedTextSymbolIndex: r, centerJustifiedTextSymbolIndex: n, leftJustifiedTextSymbolIndex: i, verticalPlacedTextSymbolIndex: s, placedIconSymbolIndex: a, verticalPlacedIconSymbolIndex: o } = e;
                        r >= 0 && this.addIndicesForPlacedSymbol(this.text, r), n >= 0 && n !== r && this.addIndicesForPlacedSymbol(this.text, n), i >= 0 && i !== n && i !== r && this.addIndicesForPlacedSymbol(this.text, i), s >= 0 && this.addIndicesForPlacedSymbol(this.text, s), a >= 0 && this.addIndicesForPlacedSymbol(this.icon, a), o >= 0 && this.addIndicesForPlacedSymbol(this.icon, o);
                    }
                    this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
                }
            }
        }
        Mo($g, "SymbolBucket", {
            omit: [
                "layers",
                "collisionBoxArray",
                "features",
                "compareText"
            ]
        }), $g.addDynamicAttributes = Ug;
        class Gg {
            constructor(t1, e, r, n){
                this.context = t1, this.format = r, this.texture = t1.gl.createTexture(), this.update(e, n);
            }
            update(t1, e, r) {
                const { width: n, height: i } = t1, { context: s } = this, { gl: a } = s;
                if (a.bindTexture(a.TEXTURE_2D, this.texture), s.pixelStoreUnpackFlipY.set(!1), s.pixelStoreUnpack.set(1), s.pixelStoreUnpackPremultiplyAlpha.set(this.format === a.RGBA && (!e || !1 !== e.premultiply)), this.useMipmap = Boolean(e && e.useMipmap), r || this.size && this.size[0] === n && this.size[1] === i) {
                    const { x: e, y: s } = r || {
                        x: 0,
                        y: 0
                    };
                    if (t1 instanceof HTMLImageElement || t1 instanceof HTMLCanvasElement || t1 instanceof HTMLVideoElement || t1 instanceof ImageData || ImageBitmap && t1 instanceof ImageBitmap) a.texSubImage2D(a.TEXTURE_2D, 0, e, s, a.RGBA, a.UNSIGNED_BYTE, t1);
                    else {
                        let r = this.format, o = a.UNSIGNED_BYTE;
                        this.format === a.R32F && (r = a.RED, o = a.FLOAT), a.texSubImage2D(a.TEXTURE_2D, 0, e, s, n, i, r, o, t1.data);
                    }
                } else if (this.size = [
                    n,
                    i
                ], t1 instanceof HTMLImageElement || t1 instanceof HTMLCanvasElement || t1 instanceof HTMLVideoElement || t1 instanceof ImageData || ImageBitmap && t1 instanceof ImageBitmap) {
                    let e = this.format;
                    this.format === a.R8 && (e = a.RED), a.texImage2D(a.TEXTURE_2D, 0, this.format, e, a.UNSIGNED_BYTE, t1);
                } else {
                    let e = this.format, r = this.format, s = a.UNSIGNED_BYTE, o = !1;
                    this.format === a.DEPTH_COMPONENT && (e = a.DEPTH_COMPONENT16, s = a.UNSIGNED_SHORT), this.format === a.DEPTH_STENCIL && (e = a.DEPTH24_STENCIL8, s = a.UNSIGNED_INT_24_8, o = !0), this.format === a.R8 && (r = a.RED), this.format === a.R32F && (s = a.FLOAT, r = a.RED), !this.useMipmap && o ? a.texStorage2D(a.TEXTURE_2D, 1, e, n, i) : a.texImage2D(a.TEXTURE_2D, 0, e, n, i, 0, r, s, t1.data);
                }
                this.useMipmap && a.generateMipmap(a.TEXTURE_2D);
            }
            bind(t1, e, r = !1) {
                const { context: n } = this, { gl: i } = n;
                i.bindTexture(i.TEXTURE_2D, this.texture), t1 !== this.minFilter && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, t1), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, this.useMipmap && !r ? t1 === i.NEAREST ? i.NEAREST_MIPMAP_NEAREST : i.LINEAR_MIPMAP_LINEAR : t1), this.minFilter = t1), e !== this.wrapS && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, e), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, e), this.wrapS = e);
            }
            bindExtraParam(t1, e, r, n) {
                const { context: i } = this, { gl: s } = i;
                s.bindTexture(s.TEXTURE_2D, this.texture), e !== this.magFilter && (s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, e), this.magFilter = e), t1 !== this.minFilter && (s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, this.useMipmap ? t1 === s.NEAREST ? s.NEAREST_MIPMAP_NEAREST : s.LINEAR_MIPMAP_LINEAR : t1), this.minFilter = t1), r !== this.wrapS && (s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, r), this.wrapS = r), n !== this.wrapT && (s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, n), this.wrapT = n);
            }
            destroy() {
                const { gl: t1 } = this.context;
                t1.deleteTexture(this.texture), this.texture = null;
            }
        }
        class Yg {
            constructor(t1, e){
                this.context = t1, this.texture = e;
            }
            bind(t1, e) {
                const { context: r } = this, { gl: n } = r;
                n.bindTexture(n.TEXTURE_2D, this.texture), t1 !== this.minFilter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t1), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, t1), this.minFilter = t1), e !== this.wrapS && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e), this.wrapS = e);
            }
        }
        const Xg = 32, Zg = 33, Hg = new Uint16Array(8184);
        for(let t1 = 0; t1 < 2046; t1++){
            let e = t1 + 2, r = 0, n = 0, i = 0, s = 0, a = 0, o = 0;
            for(1 & e ? i = s = a = Xg : r = n = o = Xg; (e >>= 1) > 1;){
                const t1 = r + i >> 1, l = n + s >> 1;
                1 & e ? (i = r, s = n, r = a, n = o) : (r = i, n = s, i = a, s = o), a = t1, o = l;
            }
            const l = 4 * t1;
            Hg[l + 0] = r, Hg[l + 1] = n, Hg[l + 2] = i, Hg[l + 3] = s;
        }
        const Kg = new Uint16Array(2178), Wg = new Uint8Array(1089), Jg = new Uint16Array(1089);
        function Qg(t1) {
            return 0 === t1 ? -0.03125 : 32 === t1 ? .03125 : 0;
        }
        var tx = Bl([
            {
                name: "a_pos",
                type: "Int16",
                components: 2
            },
            {
                name: "a_texture_pos",
                type: "Int16",
                components: 2
            }
        ]), ex = Bl([
            {
                name: "a_index",
                type: "Int16",
                components: 1
            }
        ]);
        const rx = (()=>({
                type: 2,
                extent: ps,
                loadGeometry: ()=>[
                        [
                            new Ne(0, 0),
                            new Ne(ps + 1, 0),
                            new Ne(ps + 1, ps + 1),
                            new Ne(0, ps + 1),
                            new Ne(0, 0)
                        ]
                    ]
            }))();
        class nx {
            constructor(t1, e, r, n, i){
                this.tileID = t1, this.uid = nr(), this.uses = 0, this.tileSize = e, this.tileZoom = r, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = i, n && n.style && (this._lastUpdatedBrightness = n.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", n && n.transform && (this.projection = n.transform.projection);
            }
            registerFadeDuration(t1) {
                const e = t1 + this.timeAdded;
                e < Dr.now() || this.fadeEndTime && e < this.fadeEndTime || (this.fadeEndTime = e);
            }
            wasRequested() {
                return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }
            get tileTransform() {
                return this._tileTransform || (this._tileTransform = ng(this.tileID.canonical, this.projection)), this._tileTransform;
            }
            loadVectorData(t1, e, r) {
                if (this.unloadVectorData(), this.state = "loaded", t1) {
                    t1.featureIndex && (this.latestFeatureIndex = t1.featureIndex, t1.rawTileData ? (this.latestRawTileData = t1.rawTileData, this.latestFeatureIndex.rawTileData = t1.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t1.collisionBoxArray, this.buckets = function(t1, e) {
                        const r = {};
                        if (!e) return r;
                        for (const n of t1){
                            const t1 = n.layerIds.map((t1)=>e.getLayer(t1)).filter(Boolean);
                            if (0 !== t1.length) {
                                n.layers = t1, n.stateDependentLayerIds && (n.stateDependentLayers = n.stateDependentLayerIds.map((e)=>t1.filter((t1)=>t1.id === e)[0]));
                                for (const e of t1)r[e.fqid] = n;
                            }
                        }
                        return r;
                    }(t1.buckets, e.style), this.hasSymbolBuckets = !1;
                    for(const t1 in this.buckets){
                        const e = this.buckets[t1];
                        if (e instanceof $g) {
                            if (this.hasSymbolBuckets = !0, !r) break;
                            e.justReloaded = !0;
                        }
                    }
                    if (this.hasRTLText = !1, this.hasSymbolBuckets) for(const t1 in this.buckets){
                        const e = this.buckets[t1];
                        if (e instanceof $g && e.hasRTLText) {
                            this.hasRTLText = !0, Zo.isLoading() || Zo.isLoaded() || "deferred" !== Yo() || Xo();
                            break;
                        }
                    }
                    this.queryPadding = 0;
                    for(const t1 in this.buckets){
                        const r = this.buckets[t1], n = e.style.getOwnLayer(t1);
                        if (!n) continue;
                        const i = n.queryRadius(r);
                        this.queryPadding = Math.max(this.queryPadding, i);
                    }
                    t1.imageAtlas && (this.imageAtlas = t1.imageAtlas), t1.glyphAtlasImage && (this.glyphAtlasImage = t1.glyphAtlasImage), t1.lineAtlas && (this.lineAtlas = t1.lineAtlas), this._lastUpdatedBrightness = t1.brightness;
                } else this.collisionBoxArray = new pu;
            }
            unloadVectorData() {
                if (this.hasData()) {
                    for(const t1 in this.buckets)this.buckets[t1].destroy();
                    this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
                }
            }
            getBucket(t1) {
                return this.buckets[t1.fqid];
            }
            upload(t1) {
                for(const e in this.buckets){
                    const r = this.buckets[e];
                    r.uploadPending() && r.upload(t1);
                }
                const e = t1.gl, r = this.imageAtlas;
                if (r && !r.uploaded) {
                    const n = !!Object.keys(r.patternPositions).length;
                    this.imageAtlasTexture = new Gg(t1, r.image, e.RGBA, {
                        useMipmap: n
                    }), this.imageAtlas.uploaded = !0;
                }
                this.glyphAtlasImage && (this.glyphAtlasTexture = new Gg(t1, this.glyphAtlasImage, e.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new Gg(t1, this.lineAtlas.image, e.R8), this.lineAtlas.uploaded = !0);
            }
            prepare(t1, e, r) {
                if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(t1, this.imageAtlasTexture, r), !e || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;
                const n = e.style.getBrightness();
                (this._lastUpdatedBrightness || n) && (this._lastUpdatedBrightness && n && Math.abs(this._lastUpdatedBrightness - n) < .001 || (this._lastUpdatedBrightness = n, this.updateBuckets(void 0, e)));
            }
            queryRenderedFeatures(t1, e, r, n, i, s, a, o) {
                return this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) ? this.latestFeatureIndex.query({
                    tileResult: n,
                    pixelPosMatrix: a,
                    transform: s,
                    params: i,
                    tileTransform: this.tileTransform
                }, t1, e, r) : {};
            }
            querySourceFeatures(t1, e) {
                const r = this.latestFeatureIndex;
                if (!r || !r.rawTileData) return;
                const n = r.loadVTLayers(), i = e ? e.sourceLayer : "", s = n._geojsonTileLayer || n[i];
                if (!s) return;
                const a = pl(e && e.filter), { z: o, x: l, y: u } = this.tileID.canonical, c = {
                    z: o,
                    x: l,
                    y: u
                };
                for(let e = 0; e < s.length; e++){
                    const n = s.feature(e);
                    if (a.needGeometry) {
                        const t1 = Xc(n, !0);
                        if (!a.filter(new Ho(this.tileID.overscaledZ), t1, this.tileID.canonical)) continue;
                    } else if (!a.filter(new Ho(this.tileID.overscaledZ), n)) continue;
                    const h = r.getId(n, i), p = new Cm(n, o, l, u, h);
                    p.tile = c, t1.push(p);
                }
            }
            hasData() {
                return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }
            bucketsLoaded() {
                for(const t1 in this.buckets)if (this.buckets[t1].uploadPending()) return !1;
                return !0;
            }
            patternsLoaded() {
                return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
            }
            setExpiryData(t1) {
                const e = this.expirationTime;
                if (t1.cacheControl) {
                    const e = xr(t1.cacheControl);
                    e["max-age"] && (this.expirationTime = Date.now() + 1e3 * e["max-age"]);
                } else t1.expires && (this.expirationTime = new Date(t1.expires).getTime());
                if (this.expirationTime) {
                    const t1 = Date.now();
                    let r = !1;
                    if (this.expirationTime > t1) r = !1;
                    else if (e) {
                        if (this.expirationTime < e) r = !0;
                        else {
                            const n = this.expirationTime - e;
                            n ? this.expirationTime = t1 + Math.max(n, 3e4) : r = !0;
                        }
                    } else r = !0;
                    r ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
                }
            }
            getExpiryTimeout() {
                if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1);
            }
            setFeatureState(t1, e) {
                this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(t1).length && e && this.updateBuckets(t1, e);
            }
            updateBuckets(t1, e) {
                if (!this.latestFeatureIndex) return;
                const r = this.latestFeatureIndex.loadVTLayers(), n = e.style.listImages(), i = e.style.getBrightness();
                for(const s in this.buckets){
                    if (!e.style.hasLayer(s)) continue;
                    const a = this.buckets[s], o = a.layers[0].sourceLayer || "_geojsonTileLayer", l = r[o];
                    let u = {};
                    if (t1 && (u = t1[o], !l || !u || 0 === Object.keys(u).length)) continue;
                    if (a.update(u, l, n, this.imageAtlas && this.imageAtlas.patternPositions || {}, i), a instanceof tm || a instanceof Wp) {
                        const t1 = e.style.getOwnSourceCache(a.layers[0].source);
                        e._terrain && e._terrain.enabled && t1 && a.programConfigurations.needsUpload && e._terrain._clearRenderCacheForTile(t1.id, this.tileID);
                    }
                    const c = e && e.style && e.style.getOwnLayer(s);
                    c && (this.queryPadding = Math.max(this.queryPadding, c.queryRadius(a)));
                }
            }
            holdingForFade() {
                return void 0 !== this.symbolFadeHoldUntil;
            }
            symbolFadeFinished() {
                return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Dr.now();
            }
            clearFadeHold() {
                this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(t1) {
                this.symbolFadeHoldUntil = Dr.now() + t1;
            }
            setTexture(t1, e) {
                const r = e.context, n = r.gl;
                this.texture = this.texture || e.getTileTexture(t1.width), this.texture && this.texture instanceof Gg ? this.texture.update(t1, {
                    useMipmap: !0
                }) : (this.texture = new Gg(r, t1, n.RGBA, {
                    useMipmap: !0
                }), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
            }
            setDependencies(t1, e) {
                const r = {};
                for (const t1 of e)r[t1] = !0;
                this.dependencies[t1] = r;
            }
            hasDependency(t1, e) {
                for (const r of t1){
                    const t1 = this.dependencies[r];
                    if (t1) {
                        for (const r of e)if (t1[r]) return !0;
                    }
                }
                return !1;
            }
            clearQueryDebugViz() {}
            _makeDebugTileBoundsBuffers(t1, e) {
                if (!e || "mercator" === e.name || this._tileDebugBuffer) return;
                const r = Yc(rx, this.tileID.canonical, this.tileTransform)[0], n = new Cl, i = new au;
                for(let t1 = 0; t1 < r.length; t1++){
                    const { x: e, y: s } = r[t1];
                    n.emplaceBack(e, s), i.emplaceBack(t1);
                }
                i.emplaceBack(0), this._tileDebugIndexBuffer = t1.createIndexBuffer(i), this._tileDebugBuffer = t1.createVertexBuffer(n, kh.members), this._tileDebugSegments = Au.simpleSegment(0, 0, n.length, i.length);
            }
            _makeTileBoundsBuffers(t1, e) {
                if (this._tileBoundsBuffer || !e || "mercator" === e.name) return;
                const r = Yc(rx, this.tileID.canonical, this.tileTransform)[0];
                let n, i;
                if (this.isRaster) {
                    const t1 = function(t1, e) {
                        const r = ng(t1, e), n = Math.pow(2, t1.z);
                        for(let i = 0; i < Zg; i++)for(let s = 0; s < Zg; s++){
                            const a = zc((t1.x + (s + Qg(s)) / Xg) / n), o = Ec((t1.y + (i + Qg(i)) / Xg) / n), l = e.project(a, o), u = i * Zg + s;
                            Kg[2 * u + 0] = Math.round((l.x * r.scale - r.x) * ps), Kg[2 * u + 1] = Math.round((l.y * r.scale - r.y) * ps);
                        }
                        Wg.fill(0), Jg.fill(0);
                        for(let t1 = 2045; t1 >= 0; t1--){
                            const e = 4 * t1, r = Hg[e + 0], n = Hg[e + 1], i = Hg[e + 2], s = Hg[e + 3], a = r + i >> 1, o = n + s >> 1, l = a + o - n, u = o + r - a, c = n * Zg + r, h = s * Zg + i, p = o * Zg + a, f = Math.hypot((Kg[2 * c + 0] + Kg[2 * h + 0]) / 2 - Kg[2 * p + 0], (Kg[2 * c + 1] + Kg[2 * h + 1]) / 2 - Kg[2 * p + 1]) >= 16;
                            Wg[p] = Wg[p] || (f ? 1 : 0), t1 < 1022 && (Wg[p] = Wg[p] || Wg[(n + u >> 1) * Zg + (r + l >> 1)] || Wg[(s + u >> 1) * Zg + (i + l >> 1)]);
                        }
                        const i = new Vl, s = new Ql;
                        let a = 0;
                        function o(t1, e) {
                            const r = e * Zg + t1;
                            return 0 === Jg[r] && (i.emplaceBack(Kg[2 * r + 0], Kg[2 * r + 1], t1 * ps / Xg, e * ps / Xg), Jg[r] = ++a), Jg[r] - 1;
                        }
                        function l(t1, e, r, n, i, a) {
                            const u = t1 + r >> 1, c = e + n >> 1;
                            if (Math.abs(t1 - i) + Math.abs(e - a) > 1 && Wg[c * Zg + u]) l(i, a, t1, e, u, c), l(r, n, i, a, u, c);
                            else {
                                const l = o(t1, e), u = o(r, n), c = o(i, a);
                                s.emplaceBack(l, u, c);
                            }
                        }
                        return l(0, 0, Xg, Xg, Xg, 0), l(Xg, Xg, 0, 0, 0, Xg), {
                            vertices: i,
                            indices: s
                        };
                    }(this.tileID.canonical, e);
                    n = t1.vertices, i = t1.indices;
                } else {
                    n = new Vl, i = new Ql;
                    for (const { x: t1, y: e } of r)n.emplaceBack(t1, e, 0, 0);
                    const t1 = wp(n.int16, void 0, 4);
                    for(let e = 0; e < t1.length; e += 3)i.emplaceBack(t1[e], t1[e + 1], t1[e + 2]);
                }
                this._tileBoundsBuffer = t1.createVertexBuffer(n, tx.members), this._tileBoundsIndexBuffer = t1.createIndexBuffer(i), this._tileBoundsSegments = Au.simpleSegment(0, 0, n.length, i.length);
            }
            _makeGlobeTileDebugBuffers(e, r) {
                const n = r.projection;
                if (!n || "globe" !== n.name || r.freezeTileCoverage) return;
                const i = this.tileID.canonical, s = $h(Vh(i, r)), a = Hh(r.zoom);
                let o;
                a > 0 && (o = t1.ad.invert(new Float64Array(16), r.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(e, i, r, s, o, a), this._makeGlobeTileDebugTextBuffer(e, i, r, s, o, a);
            }
            _globePoint(e, r, n, i, s, a, o) {
                let l = Nh(e, r, n);
                if (a) {
                    const s = 1 << n.z, u = Tc(i.center.lng), c = kc(i.center.lat), h = (n.x + .5) / s - u;
                    let p = 0;
                    h > .5 ? p = -1 : h < -0.5 && (p = 1);
                    let f = (e / ps + n.x) / s + p, d = (r / ps + n.y) / s;
                    f = (f - u) * i._pixelsPerMercatorPixel + u, d = (d - c) * i._pixelsPerMercatorPixel + c;
                    const m = [
                        f * i.worldSize,
                        d * i.worldSize,
                        0
                    ];
                    t1._.transformMat4(m, m, a), l = Rh(l, m, o);
                }
                return t1._.transformMat4(l, l, s);
            }
            _makeGlobeTileDebugBorderBuffer(t1, e, r, n, i, s) {
                const a = new Cl, o = new au, l = new Rl, u = (t1, u, c, h, p)=>{
                    const f = (c - t1) / (p - 1), d = (h - u) / (p - 1), m = a.length;
                    for(let c = 0; c < p; c++){
                        const h = t1 + c * f, p = u + c * d;
                        a.emplaceBack(h, p);
                        const y = this._globePoint(h, p, e, r, n, i, s);
                        l.emplaceBack(y[0], y[1], y[2]), o.emplaceBack(m + c);
                    }
                }, c = ps;
                u(0, 0, c, 0, 16), u(c, 0, c, c, 16), u(c, c, 0, c, 16), u(0, c, 0, 0, 16), this._tileDebugIndexBuffer = t1.createIndexBuffer(o), this._tileDebugBuffer = t1.createVertexBuffer(a, kh.members), this._globeTileDebugBorderBuffer = t1.createVertexBuffer(l, Th.members), this._tileDebugSegments = Au.simpleSegment(0, 0, a.length, o.length);
            }
            _makeGlobeTileDebugTextBuffer(t1, e, r, n, i, s) {
                const a = ps / 4, o = new Cl, l = new Ql, u = new Rl, c = 25;
                l.reserve(32), o.reserve(c), u.reserve(c);
                const h = (t1, e)=>c * t1 + e;
                for(let t1 = 0; t1 < c; t1++){
                    const l = t1 * a;
                    for(let t1 = 0; t1 < c; t1++){
                        const c = t1 * a;
                        o.emplaceBack(c, l);
                        const h = this._globePoint(c, l, e, r, n, i, s);
                        u.emplaceBack(h[0], h[1], h[2]);
                    }
                }
                for(let t1 = 0; t1 < 4; t1++)for(let e = 0; e < 4; e++){
                    const r = h(t1, e), n = h(t1, e + 1), i = h(t1 + 1, e), s = h(t1 + 1, e + 1);
                    l.emplaceBack(r, n, i), l.emplaceBack(i, n, s);
                }
                this._tileDebugTextIndexBuffer = t1.createIndexBuffer(l), this._tileDebugTextBuffer = t1.createVertexBuffer(o, kh.members), this._globeTileDebugTextBuffer = t1.createVertexBuffer(u, Th.members), this._tileDebugTextSegments = Au.simpleSegment(0, 0, c, 32);
            }
            destroy(t1 = !1) {
                for(const t1 in this.buckets)this.buckets[t1].destroy();
                this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t1 && this.texture && this.texture instanceof Gg && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded";
            }
        }
        function ix(t1, e, r) {
            1 === t1 ? e.header_length = r.readFixed32() : 2 === t1 ? e.x = r.readVarint() : 3 === t1 ? e.y = r.readVarint() : 4 === t1 ? e.z = r.readVarint() : 5 === t1 && e.layers.push(function(t1, e) {
                return t1.readFields(ux, {
                    version: 0,
                    name: "",
                    units: "",
                    tilesize: 0,
                    buffer: 0,
                    pixel_format: 0,
                    data_index: []
                }, e);
            }(r, r.readVarint() + r.pos));
        }
        function sx(t1, e, r) {
            1 === t1 ? (e.delta_filter = function(t1, e) {
                return t1.readFields(ax, {
                    block_size: 0
                }, e);
            }(r, r.readVarint() + r.pos), e.filter = "delta_filter") : 2 === t1 ? (r.readVarint(), e.filter = "zigzag_filter") : 3 === t1 ? (r.readVarint(), e.filter = "bitshuffle_filter") : 4 === t1 && (r.readVarint(), e.filter = "byteshuffle_filter");
        }
        function ax(t1, e, r) {
            1 === t1 && (e.block_size = r.readVarint());
        }
        function ox(t1, e, r) {
            1 === t1 ? (r.readVarint(), e.codec = "gzip_data") : 2 === t1 ? (r.readVarint(), e.codec = "jpeg_image") : 3 === t1 ? (r.readVarint(), e.codec = "webp_image") : 4 === t1 && (r.readVarint(), e.codec = "png_image");
        }
        function lx(t1, e, r) {
            1 === t1 ? e.first_byte = r.readFixed64() : 2 === t1 ? e.last_byte = r.readFixed64() : 3 === t1 ? e.filters.push(function(t1, e) {
                return t1.readFields(sx, {}, e);
            }(r, r.readVarint() + r.pos)) : 4 === t1 ? e.codec = function(t1, e) {
                return t1.readFields(ox, {}, e);
            }(r, r.readVarint() + r.pos) : 5 === t1 ? e.offset = r.readFloat() : 6 === t1 ? e.scale = r.readFloat() : 7 === t1 && e.bands.push(r.readString());
        }
        function ux(t1, e, r) {
            1 === t1 ? e.version = r.readVarint() : 2 === t1 ? e.name = r.readString() : 3 === t1 ? e.units = r.readString() : 4 === t1 ? e.tilesize = r.readVarint() : 5 === t1 ? e.buffer = r.readVarint() : 6 === t1 ? e.pixel_format = r.readVarint() : 7 === t1 && e.data_index.push(function(t1, e) {
                return t1.readFields(lx, {
                    first_byte: 0,
                    last_byte: 0,
                    filters: [],
                    codec: null,
                    offset: 0,
                    scale: 0,
                    bands: []
                }, e);
            }(r, r.readVarint() + r.pos));
        }
        function cx(t1, e, r) {
            if (2 === t1) !function(t1, e, r) {
                t1.readFields(hx, r, e);
            }(r, r.readVarint() + r.pos, e);
            else if (3 === t1) throw new Error("Not implemented");
        }
        function hx(t1, e, r) {
            if (1 === t1) {
                let t1 = 0;
                const n = r.readVarint() + r.pos;
                for(; r.pos < n;)e[t1++] = r.readVarint();
            }
        }
        /**
 * tiny-lru
 *
 * @copyright 2024 Jason Mulligan <jason.mulligan@avoidwork.com>
 * @license BSD-3-Clause
 * @version 11.2.11
 */ class px {
            constructor(t1 = 0, e = 0, r = !1){
                this.first = null, this.items = Object.create(null), this.last = null, this.max = t1, this.resetTtl = r, this.size = 0, this.ttl = e;
            }
            clear() {
                return this.first = null, this.items = Object.create(null), this.last = null, this.size = 0, this;
            }
            delete(t1) {
                if (this.has(t1)) {
                    const e = this.items[t1];
                    delete this.items[t1], this.size--, null !== e.prev && (e.prev.next = e.next), null !== e.next && (e.next.prev = e.prev), this.first === e && (this.first = e.next), this.last === e && (this.last = e.prev);
                }
                return this;
            }
            entries(t1 = this.keys()) {
                return t1.map((t1)=>[
                        t1,
                        this.get(t1)
                    ]);
            }
            evict(t1 = !1) {
                if (t1 || this.size > 0) {
                    const t1 = this.first;
                    delete this.items[t1.key], 0 == --this.size ? (this.first = null, this.last = null) : (this.first = t1.next, this.first.prev = null);
                }
                return this;
            }
            expiresAt(t1) {
                let e;
                return this.has(t1) && (e = this.items[t1].expiry), e;
            }
            get(t1) {
                let e;
                if (this.has(t1)) {
                    const r = this.items[t1];
                    this.ttl > 0 && r.expiry <= Date.now() ? this.delete(t1) : (e = r.value, this.set(t1, e, !0));
                }
                return e;
            }
            has(t1) {
                return t1 in this.items;
            }
            keys() {
                const t1 = [];
                let e = this.first;
                for(; null !== e;)t1.push(e.key), e = e.next;
                return t1;
            }
            set(t1, e, r = !1, n = this.resetTtl) {
                let i;
                if (r || this.has(t1)) {
                    if (i = this.items[t1], i.value = e, !1 === r && n && (i.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl), this.last !== i) {
                        const t1 = this.last, e = i.next, r = i.prev;
                        this.first === i && (this.first = i.next), i.next = null, i.prev = this.last, t1.next = i, null !== r && (r.next = e), null !== e && (e.prev = r);
                    }
                } else this.max > 0 && this.size === this.max && this.evict(!0), i = this.items[t1] = {
                    expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
                    key: t1,
                    prev: this.last,
                    next: null,
                    value: e
                }, 1 == ++this.size ? this.first = i : this.last.next = i;
                return this.last = i, this;
            }
            values(t1 = this.keys()) {
                return t1.map((t1)=>this.get(t1));
            }
        }
        function fx(t1, e) {
            if (4 !== e.length) throw new Error(`Expected data of dimension 4 but got ${e.length}.`);
            let r = e[3];
            for(let n = 2; n >= 1; n--){
                const i = 1 === n ? 1 : 0, s = 2 === n ? 1 : 0;
                for(let n = 0; n < e[0]; n++){
                    const a = e[1] * n;
                    for(let n = i; n < e[1]; n++){
                        const i = e[2] * (n + a);
                        for(let n = s; n < e[2]; n++){
                            const s = e[3] * (n + i);
                            for(let n = 0; n < e[3]; n++){
                                const e = s + n;
                                t1[e] += t1[e - r];
                            }
                        }
                    }
                }
                r *= e[n];
            }
            return t1;
        }
        function dx(t1) {
            for(let e = 0, r = t1.length; e < r; e++)t1[e] = t1[e] >>> 1 ^ -(1 & t1[e]);
            return t1;
        }
        function mx(t1, e) {
            switch(e){
                case "uint32":
                    return t1;
                case "uint16":
                    for(let e = 0; e < t1.length; e += 2){
                        const r = t1[e], n = t1[e + 1];
                        t1[e] = (240 & r) >> 4 | (61440 & r) >> 8 | (240 & n) << 4 | 61440 & n, t1[e + 1] = 15 & r | (3840 & r) >> 4 | (15 & n) << 8 | (3840 & n) << 4;
                    }
                    return t1;
                case "uint8":
                    for(let e = 0; e < t1.length; e += 4){
                        const r = t1[e], n = t1[e + 1], i = t1[e + 2], s = t1[e + 3];
                        t1[e + 0] = (192 & r) >> 6 | (192 & n) >> 4 | (192 & i) >> 2 | 192 & s, t1[e + 1] = (48 & r) >> 4 | (48 & n) >> 2 | 48 & i | (48 & s) << 2, t1[e + 2] = (12 & r) >> 2 | 12 & n | (12 & i) << 2 | (12 & s) << 4, t1[e + 3] = 3 & r | (3 & n) << 2 | (3 & i) << 4 | (3 & s) << 6;
                    }
                    return t1;
                default:
                    throw new Error(`Invalid pixel format, "${e}"`);
            }
        }
        class yx extends Error {
            constructor(t1){
                super(t1), this.name = "MRTError";
            }
        }
        var gx = Uint8Array, xx = Uint16Array, bx = Int32Array, vx = new gx([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            4,
            4,
            4,
            4,
            5,
            5,
            5,
            5,
            0,
            0,
            0,
            0
        ]), _x = new gx([
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            4,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            8,
            8,
            9,
            9,
            10,
            10,
            11,
            11,
            12,
            12,
            13,
            13,
            0,
            0
        ]), wx = new gx([
            16,
            17,
            18,
            0,
            8,
            7,
            9,
            6,
            10,
            5,
            11,
            4,
            12,
            3,
            13,
            2,
            14,
            1,
            15
        ]), Mx = function(t1, e) {
            for(var r = new xx(31), n = 0; n < 31; ++n)r[n] = e += 1 << t1[n - 1];
            var i = new bx(r[30]);
            for(n = 1; n < 30; ++n)for(var s = r[n]; s < r[n + 1]; ++s)i[s] = s - r[n] << 5 | n;
            return {
                b: r,
                r: i
            };
        }, Ax = Mx(vx, 2), Sx = Ax.b, Ix = Ax.r;
        Sx[28] = 258, Ix[258] = 28;
        for(var Tx = Mx(_x, 0).b, kx = new xx(32768), Px = 0; Px < 32768; ++Px){
            var zx = (43690 & Px) >> 1 | (21845 & Px) << 1;
            kx[Px] = ((65280 & (zx = (61680 & (zx = (52428 & zx) >> 2 | (13107 & zx) << 2)) >> 4 | (3855 & zx) << 4)) >> 8 | (255 & zx) << 8) >> 1;
        }
        var Ex = function(t1, e, r) {
            for(var n = t1.length, i = 0, s = new xx(e); i < n; ++i)t1[i] && ++s[t1[i] - 1];
            var a, o = new xx(e);
            for(i = 1; i < e; ++i)o[i] = o[i - 1] + s[i - 1] << 1;
            if (r) {
                a = new xx(1 << e);
                var l = 15 - e;
                for(i = 0; i < n; ++i)if (t1[i]) for(var u = i << 4 | t1[i], c = e - t1[i], h = o[t1[i] - 1]++ << c, p = h | (1 << c) - 1; h <= p; ++h)a[kx[h] >> l] = u;
            } else for(a = new xx(n), i = 0; i < n; ++i)t1[i] && (a[i] = kx[o[t1[i] - 1]++] >> 15 - t1[i]);
            return a;
        }, Bx = new gx(288);
        for(Px = 0; Px < 144; ++Px)Bx[Px] = 8;
        for(Px = 144; Px < 256; ++Px)Bx[Px] = 9;
        for(Px = 256; Px < 280; ++Px)Bx[Px] = 7;
        for(Px = 280; Px < 288; ++Px)Bx[Px] = 8;
        var Dx = new gx(32);
        for(Px = 0; Px < 32; ++Px)Dx[Px] = 5;
        var Cx = Ex(Bx, 9, 1), Rx = Ex(Dx, 5, 1), Vx = function(t1) {
            for(var e = t1[0], r = 1; r < t1.length; ++r)t1[r] > e && (e = t1[r]);
            return e;
        }, Lx = function(t1, e, r) {
            var n = e / 8 | 0;
            return (t1[n] | t1[n + 1] << 8) >> (7 & e) & r;
        }, Ox = function(t1, e) {
            var r = e / 8 | 0;
            return (t1[r] | t1[r + 1] << 8 | t1[r + 2] << 16) >> (7 & e);
        }, Fx = [
            "unexpected EOF",
            "invalid block type",
            "invalid length/literal",
            "invalid distance",
            "stream finished",
            "no stream handler",
            ,
            "no callback",
            "invalid UTF-8 data",
            "extra field too long",
            "date not in range 1980-2099",
            "filename too long",
            "stream finishing",
            "invalid zip data"
        ], Ux = function(t1, e, r) {
            var n = new Error(e || Fx[t1]);
            if (n.code = t1, Error.captureStackTrace && Error.captureStackTrace(n, Ux), !r) throw n;
            return n;
        }, Nx = new gx(0), jx = "undefined" != typeof TextDecoder && new TextDecoder;
        try {
            jx.decode(Nx, {
                stream: !0
            });
        } catch (t1) {}
        const qx = {
            gzip_data: "gzip"
        };
        const $x = {
            0: "uint32",
            1: "uint32",
            2: "uint16",
            3: "uint8"
        }, Gx = {
            uint32: 1,
            uint16: 2,
            uint8: 4
        }, Yx = {
            uint32: Uint32Array,
            uint16: Uint16Array,
            uint8: Uint8Array
        };
        class Xx {
            constructor(t1 = 1){
                this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = t1;
            }
            getLayer(t1) {
                return this.layers[t1];
            }
            getHeaderLength(t1) {
                const e = new Uint8Array(t1), r = new DataView(t1);
                if (13 !== e[0]) throw new yx("File is not a valid MRT.");
                return r.getUint32(1, !0);
            }
            parseHeader(t1) {
                const e = new Uint8Array(t1), r = this.getHeaderLength(t1);
                if (e.length < r) throw new yx(`Expected header with length >= ${r} but got buffer of length ${e.length}`);
                const n = function(t1, e) {
                    return t1.readFields(ix, {
                        header_length: 0,
                        x: 0,
                        y: 0,
                        z: 0,
                        layers: []
                    }, void 0);
                }(new Bm(e.subarray(0, r)));
                if (!isNaN(this.x) && (this.x !== n.x || this.y !== n.y || this.z !== n.z)) throw new yx(`Invalid attempt to parse header ${n.z}/${n.x}/${n.y} for tile ${this.z}/${this.x}/${this.y}`);
                this.x = n.x, this.y = n.y, this.z = n.z;
                for (const t1 of n.layers)this.layers[t1.name] = new Zx(t1, {
                    cacheSize: this._cacheSize
                });
                return this;
            }
            createDecodingTask(t1) {
                const e = [], r = this.getLayer(t1.layerName);
                for(let n = 0; n < r.dataIndex.length; n++){
                    const i = r.dataIndex[n], s = i.first_byte - t1.firstByte, a = i.last_byte + 1 - t1.firstByte;
                    if (n < t1.firstBlock || n > t1.lastBlock) continue;
                    if (r._blocksInProgress.has(n)) continue;
                    const o = {
                        layerName: r.name,
                        firstByte: s,
                        lastByte: a,
                        pixelFormat: r.pixelFormat,
                        blockIndex: n,
                        blockShape: [
                            i.bands.length
                        ].concat(r.bandShape),
                        buffer: r.buffer,
                        codec: i.codec.codec,
                        filters: i.filters.map((t1)=>t1.filter)
                    };
                    r._blocksInProgress.add(n), e.push(o);
                }
                return new Hx(e, ()=>{
                    e.forEach((t1)=>r._blocksInProgress.delete(t1.blockIndex));
                }, (t1, n)=>{
                    if (e.forEach((t1)=>r._blocksInProgress.delete(t1.blockIndex)), t1) throw t1;
                    n.forEach((t1)=>{
                        this.getLayer(t1.layerName).processDecodedData(t1);
                    });
                });
            }
        }
        class Zx {
            constructor({ version: t1, name: e, units: r, tilesize: n, pixel_format: i, buffer: s, data_index: a }, o){
                if (this.version = t1, 1 !== this.version) throw new yx(`Cannot parse raster layer encoded with MRT version ${t1}`);
                this.name = e, this.units = r, this.tileSize = n, this.buffer = s, this.pixelFormat = $x[i], this.dataIndex = a, this.bandShape = [
                    n + 2 * s,
                    n + 2 * s,
                    Gx[this.pixelFormat]
                ], this._decodedBlocks = function(t1 = 1e3, e = 0, r = !1) {
                    if (isNaN(t1) || t1 < 0) throw new TypeError("Invalid max value");
                    if (isNaN(e) || e < 0) throw new TypeError("Invalid ttl value");
                    if ("boolean" != typeof r) throw new TypeError("Invalid resetTtl value");
                    return new px(t1, e, r);
                }(o ? o.cacheSize : 5), this._blocksInProgress = new Set;
            }
            processDecodedData(t1) {
                const e = t1.blockIndex.toString();
                this._decodedBlocks.get(e) || this._decodedBlocks.set(e, t1.data);
            }
            getBlockForBand(t1) {
                let e = 0;
                switch(typeof t1){
                    case "string":
                        for (const [r, n] of this.dataIndex.entries()){
                            for (const [i, s] of n.bands.entries())if (s === t1) return {
                                bandIndex: e + i,
                                blockIndex: r,
                                blockBandIndex: i
                            };
                            e += n.bands.length;
                        }
                        break;
                    case "number":
                        for (const [r, n] of this.dataIndex.entries()){
                            if (t1 >= e && t1 < e + n.bands.length) return {
                                bandIndex: t1,
                                blockIndex: r,
                                blockBandIndex: t1 - e
                            };
                            e += n.bands.length;
                        }
                        break;
                    default:
                        throw new yx(`Invalid band \`${JSON.stringify(t1)}\`. Expected string or integer.`);
                }
                throw new yx(`Band not found: ${JSON.stringify(t1)}`);
            }
            getDataRange(t1) {
                let e = 1 / 0, r = -1 / 0, n = 1 / 0, i = -1 / 0;
                for (const s of t1){
                    const { blockIndex: t1 } = this.getBlockForBand(s);
                    if (t1 < 0) throw new yx(`Invalid band: ${JSON.stringify(s)}`);
                    const a = this.dataIndex[t1];
                    n = Math.min(n, t1), i = Math.max(i, t1), e = Math.min(e, a.first_byte), r = Math.max(r, a.last_byte);
                }
                return {
                    layerName: this.name,
                    firstByte: e,
                    lastByte: r,
                    firstBlock: n,
                    lastBlock: i
                };
            }
            hasBand(t1) {
                const { blockIndex: e } = this.getBlockForBand(t1);
                return e >= 0;
            }
            hasDataForBand(t1) {
                const { blockIndex: e } = this.getBlockForBand(t1);
                return e >= 0 && !!this._decodedBlocks.get(e.toString());
            }
            getBandView(t1) {
                const { blockIndex: e, blockBandIndex: r } = this.getBlockForBand(t1), n = this._decodedBlocks.get(e.toString());
                if (!n) throw new yx(`Data for band ${JSON.stringify(t1)} of layer "${this.name}" not decoded.`);
                const i = this.dataIndex[e], s = this.bandShape.reduce((t1, e)=>t1 * e, 1), a = r * s, o = n.subarray(a, a + s);
                return {
                    data: o,
                    bytes: new Uint8Array(o.buffer).subarray(o.byteOffset, o.byteOffset + o.byteLength),
                    tileSize: this.tileSize,
                    buffer: this.buffer,
                    offset: i.offset,
                    scale: i.scale
                };
            }
        }
        class Hx {
            constructor(t1, e, r){
                this.tasks = t1, this._onCancel = e, this._onComplete = r, this._finalized = !1;
            }
            cancel() {
                this._finalized || (this._onCancel(), this._finalized = !0);
            }
            complete(t1, e) {
                this._finalized || (this._onComplete(t1, e), this._finalized = !0);
            }
        }
        Xx.performDecoding = function(t1, e) {
            return Promise.all(e.tasks.map((e)=>{
                const { layerName: r, firstByte: n, lastByte: i, pixelFormat: s, blockShape: a, blockIndex: o, filters: l, codec: u } = e, c = new Uint8Array(t1).subarray(n, i + 1), h = new Uint32Array(a[0] * a[1] * a[2]);
                let p;
                if ("gzip_data" !== u) throw new Error(`Unhandled codec: ${u}`);
                return p = (function(t1, e) {
                    if (!globalThis.DecompressionStream && "gzip_data" === e) return Promise.resolve(((s = function(t1) {
                        31 == t1[0] && 139 == t1[1] && 8 == t1[2] || Ux(6, "invalid gzip data");
                        var e = t1[3], r = 10;
                        4 & e && (r += 2 + (t1[10] | t1[11] << 8));
                        for(var n = (e >> 3 & 1) + (e >> 4 & 1); n > 0; n -= !t1[r++]);
                        return r + (2 & e);
                    }(i = t1)) + 8 > i.length && Ux(6, "invalid gzip data"), function(t1, e, r, n) {
                        var i = t1.length;
                        if (!i || e.f && !e.l) return r || new gx(0);
                        var s = !r, a = s || 2 != e.i, o = e.i;
                        s && (r = new gx(3 * i));
                        var l, u, c = function(t1) {
                            var e = r.length;
                            if (t1 > e) {
                                var n = new gx(Math.max(2 * e, t1));
                                n.set(r), r = n;
                            }
                        }, h = e.f || 0, p = e.p || 0, f = e.b || 0, d = e.l, m = e.d, y = e.m, g = e.n, x = 8 * i;
                        do {
                            if (!d) {
                                h = Lx(t1, p, 1);
                                var b = Lx(t1, p + 1, 3);
                                if (p += 3, !b) {
                                    var v = t1[(E = 4 + ((p + 7) / 8 | 0)) - 4] | t1[E - 3] << 8, _ = E + v;
                                    if (_ > i) {
                                        o && Ux(0);
                                        break;
                                    }
                                    a && c(f + v), r.set(t1.subarray(E, _), f), e.b = f += v, e.p = p = 8 * _, e.f = h;
                                    continue;
                                }
                                if (1 == b) d = Cx, m = Rx, y = 9, g = 5;
                                else if (2 == b) {
                                    var w = Lx(t1, p, 31) + 257, M = Lx(t1, p + 10, 15) + 4, A = w + Lx(t1, p + 5, 31) + 1;
                                    p += 14;
                                    for(var S = new gx(A), I = new gx(19), T = 0; T < M; ++T)I[wx[T]] = Lx(t1, p + 3 * T, 7);
                                    p += 3 * M;
                                    var k = Vx(I), P = (1 << k) - 1, z = Ex(I, k, 1);
                                    for(T = 0; T < A;){
                                        var E, B = z[Lx(t1, p, P)];
                                        if (p += 15 & B, (E = B >> 4) < 16) S[T++] = E;
                                        else {
                                            var D = 0, C = 0;
                                            for(16 == E ? (C = 3 + Lx(t1, p, 3), p += 2, D = S[T - 1]) : 17 == E ? (C = 3 + Lx(t1, p, 7), p += 3) : 18 == E && (C = 11 + Lx(t1, p, 127), p += 7); C--;)S[T++] = D;
                                        }
                                    }
                                    var R = S.subarray(0, w), V = S.subarray(w);
                                    y = Vx(R), g = Vx(V), d = Ex(R, y, 1), m = Ex(V, g, 1);
                                } else Ux(1);
                                if (p > x) {
                                    o && Ux(0);
                                    break;
                                }
                            }
                            a && c(f + 131072);
                            for(var L = (1 << y) - 1, O = (1 << g) - 1, F = p;; F = p){
                                var U = (D = d[Ox(t1, p) & L]) >> 4;
                                if ((p += 15 & D) > x) {
                                    o && Ux(0);
                                    break;
                                }
                                if (D || Ux(2), U < 256) r[f++] = U;
                                else {
                                    if (256 == U) {
                                        F = p, d = null;
                                        break;
                                    }
                                    var N = U - 254;
                                    U > 264 && (N = Lx(t1, p, (1 << ($ = vx[T = U - 257])) - 1) + Sx[T], p += $);
                                    var j = m[Ox(t1, p) & O], q = j >> 4;
                                    if (j || Ux(3), p += 15 & j, V = Tx[q], q > 3) {
                                        var $ = _x[q];
                                        V += Ox(t1, p) & (1 << $) - 1, p += $;
                                    }
                                    if (p > x) {
                                        o && Ux(0);
                                        break;
                                    }
                                    a && c(f + 131072);
                                    var G = f + N;
                                    if (f < V) {
                                        var Y = 0 - V, X = Math.min(V, G);
                                        for(Y + f < 0 && Ux(3); f < X; ++f)r[f] = (void 0)[Y + f];
                                    }
                                    for(; f < G; ++f)r[f] = r[f - V];
                                }
                            }
                            e.l = d, e.p = F, e.b = f, e.f = h, d && (h = 1, e.m = y, e.d = m, e.n = g);
                        }while (!h);
                        return f != r.length && s ? (l = r, (null == (u = f) || u > l.length) && (u = l.length), new gx(l.subarray(0, u))) : r.subarray(0, f);
                    }(i.subarray(s, -8), {
                        i: 2
                    }, new gx(((r = i)[(n = r.length) - 4] | r[n - 3] << 8 | r[n - 2] << 16 | r[n - 1] << 24) >>> 0))));
                    var r, n, i, s;
                    const a = qx[e];
                    if (!a) throw new Error(`Unhandled codec: ${e}`);
                    const o = new globalThis.DecompressionStream(a);
                    return new Response(new Blob([
                        t1
                    ]).stream().pipeThrough(o)).arrayBuffer().then((t1)=>new Uint8Array(t1));
                })(c, u).then((t1)=>((function(t1, e) {
                        t1.readFields(cx, e);
                    })(new Bm(t1), h), new Yx[s](h.buffer))), p.then((t1)=>{
                    for(let e = l.length - 1; e >= 0; e--)switch(l[e]){
                        case "delta_filter":
                            fx(t1, a);
                            break;
                        case "zigzag_filter":
                            dx(t1);
                            break;
                        case "bitshuffle_filter":
                            mx(t1, s);
                            break;
                        default:
                            throw new Error(`Unhandled filter "${l[e]}"`);
                    }
                    return {
                        layerName: r,
                        blockIndex: o,
                        data: t1
                    };
                }).catch((t1)=>{
                    throw t1;
                });
            }));
        };
        class Kx extends nx {
            constructor(t1, e, r, n, i){
                super(t1, e, r, n, i), this._workQueue = [], this._fetchQueue = [], this._isHeaderLoaded = !1;
            }
            setTexture(t1, e) {
                const r = e.context, n = r.gl;
                this.texture = this.texture || e.getTileTexture(t1.width), this.texture && this.texture instanceof Gg ? this.texture.update(t1, {
                    useMipmap: !1,
                    premultiply: !1
                }) : this.texture = new Gg(r, t1, n.RGBA, {
                    useMipmap: !1,
                    premultiply: !1
                });
            }
            flushQueues() {
                for(; this._workQueue.length;)this._workQueue.pop()();
                for(; this._fetchQueue.length;)this._fetchQueue.pop()();
            }
            fetchHeader(t1 = 16384, e) {
                const r = this._mrt = new Xx(30), n = Object.assign({}, this.requestParams, {
                    headers: {
                        Range: "bytes=0-" + (t1 - 1)
                    }
                });
                return this.entireBuffer = null, this.request = en(n, (n, i, s, a)=>{
                    if (n) e(n);
                    else try {
                        const n = r.getHeaderLength(i);
                        if (n > t1) return void (this.request = this.fetchHeader(n, e));
                        r.parseHeader(i), this._isHeaderLoaded = !0;
                        let o = 0;
                        for (const t1 of Object.values(r.layers))o = Math.max(o, t1.dataIndex[t1.dataIndex.length - 1].last_byte);
                        i.byteLength >= o && (this.entireBuffer = i), e(null, this.entireBuffer || i, s, a);
                    } catch (t1) {
                        e(t1);
                    }
                }), this.request;
            }
            fetchBand(t1, e, r) {
                const n = this._mrt;
                if (!this._isHeaderLoaded || !n) return void r(new Error("Tile header is not ready"));
                const i = this.actor;
                if (!i) return void r(new Error("Can't fetch tile band without an actor"));
                let s;
                const a = (n, i)=>{
                    s.complete(n, i), n ? r(n) : (this.updateTextureDescriptor(t1, e), r(null, this.textureDescriptor && this.textureDescriptor.img));
                }, o = (t1, e)=>{
                    if (t1) return r(t1);
                    const n = i.send("decodeRasterArray", {
                        buffer: e,
                        task: s
                    }, a, void 0, !0);
                    this._workQueue.push(()=>{
                        n && n.cancel(), s.cancel();
                    });
                }, l = n.getLayer(t1);
                if (!l) return void r(new Error(`Unknown sourceLayer "${t1}"`));
                if (l.hasDataForBand(e)) return this.updateTextureDescriptor(t1, e), void r(null, this.textureDescriptor ? this.textureDescriptor.img : null);
                const u = l.getDataRange([
                    e
                ]);
                if (s = n.createDecodingTask(u), !s || s.tasks.length) {
                    if (this.flushQueues(), this.entireBuffer) o(null, this.entireBuffer.slice(u.firstByte, u.lastByte + 1));
                    else {
                        const t1 = Object.assign({}, this.requestParams, {
                            headers: {
                                Range: `bytes=${u.firstByte}-${u.lastByte}`
                            }
                        }), e = en(t1, o);
                        this._fetchQueue.push(()=>{
                            e.cancel(), s.cancel();
                        });
                    }
                } else r(null);
            }
            updateNeeded(t1, e) {
                return (!this.textureDescriptor || this.textureDescriptor.band !== e || this.textureDescriptor.layer !== t1) && "errored" !== this.state;
            }
            updateTextureDescriptor(t1, e) {
                if (!this._mrt) return;
                const r = this._mrt.getLayer(t1);
                if (!r || !r.hasBand(e) || !r.hasDataForBand(e)) return;
                const { bytes: n, tileSize: i, buffer: s, offset: a, scale: o } = r.getBandView(e), l = i + 2 * s, u = {
                    data: n,
                    width: l,
                    height: l
                }, c = this.texture;
                c && c instanceof Gg && c.update(u, {
                    useMipmap: !1,
                    premultiply: !1
                }), this.textureDescriptor = {
                    layer: t1,
                    band: e,
                    img: u,
                    buffer: s,
                    offset: a,
                    tileSize: i,
                    format: r.pixelFormat,
                    mix: [
                        o,
                        256 * o,
                        65536 * o,
                        16777216 * o
                    ]
                };
            }
        }
        class Wx {
            constructor(t1, e){
                this.max = t1, this.onRemove = e, this.reset();
            }
            reset() {
                for(const t1 in this.data)for (const e of this.data[t1])e.timeout && clearTimeout(e.timeout), this.onRemove(e.value);
                return this.data = {}, this.order = [], this;
            }
            add(t1, e, r) {
                const n = t1.wrapped().key;
                void 0 === this.data[n] && (this.data[n] = []);
                const i = {
                    value: e,
                    timeout: void 0
                };
                if (void 0 !== r && (i.timeout = setTimeout(()=>{
                    this.remove(t1, i);
                }, r)), this.data[n].push(i), this.order.push(n), this.order.length > this.max) {
                    const t1 = this._getAndRemoveByKey(this.order[0]);
                    t1 && this.onRemove(t1);
                }
                return this;
            }
            has(t1) {
                return t1.wrapped().key in this.data;
            }
            getAndRemove(t1) {
                return this.has(t1) ? this._getAndRemoveByKey(t1.wrapped().key) : null;
            }
            _getAndRemoveByKey(t1) {
                const e = this.data[t1].shift();
                return e.timeout && clearTimeout(e.timeout), 0 === this.data[t1].length && delete this.data[t1], this.order.splice(this.order.indexOf(t1), 1), e.value;
            }
            getByKey(t1) {
                const e = this.data[t1];
                return e ? e[0].value : null;
            }
            get(t1) {
                return this.has(t1) ? this.data[t1.wrapped().key][0].value : null;
            }
            remove(t1, e) {
                if (!this.has(t1)) return this;
                const r = t1.wrapped().key, n = void 0 === e ? 0 : this.data[r].indexOf(e), i = this.data[r][n];
                return this.data[r].splice(n, 1), i.timeout && clearTimeout(i.timeout), 0 === this.data[r].length && delete this.data[r], this.onRemove(i.value), this.order.splice(this.order.indexOf(r), 1), this;
            }
            setMaxSize(t1) {
                for(this.max = t1; this.order.length > this.max;){
                    const t1 = this._getAndRemoveByKey(this.order[0]);
                    t1 && this.onRemove(t1);
                }
                return this;
            }
            filter(t1) {
                const e = [];
                for(const r in this.data)for (const n of this.data[r])t1(n.value) || e.push(n);
                for (const t1 of e)this.remove(t1.value.tileID, t1);
            }
        }
        class Jx extends Ln {
            constructor(t1, e, r){
                super(), this.id = t1, this._onlySymbols = r, e.on("data", (t1)=>{
                    "source" === t1.dataType && "metadata" === t1.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === t1.dataType && "content" === t1.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
                }), e.on("error", ()=>{
                    this._sourceErrored = !0;
                }), this._source = e, this._tiles = {}, this._cache = new Wx(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = e.minTileCacheSize, this._maxTileCacheSize = e.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = !1, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new Rm, this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "raster-array" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
            }
            onAdd(t1) {
                this.map = t1, this._minTileCacheSize = void 0 === this._minTileCacheSize && t1 ? t1._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t1 ? t1._maxTileCacheSize : this._maxTileCacheSize;
            }
            loaded() {
                if (this._sourceErrored) return !0;
                if (!this._sourceLoaded) return !1;
                if (!this._source.loaded()) return !1;
                for(const t1 in this._tiles){
                    const e = this._tiles[t1];
                    if ("errored" !== e.state && ("loaded" !== e.state || !e.bucketsLoaded())) return !1;
                }
                return !0;
            }
            getSource() {
                return this._source;
            }
            pause() {
                this._paused = !0;
            }
            resume() {
                if (!this._paused) return;
                const t1 = this._shouldReloadOnResume;
                this._paused = !1, this._shouldReloadOnResume = !1, t1 && this.reload(), this.transform && this.update(this.transform);
            }
            _loadTile(t1, e) {
                return t1.isSymbolTile = this._onlySymbols, t1.isExtraShadowCaster = this._shadowCasterTiles[t1.tileID.key], this._source.loadTile(t1, e);
            }
            _unloadTile(t1) {
                if (this._source.unloadTile) return this._source.unloadTile(t1);
            }
            _abortTile(t1) {
                if (this._source.abortTile) return this._source.abortTile(t1);
            }
            serialize() {
                return this._source.serialize();
            }
            prepare(t1) {
                this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                for(const e in this._tiles){
                    const r = this._tiles[e];
                    r.upload(t1), r.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
                }
            }
            getIds() {
                return tr(this._tiles).map((t1)=>t1.tileID).sort(Qx).map((t1)=>t1.key);
            }
            getRenderableIds(t1, e) {
                const r = [];
                for(const n in this._tiles)this._isIdRenderable(+n, t1, e) && r.push(this._tiles[n]);
                return t1 ? r.sort((t1, e)=>{
                    const r = t1.tileID, n = e.tileID, i = new Ne(r.canonical.x, r.canonical.y)._rotate(this.transform.angle), s = new Ne(n.canonical.x, n.canonical.y)._rotate(this.transform.angle);
                    return r.overscaledZ - n.overscaledZ || s.y - i.y || s.x - i.x;
                }).map((t1)=>t1.tileID.key) : r.map((t1)=>t1.tileID).sort(Qx).map((t1)=>t1.key);
            }
            hasRenderableParent(t1) {
                const e = this.findLoadedParent(t1, 0);
                return !!e && this._isIdRenderable(e.tileID.key);
            }
            _isIdRenderable(t1, e, r) {
                return this._tiles[t1] && this._tiles[t1].hasData() && !this._coveredTiles[t1] && (e || !this._tiles[t1].holdingForFade()) && (r || !this._shadowCasterTiles[t1]);
            }
            reload() {
                if (this._paused) this._shouldReloadOnResume = !0;
                else {
                    this._cache.reset();
                    for(const t1 in this._tiles)"errored" !== this._tiles[t1].state && this._reloadTile(+t1, "reloading");
                }
            }
            _reloadTile(t1, e) {
                const r = this._tiles[t1];
                r && ("loading" !== r.state && (r.state = e), this._loadTile(r, this._tileLoaded.bind(this, r, t1, e)));
            }
            _tileLoaded(t1, e, r, n) {
                if (n) {
                    if (t1.state = "errored", 404 !== n.status) this._source.fire(new Cn(n, {
                        tile: t1
                    }));
                    else {
                        if (!(t1.tileID.key in this._loadedParentTiles)) return void this._source.fire(new Dn("data", {
                            dataType: "source",
                            sourceDataType: "error",
                            sourceId: this._source.id
                        }));
                        if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                            const t1 = this.map.painter.terrain;
                            this.update(this.transform, t1.getScaledDemTileSize(), !0), t1.resetTileLookupCache(this.id);
                        } else this.update(this.transform);
                    }
                } else t1.timeAdded = Dr.now(), "expired" === r && (t1.refreshedUponExpiration = !0), this._setTileReloadTimer(e, t1), "raster-dem" === this._source.type && t1.dem && this._backfillDEM(t1), this._state.initializeTileState(t1, this.map ? this.map.painter : null), this._source.fire(new Dn("data", {
                    dataType: "source",
                    tile: t1,
                    coord: t1.tileID,
                    sourceCacheId: this.id
                }));
            }
            _backfillDEM(t1) {
                const e = this.getRenderableIds();
                for(let n = 0; n < e.length; n++){
                    const i = e[n];
                    if (t1.neighboringTiles && t1.neighboringTiles[i]) {
                        const e = this.getTileByID(i);
                        r(t1, e), r(e, t1);
                    }
                }
                function r(t1, e) {
                    if (!t1.dem || t1.dem.borderReady) return;
                    t1.needsHillshadePrepare = !0, t1.needsDEMTextureUpload = !0;
                    let r = e.tileID.canonical.x - t1.tileID.canonical.x;
                    const n = e.tileID.canonical.y - t1.tileID.canonical.y, i = Math.pow(2, t1.tileID.canonical.z), s = e.tileID.key;
                    0 === r && 0 === n || Math.abs(n) > 1 || (Math.abs(r) > 1 && (1 === Math.abs(r + i) ? r += i : 1 === Math.abs(r - i) && (r -= i)), e.dem && t1.dem && (t1.dem.backfillBorder(e.dem, r, n), t1.neighboringTiles && t1.neighboringTiles[s] && (t1.neighboringTiles[s].backfilled = !0)));
                }
            }
            getTile(t1) {
                return this.getTileByID(t1.key);
            }
            getTileByID(t1) {
                return this._tiles[t1];
            }
            _retainLoadedChildren(t1, e, r, n) {
                for(const i in this._tiles){
                    let s = this._tiles[i];
                    if (n[i] || !s.hasData() || s.tileID.overscaledZ <= e || s.tileID.overscaledZ > r) continue;
                    let a = s.tileID;
                    for(; s && s.tileID.overscaledZ > e + 1;){
                        const t1 = s.tileID.scaledTo(s.tileID.overscaledZ - 1);
                        s = this._tiles[t1.key], s && s.hasData() && (a = t1);
                    }
                    let o = a;
                    for(; o.overscaledZ > e;)if (o = o.scaledTo(o.overscaledZ - 1), t1[o.key]) {
                        n[a.key] = a;
                        break;
                    }
                }
            }
            findLoadedParent(t1, e) {
                if (t1.key in this._loadedParentTiles) {
                    const r = this._loadedParentTiles[t1.key];
                    return r && r.tileID.overscaledZ >= e ? r : null;
                }
                for(let r = t1.overscaledZ - 1; r >= e; r--){
                    const e = t1.scaledTo(r), n = this._getLoadedTile(e);
                    if (n) return n;
                }
            }
            _getLoadedTile(t1) {
                const e = this._tiles[t1.key];
                return e && e.hasData() ? e : this._cache.getByKey(this._source.reparseOverscaled ? t1.wrapped().key : t1.canonical.key);
            }
            updateCacheSize(t1, e) {
                e = e || this._source.tileSize;
                const r = Math.ceil(t1.width / e) + 1, n = Math.ceil(t1.height / e) + 1, i = Math.floor(r * n * 5), s = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, i) : i, a = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s) : s;
                this._cache.setMaxSize(a);
            }
            handleWrapJump(t1) {
                const e = Math.round((t1 - (void 0 === this._prevLng ? t1 : this._prevLng)) / 360);
                if (this._prevLng = t1, e) {
                    const t1 = {};
                    for(const r in this._tiles){
                        const n = this._tiles[r];
                        n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e), t1[n.tileID.key] = n;
                    }
                    this._tiles = t1;
                    for(const t1 in this._timers)clearTimeout(this._timers[t1]), delete this._timers[t1];
                    for(const t1 in this._tiles)this._setTileReloadTimer(+t1, this._tiles[t1]);
                }
            }
            update(t1, e, r, n) {
                if (this.transform = t1, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;
                if (this.usedForTerrain && !r) return;
                let i;
                if (this.updateCacheSize(t1, e), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {}, this.used || this.usedForTerrain) {
                    if (this._source.tileID) i = t1.getVisibleUnwrappedCoordinates(this._source.tileID).map((t1)=>new _c(t1.canonical.z, t1.wrap, t1.canonical.z, t1.canonical.x, t1.canonical.y));
                    else if (0 !== this.tileCoverLift) {
                        const n = t1.clone();
                        n.tileCoverLift = this.tileCoverLift, i = n.coveringTiles({
                            tileSize: e || this._source.tileSize,
                            minzoom: this._source.minzoom,
                            maxzoom: this._source.maxzoom,
                            roundZoom: this._source.roundZoom && !r,
                            reparseOverscaled: this._source.reparseOverscaled,
                            isTerrainDEM: this.usedForTerrain
                        }), this._source.minzoom <= 1 && "globe" === t1.projection.name && (i.push(new _c(1, 0, 1, 0, 0)), i.push(new _c(1, 0, 1, 1, 0)), i.push(new _c(1, 0, 1, 0, 1)), i.push(new _c(1, 0, 1, 1, 1)));
                    } else if (i = t1.coveringTiles({
                        tileSize: e || this._source.tileSize,
                        minzoom: this._source.minzoom,
                        maxzoom: this._source.maxzoom,
                        roundZoom: this._source.roundZoom && !r,
                        reparseOverscaled: this._source.reparseOverscaled,
                        isTerrainDEM: this.usedForTerrain
                    }), this._source.hasTile) {
                        const t1 = this._source.hasTile.bind(this._source);
                        i = i.filter((e)=>t1(e));
                    }
                } else i = [];
                if (i.length > 0 && this.castsShadows && n && "globe" !== this.transform.projection.name && !this.usedForTerrain && !tb(this._source.type)) {
                    const s = t1.coveringZoomLevel({
                        tileSize: e || this._source.tileSize,
                        roundZoom: this._source.roundZoom && !r
                    }), a = Math.min(s, this._source.maxzoom), o = t1.extendTileCoverForShadows(i, n, a);
                    for (const t1 of o)this._shadowCasterTiles[t1.key] = !0, i.push(t1);
                }
                const s = this._updateRetainedTiles(i);
                if (tb(this._source.type) && 0 !== i.length) {
                    const t1 = {}, e = {}, r = Object.keys(s);
                    for (const n of r){
                        const r = s[n], i = this._tiles[n];
                        if (!i || i.fadeEndTime && i.fadeEndTime <= Dr.now()) continue;
                        const a = this.findLoadedParent(r, Math.max(r.overscaledZ - Jx.maxOverzooming, this._source.minzoom));
                        a && (this._addTile(a.tileID), t1[a.tileID.key] = a.tileID), e[n] = r;
                    }
                    const n = i[i.length - 1].overscaledZ;
                    for(const t1 in this._tiles){
                        const r = this._tiles[t1];
                        if (s[t1] || !r.hasData()) continue;
                        let i = r.tileID;
                        for(; i.overscaledZ > n;){
                            i = i.scaledTo(i.overscaledZ - 1);
                            const n = this._tiles[i.key];
                            if (n && n.hasData() && e[i.key]) {
                                s[t1] = r.tileID;
                                break;
                            }
                        }
                    }
                    for(const e in t1)s[e] || (this._coveredTiles[e] = !0, s[e] = t1[e]);
                }
                for(const t1 in s)this._tiles[t1].clearFadeHold();
                const a = function(t1, e) {
                    const r = [];
                    for(const n in t1)n in e || r.push(n);
                    return r;
                }(this._tiles, s);
                for (const t1 of a){
                    const e = this._tiles[t1];
                    e.hasSymbolBuckets && !e.holdingForFade() ? e.setHoldDuration(this.map._fadeDuration) : e.hasSymbolBuckets && !e.symbolFadeFinished() || this._removeTile(+t1);
                }
                this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
            }
            releaseSymbolFadeTiles() {
                for(const t1 in this._tiles)this._tiles[t1].holdingForFade() && this._removeTile(+t1);
            }
            _updateRetainedTiles(t1) {
                const e = {};
                if (0 === t1.length) return e;
                const r = {}, n = t1.reduce((t1, e)=>Math.min(t1, e.overscaledZ), 1 / 0), i = t1[0].overscaledZ, s = Math.max(i - Jx.maxOverzooming, this._source.minzoom), a = Math.max(i + Jx.maxUnderzooming, this._source.minzoom), o = {};
                for (const r of t1){
                    const t1 = this._addTile(r);
                    e[r.key] = r, t1.hasData() || n < this._source.maxzoom && (o[r.key] = r);
                }
                this._retainLoadedChildren(o, n, a, e);
                for (const n of t1){
                    let t1 = this._tiles[n.key];
                    if (t1.hasData()) continue;
                    if (n.canonical.z >= this._source.maxzoom) {
                        const t1 = n.children(this._source.maxzoom)[0], r = this.getTile(t1);
                        if (r && r.hasData()) {
                            e[t1.key] = t1;
                            continue;
                        }
                    } else {
                        const t1 = n.children(this._source.maxzoom);
                        if (e[t1[0].key] && e[t1[1].key] && e[t1[2].key] && e[t1[3].key]) continue;
                    }
                    let i = t1.wasRequested();
                    for(let a = n.overscaledZ - 1; a >= s; --a){
                        const s = n.scaledTo(a);
                        if (r[s.key]) break;
                        if (r[s.key] = !0, t1 = this.getTile(s), !t1 && i && (t1 = this._addTile(s)), t1 && (e[s.key] = s, i = t1.wasRequested(), t1.hasData())) break;
                    }
                }
                return e;
            }
            _updateLoadedParentTileCache() {
                this._loadedParentTiles = {};
                for(const t1 in this._tiles){
                    const e = [];
                    let r, n = this._tiles[t1].tileID;
                    for(; n.overscaledZ > 0;){
                        if (n.key in this._loadedParentTiles) {
                            r = this._loadedParentTiles[n.key];
                            break;
                        }
                        e.push(n.key);
                        const t1 = n.scaledTo(n.overscaledZ - 1);
                        if (r = this._getLoadedTile(t1), r) break;
                        n = t1;
                    }
                    for (const t1 of e)this._loadedParentTiles[t1] = r;
                }
            }
            _addTile(t1) {
                let e = this._tiles[t1.key];
                if (e) return !0 !== e.isExtraShadowCaster || !!this._shadowCasterTiles[t1.key] || this._reloadTile(t1.key, "reloading"), e;
                e = this._cache.getAndRemove(t1), e && (this._setTileReloadTimer(t1.key, e), e.tileID = t1, this._state.initializeTileState(e, this.map ? this.map.painter : null), this._cacheTimers[t1.key] && (clearTimeout(this._cacheTimers[t1.key]), delete this._cacheTimers[t1.key], this._setTileReloadTimer(t1.key, e)));
                const r = Boolean(e);
                if (!r) {
                    const r = this.map ? this.map.painter : null, n = this._source.tileSize * t1.overscaleFactor();
                    e = "raster-array" === this._source.type ? new Kx(t1, n, this.transform.tileZoom, r, this._isRaster) : new nx(t1, n, this.transform.tileZoom, r, this._isRaster), this._loadTile(e, this._tileLoaded.bind(this, e, t1.key, e.state));
                }
                return e ? (e.uses++, this._tiles[t1.key] = e, r || this._source.fire(new Dn("dataloading", {
                    tile: e,
                    coord: e.tileID,
                    dataType: "source"
                })), e) : null;
            }
            _setTileReloadTimer(t1, e) {
                t1 in this._timers && (clearTimeout(this._timers[t1]), delete this._timers[t1]);
                const r = e.getExpiryTimeout();
                r && (this._timers[t1] = setTimeout(()=>{
                    this._reloadTile(t1, "expired"), delete this._timers[t1];
                }, r));
            }
            _removeTile(t1) {
                const e = this._tiles[t1];
                e && (e.uses--, delete this._tiles[t1], this._timers[t1] && (clearTimeout(this._timers[t1]), delete this._timers[t1]), e.uses > 0 || (e.hasData() && "reloading" !== e.state || "empty" === e.state ? this._cache.add(e.tileID, e, e.getExpiryTimeout()) : (e.aborted = !0, this._abortTile(e), this._unloadTile(e))));
            }
            clearTiles() {
                this._shouldReloadOnResume = !1, this._paused = !1;
                for(const t1 in this._tiles)this._removeTile(+t1);
                this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
            }
            tilesIn(t1, e, r) {
                const n = [], i = this.transform;
                if (!i) return n;
                const s = "globe" === i.projection.name, a = Tc(i.center.lng);
                for(const o in this._tiles){
                    const l = this._tiles[o];
                    if (r && l.clearQueryDebugViz(), l.holdingForFade()) continue;
                    let u;
                    if (s) {
                        const t1 = l.tileID.canonical;
                        if (0 === t1.z) {
                            const e = [
                                Math.abs(Ke(a, ...eb(t1, -1)) - a),
                                Math.abs(Ke(a, ...eb(t1, 1)) - a)
                            ];
                            u = [
                                0,
                                2 * e.indexOf(Math.min(...e)) - 1
                            ];
                        } else {
                            const e = [
                                Math.abs(Ke(a, ...eb(t1, -1)) - a),
                                Math.abs(Ke(a, ...eb(t1, 0)) - a),
                                Math.abs(Ke(a, ...eb(t1, 1)) - a)
                            ];
                            u = [
                                e.indexOf(Math.min(...e)) - 1
                            ];
                        }
                    } else u = [
                        0
                    ];
                    for (const r of u){
                        const s = t1.containsTile(l, i, e, r);
                        s && n.push(s);
                    }
                }
                return n;
            }
            getShadowCasterCoordinates() {
                return this._getRenderableCoordinates(!1, !0);
            }
            getVisibleCoordinates(t1) {
                return this._getRenderableCoordinates(t1);
            }
            _getRenderableCoordinates(t1, e) {
                const r = this.getRenderableIds(t1, e).map((t1)=>this._tiles[t1].tileID), n = "globe" === this.transform.projection.name;
                for (const t1 of r)t1.projMatrix = this.transform.calculateProjMatrix(t1.toUnwrapped()), t1.expandedProjMatrix = n ? this.transform.calculateProjMatrix(t1.toUnwrapped(), !1, !0) : t1.projMatrix;
                return r;
            }
            sortCoordinatesByDistance(t1) {
                const e = t1.slice(), r = this.transform._camera.position, n = this.transform._camera.forward(), i = {};
                for (const t1 of e){
                    const e = 1 / (1 << t1.canonical.z);
                    i[t1.key] = ((t1.canonical.x + .5) * e + t1.wrap - r[0]) * n[0] + ((t1.canonical.y + .5) * e - r[1]) * n[1] - r[2] * n[2];
                }
                return e.sort((t1, e)=>i[t1.key] - i[e.key]), e;
            }
            hasTransition() {
                if (this._source.hasTransition()) return !0;
                if (tb(this._source.type)) for(const t1 in this._tiles){
                    const e = this._tiles[t1];
                    if (void 0 !== e.fadeEndTime && e.fadeEndTime >= Dr.now()) return !0;
                }
                return !1;
            }
            setFeatureState(t1, e, r) {
                this._state.updateState(t1 = t1 || "_geojsonTileLayer", e, r);
            }
            removeFeatureState(t1, e, r) {
                this._state.removeFeatureState(t1 = t1 || "_geojsonTileLayer", e, r);
            }
            getFeatureState(t1, e) {
                return this._state.getState(t1 = t1 || "_geojsonTileLayer", e);
            }
            setDependencies(t1, e, r) {
                const n = this._tiles[t1];
                n && n.setDependencies(e, r);
            }
            reloadTilesForDependencies(t1, e) {
                for(const r in this._tiles)this._tiles[r].hasDependency(t1, e) && this._reloadTile(+r, "reloading");
                this._cache.filter((r)=>!r.hasDependency(t1, e));
            }
            _preloadTiles(t1, e) {
                if (!this._sourceLoaded) {
                    const r = ()=>{
                        this._sourceLoaded && (this._source.off("data", r), this._preloadTiles(t1, e));
                    };
                    return void this._source.on("data", r);
                }
                const r = new Map, n = Array.isArray(t1) ? t1 : [
                    t1
                ], i = this.map.painter.terrain, s = this.usedForTerrain && i ? i.getScaledDemTileSize() : this._source.tileSize;
                for (const t1 of n){
                    const e = t1.coveringTiles({
                        tileSize: s,
                        minzoom: this._source.minzoom,
                        maxzoom: this._source.maxzoom,
                        roundZoom: this._source.roundZoom && !this.usedForTerrain,
                        reparseOverscaled: this._source.reparseOverscaled,
                        isTerrainDEM: this.usedForTerrain
                    });
                    for (const t1 of e)r.set(t1.key, t1);
                    this.usedForTerrain && t1.updateElevation(!1);
                }
                Qe(Array.from(r.values()), (t1, e)=>{
                    const r = new nx(t1, this._source.tileSize * t1.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
                    this._loadTile(r, (t1)=>{
                        "raster-dem" === this._source.type && r.dem && this._backfillDEM(r), e(t1, r);
                    });
                }, e);
            }
        }
        function Qx(t1, e) {
            const r = Math.abs(2 * t1.wrap) - +(t1.wrap < 0), n = Math.abs(2 * e.wrap) - +(e.wrap < 0);
            return t1.overscaledZ - e.overscaledZ || n - r || e.canonical.y - t1.canonical.y || e.canonical.x - t1.canonical.x;
        }
        function tb(t1) {
            return "raster" === t1 || "image" === t1 || "video" === t1 || "custom" === t1;
        }
        function eb(t1, e) {
            const r = 1 << t1.z;
            return [
                t1.x / r + e,
                (t1.x + 1) / r + e
            ];
        }
        Jx.maxOverzooming = 10, Jx.maxUnderzooming = 3;
        const rb = new class extends sl {
            possiblyEvaluate(t1, e) {
                return e = new Ho(Math.floor(e.zoom), {
                    now: e.now,
                    fadeDuration: e.fadeDuration,
                    transition: e.transition
                }), super.possiblyEvaluate(t1, e);
            }
            evaluate(t1, e, r, n) {
                return e = er({}, e, {
                    zoom: Math.floor(e.zoom)
                }), super.evaluate(t1, e, r, n);
            }
        }(nm.paint.properties["line-width"].specification);
        function nb(t1, e) {
            return e > 0 ? e + 2 * t1 : t1;
        }
        rb.useIntegerZoom = !0;
        const ib = new ol({
            "symbol-placement": new il(ll.layout_symbol["symbol-placement"]),
            "symbol-spacing": new il(ll.layout_symbol["symbol-spacing"]),
            "symbol-avoid-edges": new il(ll.layout_symbol["symbol-avoid-edges"]),
            "symbol-sort-key": new sl(ll.layout_symbol["symbol-sort-key"]),
            "symbol-z-order": new il(ll.layout_symbol["symbol-z-order"]),
            "symbol-z-elevate": new il(ll.layout_symbol["symbol-z-elevate"]),
            "icon-allow-overlap": new il(ll.layout_symbol["icon-allow-overlap"]),
            "icon-ignore-placement": new il(ll.layout_symbol["icon-ignore-placement"]),
            "icon-optional": new il(ll.layout_symbol["icon-optional"]),
            "icon-rotation-alignment": new il(ll.layout_symbol["icon-rotation-alignment"]),
            "icon-size": new sl(ll.layout_symbol["icon-size"]),
            "icon-text-fit": new sl(ll.layout_symbol["icon-text-fit"]),
            "icon-text-fit-padding": new sl(ll.layout_symbol["icon-text-fit-padding"]),
            "icon-image": new sl(ll.layout_symbol["icon-image"]),
            "icon-rotate": new sl(ll.layout_symbol["icon-rotate"]),
            "icon-padding": new il(ll.layout_symbol["icon-padding"]),
            "icon-keep-upright": new il(ll.layout_symbol["icon-keep-upright"]),
            "icon-offset": new sl(ll.layout_symbol["icon-offset"]),
            "icon-anchor": new sl(ll.layout_symbol["icon-anchor"]),
            "icon-pitch-alignment": new il(ll.layout_symbol["icon-pitch-alignment"]),
            "text-pitch-alignment": new il(ll.layout_symbol["text-pitch-alignment"]),
            "text-rotation-alignment": new il(ll.layout_symbol["text-rotation-alignment"]),
            "text-field": new sl(ll.layout_symbol["text-field"]),
            "text-font": new sl(ll.layout_symbol["text-font"]),
            "text-size": new sl(ll.layout_symbol["text-size"]),
            "text-max-width": new sl(ll.layout_symbol["text-max-width"]),
            "text-line-height": new sl(ll.layout_symbol["text-line-height"]),
            "text-letter-spacing": new sl(ll.layout_symbol["text-letter-spacing"]),
            "text-justify": new sl(ll.layout_symbol["text-justify"]),
            "text-radial-offset": new sl(ll.layout_symbol["text-radial-offset"]),
            "text-variable-anchor": new il(ll.layout_symbol["text-variable-anchor"]),
            "text-anchor": new sl(ll.layout_symbol["text-anchor"]),
            "text-max-angle": new il(ll.layout_symbol["text-max-angle"]),
            "text-writing-mode": new il(ll.layout_symbol["text-writing-mode"]),
            "text-rotate": new sl(ll.layout_symbol["text-rotate"]),
            "text-padding": new il(ll.layout_symbol["text-padding"]),
            "text-keep-upright": new il(ll.layout_symbol["text-keep-upright"]),
            "text-transform": new sl(ll.layout_symbol["text-transform"]),
            "text-offset": new sl(ll.layout_symbol["text-offset"]),
            "text-allow-overlap": new il(ll.layout_symbol["text-allow-overlap"]),
            "text-ignore-placement": new il(ll.layout_symbol["text-ignore-placement"]),
            "text-optional": new il(ll.layout_symbol["text-optional"]),
            visibility: new il(ll.layout_symbol.visibility)
        });
        var sb = {
            paint: new ol({
                "icon-opacity": new sl(ll.paint_symbol["icon-opacity"]),
                "icon-occlusion-opacity": new sl(ll.paint_symbol["icon-occlusion-opacity"]),
                "icon-emissive-strength": new sl(ll.paint_symbol["icon-emissive-strength"]),
                "text-emissive-strength": new sl(ll.paint_symbol["text-emissive-strength"]),
                "icon-color": new sl(ll.paint_symbol["icon-color"]),
                "icon-halo-color": new sl(ll.paint_symbol["icon-halo-color"]),
                "icon-halo-width": new sl(ll.paint_symbol["icon-halo-width"]),
                "icon-halo-blur": new sl(ll.paint_symbol["icon-halo-blur"]),
                "icon-translate": new il(ll.paint_symbol["icon-translate"]),
                "icon-translate-anchor": new il(ll.paint_symbol["icon-translate-anchor"]),
                "icon-image-cross-fade": new sl(ll.paint_symbol["icon-image-cross-fade"]),
                "text-opacity": new sl(ll.paint_symbol["text-opacity"]),
                "text-occlusion-opacity": new sl(ll.paint_symbol["text-occlusion-opacity"]),
                "text-color": new sl(ll.paint_symbol["text-color"], {
                    runtimeType: ei,
                    getOverride: (t1)=>t1.textColor,
                    hasOverride: (t1)=>!!t1.textColor
                }),
                "text-halo-color": new sl(ll.paint_symbol["text-halo-color"]),
                "text-halo-width": new sl(ll.paint_symbol["text-halo-width"]),
                "text-halo-blur": new sl(ll.paint_symbol["text-halo-blur"]),
                "text-translate": new il(ll.paint_symbol["text-translate"]),
                "text-translate-anchor": new il(ll.paint_symbol["text-translate-anchor"]),
                "icon-color-saturation": new il(ll.paint_symbol["icon-color-saturation"]),
                "icon-color-contrast": new il(ll.paint_symbol["icon-color-contrast"]),
                "icon-color-brightness-min": new il(ll.paint_symbol["icon-color-brightness-min"]),
                "icon-color-brightness-max": new il(ll.paint_symbol["icon-color-brightness-max"])
            }),
            layout: ib
        };
        class ab {
            constructor(t1){
                this.type = t1.property.overrides ? t1.property.overrides.runtimeType : Wn, this.defaultValue = t1;
            }
            evaluate(t1) {
                if (t1.formattedSection) {
                    const e = this.defaultValue.property.overrides;
                    if (e && e.hasOverride(t1.formattedSection)) return e.getOverride(t1.formattedSection);
                }
                return t1.feature && t1.featureState ? this.defaultValue.evaluate(t1.feature, t1.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t1) {
                this.defaultValue.isConstant() || t1(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return null;
            }
        }
        Mo(ab, "FormatSectionOverride", {
            omit: [
                "defaultValue"
            ]
        });
        class ob extends kl {
            constructor(e, r, n, i){
                super(e, sb, r, n, i), this._colorAdjustmentMatrix = t1.ad.identity([]), this.hasInitialOcclusionOpacityProperties = void 0 !== e.paint && ("icon-occlusion-opacity" in e.paint || "text-occlusion-opacity" in e.paint);
            }
            recalculate(t1, e) {
                super.recalculate(t1, e), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
                const r = this.layout.get("text-writing-mode");
                if (r) {
                    const t1 = [];
                    for (const e of r)t1.indexOf(e) < 0 && t1.push(e);
                    this.layout._values["text-writing-mode"] = t1;
                } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? [
                    "horizontal"
                ] : [
                    "horizontal",
                    "vertical"
                ];
                this._setPaintOverrides();
            }
            getColorAdjustmentMatrix(e, r, n, i) {
                return this._saturation === e && this._contrast === r && this._brightnessMin === n && this._brightnessMax === i || (this._colorAdjustmentMatrix = function(e, r, n, i) {
                    e = Er(e), r = zr(r);
                    const s = t1.ad.create(), a = e / 3, o = 1 - 2 * a, l = [
                        o,
                        a,
                        a,
                        0,
                        a,
                        o,
                        a,
                        0,
                        a,
                        a,
                        o,
                        0,
                        0,
                        0,
                        0,
                        1
                    ], u = .5 - .5 * r, c = i - n;
                    return t1.ad.multiply(s, [
                        c,
                        0,
                        0,
                        0,
                        0,
                        c,
                        0,
                        0,
                        0,
                        0,
                        c,
                        0,
                        n,
                        n,
                        n,
                        1
                    ], [
                        r,
                        0,
                        0,
                        0,
                        0,
                        r,
                        0,
                        0,
                        0,
                        0,
                        r,
                        0,
                        u,
                        u,
                        u,
                        1
                    ]), t1.ad.multiply(s, s, l), s;
                }(e, r, n, i), this._saturation = e, this._contrast = r, this._brightnessMin = n, this._brightnessMax = i), this._colorAdjustmentMatrix;
            }
            getValueAndResolveTokens(t1, e, r, n) {
                const i = this.layout.get(t1).evaluate(e, {}, r, n), s = this._unevaluatedLayout._values[t1];
                return s.isDataDriven() || co(s.value) || !i ? i : function(t1, e) {
                    return e.replace(/{([^{}]+)}/g, (e, r)=>r in t1 ? String(t1[r]) : "");
                }(e.properties, i);
            }
            createBucket(t1) {
                return new $g(t1);
            }
            queryRadius() {
                return 0;
            }
            queryIntersectsFeature() {
                return !1;
            }
            _setPaintOverrides() {
                for (const t1 of sb.paint.overridableProperties){
                    if (!ob.hasPaintOverride(this.layout, t1)) continue;
                    const e = this.paint.get(t1), r = new ab(e), n = new uo(r, e.property.specification, this.scope, this.options);
                    let i = null;
                    i = "constant" === e.value.kind || "source" === e.value.kind ? new po("source", n) : new fo("composite", n, e.value.zoomStops, e.value._interpolationType), this.paint._values[t1] = new rl(e.property, i, e.parameters);
                }
            }
            _handleOverridablePaintPropertyUpdate(t1, e, r) {
                return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && ob.hasPaintOverride(this.layout, t1);
            }
            static hasPaintOverride(t1, e) {
                const r = t1.get("text-field"), n = sb.paint.properties[e];
                let i = !1;
                const s = (t1)=>{
                    for (const e of t1)if (n.overrides && n.overrides.hasOverride(e)) return void (i = !0);
                };
                if ("constant" === r.value.kind && r.value.value instanceof mi) s(r.value.value.sections);
                else if ("source" === r.value.kind) {
                    const t1 = (e)=>{
                        i || (e instanceof _i && bi(e.value) === si ? s(e.value.sections) : e instanceof Si ? s(e.sections) : e.eachChild(t1));
                    }, e = r.value;
                    e._styleExpression && t1(e._styleExpression.expression);
                }
                return i;
            }
            getProgramIds() {
                const t1 = 0 !== this.paint.get("icon-opacity").constantOr(1), e = 0 !== this.paint.get("text-opacity").constantOr(1), r = [];
                return t1 && r.push("symbolIcon"), e && r.push("symbolSDF"), r;
            }
            getDefaultProgramParams(t1, e, r) {
                return {
                    config: new Ku(this, {
                        zoom: e,
                        lut: r
                    }),
                    overrideFog: !1
                };
            }
        }
        const lb = new ol({
            visibility: new il(ll.layout_background.visibility)
        });
        var ub = {
            paint: new ol({
                "background-color": new il(ll.paint_background["background-color"]),
                "background-pattern": new il(ll.paint_background["background-pattern"]),
                "background-opacity": new il(ll.paint_background["background-opacity"]),
                "background-emissive-strength": new il(ll.paint_background["background-emissive-strength"])
            }),
            layout: lb
        };
        const cb = new ol({
            visibility: new il(ll.layout_raster.visibility)
        });
        var hb = {
            paint: new ol({
                "raster-opacity": new il(ll.paint_raster["raster-opacity"]),
                "raster-color": new al(ll.paint_raster["raster-color"]),
                "raster-color-mix": new il(ll.paint_raster["raster-color-mix"]),
                "raster-color-range": new il(ll.paint_raster["raster-color-range"]),
                "raster-hue-rotate": new il(ll.paint_raster["raster-hue-rotate"]),
                "raster-brightness-min": new il(ll.paint_raster["raster-brightness-min"]),
                "raster-brightness-max": new il(ll.paint_raster["raster-brightness-max"]),
                "raster-saturation": new il(ll.paint_raster["raster-saturation"]),
                "raster-contrast": new il(ll.paint_raster["raster-contrast"]),
                "raster-resampling": new il(ll.paint_raster["raster-resampling"]),
                "raster-fade-duration": new il(ll.paint_raster["raster-fade-duration"]),
                "raster-emissive-strength": new il(ll.paint_raster["raster-emissive-strength"]),
                "raster-array-band": new il(ll.paint_raster["raster-array-band"]),
                "raster-elevation": new il(ll.paint_raster["raster-elevation"])
            }),
            layout: cb
        };
        function pb(e, r, n, i, s, a, o, l) {
            const u = [
                e,
                r,
                1,
                n,
                i,
                1,
                s,
                a,
                1
            ], c = [
                o,
                l,
                1
            ], h = t1.bC.adjoint([], u), [p, f, d] = t1._.transformMat3(c, c, h);
            return t1.bC.multiply(u, u, [
                p,
                0,
                0,
                0,
                f,
                0,
                0,
                0,
                d
            ]);
        }
        function fb(e, r, n, i, s, a, o, l) {
            const u = function(e, r, n, i, s, a, o, l) {
                const u = pb(0, 0, 1, 0, 1, 1, 0, 1), c = pb(e, r, n, i, s, a, o, l), h = t1.bC.adjoint([], u);
                return t1.bC.multiply(c, c, h);
            }(e, r, n, i, s, a, o, l);
            return [
                u[2] / u[8] / ps,
                u[5] / u[8] / ps
            ];
        }
        function db(t1) {
            return [
                t1[0],
                Math.min(Math.max(t1[1], -Dc), Dc)
            ];
        }
        class mb extends Ln {
            constructor(t1, e, r, n){
                super(), this.id = t1, this.dispatcher = r, this.coordinates = e.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.onNorthPole = !1, this.onSouthPole = !1, this.setEventedParent(n), this.options = e, this._dirty = !1;
            }
            load(t1, e) {
                if (this._loaded = e || !1, this.fire(new Dn("dataloading", {
                    dataType: "source"
                })), this.url = this.options.url, !this.url) return t1 && (this.coordinates = t1), this._loaded = !0, void this._finishLoading();
                this._imageRequest = on(this.map._requestManager.transformRequest(this.url, Wr.Image), (e, r)=>{
                    this._imageRequest = null, this._loaded = !0, e ? this.fire(new Cn(e)) : r && (this.image = r instanceof HTMLImageElement ? Dr.getImageData(r) : r, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, t1 && (this.coordinates = t1), this._finishLoading());
                });
            }
            loaded() {
                return this._loaded;
            }
            updateImage(t1) {
                return t1.url ? (this._imageRequest && t1.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = t1.url, this.load(t1.coordinates, this._loaded), this) : this;
            }
            setTexture(t1) {
                if (!(t1.handle instanceof WebGLTexture)) throw new Error("The provided handle is not a WebGLTexture instance");
                return this.texture = new Yg(this.map.painter.context, t1.handle), this.width = t1.dimensions[0], this.height = t1.dimensions[1], this._dirty = !1, this._loaded = !0, this._finishLoading(), this;
            }
            _finishLoading() {
                this.map && (this.setCoordinates(this.coordinates), this.fire(new Dn("data", {
                    dataType: "source",
                    sourceDataType: "metadata"
                })));
            }
            onAdd(t1) {
                this.map = t1, this.load();
            }
            onRemove(t1) {
                this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof Yg || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
            }
            setCoordinates(t1) {
                if (this.coordinates = t1, this._boundsArray = void 0, this._unsupportedCoords = !1, !t1.length) return this;
                this.onNorthPole = !1, this.onSouthPole = !1;
                let e = t1[0][1], r = t1[0][1];
                for (const n of t1)n[1] > r && (r = n[1]), n[1] < e && (e = n[1]);
                const n = (r + e) / 2;
                if (n > Dc ? this.onNorthPole = !0 : n < -Dc && (this.onSouthPole = !0), !this.onNorthPole && !this.onSouthPole) {
                    const e = t1.map(Oc.fromLngLat);
                    this.tileID = function(t1) {
                        let e = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0;
                        for (const s of t1)e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);
                        const s = Math.max(n - e, i - r), a = Math.max(0, Math.floor(-Math.log(s) / Math.LN2)), o = Math.pow(2, a);
                        let l = Math.floor((e + n) / 2 * o);
                        return l > 1 && (l -= 1), new bc(a, l, Math.floor((r + i) / 2 * o));
                    }(e), this.minzoom = this.maxzoom = this.tileID.z;
                }
                return this.fire(new Dn("data", {
                    dataType: "source",
                    sourceDataType: "content"
                })), this;
            }
            _clear() {
                this._boundsArray = void 0, this._unsupportedCoords = !1;
            }
            _prepareData(e) {
                for(const t1 in this.tiles){
                    const e = this.tiles[t1];
                    "loaded" !== e.state && (e.state = "loaded", e.texture = this.texture);
                }
                if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords) return;
                const r = ng(new bc(0, 0, 0), this.map.transform.projection), n = [
                    r.projection.project(this.coordinates[0][0], this.coordinates[0][1]),
                    r.projection.project(this.coordinates[1][0], this.coordinates[1][1]),
                    r.projection.project(this.coordinates[2][0], this.coordinates[2][1]),
                    r.projection.project(this.coordinates[3][0], this.coordinates[3][1])
                ];
                if (!function(t1) {
                    const e = t1[1].x - t1[0].x, r = t1[1].y - t1[0].y, n = t1[2].x - t1[1].x, i = t1[2].y - t1[1].y, s = t1[3].x - t1[2].x, a = t1[3].y - t1[2].y, o = t1[0].x - t1[3].x, l = t1[0].y - t1[3].y, u = e * i - n * r, c = n * a - s * i, h = s * l - o * a, p = o * r - e * l;
                    return u > 0 && c > 0 && h > 0 && p > 0 || u < 0 && c < 0 && h < 0 && p < 0;
                }(n)) return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = !0);
                const i = ng(this.tileID, this.map.transform.projection), [s, a, o, l] = this.coordinates.map((t1)=>{
                    const e = i.projection.project(t1[0], t1[1]);
                    return ig(i, e)._round();
                });
                this.perspectiveTransform = fb(s.x, s.y, a.x, a.y, o.x, o.y, l.x, l.y);
                const u = this._boundsArray = new Vl;
                u.emplaceBack(s.x, s.y, 0, 0), u.emplaceBack(a.x, a.y, ps, 0), u.emplaceBack(l.x, l.y, 0, ps), u.emplaceBack(o.x, o.y, ps, ps), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = e.createVertexBuffer(u, tx.members), this.boundsSegments = Au.simpleSegment(0, 0, 4, 2);
                const c = [], h = function(t1) {
                    return [
                        db(t1[0]),
                        db(t1[1]),
                        db(t1[2]),
                        db(t1[3])
                    ];
                }(this.coordinates), [p, f, d, m] = function(t1) {
                    let e = t1[0][0], r = e, n = t1[0][1], i = n;
                    for(let s = 1; s < t1.length; s++)t1[s][0] < e ? e = t1[s][0] : t1[s][0] > r && (r = t1[s][0]), t1[s][1] < n ? n = t1[s][1] : t1[s][1] > i && (i = t1[s][1]);
                    return [
                        e,
                        n,
                        r - e,
                        i - n
                    ];
                }(h);
                {
                    const i = new Vl, [s, a, o, l] = function(t1) {
                        let e = t1[0].x, r = e, n = t1[0].y, i = n;
                        for(let s = 1; s < t1.length; s++)t1[s].x < e ? e = t1[s].x : t1[s].x > r && (r = t1[s].x), t1[s].y < n ? n = t1[s].y : t1[s].y > i && (i = t1[s].y);
                        return [
                            e,
                            n,
                            r - e,
                            i - n
                        ];
                    }(n), u = (t1)=>[
                            (t1.x - s) / o,
                            (t1.y - a) / l
                        ], [h, y, g, x] = n.map(u), b = function(e, r, n, i, s, a, o, l) {
                        const u = pb(0, 0, 1, 0, 1, 1, 0, 1), c = pb(e, r, n, i, s, a, o, l), h = t1.bC.adjoint([], c);
                        return t1.bC.multiply(u, u, h);
                    }(h[0], h[1], y[0], y[1], g[0], g[1], x[0], x[1]);
                    this.elevatedGlobePerspectiveTransform = fb(h[0], h[1], y[0], y[1], g[0], g[1], x[0], x[1]);
                    const v = (e, r)=>{
                        c.push(e.lng);
                        const n = Math.round((e.lng - p) / d * ps), s = Math.round((e.lat - f) / m * ps), a = u(r), o = t1._.transformMat3([], [
                            a[0],
                            a[1],
                            1
                        ], b), l = Math.round(o[0] / o[2] * ps), h = Math.round(o[1] / o[2] * ps);
                        i.emplaceBack(n, s, l, h);
                    }, _ = n[3].x - n[0].x, w = n[3].y - n[0].y, M = n[2].x - n[1].x, A = n[2].y - n[1].y;
                    for(let t1 = 0; t1 < 65; t1++){
                        const e = t1 / 64, i = [
                            n[0].x + e * _,
                            n[0].y + e * w
                        ], s = [
                            n[1].x + e * M,
                            n[1].y + e * A
                        ], a = s[0] - i[0], o = s[1] - i[1];
                        for(let t1 = 0; t1 < 65; t1++){
                            const e = t1 / 64, n = {
                                x: i[0] + a * e,
                                y: i[1] + o * e,
                                z: 0
                            };
                            v(r.projection.unproject(n.x, n.y), n);
                        }
                    }
                    this.elevatedGlobeVertexBuffer = e.createVertexBuffer(i, tx.members);
                }
                {
                    this.maxLongitudeTriangleSize = 0;
                    let t1 = [], r = new Ql;
                    const n = (e, n, i)=>{
                        r.emplaceBack(e, n, i);
                        const s = c[e], a = c[n], o = c[i], l = Math.min(Math.min(s, a), o), u = Math.max(Math.max(s, a), o) - l;
                        u > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = u), t1.push(l + u / 2);
                    };
                    for(let t1 = 0; t1 < 64; t1++)for(let e = 0; e < 64; e++){
                        const r = 65 * t1 + e, i = r + 1, s = r + 65, a = s + 1;
                        n(r, s, i), n(i, s, a);
                    }
                    [t1, r] = function(t1, e) {
                        const r = Array.from({
                            length: t1.length
                        }, (t1, e)=>e);
                        r.sort((e, r)=>t1[e] - t1[r]);
                        const n = [], i = new Ql;
                        for(let s = 0; s < r.length; s++){
                            const a = r[s];
                            n.push(t1[a]);
                            const o = 3 * a, l = o + 1;
                            i.emplaceBack(e.uint16[o], e.uint16[l], e.uint16[l + 1]);
                        }
                        return [
                            n,
                            i
                        ];
                    }(t1, r), this.elevatedGlobeTrianglesCenterLongitudes = t1, this.elevatedGlobeIndexBuffer = e.createIndexBuffer(r);
                }
                this.elevatedGlobeSegments = Au.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([
                    0,
                    d / ps,
                    0,
                    m / ps,
                    0,
                    0,
                    f,
                    p,
                    0
                ]);
            }
            prepare() {
                const t1 = 0 !== Object.keys(this.tiles).length;
                if (this.tileID && !t1) return;
                const e = this.map.painter.context, r = e.gl;
                !this._dirty || this.texture instanceof Yg || (this.texture ? this.texture.update(this.image) : (this.texture = new Gg(e, this.image, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE)), this._dirty = !1), t1 && this._prepareData(e);
            }
            loadTile(t1, e) {
                this.tileID && this.tileID.equals(t1.tileID.canonical) ? (this.tiles[String(t1.tileID.wrap)] = t1, t1.buckets = {}, e(null)) : (t1.state = "errored", e(null));
            }
            serialize() {
                return {
                    type: "image",
                    url: this.options.url,
                    coordinates: this.coordinates
                };
            }
            hasTransition() {
                return !1;
            }
            getSegmentsForLongitude(t1) {
                const e = this.elevatedGlobeSegments;
                if (!this.elevatedGlobeTrianglesCenterLongitudes || !e) return null;
                const r = this.elevatedGlobeTrianglesCenterLongitudes;
                let n = (i = t1 + 180) + 360 * Math.round((r[0] - i) / 360);
                var i;
                const s = new Au, a = (t1, r)=>{
                    s.segments.push({
                        vertexOffset: 0,
                        primitiveOffset: t1,
                        vertexLength: e.segments[0].vertexLength,
                        primitiveLength: r,
                        sortKey: void 0,
                        vaos: {}
                    });
                }, o = .51 * this.maxLongitudeTriangleSize;
                if (Math.abs(r[0] - n) <= o) {
                    const t1 = Pr(r, 0, r.length, n + o);
                    return t1 === r.length || a(t1, kr(r, t1 + 1, r.length, n + 360 - o) - t1), s;
                }
                n < r[0] && (n += 360);
                const l = kr(r, 0, r.length, n - o);
                if (l === r.length) return a(0, r.length), s;
                a(0, l - 0);
                const u = Pr(r, l + 1, r.length, n + o);
                return u !== r.length && a(u, r.length - u), s;
            }
        }
        const yb = (Math.pow(256, 2) - 1) / 16907520;
        class gb extends kl {
            constructor(t1, e, r, n){
                super(t1, hb, e, r, n), this.updateColorRamp(), this._curRampRange = [
                    NaN,
                    NaN
                ];
            }
            getProgramIds() {
                return [
                    "raster"
                ];
            }
            hasColorMap() {
                return !!this._transitionablePaint._values["raster-color"].value.value;
            }
            tileCoverLift() {
                return this.paint.get("raster-elevation");
            }
            isDraped(t1) {
                return !(t1 && t1._source instanceof mb && (t1._source.onNorthPole || t1._source.onSouthPole)) && 0 === this.paint.get("raster-elevation");
            }
            _handleSpecialPaintPropertyUpdate(t1) {
                "raster-color" !== t1 && "raster-color-range" !== t1 || (this._curRampRange = [
                    NaN,
                    NaN
                ], this.updateColorRamp());
            }
            updateColorRamp(t1) {
                if (!this.hasColorMap()) return;
                if (!this._curRampRange) return;
                const e = this._transitionablePaint._values["raster-color"].value.expression, [r, n] = t1 || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({
                    zoom: 0
                }) || [
                    NaN,
                    NaN
                ];
                isNaN(r) && isNaN(n) || r === this._curRampRange[0] && n === this._curRampRange[1] || (this.colorRamp = gp({
                    expression: e,
                    evaluationKey: "rasterValue",
                    image: this.colorRamp,
                    clips: [
                        {
                            start: r,
                            end: n
                        }
                    ],
                    resolution: 256
                }), this.colorRampTexture = null, this._curRampRange = [
                    r,
                    n
                ]);
            }
        }
        const xb = new ol({
            visibility: new il(ll["layout_raster-particle"].visibility)
        });
        var bb = {
            paint: new ol({
                "raster-particle-array-band": new il(ll["paint_raster-particle"]["raster-particle-array-band"]),
                "raster-particle-count": new il(ll["paint_raster-particle"]["raster-particle-count"]),
                "raster-particle-color": new al(ll["paint_raster-particle"]["raster-particle-color"]),
                "raster-particle-max-speed": new il(ll["paint_raster-particle"]["raster-particle-max-speed"]),
                "raster-particle-speed-factor": new il(ll["paint_raster-particle"]["raster-particle-speed-factor"]),
                "raster-particle-fade-opacity-factor": new il(ll["paint_raster-particle"]["raster-particle-fade-opacity-factor"]),
                "raster-particle-reset-rate-factor": new il(ll["paint_raster-particle"]["raster-particle-reset-rate-factor"])
            }),
            layout: xb
        };
        class vb extends kl {
            constructor(t1, e, r, n){
                super(t1, bb, e, r, n), this._updateColorRamp(), this.lastInvalidatedAt = Dr.now();
            }
            onRemove(t1) {
                this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();
            }
            hasColorMap() {
                return !!this._transitionablePaint._values["raster-particle-color"].value.value;
            }
            getProgramIds() {
                return [
                    "rasterParticle"
                ];
            }
            hasOffscreenPass() {
                return "none" !== this.visibility;
            }
            isDraped(t1) {
                return !1;
            }
            _handleSpecialPaintPropertyUpdate(t1) {
                "raster-particle-color" !== t1 && "raster-particle-max-speed" !== t1 || (this._updateColorRamp(), this._invalidateAnimationState()), "raster-particle-count" === t1 && this._invalidateAnimationState();
            }
            _updateColorRamp() {
                if (!this.hasColorMap()) return;
                const t1 = this._transitionablePaint._values["raster-particle-color"].value.expression, e = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({
                    zoom: 0
                });
                this.colorRamp = gp({
                    expression: t1,
                    evaluationKey: "rasterParticleSpeed",
                    image: this.colorRamp,
                    clips: [
                        {
                            start: 0,
                            end: e
                        }
                    ],
                    resolution: 256
                }), this.colorRampTexture = null;
            }
            _invalidateAnimationState() {
                this.lastInvalidatedAt = Dr.now();
            }
        }
        class _b extends kl {
            constructor(t1, e){
                super(t1, {}, e, null), this.implementation = t1, t1.slot && (this.slot = t1.slot);
            }
            is3D() {
                return "3d" === this.implementation.renderingMode;
            }
            hasOffscreenPass() {
                return void 0 !== this.implementation.prerender;
            }
            isDraped(t1) {
                return void 0 !== this.implementation.renderToTile;
            }
            shouldRedrape() {
                return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
            }
            recalculate() {}
            updateTransitions() {}
            hasTransition() {
                return !1;
            }
            serialize() {}
            onAdd(t1) {
                this.implementation.onAdd && this.implementation.onAdd(t1, t1.painter.context.gl);
            }
            onRemove(t1) {
                this.implementation.onRemove && this.implementation.onRemove(t1, t1.painter.context.gl);
            }
        }
        const wb = new ol({
            visibility: new il(ll.layout_sky.visibility)
        });
        var Mb = {
            paint: new ol({
                "sky-type": new il(ll.paint_sky["sky-type"]),
                "sky-atmosphere-sun": new il(ll.paint_sky["sky-atmosphere-sun"]),
                "sky-atmosphere-sun-intensity": new il(ll.paint_sky["sky-atmosphere-sun-intensity"]),
                "sky-gradient-center": new il(ll.paint_sky["sky-gradient-center"]),
                "sky-gradient-radius": new il(ll.paint_sky["sky-gradient-radius"]),
                "sky-gradient": new al(ll.paint_sky["sky-gradient"]),
                "sky-atmosphere-halo-color": new il(ll.paint_sky["sky-atmosphere-halo-color"]),
                "sky-atmosphere-color": new il(ll.paint_sky["sky-atmosphere-color"]),
                "sky-opacity": new il(ll.paint_sky["sky-opacity"])
            }),
            layout: wb
        };
        function Ab(e, r, n) {
            const i = [
                0,
                0,
                1
            ], s = t1.av.identity([]);
            return t1.av.rotateY(s, s, n ? -$e(e) + Math.PI : $e(e)), t1.av.rotateX(s, s, -$e(r)), t1._.transformQuat(i, i, s), t1._.normalize(i, i);
        }
        var Sb = {
            paint: new ol({})
        };
        function Ib(e, r) {
            const n = kb(e.projection, e.zoom, e.width, e.height), i = function(e, r, n, i, s) {
                const a = new mc(n.lng - 180 * Pb, n.lat), o = new mc(n.lng + 180 * Pb, n.lat), l = e.project(a.lng, a.lat), u = e.project(o.lng, o.lat), c = -Math.atan2(u.y - l.y, u.x - l.x), h = Oc.fromLngLat(n);
                h.y = Ke(h.y, -1 + Pb, 1 - Pb);
                const p = h.toLngLat(), f = e.project(p.lng, p.lat), d = Oc.fromLngLat(p);
                d.x += Pb;
                const m = d.toLngLat(), y = e.project(m.lng, m.lat), g = Eb(y.x - f.x, y.y - f.y, c), x = Oc.fromLngLat(p);
                x.y += Pb;
                const b = x.toLngLat(), v = e.project(b.lng, b.lat), _ = Eb(v.x - f.x, v.y - f.y, c), w = Math.abs(g.x) / Math.abs(_.y), M = t1.ad.identity([]);
                t1.ad.rotateZ(M, M, -c * (1 - (s ? 0 : i)));
                const A = t1.ad.identity([]);
                return t1.ad.scale(A, A, [
                    1,
                    1 - (1 - w) * i,
                    1
                ]), A[4] = -_.x / _.y * i, t1.ad.rotateZ(A, A, c), t1.ad.multiply(A, M, A), A;
            }(e.projection, 0, e.center, n, r), s = Tb(e);
            return t1.ad.scale(i, i, [
                s,
                s,
                1
            ]), i;
        }
        function Tb(t1) {
            const e = t1.projection, r = kb(t1.projection, t1.zoom, t1.width, t1.height), n = zb(e, t1.center), i = zb(e, mc.convert(e.center));
            return Math.pow(2, n * r + (1 - r) * i);
        }
        function kb(t1, e, r, n, i = 1 / 0) {
            const s = t1.range;
            if (!s) return 0;
            const a = Math.min(i, Math.max(r, n)), o = Math.log(a / 1024) / Math.LN2;
            return We(s[0] + o, s[1] + o, e);
        }
        const Pb = 1 / 4e4;
        function zb(t1, e) {
            const r = Ke(e.lat, -Dc, Dc), n = new mc(e.lng - 180 * Pb, r), i = new mc(e.lng + 180 * Pb, r), s = t1.project(n.lng, r), a = t1.project(i.lng, r), o = Oc.fromLngLat(n), l = Oc.fromLngLat(i), u = a.x - s.x, c = a.y - s.y, h = l.x - o.x, p = l.y - o.y, f = Math.sqrt((h * h + p * p) / (u * u + c * c));
            return Math.log(f) / Math.LN2;
        }
        function Eb(t1, e, r) {
            const n = Math.cos(r), i = Math.sin(r);
            return {
                x: t1 * n - e * i,
                y: t1 * i + e * n
            };
        }
        function Bb(e, r, n) {
            t1.ad.identity(e), t1.ad.rotateZ(e, e, $e(r[2])), t1.ad.rotateX(e, e, $e(r[0])), t1.ad.rotateY(e, e, $e(r[1])), t1.ad.scale(e, e, n), t1.ad.multiply(e, e, [
                1,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                1
            ]);
        }
        function Db(e, r, n, i, s, a, o, l) {
            const u = [
                n[0] - r[0],
                n[1] - r[1],
                0
            ], c = [
                i[0] - r[0],
                i[1] - r[1],
                0
            ];
            if (t1._.length(u) < 1e-12 || t1._.length(c) < 1e-12) return t1.av.identity(e);
            const h = t1._.cross([], u, c);
            t1._.normalize(h, h), t1._.subtract(c, i, r), u[2] = (a - s) * l, c[2] = (o - s) * l;
            const p = u;
            return t1._.cross(p, u, c), t1._.normalize(p, p), t1.av.rotationTo(e, h, p);
        }
        function Cb(e, r, n = !1) {
            const i = Hh(r.zoom), s = function(e, r, n) {
                const i = r.worldSize, s = [
                    e[12],
                    e[13],
                    e[14]
                ], a = Ec(s[1] / i), o = zc(s[0] / i), l = t1.ad.identity([]), u = Pc(1, a) * i, c = Pc(1, 0) * i * Rc(a, r.zoom), h = 1 / Yh(i);
                let p = c * h;
                if (n) {
                    const t1 = kb(r.projection, r.zoom, r.width, r.height, 1024);
                    p = h * r.projection.pixelSpaceConversion(r.center.lat, i, t1);
                }
                const f = pc(a, o);
                t1._.add(f, f, t1._.scale([], t1._.normalize([], f), u * p * s[2]));
                const d = function(e) {
                    const r = [
                        e[0],
                        e[1],
                        e[2]
                    ];
                    let n = [
                        0,
                        1,
                        0
                    ];
                    const i = t1._.cross([], n, r);
                    return t1._.cross(n, r, i), 0 === t1._.squaredLength(n) && (n = [
                        0,
                        1,
                        0
                    ], t1._.cross(i, r, n)), t1._.normalize(i, i), t1._.normalize(n, n), t1._.normalize(r, r), [
                        i[0],
                        i[1],
                        i[2],
                        0,
                        n[0],
                        n[1],
                        n[2],
                        0,
                        r[0],
                        r[1],
                        r[2],
                        0,
                        e[0],
                        e[1],
                        e[2],
                        1
                    ];
                }(f);
                t1.ad.scale(l, l, [
                    p,
                    p,
                    p * u
                ]), t1.ad.translate(l, l, [
                    -s[0],
                    -s[1],
                    -s[2]
                ]);
                const m = t1.ad.multiply([], r.globeMatrix, d);
                return t1.ad.multiply(m, m, l), t1.ad.multiply(m, m, e), m;
            }(e, r, n);
            if (i > 0) {
                const n = function(e, r) {
                    const n = r.worldSize, i = Pc(1, 0) * n * Rc(r.center.lat, r.zoom) / Yh(n), s = Pc(1, r.center.lat) * n, a = t1.ad.identity([]);
                    return t1.ad.rotateY(a, a, $e(r.center.lng)), t1.ad.rotateX(a, a, $e(r.center.lat)), t1.ad.translate(a, a, [
                        0,
                        0,
                        nc
                    ]), t1.ad.scale(a, a, [
                        i,
                        i,
                        i * s
                    ]), t1.ad.translate(a, a, [
                        r.point.x - .5 * n,
                        r.point.y - .5 * n,
                        0
                    ]), t1.ad.multiply(a, a, e), t1.ad.multiply(a, r.globeMatrix, a);
                }(e, r);
                return function(e, r, n) {
                    const i = (e, r, n)=>{
                        const i = t1._.length(e), s = t1._.length(r), a = Rh(e, r, n);
                        return t1._.scale(a, a, 1 / t1._.length(a) * Gn(i, s, n));
                    }, s = i([
                        e[0],
                        e[1],
                        e[2]
                    ], [
                        r[0],
                        r[1],
                        r[2]
                    ], n), a = i([
                        e[4],
                        e[5],
                        e[6]
                    ], [
                        r[4],
                        r[5],
                        r[6]
                    ], n), o = i([
                        e[8],
                        e[9],
                        e[10]
                    ], [
                        r[8],
                        r[9],
                        r[10]
                    ], n), l = Rh([
                        e[12],
                        e[13],
                        e[14]
                    ], [
                        r[12],
                        r[13],
                        r[14]
                    ], n);
                    return [
                        s[0],
                        s[1],
                        s[2],
                        0,
                        a[0],
                        a[1],
                        a[2],
                        0,
                        o[0],
                        o[1],
                        o[2],
                        0,
                        l[0],
                        l[1],
                        l[2],
                        1
                    ];
                }(s, n, i);
            }
            return s;
        }
        function Rb(t1, e, r, n) {
            const i = Ah.projectAabbCorners(n, r);
            let s = Number.MAX_VALUE, a = -1;
            for(let t1 = 0; t1 < i.length; ++t1){
                const r = i[t1];
                r[0] = (.5 * r[0] + .5) * e.width, r[1] = (.5 - .5 * r[1]) * e.height, r[2] < s && (a = t1, s = r[2]);
            }
            const o = (t1)=>new Ne(i[t1][0], i[t1][1]);
            let l;
            switch(a){
                case 0:
                case 6:
                    l = [
                        o(1),
                        o(5),
                        o(4),
                        o(7),
                        o(3),
                        o(2),
                        o(1)
                    ];
                    break;
                case 1:
                case 7:
                    l = [
                        o(0),
                        o(4),
                        o(5),
                        o(6),
                        o(2),
                        o(3),
                        o(0)
                    ];
                    break;
                case 3:
                case 5:
                    l = [
                        o(1),
                        o(0),
                        o(4),
                        o(7),
                        o(6),
                        o(2),
                        o(1)
                    ];
                    break;
                default:
                    l = [
                        o(1),
                        o(5),
                        o(6),
                        o(7),
                        o(3),
                        o(0),
                        o(1)
                    ];
            }
            if (Wc(t1, l)) return s;
        }
        const Vb = Bl([
            {
                name: "a_pos_3f",
                components: 3,
                type: "Float32"
            }
        ]), Lb = Bl([
            {
                name: "a_color_3f",
                components: 3,
                type: "Float32"
            }
        ]), Ob = Bl([
            {
                name: "a_color_4f",
                components: 4,
                type: "Float32"
            }
        ]), Fb = Bl([
            {
                name: "a_uv_2f",
                components: 2,
                type: "Float32"
            }
        ]), Ub = Bl([
            {
                name: "a_normal_3f",
                components: 3,
                type: "Float32"
            }
        ]), Nb = Bl([
            {
                name: "a_normal_matrix0",
                components: 4,
                type: "Float32"
            },
            {
                name: "a_normal_matrix1",
                components: 4,
                type: "Float32"
            },
            {
                name: "a_normal_matrix2",
                components: 4,
                type: "Float32"
            },
            {
                name: "a_normal_matrix3",
                components: 4,
                type: "Float32"
            }
        ]), jb = Bl([
            {
                name: "a_pbr",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_heightBasedEmissiveStrength",
                components: 3,
                type: "Float32"
            }
        ]);
        class qb {
            constructor(t1, e, r, n){
                this.message = (t1 ? `${t1}: ` : "") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__);
            }
        }
        function $b(t1, e) {
            const r = -1 === t1.indexOf("://");
            try {
                return new URL(t1, r && e ? "http://example.com" : void 0), !0;
            } catch (t1) {
                return !1;
            }
        }
        class Gb {
            constructor(t1, e){
                this.feature = t1, this.instancedDataOffset = e, this.instancedDataCount = 0, this.rotation = [
                    0,
                    0,
                    0
                ], this.scale = [
                    1,
                    1,
                    1
                ], this.translation = [
                    0,
                    0,
                    0
                ];
            }
        }
        class Yb {
            constructor(){
                this.instancedDataArray = new ou, this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
            }
        }
        class Xb {
            constructor(t1){
                this.zoom = t1.zoom, this.canonical = t1.canonical, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.projection = t1.projection, this.index = t1.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.hasPattern = !1, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = {
                    id: null,
                    timestamp: 0
                }, this.modelUris = [], this.modelsRequested = !1, this.activeReplacements = [], this.replacementUpdateTime = 0;
            }
            updateFootprints(t1, e) {}
            populate(t1, e, r, n) {
                this.tileToMeter = Lc(r);
                const i = this.layers[0]._featureFilter.needGeometry;
                this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
                for (const { feature: s, id: a, index: o, sourceLayerIndex: l } of t1){
                    const t1 = null != a ? a : s.properties && s.properties.hasOwnProperty("id") ? s.properties.id : void 0, u = Xc(s, i);
                    if (!this.layers[0]._featureFilter.filter(new Ho(this.zoom), u, r)) continue;
                    const c = {
                        id: t1,
                        sourceLayerIndex: l,
                        index: o,
                        geometry: i ? u.geometry : Yc(s, r, n),
                        properties: s.properties,
                        type: s.type,
                        patterns: {}
                    }, h = this.addFeature(c, c.geometry, u);
                    h && e.featureIndex.insert(s, c.geometry, o, l, this.index, this.instancesPerModel[h].instancedDataArray.length, ps / 32);
                }
                this.lookup = null;
            }
            update(t1, e, r, n) {
                for(const e in this.instancesPerModel){
                    const r = this.instancesPerModel[e];
                    for(const e in t1)r.idToFeaturesIndex.hasOwnProperty(e) && (this.evaluate(r.features[r.idToFeaturesIndex[e]], t1[e], r, !0), this.uploaded = !1);
                }
                this.maxHeight = 0;
            }
            updateZoomBasedPaintProperties() {
                if (!this.hasZoomDependentProperties) return !1;
                let e = !1;
                for(const r in this.instancesPerModel){
                    const n = this.instancesPerModel[r];
                    for (const r of n.features){
                        const i = this.layers[0], s = r.feature, a = this.canonical, o = i.paint.get("model-rotation").evaluate(s, {}, a), l = i.paint.get("model-scale").evaluate(s, {}, a), u = i.paint.get("model-translation").evaluate(s, {}, a);
                        t1._.exactEquals(r.rotation, o) && t1._.exactEquals(r.scale, l) && t1._.exactEquals(r.translation, u) || (this.evaluate(r, r.featureStates, n, !0), e = !0);
                    }
                }
                return e;
            }
            updateReplacement(t1, e, r) {
                if (e.updateTime === this.replacementUpdateTime) return !1;
                this.replacementUpdateTime = e.updateTime;
                const n = e.getReplacementRegionsForTile(t1.toUnwrapped(), !0);
                if (Cf(this.activeReplacements, n)) return !1;
                this.activeReplacements = n;
                let i = !1;
                for(const e in this.instancesPerModel){
                    const n = this.instancesPerModel[e], s = n.instancedDataArray;
                    for (const e of n.features){
                        const n = e.instancedDataOffset, a = e.instancedDataCount;
                        for(let e = 0; e < a; e++){
                            const a = 16 * (e + n);
                            let o = s.float32[a + 0];
                            o = o > ps ? o - ps : o;
                            const l = Math.floor(o), u = s.float32[a + 1];
                            let c = !1;
                            for (const e of this.activeReplacements)if (!(e.order < r || e.order === 1 / 0) && e.clipMask & td.Model && !(e.min.x > l || l > e.max.x || e.min.y > u || u > e.max.y) && (c = Uf(Ff(l, u, t1.canonical, e.footprintTileId.canonical), e), c)) break;
                            s.float32[a] = c ? o + ps : o, i = i || c;
                        }
                    }
                }
                return i;
            }
            isEmpty() {
                for(const t1 in this.instancesPerModel)if (0 !== this.instancesPerModel[t1].instancedDataArray.length) return !1;
                return !0;
            }
            uploadPending() {
                return !this.uploaded;
            }
            upload(t1) {
                if (!this.uploaded) for(const e in this.instancesPerModel){
                    const r = this.instancesPerModel[e];
                    r.instancedDataArray.length < 0 || 0 === r.instancedDataArray.length || (r.instancedDataBuffer ? r.instancedDataBuffer.updateData(r.instancedDataArray) : r.instancedDataBuffer = t1.createVertexBuffer(r.instancedDataArray, Nb.members, !0, void 0, this.instanceCount));
                }
                this.uploaded = !0;
            }
            destroy() {
                for(const t1 in this.instancesPerModel){
                    const e = this.instancesPerModel[t1];
                    0 !== e.instancedDataArray.length && e.instancedDataBuffer && e.instancedDataBuffer.destroy();
                }
                const t1 = this.layers[0].modelManager;
                if (t1 && this.modelUris) for (const e of this.modelUris)t1.removeModel(e, "");
            }
            addFeature(t1, e, r) {
                const n = this.layers[0], i = n.layout.get("model-id").evaluate(r, {}, this.canonical);
                if (!i) return fr(`modelId is not evaluated for layer ${n.id} and it is not going to get rendered.`), i;
                $b(i, !1) && (this.modelUris.includes(i) || this.modelUris.push(i)), this.instancesPerModel[i] || (this.instancesPerModel[i] = new Yb);
                const s = this.instancesPerModel[i], a = s.instancedDataArray, o = new Gb(r, a.length);
                for (const t1 of e)for (const e of t1){
                    if (e.x < 0 || e.x >= ps || e.y < 0 || e.y >= ps) continue;
                    const t1 = (this.lookupDim - 1) / ps, r = this.lookupDim * (e.y * t1 | 0) + e.x * t1 | 0;
                    if (this.lookup) {
                        if (0 !== this.lookup[r]) continue;
                        this.lookup[r] = 1;
                    }
                    this.instanceCount++;
                    const n = a.length;
                    a.resize(n + 1), s.instancesEvaluatedElevation.push(0), a.float32[16 * n] = e.x, a.float32[16 * n + 1] = e.y;
                }
                return o.instancedDataCount = s.instancedDataArray.length - o.instancedDataOffset, o.instancedDataCount > 0 && (t1.id && (s.idToFeaturesIndex[t1.id] = s.features.length), s.features.push(o), this.evaluate(o, {}, s, !1)), i;
            }
            getModelUris() {
                return this.modelUris;
            }
            evaluate(t1, e, r, n) {
                const i = this.layers[0], s = t1.feature, a = this.canonical, o = t1.rotation = i.paint.get("model-rotation").evaluate(s, e, a), l = t1.scale = i.paint.get("model-scale").evaluate(s, e, a), u = t1.translation = i.paint.get("model-translation").evaluate(s, e, a), c = i.paint.get("model-color").evaluate(s, e, a);
                c.a = i.paint.get("model-color-mix-intensity").evaluate(s, e, a);
                const h = [];
                this.maxVerticalOffset < u[2] && (this.maxVerticalOffset = u[2]), this.maxScale = Math.max(Math.max(this.maxScale, l[0]), Math.max(l[1], l[2])), Bb(h, o, l);
                const p = Math.round(100 * c.a) + c.b / 1.05;
                for(let e = 0; e < t1.instancedDataCount; ++e){
                    const i = t1.instancedDataOffset + e, s = 16 * i, o = r.instancedDataArray.float32;
                    let l = 0;
                    n && (l = o[s + 6] - r.instancesEvaluatedElevation[i]);
                    const f = 0 | o[s + 1];
                    o[s] = (0 | o[s]) + c.r / 1.05, o[s + 1] = f + c.g / 1.05, o[s + 2] = p, o[s + 3] = 1 / (a.z > 10 ? this.tileToMeter : Lc(a, f)), o[s + 4] = u[0], o[s + 5] = u[1], o[s + 6] = u[2] + l, o[s + 7] = h[0], o[s + 8] = h[1], o[s + 9] = h[2], o[s + 10] = h[4], o[s + 11] = h[5], o[s + 12] = h[6], o[s + 13] = h[8], o[s + 14] = h[9], o[s + 15] = h[10], r.instancesEvaluatedElevation[i] = u[2];
                }
            }
        }
        Mo(Xb, "ModelBucket", {
            omit: [
                "layers"
            ]
        }), Mo(Yb, "PerModelAttributes"), Mo(Gb, "ModelFeature");
        const Zb = new ol({
            visibility: new il(ll.layout_model.visibility),
            "model-id": new sl(ll.layout_model["model-id"])
        });
        var Hb = {
            paint: new ol({
                "model-opacity": new il(ll.paint_model["model-opacity"]),
                "model-rotation": new sl(ll.paint_model["model-rotation"]),
                "model-scale": new sl(ll.paint_model["model-scale"]),
                "model-translation": new sl(ll.paint_model["model-translation"]),
                "model-color": new sl(ll.paint_model["model-color"]),
                "model-color-mix-intensity": new sl(ll.paint_model["model-color-mix-intensity"]),
                "model-type": new il(ll.paint_model["model-type"]),
                "model-cast-shadows": new il(ll.paint_model["model-cast-shadows"]),
                "model-receive-shadows": new il(ll.paint_model["model-receive-shadows"]),
                "model-ambient-occlusion-intensity": new il(ll.paint_model["model-ambient-occlusion-intensity"]),
                "model-emissive-strength": new sl(ll.paint_model["model-emissive-strength"]),
                "model-roughness": new sl(ll.paint_model["model-roughness"]),
                "model-height-based-emissive-strength-multiplier": new sl(ll.paint_model["model-height-based-emissive-strength-multiplier"]),
                "model-cutoff-fade-range": new il(ll.paint_model["model-cutoff-fade-range"]),
                "model-front-cutoff": new il(ll.paint_model["model-front-cutoff"])
            }),
            layout: Zb
        };
        const Kb = 64, Wb = {
            CoordinateSpaceTile: 1,
            CoordinateSpaceYUp: 2,
            HasMapboxMeshFeatures: 4,
            HasMeshoptCompression: 8
        };
        function Jb(e, r, n, i, s, a, o, l, u, c = !1) {
            const h = n.zoom, p = n.project(i), f = Rc(i.lat, h), d = 1 / f;
            t1.ad.identity(e), t1.ad.translate(e, e, [
                p.x + o[0] * d,
                p.y + o[1] * d,
                o[2]
            ]);
            let m = 1, y = 1;
            const g = n.worldSize;
            if (c) {
                if ("mercator" === n.projection.name) {
                    let e = 0;
                    n.elevation && (e = n.elevation.getAtPointOrZero(new Oc(p.x / g, p.y / g), 0));
                    const r = t1.aA.transformMat4([], [
                        p.x,
                        p.y,
                        e,
                        1
                    ], n.projMatrix)[3] / n.cameraToCenterDistance;
                    m = r, y = r * Rc(n.center.lat, h);
                } else if ("globe" === n.projection.name) {
                    const r = Cb(e, n), s = t1.ad.multiply([], n.projMatrix, r), a = [
                        0,
                        0,
                        0,
                        1
                    ];
                    t1.aA.transformMat4(a, a, s);
                    const o = a[3] / n.cameraToCenterDistance, l = Hh(h), u = n.projection.pixelsPerMeter(i.lat, g) * Rc(i.lat, h), c = n.projection.pixelsPerMeter(n.center.lat, g) * Rc(n.center.lat, h);
                    m = o / Gn(u, Cc(n.center.lat), l), y = o * f / u, m *= c, y *= c;
                }
            } else m = d;
            t1.ad.scale(e, e, [
                m,
                m,
                y
            ]);
            const x = [
                ...e
            ], b = r.orientation, v = [];
            if (Bb(v, [
                b[0] + s[0],
                b[1] + s[1],
                b[2] + s[2]
            ], a), t1.ad.multiply(e, x, v), l && n.elevation) {
                let s = 0;
                const a = [];
                if (u && n.elevation) {
                    s = function(e, r, n, i, s) {
                        const a = r.elevation;
                        if (!a) return 0;
                        const o = Ah.projectAabbCorners(n, i), l = Pc(1, s.lat) * r.worldSize, u = function(e, r) {
                            const n = [
                                0,
                                0,
                                1
                            ], i = [
                                {
                                    corners: [
                                        0,
                                        1,
                                        3,
                                        2
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        1,
                                        5,
                                        2,
                                        6
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        0,
                                        4,
                                        1,
                                        5
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        2,
                                        6,
                                        3,
                                        7
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        4,
                                        7,
                                        5,
                                        6
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        0,
                                        3,
                                        4,
                                        7
                                    ],
                                    dotProductWithUp: 0
                                }
                            ];
                            for (const s of i){
                                const i = e[s.corners[0]], a = e[s.corners[1]], o = e[s.corners[2]], l = [
                                    a[0] - i[0],
                                    a[1] - i[1],
                                    r * (a[2] - i[2])
                                ], u = t1._.cross(l, l, [
                                    o[0] - i[0],
                                    o[1] - i[1],
                                    r * (o[2] - i[2])
                                ]);
                                t1._.normalize(u, u), s.dotProductWithUp = t1._.dot(u, n);
                            }
                            return i.sort((t1, e)=>t1.dotProductWithUp - e.dotProductWithUp), i[0].corners;
                        }(o, l), c = o[u[0]], h = o[u[1]], p = o[u[2]], f = o[u[3]], d = a.getAtPointOrZero(new Oc(c[0] / r.worldSize, c[1] / r.worldSize), 0), m = a.getAtPointOrZero(new Oc(h[0] / r.worldSize, h[1] / r.worldSize), 0), y = a.getAtPointOrZero(new Oc(p[0] / r.worldSize, p[1] / r.worldSize), 0), g = a.getAtPointOrZero(new Oc(f[0] / r.worldSize, f[1] / r.worldSize), 0), x = (d + g) / 2, b = (m + y) / 2;
                        return x > b ? m < y ? Db(e, h, f, c, m, g, d, l) : Db(e, p, c, f, y, d, g, l) : d < g ? Db(e, c, h, p, d, m, y, l) : Db(e, f, p, h, g, y, m, l), Math.max(x, b);
                    }(a, n, r.aabb, e, i);
                    const o = t1.ad.fromQuat([], a), l = t1.ad.multiply([], o, v);
                    t1.ad.multiply(e, x, l);
                } else s = n.elevation.getAtPointOrZero(new Oc(p.x / g, p.y / g), 0);
                0 !== s && (e[14] += s);
            }
        }
        function Qb(t1, e, r = !1) {
            t1.uploaded || (t1.gfxTexture = new Gg(e, t1.image, r ? e.gl.R8 : e.gl.RGBA, {
                useMipmap: t1.sampler.minFilter >= e.gl.NEAREST_MIPMAP_NEAREST
            }), t1.uploaded = !0, t1.image = null);
        }
        function tv(t1, e, r) {
            t1.indexBuffer = e.createIndexBuffer(t1.indexArray, !1, !0), t1.vertexBuffer = e.createVertexBuffer(t1.vertexArray, Vb.members, !1, !0), t1.normalArray && (t1.normalBuffer = e.createVertexBuffer(t1.normalArray, Ub.members, !1, !0)), t1.texcoordArray && (t1.texcoordBuffer = e.createVertexBuffer(t1.texcoordArray, Fb.members, !1, !0)), t1.colorArray && (t1.colorBuffer = e.createVertexBuffer(t1.colorArray, (12 === t1.colorArray.bytesPerElement ? Lb : Ob).members, !1, !0)), t1.featureArray && (t1.pbrBuffer = e.createVertexBuffer(t1.featureArray, jb.members, !0)), t1.segments = Au.simpleSegment(0, 0, t1.vertexArray.length, t1.indexArray.length);
            const n = t1.material;
            n.pbrMetallicRoughness.baseColorTexture && Qb(n.pbrMetallicRoughness.baseColorTexture, e), n.pbrMetallicRoughness.metallicRoughnessTexture && Qb(n.pbrMetallicRoughness.metallicRoughnessTexture, e), n.normalTexture && Qb(n.normalTexture, e), n.occlusionTexture && Qb(n.occlusionTexture, e, r), n.emissionTexture && Qb(n.emissionTexture, e);
        }
        function ev(t1, e, r) {
            if (t1.meshes) for (const n of t1.meshes)tv(n, e, r);
            if (t1.children) for (const n of t1.children)ev(n, e, r);
        }
        function rv(t1) {
            if (t1.meshes) for (const e of t1.meshes)e.indexArray.destroy(), e.vertexArray.destroy(), e.colorArray && e.colorArray.destroy(), e.normalArray && e.normalArray.destroy(), e.texcoordArray && e.texcoordArray.destroy(), e.featureArray && e.featureArray.destroy();
            if (t1.children) for (const e of t1.children)rv(e);
        }
        function nv(t1) {
            if (t1.meshes) for (const r of t1.meshes)r.vertexBuffer && (r.vertexBuffer.destroy(), r.indexBuffer.destroy(), r.normalBuffer && r.normalBuffer.destroy(), r.texcoordBuffer && r.texcoordBuffer.destroy(), r.colorBuffer && r.colorBuffer.destroy(), r.pbrBuffer && r.pbrBuffer.destroy(), r.segments.destroy(), r.material && ((e = r.material).pbrMetallicRoughness.baseColorTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e.pbrMetallicRoughness.metallicRoughnessTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e.normalTexture && e.normalTexture.gfxTexture && e.normalTexture.gfxTexture.destroy(), e.emissionTexture && e.emissionTexture.gfxTexture && e.emissionTexture.gfxTexture.destroy(), e.occlusionTexture && e.occlusionTexture.gfxTexture && e.occlusionTexture.gfxTexture.destroy()));
            var e;
            if (t1.children) for (const e of t1.children)nv(e);
        }
        class iv {
            constructor(t1){
                this._callback = t1, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel, this._channel.port2.onmessage = ()=>{
                    this._triggered = !1, this._callback();
                });
            }
            trigger() {
                this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(()=>{
                    this._triggered = !1, this._callback();
                }, 0));
            }
            remove() {
                this._channel = void 0, this._callback = ()=>{};
            }
        }
        class sv {
            constructor(){
                this.tasks = {}, this.taskQueue = [], or([
                    "process"
                ], this), this.invoker = new iv(this.process), this.nextId = 0;
            }
            add(t1, e) {
                const r = this.nextId++, n = function({ type: t1, isSymbolTile: e, zoom: r }) {
                    return r = r || 0, "message" === t1 ? 0 : "maybePrepare" !== t1 || e ? "parseTile" !== t1 || e ? "parseTile" === t1 && e ? 300 - r : "maybePrepare" === t1 && e ? 400 - r : 500 : 200 - r : 100 - r;
                }(e);
                if (0 === n) {
                    t1();
                    return null;
                }
                return this.tasks[r] = {
                    fn: t1,
                    metadata: e,
                    priority: n,
                    id: r
                }, this.taskQueue.push(r), this.invoker.trigger(), {
                    cancel: ()=>{
                        delete this.tasks[r];
                    }
                };
            }
            process() {
                {
                    if (this.taskQueue = this.taskQueue.filter((t1)=>!!this.tasks[t1]), !this.taskQueue.length) return;
                    const t1 = this.pick();
                    if (null === t1) return;
                    const e = this.tasks[t1];
                    if (delete this.tasks[t1], this.taskQueue.length && this.invoker.trigger(), !e) return;
                    e.fn();
                }
            }
            pick() {
                let t1 = null, e = 1 / 0;
                for(let r = 0; r < this.taskQueue.length; r++){
                    const n = this.tasks[this.taskQueue[r]];
                    n.priority < e && (e = n.priority, t1 = r);
                }
                if (null === t1) return null;
                const r = this.taskQueue[t1];
                return this.taskQueue.splice(t1, 1), r;
            }
            remove() {
                this.invoker.remove();
            }
        }
        class av {
            constructor(t1, e, r){
                this.target = t1, this.parent = e, this.mapId = r, this.callbacks = {}, this.cancelCallbacks = {}, or([
                    "receive"
                ], this), this.target.addEventListener("message", this.receive, !1), this.scheduler = new sv;
            }
            send(t1, e, r, n, i = !1, s) {
                const a = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
                r && (r.metadata = s, this.callbacks[a] = r);
                const o = new Set;
                return this.target.postMessage({
                    id: a,
                    type: t1,
                    hasCallback: !!r,
                    targetMapId: n,
                    mustQueue: i,
                    sourceMapId: this.mapId,
                    data: Io(e, o)
                }, o), {
                    cancel: ()=>{
                        r && delete this.callbacks[a], this.target.postMessage({
                            id: a,
                            type: "<cancel>",
                            targetMapId: n,
                            sourceMapId: this.mapId
                        });
                    }
                };
            }
            receive(t1) {
                const e = t1.data, r = e.id;
                if (r && (!e.targetMapId || this.mapId === e.targetMapId)) {
                    if ("<cancel>" === e.type) {
                        const t1 = this.cancelCallbacks[r];
                        delete this.cancelCallbacks[r], t1 && t1.cancel();
                    } else if (e.mustQueue || gr()) {
                        const t1 = this.callbacks[r], n = this.scheduler.add(()=>this.processTask(r, e), t1 && t1.metadata || {
                            type: "message"
                        });
                        n && (this.cancelCallbacks[r] = n);
                    } else this.processTask(r, e);
                }
            }
            processTask(t1, e) {
                if (delete this.cancelCallbacks[t1], "<response>" === e.type) {
                    const r = this.callbacks[t1];
                    delete this.callbacks[t1], r && (e.error ? r(To(e.error)) : r(null, To(e.data)));
                } else {
                    const r = new Set, n = e.hasCallback ? (e, n)=>{
                        this.target.postMessage({
                            id: t1,
                            type: "<response>",
                            sourceMapId: this.mapId,
                            error: e ? Io(e) : null,
                            data: Io(n, r)
                        }, r);
                    } : (t1)=>{}, i = To(e.data);
                    if (this.parent[e.type]) this.parent[e.type](e.sourceMapId, i, n);
                    else if (this.parent.getWorkerSource) {
                        const t1 = e.type.split(".");
                        this.parent.getWorkerSource(e.sourceMapId, t1[0], i.source, i.scope)[t1[1]](i, n);
                    } else n(new Error(`Could not find function ${e.type}`));
                }
            }
            remove() {
                this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1);
            }
        }
        class ov {
            constructor(t1, e){
                this.workerPool = t1, this.actors = [], this.currentActor = 0, this.id = nr();
                const r = this.workerPool.acquire(this.id);
                for(let t1 = 0; t1 < r.length; t1++){
                    const n = new ov.Actor(r[t1], e, this.id);
                    n.name = `Worker ${t1}`, this.actors.push(n);
                }
                this.ready = !1, this.broadcast("checkIfReady", null, ()=>{
                    this.ready = !0;
                });
            }
            broadcast(t1, e, r) {
                Qe(this.actors, (r, n)=>{
                    r.send(t1, e, n);
                }, r = r || function() {});
            }
            getActor() {
                return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove() {
                this.actors.forEach((t1)=>{
                    t1.remove();
                }), this.actors = [], this.workerPool.release(this.id);
            }
        }
        ov.Actor = av;
        var lv = {
            workerUrl: "",
            workerClass: null,
            workerParams: void 0
        };
        function uv() {
            return null != lv.workerClass ? new lv.workerClass : new self.Worker(lv.workerUrl, lv.workerParams);
        }
        const cv = "mapboxgl_preloaded_worker_pool";
        class hv {
            constructor(){
                this.active = {};
            }
            acquire(t1) {
                if (!this.workers) for(this.workers = []; this.workers.length < hv.workerCount;)this.workers.push(new uv);
                return this.active[t1] = !0, this.workers.slice();
            }
            release(t1) {
                delete this.active[t1], this.workers && 0 === this.numActive() && (this.workers.forEach((t1)=>{
                    t1.terminate();
                }), this.workers = null);
            }
            isPreloaded() {
                return !!this.active[cv];
            }
            numActive() {
                return Object.keys(this.active).length;
            }
        }
        let pv;
        function fv() {
            return pv || (pv = new hv), pv;
        }
        hv.workerCount = 2;
        let dv, mv, yv, gv, xv, bv = null;
        function vv() {
            return gr() && self.worker && self.worker.dracoUrl ? self.worker.dracoUrl : mv || n.DRACO_URL;
        }
        function _v() {
            if (gr() && self.worker && self.worker.meshoptUrl) return self.worker.meshoptUrl;
            if (gv) return gv;
            const t1 = new Uint8Array([
                0,
                97,
                115,
                109,
                1,
                0,
                0,
                0,
                1,
                4,
                1,
                96,
                0,
                0,
                3,
                3,
                2,
                0,
                0,
                5,
                3,
                1,
                0,
                1,
                12,
                1,
                0,
                10,
                22,
                2,
                12,
                0,
                65,
                0,
                65,
                0,
                65,
                0,
                252,
                10,
                0,
                0,
                11,
                7,
                0,
                65,
                0,
                253,
                15,
                26,
                11
            ]);
            if ("object" != typeof WebAssembly) throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
            return gv = WebAssembly.validate(t1) ? n.MESHOPT_SIMD_URL : n.MESHOPT_URL, gv;
        }
        const wv = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        }, Mv = {
            5120: "DT_INT8",
            5121: "DT_UINT8",
            5122: "DT_INT16",
            5123: "DT_UINT16",
            5125: "DT_UINT32",
            5126: "DT_FLOAT32"
        }, Av = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        };
        function Sv(t1, e, r) {
            const n = r.json.bufferViews.length, i = r.buffers.length;
            e.bufferView = n, r.json.bufferViews[n] = {
                buffer: i,
                byteLength: t1.byteLength
            }, r.buffers[i] = t1;
        }
        const Iv = "KHR_draco_mesh_compression";
        function Tv(t1, e) {
            const r = t1.extensions && t1.extensions[Iv];
            if (!r) return;
            const n = new yv.Decoder, i = Cv(e, r.bufferView), s = new yv.Mesh;
            if (!n.DecodeArrayToMesh(i, i.byteLength, s)) throw new Error("Failed to decode Draco mesh");
            const a = e.json.accessors[t1.indices], o = wv[a.componentType], l = a.count * o.BYTES_PER_ELEMENT, u = yv._malloc(l);
            o === Uint16Array ? n.GetTrianglesUInt16Array(s, l, u) : n.GetTrianglesUInt32Array(s, l, u), Sv(yv.memory.buffer.slice(u, u + l), a, e), yv._free(u);
            for (const i of Object.keys(r.attributes)){
                const a = n.GetAttributeByUniqueId(s, r.attributes[i]), o = e.json.accessors[t1.attributes[i]], l = Mv[o.componentType], u = o.count * Av[o.type] * wv[o.componentType].BYTES_PER_ELEMENT, c = yv._malloc(u);
                n.GetAttributeDataArrayForAllPoints(s, a, yv[l], u, c), Sv(yv.memory.buffer.slice(c, c + u), o, e), yv._free(c);
            }
            n.destroy(), s.destroy(), delete t1.extensions[Iv];
        }
        const kv = "EXT_meshopt_compression";
        function Pv(t1, e) {
            if (!t1.extensions || !t1.extensions[kv]) return;
            const r = t1.extensions[kv], n = new Uint8Array(e.buffers[r.buffer], r.byteOffset || 0, r.byteLength || 0), i = new Uint8Array(r.count * r.byteStride);
            xv.decodeGltfBuffer(i, r.count, r.byteStride, n, r.mode, r.filter), t1.buffer = e.buffers.length, t1.byteOffset = 0, e.buffers[t1.buffer] = i.buffer, delete t1.extensions[kv];
        }
        const zv = 1179937895, Ev = new TextDecoder("utf8");
        function Bv(t1, e) {
            return new URL(t1, e).href;
        }
        function Dv(t1, e, r, n) {
            return fetch(Bv(t1.uri, n)).then((t1)=>t1.arrayBuffer()).then((t1)=>{
                e.buffers[r] = t1;
            });
        }
        function Cv(t1, e) {
            const r = t1.json.bufferViews[e];
            return new Uint8Array(t1.buffers[r.buffer], r.byteOffset || 0, r.byteLength);
        }
        function Rv(t1, e, r, n) {
            if (t1.uri) {
                const i = Bv(t1.uri, n);
                return fetch(i).then((t1)=>t1.blob()).then((t1)=>createImageBitmap(t1)).then((t1)=>{
                    e.images[r] = t1;
                });
            }
            if (void 0 !== t1.bufferView) {
                const n = Cv(e, t1.bufferView), i = new Blob([
                    n
                ], {
                    type: t1.mimeType
                });
                return createImageBitmap(i).then((t1)=>{
                    e.images[r] = t1;
                });
            }
        }
        function Vv(t1, e = 0, r) {
            const n = {
                json: null,
                images: [],
                buffers: []
            };
            if (new Uint32Array(t1, e, 1)[0] === zv) {
                const r = new Uint32Array(t1, e);
                let i = 2;
                const s = (r[i++] >> 2) - 3, a = r[i++] >> 2;
                if (i++, n.json = JSON.parse(Ev.decode(r.subarray(i, i + a))), i += a, i < s) {
                    const s = r[i++];
                    i++;
                    const a = e + (i << 2);
                    n.buffers[0] = t1.slice(a, a + s);
                }
            } else n.json = JSON.parse(Ev.decode(new Uint8Array(t1, e)));
            const { buffers: i, images: s, meshes: a, extensionsUsed: o, bufferViews: l } = n.json;
            let u = Promise.resolve();
            if (i) {
                const t1 = [];
                for(let e = 0; e < i.length; e++){
                    const s = i[e];
                    s.uri ? t1.push(Dv(s, n, e, r)) : n.buffers[e] || (n.buffers[e] = null);
                }
                u = Promise.all(t1);
            }
            return u.then(()=>{
                const t1 = [], e = o && o.includes(Iv), i = o && o.includes(kv);
                if (e && t1.push(function() {
                    if (!yv) return dv || (dv = function(t1) {
                        let e, r = null;
                        function n() {
                            e = new Uint8Array(r.buffer);
                        }
                        function i() {
                            throw new Error("Unexpected Draco error.");
                        }
                        const s = {
                            a: {
                                a: i,
                                d: function(t1, r, n) {
                                    return e.copyWithin(t1, r, r + n);
                                },
                                c: function(t1) {
                                    const i = e.length, s = Math.max(t1 >>> 0, Math.ceil(1.2 * i)), a = Math.ceil((s - i) / 65536);
                                    try {
                                        return r.grow(a), n(), !0;
                                    } catch (t1) {
                                        return !1;
                                    }
                                },
                                b: i
                            }
                        };
                        return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t1, s) : t1.then((t1)=>t1.arrayBuffer()).then((t1)=>WebAssembly.instantiate(t1, s))).then((t1)=>{
                            const { Rb: i, Qb: s, P: a, T: o, X: l, Ja: u, La: c, Qa: h, Va: p, Wa: f, eb: d, jb: m, f: y, e: g, yb: x, zb: b, Ab: v, Bb: _, Db: w, Gb: M } = t1.instance.exports;
                            r = g;
                            const A = (()=>{
                                let t1 = 0, r = 0, n = 0, a = 0;
                                return (o)=>{
                                    n && (i(a), i(t1), r += n, n = t1 = 0), t1 || (r += 128, t1 = s(r));
                                    const l = o.length + 7 & -8;
                                    let u = t1;
                                    l >= r && (n = l, u = a = s(l));
                                    for(let t1 = 0; t1 < o.length; t1++)e[u + t1] = o[t1];
                                    return u;
                                };
                            })();
                            return n(), y(), {
                                memory: g,
                                _free: i,
                                _malloc: s,
                                Mesh: class {
                                    constructor(){
                                        this.ptr = a();
                                    }
                                    destroy() {
                                        o(this.ptr);
                                    }
                                },
                                Decoder: class {
                                    constructor(){
                                        this.ptr = u();
                                    }
                                    destroy() {
                                        m(this.ptr);
                                    }
                                    DecodeArrayToMesh(t1, e, r) {
                                        const n = A(t1), i = c(this.ptr, n, e, r.ptr);
                                        return !!l(i);
                                    }
                                    GetAttributeByUniqueId(t1, e) {
                                        return {
                                            ptr: h(this.ptr, t1.ptr, e)
                                        };
                                    }
                                    GetTrianglesUInt16Array(t1, e, r) {
                                        p(this.ptr, t1.ptr, e, r);
                                    }
                                    GetTrianglesUInt32Array(t1, e, r) {
                                        f(this.ptr, t1.ptr, e, r);
                                    }
                                    GetAttributeDataArrayForAllPoints(t1, e, r, n, i) {
                                        d(this.ptr, t1.ptr, e.ptr, r, n, i);
                                    }
                                },
                                DT_INT8: x(),
                                DT_UINT8: b(),
                                DT_INT16: v(),
                                DT_UINT16: _(),
                                DT_UINT32: w(),
                                DT_FLOAT32: M()
                            };
                        });
                    }(fetch(vv())), dv.then((t1)=>{
                        yv = t1, dv = void 0;
                    }));
                }()), i && t1.push(function() {
                    if (xv) return;
                    const t1 = function(t1) {
                        let e;
                        const r = WebAssembly.instantiateStreaming(t1, {}).then((t1)=>{
                            e = t1.instance, e.exports.__wasm_call_ctors();
                        }), n = {
                            NONE: "",
                            OCTAHEDRAL: "meshopt_decodeFilterOct",
                            QUATERNION: "meshopt_decodeFilterQuat",
                            EXPONENTIAL: "meshopt_decodeFilterExp"
                        }, i = {
                            ATTRIBUTES: "meshopt_decodeVertexBuffer",
                            TRIANGLES: "meshopt_decodeIndexBuffer",
                            INDICES: "meshopt_decodeIndexSequence"
                        };
                        return {
                            ready: r,
                            supported: !0,
                            decodeGltfBuffer (t1, r, s, a, o, l) {
                                !function(t1, e, r, n, i, s, a) {
                                    const o = t1.exports.sbrk, l = n + 3 & -4, u = o(l * i), c = o(s.length), h = new Uint8Array(t1.exports.memory.buffer);
                                    h.set(s, c);
                                    const p = e(u, n, i, c, s.length);
                                    if (0 === p && a && a(u, l, i), r.set(h.subarray(u, u + n * i)), o(u - o(0)), 0 !== p) throw new Error(`Malformed buffer data: ${p}`);
                                }(e, e.exports[i[o]], t1, r, s, a, e.exports[n[l]]);
                            }
                        };
                    }(fetch(_v()));
                    return t1.ready.then(()=>{
                        xv = t1;
                    });
                }()), s) for(let e = 0; e < s.length; e++)t1.push(Rv(s[e], n, e, r));
                return (t1.length ? Promise.all(t1) : Promise.resolve()).then(()=>{
                    if (e && a) for (const { primitives: t1 } of a)for (const e of t1)Tv(e, n);
                    if (i && a && l) for (const t1 of l)Pv(t1, n);
                    return n;
                });
            });
        }
        function Lv(t1, e) {
            const r = t1.json.bufferViews[e.bufferView], n = wv[e.componentType];
            return new n(t1.buffers[r.buffer], (e.byteOffset || 0) + (r.byteOffset || 0), e.count * (r.byteStride && r.byteStride !== Av[e.type] * n.BYTES_PER_ELEMENT ? r.byteStride / n.BYTES_PER_ELEMENT : Av[e.type]));
        }
        function Ov(t1, e, r, n) {
            const i = wv[e.componentType], s = function(t1) {
                switch(t1){
                    case Int8Array:
                        return 1 / 127;
                    case Uint8Array:
                        return 1 / 255;
                    case Int16Array:
                        return 1 / 32767;
                    case Uint16Array:
                        return 1 / 65535;
                    default:
                        return 1;
                }
            }(i), a = t1.json.bufferViews[e.bufferView], o = a.byteStride ? a.byteStride / i.BYTES_PER_ELEMENT : Av[e.type], l = r.float32, u = l.length / r.capacity;
            for(let t1 = 0, r = 0; t1 < e.count * o; t1 += o, r += u)for(let e = 0; e < u; e++)l[r + e] = n[t1 + e] * s;
            r._trim();
        }
        function Fv(t1, e, r) {
            const n = t1.indices, i = t1.attributes, s = {};
            s.indexArray = new Ql;
            const a = e.json.accessors[n], o = a.count / 3;
            s.indexArray.reserve(o);
            const l = Lv(e, a);
            for(let t1 = 0; t1 < o; t1++)s.indexArray.emplaceBack(l[3 * t1], l[3 * t1 + 1], l[3 * t1 + 2]);
            s.indexArray._trim(), s.vertexArray = new Ul;
            const u = e.json.accessors[i.POSITION];
            s.vertexArray.reserve(u.count);
            const c = Lv(e, u);
            for(let t1 = 0; t1 < u.count; t1++)s.vertexArray.emplaceBack(c[3 * t1], c[3 * t1 + 1], c[3 * t1 + 2]);
            if (s.vertexArray._trim(), s.aabb = new Ah(u.min, u.max), s.centroid = function(t1, e) {
                const r = [
                    0,
                    0,
                    0
                ], n = t1.length;
                if (n > 0) {
                    for(let i = 0; i < n; i++){
                        const n = 3 * t1[i];
                        r[0] += e[n], r[1] += e[n + 1], r[2] += e[n + 2];
                    }
                    r[0] /= n, r[1] /= n, r[2] /= n;
                }
                return r;
            }(l, c), void 0 !== i.COLOR_0) {
                const t1 = e.json.accessors[i.COLOR_0], r = Av[t1.type], n = Lv(e, t1);
                s.colorArray = 3 === r ? new Ul : new Fl, s.colorArray.resize(t1.count), Ov(e, t1, s.colorArray, n);
            }
            if (void 0 !== i.NORMAL) {
                s.normalArray = new Ul;
                const t1 = e.json.accessors[i.NORMAL];
                s.normalArray.resize(t1.count);
                const r = Lv(e, t1);
                Ov(e, t1, s.normalArray, r);
            }
            if (void 0 !== i.TEXCOORD_0 && r.length > 0) {
                s.texcoordArray = new iu;
                const t1 = e.json.accessors[i.TEXCOORD_0];
                s.texcoordArray.resize(t1.count);
                const r = Lv(e, t1);
                Ov(e, t1, s.texcoordArray, r);
            }
            if (void 0 !== i._FEATURE_ID_RGBA4444) {
                const t1 = e.json.accessors[i._FEATURE_ID_RGBA4444];
                e.json.extensionsUsed && e.json.extensionsUsed.includes("EXT_meshopt_compression") && (s.featureData = Lv(e, t1));
            }
            void 0 !== i._FEATURE_RGBA4444 && (s.featureData = new Uint32Array(Lv(e, e.json.accessors[i._FEATURE_RGBA4444]).buffer));
            const h = t1.material;
            return s.material = function(t1, e) {
                const { emissiveFactor: r = [
                    0,
                    0,
                    0
                ], alphaMode: n = "OPAQUE", alphaCutoff: i = .5, normalTexture: s, occlusionTexture: a, emissiveTexture: o, doubleSided: l } = t1, { baseColorFactor: u = [
                    1,
                    1,
                    1,
                    1
                ], metallicFactor: c = 1, roughnessFactor: h = 1, baseColorTexture: p, metallicRoughnessTexture: f } = t1.pbrMetallicRoughness || {}, d = a ? e[a.index] : void 0;
                if (a && a.extensions && a.extensions.KHR_texture_transform && d) {
                    const t1 = a.extensions.KHR_texture_transform;
                    d.offsetScale = [
                        t1.offset[0],
                        t1.offset[1],
                        t1.scale[0],
                        t1.scale[1]
                    ];
                }
                return {
                    pbrMetallicRoughness: {
                        baseColorFactor: new qn(...u),
                        metallicFactor: c,
                        roughnessFactor: h,
                        baseColorTexture: p ? e[p.index] : void 0,
                        metallicRoughnessTexture: f ? e[f.index] : void 0
                    },
                    doubleSided: l,
                    emissiveFactor: r,
                    alphaMode: n,
                    alphaCutoff: i,
                    normalTexture: s ? e[s.index] : void 0,
                    occlusionTexture: d,
                    emissionTexture: o ? e[o.index] : void 0,
                    defined: void 0 === t1.defined
                };
            }(void 0 !== h ? e.json.materials[h] : {
                defined: !1
            }, r), s;
        }
        function Uv(e, r, n) {
            const { matrix: i, rotation: s, translation: a, scale: o, mesh: l, extras: u, children: c } = e, h = {};
            if (h.matrix = i || t1.ad.fromRotationTranslationScale([], s || [
                0,
                0,
                0,
                1
            ], a || [
                0,
                0,
                0
            ], o || [
                1,
                1,
                1
            ]), void 0 !== l) {
                h.meshes = n[l];
                const t1 = h.anchor = [
                    0,
                    0
                ];
                for (const e of h.meshes){
                    const { min: r, max: n } = e.aabb;
                    t1[0] += r[0] + n[0], t1[1] += r[1] + n[1];
                }
                t1[0] = Math.floor(t1[0] / h.meshes.length / 2), t1[1] = Math.floor(t1[1] / h.meshes.length / 2);
            }
            if (u && (u.id && (h.id = u.id), u.lights && (h.lights = function(t1) {
                if (!t1.length) return [];
                const e = function(t1) {
                    const e = atob(t1), r = new Uint8Array(e.length);
                    for(let t1 = 0; t1 < e.length; t1++)r[t1] = e.codePointAt(t1);
                    return r;
                }(t1), r = [], n = e.length / 24, i = new Uint16Array(e.buffer), s = new Float32Array(e.buffer);
                for(let t1 = 0; t1 < n; t1++){
                    const e = i[2 * t1 * 6] / 30, n = i[2 * t1 * 6 + 1] / 30, a = i[2 * t1 * 6 + 10] / 100, o = s[6 * t1 + 1], l = s[6 * t1 + 2], u = s[6 * t1 + 3], c = s[6 * t1 + 4], h = u - o, p = c - l, f = Math.hypot(h, p);
                    r.push({
                        pos: [
                            o + .5 * h,
                            l + .5 * p,
                            n
                        ],
                        normal: [
                            p / f,
                            -h / f,
                            0
                        ],
                        width: f,
                        height: e,
                        depth: a,
                        points: [
                            o,
                            l,
                            u,
                            c
                        ]
                    });
                }
                return r;
            }(u.lights))), c) {
                const t1 = [];
                for (const e of c)t1.push(Uv(r.json.nodes[e], r, n));
                h.children = t1;
            }
            return h;
        }
        function Nv(t1) {
            if (0 === t1.vertices.length || 0 === t1.indices.length) return null;
            const e = new tf(t1.vertices, t1.indices, 8, 256), [r, n] = [
                e.min.clone(),
                e.max.clone()
            ];
            return {
                vertices: t1.vertices,
                indices: t1.indices,
                grid: e,
                min: r,
                max: n
            };
        }
        function jv(t1) {
            if (!t1.extras || !t1.extras.ground) return null;
            const e = t1.extras.ground;
            if (!e || !Array.isArray(e) || 0 === e.length) return null;
            const r = e[0];
            if (!r || !Array.isArray(r) || 0 === r.length) return null;
            const n = [];
            for (const t1 of r){
                if (!Array.isArray(t1) || 2 !== t1.length) continue;
                const e = t1[0], r = t1[1];
                "number" == typeof e && "number" == typeof r && n.push(new Ne(e, r));
            }
            if (n.length < 3) return null;
            n.length > 1 && n[n.length - 1].equals(n[0]) && n.pop();
            let i = 0;
            for(let t1 = 0; t1 < n.length; t1++){
                const e = n[t1], r = n[(t1 + 1) % n.length], s = n[(t1 + 2) % n.length];
                i += (e.x - r.x) * (s.y - r.y) - (s.x - r.x) * (e.y - r.y);
            }
            i > 0 && n.reverse();
            const s = wp(n.flatMap((t1)=>[
                    t1.x,
                    t1.y
                ]), []);
            return 0 === s.length ? null : {
                vertices: n,
                indices: s
            };
        }
        function qv(e, r) {
            const n = [], i = [];
            let s = 0;
            const a = [];
            for (const o of e){
                s = n.length;
                const e = o.vertexArray.float32, l = o.indexArray.uint16;
                for(let i = 0; i < o.vertexArray.length; i++)a[0] = e[3 * i + 0], a[1] = e[3 * i + 1], a[2] = e[3 * i + 2], t1._.transformMat4(a, a, r), n.push(new Ne(a[0], a[1]));
                for(let t1 = 0; t1 < 3 * o.indexArray.length; t1++)i.push(l[t1] + s);
            }
            if (i.length % 3 != 0) return null;
            for(let t1 = 0; t1 < i.length; t1 += 3){
                const e = n[i[t1 + 0]], r = n[i[t1 + 1]], s = n[i[t1 + 2]];
                (e.x - r.x) * (s.y - r.y) - (s.x - r.x) * (e.y - r.y) > 0 && ([i[t1 + 1], i[t1 + 2]] = [
                    i[t1 + 2],
                    i[t1 + 1]
                ]);
            }
            return {
                vertices: n,
                indices: i
            };
        }
        function $v(t1) {
            const e = function(t1, e) {
                const r = [], n = WebGL2RenderingContext;
                if (t1.json.textures) for (const i of t1.json.textures){
                    const s = {
                        magFilter: n.LINEAR,
                        minFilter: n.NEAREST,
                        wrapS: n.REPEAT,
                        wrapT: n.REPEAT
                    };
                    void 0 !== i.sampler && Object.assign(s, t1.json.samplers[i.sampler]), r.push({
                        image: e[i.source],
                        sampler: s,
                        uploaded: !1
                    });
                }
                return r;
            }(t1, t1.images), r = function(t1, e) {
                const r = [];
                for (const n of t1.json.meshes){
                    const i = [];
                    for (const r of n.primitives)i.push(Fv(r, t1, e));
                    r.push(i);
                }
                return r;
            }(t1, e), { scenes: n, scene: i, nodes: s } = t1.json, a = n ? n[i || 0].nodes : s, o = [];
            for (const e of a)o.push(Uv(s[e], t1, r));
            return function(t1, e, r) {
                const n = {}, i = new Set;
                for(let s = 0; s < t1.length; s++){
                    const t1 = r[e[s]];
                    if (!t1.extras) continue;
                    const a = t1.extras["mapbox:footprint:version"], o = t1.extras["mapbox:footprint:id"];
                    (a || o) && i.add(s), "1.0.0" === a && o && (n[o] = s);
                }
                for(let s = 0; s < t1.length; s++){
                    if (i.has(s)) continue;
                    const a = t1[s], o = r[e[s]];
                    if (!o.extras) continue;
                    let l = null;
                    a.id in n && (l = qv(t1[n[a.id]].meshes, a.matrix)), l || (l = jv(o)), l && (a.footprint = Nv(l));
                }
                if (i.size > 0) {
                    const e = Array.from(i.values()).sort((t1, e)=>t1 - e);
                    for(let r = e.length - 1; r >= 0; r--)t1.splice(e[r], 1);
                }
            }(o, a, t1.json.nodes), o;
        }
        function Gv(t1) {
            t1.heightmap = new Float32Array(4096), t1.heightmap.fill(-1);
            const e = t1.vertexArray.float32, r = t1.aabb.min[0] - 1, n = t1.aabb.min[1] - 1, i = Kb / (t1.aabb.max[0] - r + 2), s = Kb / (t1.aabb.max[1] - n + 2);
            for(let a = 0; a < e.length; a += 3){
                const o = e[a + 2], l = (e[a + 0] - r) * i | 0, u = (e[a + 1] - n) * s | 0;
                o > t1.heightmap[u * Kb + l] && (t1.heightmap[u * Kb + l] = o);
            }
        }
        function Yv(e, r) {
            const n = {};
            n.indexArray = new Ql, n.indexArray.reserve(4 * e.length), n.vertexArray = new Ul, n.vertexArray.reserve(10 * e.length), n.colorArray = new Fl, n.vertexArray.reserve(10 * e.length);
            let i = 0;
            for (const s of e){
                const e = Math.min(10, Math.max(4, 1.3 * s.height)) * r, a = [
                    -s.normal[1],
                    s.normal[0],
                    0
                ], o = Math.min(.29, .1 * s.width / s.depth), l = s.width - 2 * s.depth * r * (o + .01), u = t1._.scaleAndAdd([], s.pos, a, l / 2), c = t1._.scaleAndAdd([], s.pos, a, -l / 2), h = [
                    u[0],
                    u[1],
                    u[2] + s.height
                ], p = [
                    c[0],
                    c[1],
                    c[2] + s.height
                ], f = t1._.scaleAndAdd([], s.normal, a, o);
                t1._.scale(f, f, e);
                const d = t1._.scaleAndAdd([], s.normal, a, -o);
                t1._.scale(d, d, e), t1._.add(f, u, f), t1._.add(d, c, d), u[2] += .1, c[2] += .1, n.vertexArray.emplaceBack(f[0], f[1], f[2]), n.vertexArray.emplaceBack(d[0], d[1], d[2]), n.vertexArray.emplaceBack(u[0], u[1], u[2]), n.vertexArray.emplaceBack(c[0], c[1], c[2]), n.vertexArray.emplaceBack(h[0], h[1], h[2]), n.vertexArray.emplaceBack(p[0], p[1], p[2]), n.vertexArray.emplaceBack(u[0], u[1], u[2]), n.vertexArray.emplaceBack(c[0], c[1], c[2]), n.vertexArray.emplaceBack(f[0], f[1], f[2]), n.vertexArray.emplaceBack(d[0], d[1], d[2]);
                const m = l / e / 2;
                n.colorArray.emplaceBack(-m - o, -1, m, .8), n.colorArray.emplaceBack(m + o, -1, m, .8), n.colorArray.emplaceBack(-m, 0, m, 1.3), n.colorArray.emplaceBack(m, 0, m, 1.3), n.colorArray.emplaceBack(m + o, -0.8, m, .7), n.colorArray.emplaceBack(m + o, -0.8, m, .7), n.colorArray.emplaceBack(0, 0, m, 1.3), n.colorArray.emplaceBack(0, 0, m, 1.3), n.colorArray.emplaceBack(m + o, -1.2, m, .8), n.colorArray.emplaceBack(m + o, -1.2, m, .8), n.indexArray.emplaceBack(6 + i, 4 + i, 8 + i), n.indexArray.emplaceBack(7 + i, 9 + i, 5 + i), n.indexArray.emplaceBack(0 + i, 1 + i, 2 + i), n.indexArray.emplaceBack(1 + i, 3 + i, 2 + i), i += 10;
            }
            const s = {
                defined: !0,
                emissiveFactor: [
                    0,
                    0,
                    0
                ]
            }, a = {};
            return a.baseColorFactor = qn.white, s.pbrMetallicRoughness = a, n.material = s, n.aabb = new Ah([
                1 / 0,
                1 / 0,
                1 / 0
            ], [
                -1 / 0,
                -1 / 0,
                -1 / 0
            ]), n;
        }
        const Xv = new Float32Array(262144), Zv = new Uint8Array(262144);
        function Hv(t1) {
            let e = 0;
            if (t1.meshes) for (const r of t1.meshes)e = Math.max(e, r.aabb.max[2]);
            if (t1.children) for (const r of t1.children)e = Math.max(e, Hv(r));
            return e;
        }
        function Kv(t1, e, r) {
            if (t1.meshes) for (const n of t1.meshes)n.aabb.min[0] !== 1 / 0 && r.insert(e, n.aabb.min[0], n.aabb.min[1], n.aabb.max[0], n.aabb.max[1]);
            if (t1.children) for (const n of t1.children)Kv(n, e, r);
        }
        const Wv = [
            "",
            "wall",
            "door",
            "roof",
            "window",
            "lamp",
            "logo"
        ];
        class Jv {
            constructor(t1){
                this.node = t1, this.evaluatedRMEA = [
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        .4,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ]
                ], this.hiddenByReplacement = !1, this.evaluatedScale = [
                    1,
                    1,
                    1
                ], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.feature = {
                    type: "Point",
                    id: t1.id,
                    geometry: [],
                    properties: {
                        height: Hv(t1)
                    }
                }, this.aabb = this._getLocalBounds();
            }
            _getLocalBounds() {
                if (!this.node.meshes) return new Ah([
                    1 / 0,
                    1 / 0,
                    1 / 0
                ], [
                    -1 / 0,
                    -1 / 0,
                    -1 / 0
                ]);
                if (!this.aabb) {
                    let t1 = 0;
                    const e = new Ah([
                        1 / 0,
                        1 / 0,
                        1 / 0
                    ], [
                        -1 / 0,
                        -1 / 0,
                        -1 / 0
                    ]);
                    for (const r of this.node.meshes)this.node.lightMeshIndex !== t1 && (r.transformedAabb = Ah.applyTransformFast(r.aabb, this.node.matrix), e.encapsulate(r.transformedAabb)), t1++;
                    this.aabb = e;
                }
                return this.aabb;
            }
        }
        class Qv {
            constructor(t1, e, r, n, i, s){
                this.id = e, this.modelTraits |= Wb.CoordinateSpaceTile, this.uploaded = !1, this.hasPattern = !1, r && (this.modelTraits |= Wb.HasMapboxMeshFeatures), n && (this.modelTraits |= Wb.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = {
                    name: "mercator"
                }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = i, this.dirty = !0, this.needsUpload = !1, this.nodesInfo = [];
                for (const e of t1)this.nodesInfo.push(new Jv(e)), Kv(e, s.featureIndexArray.length, s.grid), s.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, s.bucketLayerIDs.length - 1, 0);
            }
            updateFootprints(t1, e) {
                for (const r of this.getNodesInfo()){
                    const n = r.node;
                    n.footprint && e.push({
                        footprint: n.footprint,
                        id: t1
                    });
                }
            }
            update() {
                console.log("Update 3D model bucket");
            }
            populate() {
                console.log("populate 3D model bucket");
            }
            uploadPending() {
                return !this.uploaded || this.needsUpload;
            }
            upload(t1) {
                if (!this.needsUpload) return;
                const e = this.getNodesInfo();
                for (const r of e){
                    const e = r.node;
                    this.uploaded ? this.updatePbrBuffer(e) : ev(e, t1, !0);
                }
                for (const t1 of e)rv(t1.node);
                this.uploaded = !0, this.needsUpload = !1;
            }
            updatePbrBuffer(t1) {
                let e = !1;
                if (!t1.meshes) return e;
                for (const r of t1.meshes)r.pbrBuffer && (r.pbrBuffer.updateData(r.featureArray), e = !0);
                return e;
            }
            needsReEvaluation(t1, e, r) {
                const n = t1.transform.projectionOptions, i = t1.style.getBrightness(), s = this.brightness !== i;
                return !!(!this.uploaded || this.dirty || n.name !== this.projection.name || t_(r.paint.get("model-color").value, s) || t_(r.paint.get("model-color-mix-intensity").value, s) || t_(r.paint.get("model-roughness").value, s) || t_(r.paint.get("model-emissive-strength").value, s) || t_(r.paint.get("model-height-based-emissive-strength-multiplier").value, s)) && (this.projection = n, this.brightness = i, !0);
            }
            evaluateScale(t1, e) {
                if (t1.transform.zoom === this.zoom) return;
                this.zoom = t1.transform.zoom;
                const r = this.getNodesInfo(), n = this.id.canonical;
                for (const t1 of r){
                    const r = t1.feature;
                    t1.evaluatedScale = e.paint.get("model-scale").evaluate(r, {}, n);
                }
            }
            evaluate(t1) {
                const e = this.getNodesInfo();
                for (const r of e){
                    if (!r.node.meshes) continue;
                    const e = r.feature, n = r.node.meshes && r.node.meshes[0].featureData, i = r.evaluatedColor[2], s = r.evaluatedRMEA[2], a = this.id.canonical;
                    if (r.hasTranslucentParts = !1, n) {
                        for(let n = 0; n < Wv.length; n++){
                            const i = Wv[n];
                            i.length && (e.properties.part = i);
                            const s = t1.paint.get("model-color").evaluate(e, {}, a).toRenderColor(null), o = t1.paint.get("model-color-mix-intensity").evaluate(e, {}, a);
                            r.evaluatedColor[n] = [
                                s.r,
                                s.g,
                                s.b,
                                o
                            ], r.evaluatedRMEA[n][0] = t1.paint.get("model-roughness").evaluate(e, {}, a), r.evaluatedRMEA[n][2] = t1.paint.get("model-emissive-strength").evaluate(e, {}, a), r.evaluatedRMEA[n][3] = s.a, r.emissionHeightBasedParams[n] = t1.paint.get("model-height-based-emissive-strength-multiplier").evaluate(e, {}, a), !r.hasTranslucentParts && s.a < 1 && (r.hasTranslucentParts = !0);
                        }
                        delete e.properties.part, r_(r, i !== r.evaluatedColor[2] || s !== r.evaluatedRMEA[2], this.modelTraits);
                    } else r.evaluatedRMEA[0][2] = t1.paint.get("model-emissive-strength").evaluate(e, {}, a);
                    r.evaluatedScale = t1.paint.get("model-scale").evaluate(e, {}, a), this.updatePbrBuffer(r.node) || (this.needsUpload = !0);
                }
                this.dirty = !1;
            }
            elevationUpdate(t1, e, r, n) {
                const i = t1.findDEMTileFor(r);
                if (i && (i.tileID.canonical !== this.terrainTile || e !== this.terrainExaggeration)) {
                    if (i.dem && i.tileID.overscaledZ !== this.elevationReadFromZ) {
                        this.elevationReadFromZ = i.tileID.overscaledZ;
                        const e = Qf.create(t1, r, i);
                        if (!e) return;
                        this.modelTraits & Wb.HasMapboxMeshFeatures && this.updateDEM(t1, e, r, n);
                        for (const t1 of this.getNodesInfo()){
                            const r = t1.node;
                            if (!r.footprint || !r.footprint.vertices || !r.footprint.vertices.length) continue;
                            const n = r.footprint.vertices;
                            let i = e.getElevationAt(n[0].x, n[0].y, !0, !0);
                            for(let t1 = 1; t1 < n.length; t1++)i = Math.min(i, e.getElevationAt(n[t1].x, n[t1].y, !0, !0));
                            r.elevation = i;
                        }
                    }
                    this.terrainTile = i.tileID.canonical, this.terrainExaggeration = e;
                }
            }
            updateDEM(t1, e, r, n) {
                let i = e._dem._modifiedForSources[n];
                if (void 0 === i && (e._dem._modifiedForSources[n] = [], i = e._dem._modifiedForSources[n]), i.includes(r.canonical)) return;
                const s = e._dem.dim;
                i.push(r.canonical);
                let a = !1;
                for (const t1 of this.getNodesInfo()){
                    const r = t1.node;
                    if (!r.footprint || !r.footprint.grid) continue;
                    const n = r.footprint.grid, i = e.tileCoordToPixel(n.min.x, n.min.y), o = e.tileCoordToPixel(n.max.x, n.max.y), l = Math.min(Math.min(s - o.y, i.x), Math.min(i.y, s - o.x));
                    if (l < 0) continue;
                    const u = Ke(l, 2, 5);
                    let c = Math.max(0, i.x - u), h = Math.max(0, i.y - u), p = Math.min(o.x + u, s - 1), f = Math.min(o.y + u, s - 1);
                    for(let t1 = h; t1 <= f; ++t1)for(let e = c; e <= p; ++e)Zv[t1 * s + e] = 255;
                    let d = 0, m = 0;
                    for(let t1 = 0; t1 < n.cellsY; ++t1)for(let r = 0; r < n.cellsX; ++r){
                        if (!n.cells[t1 * n.cellsX + r]) continue;
                        const i = e.tileCoordToPixel(n.min.x + r / n.xScale, n.min.y + t1 / n.yScale), a = e.tileCoordToPixel(n.min.x + (r + 1) / n.xScale, n.min.y + (t1 + 1) / n.yScale);
                        for(let t1 = i.y; t1 <= Math.min(a.y + 1, s - 1); ++t1)for(let r = i.x; r <= Math.min(a.x + 1, s - 1); ++r)255 === Zv[t1 * s + r] && (Zv[t1 * s + r] = 0, d += e.getElevationAtPixel(r, t1), m++);
                    }
                    const y = d / m;
                    c = Math.max(1, i.x - u), h = Math.max(1, i.y - u), p = Math.min(o.x + u, s - 2), f = Math.min(o.y + u, s - 2), a = !0;
                    for(let t1 = h; t1 <= f; ++t1)for(let r = c; r <= p; ++r)0 === Zv[t1 * s + r] && (Xv[t1 * s + r] = e._dem.set(r, t1, y));
                    for(let t1 = 1; t1 < u; ++t1){
                        c = Math.max(1, i.x - t1), h = Math.max(1, i.y - t1), p = Math.min(o.x + t1, s - 2), f = Math.min(o.y + t1, s - 2);
                        for(let r = h; r <= f; ++r)for(let n = c; n <= p; ++n){
                            const i = r * s + n;
                            if (255 === Zv[i]) {
                                let a = 0, o = 0, l = -1, c = -1;
                                for(let e = -1; e <= 1; ++e)for(let i = -1; i <= 1; ++i){
                                    const u = (r + e) * s + n + i;
                                    if (Zv[u] >= t1) continue;
                                    const h = Xv[u], p = Math.abs(h);
                                    p > o && (a = h, o = p, l = i, c = e);
                                }
                                if (o > .1) {
                                    const s = 1 - (t1 + .5 * Math.abs(l * c)) / u;
                                    let o = e._dem.get(n, r) + a * s;
                                    const h = e._dem.get(n + l, r + c), p = e._dem.get(n - l, r - c, !0);
                                    (o - h) * (o - p) > 0 && (o = (h + p) / 2), Xv[i] = e._dem.set(n, r, o), Zv[i] = t1;
                                }
                            }
                        }
                    }
                }
                a && (e._demTile.needsDEMTextureUpload = !0, e._dem._timestamp = Dr.now());
            }
            getNodesInfo() {
                return this.nodesInfo;
            }
            destroy() {
                const t1 = this.getNodesInfo();
                for (const e of t1)rv(e.node), nv(e.node);
            }
            isEmpty() {
                return !this.nodesInfo.length;
            }
            updateReplacement(t1, e) {
                if (e.updateTime === this.replacementUpdateTime) return;
                this.replacementUpdateTime = e.updateTime;
                const r = e.getReplacementRegionsForTile(t1.toUnwrapped()), n = this.getNodesInfo();
                for(let t1 = 0; t1 < this.nodesInfo.length; t1++){
                    const e = n[t1].node;
                    n[t1].hiddenByReplacement = !!e.footprint && !r.find((t1)=>t1.footprint === e.footprint);
                }
            }
            getHeightAtTileCoord(e, r) {
                const n = this.getNodesInfo(), i = [], s = [
                    0,
                    0,
                    0
                ], a = t1.ad.identity([]);
                for(let o = 0; o < this.nodesInfo.length; o++){
                    const l = n[o], u = l.node.meshes[0], c = u.transformedAabb;
                    if (e < c.min[0] || r < c.min[1] || e > c.max[0] || r > c.max[1]) continue;
                    if (!0 === l.node.hidden) return {
                        height: 0,
                        maxHeight: l.feature.properties.height,
                        hidden: !1,
                        verticalScale: l.evaluatedScale[2]
                    };
                    t1.ad.invert(a, l.node.matrix), s[0] = e, s[1] = r, t1._.transformMat4(s, s, a);
                    const h = (s[0] - u.aabb.min[0]) / (u.aabb.max[0] - u.aabb.min[0]) * Kb | 0, p = Math.min(63, (s[1] - u.aabb.min[1]) / (u.aabb.max[1] - u.aabb.min[1]) * Kb | 0) * Kb + Math.min(63, h), f = u.heightmap[p];
                    if (!(f < 0 && l.node.footprint)) {
                        if (l.hiddenByReplacement) return;
                        return {
                            height: f,
                            maxHeight: l.feature.properties.height,
                            hidden: !1,
                            verticalScale: l.evaluatedScale[2]
                        };
                    }
                    if (l.node.footprint.grid.query(new Ne(e, r), new Ne(e, r), i), i.length > 0) return {
                        height: void 0,
                        maxHeight: l.feature.properties.height,
                        hidden: l.hiddenByReplacement,
                        verticalScale: l.evaluatedScale[2]
                    };
                }
            }
        }
        function t_(t1, e) {
            return !t1.isLightConstant && e;
        }
        function e_(t1, e, r, n, i, s, a, o) {
            let l = (61440 & e | (61440 & e) >> 4) >> 8, u = (3840 & e | (3840 & e) >> 4) >> 4, c = 240 & e | (240 & e) >> 4;
            r[3] > 0 && (l = Gn(l, 255 * r[0], r[3]), u = Gn(u, 255 * r[1], r[3]), c = Gn(c, 255 * r[2], r[3]));
            const h = l << 8 | u, p = c << 8 | Math.floor(255 * n[3]), f = function(t1) {
                const e = Ke(t1, 0, 2);
                return Math.min(Math.round(.5 * e * 255), 255);
            }(n[2]) << 8 | 15 * n[0] << 4 | 15 * n[1], d = Ke(i[0], 0, 1), m = Ke(i[1], 0, 1), y = Ke(i[2], 0, 1), g = Ke(i[3], 0, 1);
            let x, b, v, _;
            if (d !== m && a !== s && m !== d) {
                const t1 = a - s;
                b = 1 / (t1 * (m - d)), v = -(s + t1 * d) / (t1 * (m - d));
                const e = Ke(i[4], -1, 1);
                _ = Math.pow(10, e), x = 255 * y << 8 | 255 * g;
            } else x = 65535, b = 0, v = 1, _ = 1;
            if (t1.emplaceBack(h, p, f, x, b, v, _), o) {
                const t1 = o.length;
                o.clear();
                for(let e = 0; e < t1; e++)o.emplaceBack(h, p, f, x, b, v, _);
            }
        }
        function r_(t1, e, r) {
            const n = t1.node;
            let i = 0;
            const s = r & Wb.HasMeshoptCompression;
            for (const r of n.meshes){
                if (n.lights && n.lightMeshIndex === i) continue;
                if (!r.featureData) continue;
                r.featureArray = new lu, r.featureArray.reserve(r.featureData.length);
                let a = e;
                for (const e of r.featureData){
                    const i = s ? 65535 & e : e >> 16 & 65535, o = s ? e >> 16 & 65535 : 65535 & e, l = (15 & o) < 8 ? 15 & o : 0, u = t1.evaluatedRMEA[l], c = t1.evaluatedColor[l], h = t1.emissionHeightBasedParams[l];
                    let p;
                    if (a && 2 === l && n.lights && (p = new lu, p.resize(10 * n.lights.length)), e_(r.featureArray, i, c, u, h, r.aabb.min[2], r.aabb.max[2], p), p && a) {
                        a = !1;
                        const t1 = n.meshes[n.lightMeshIndex];
                        t1.featureArray = p, t1.featureArray._trim();
                    }
                }
                r.featureArray._trim(), i++;
            }
        }
        function n_(t1, e, r, n) {
            const i = 1 << t1.z;
            e.lat = Ec((n / ps + t1.y) / i), e.lng = zc((r / ps + t1.x) / i);
        }
        Mo(Qv, "Tiled3dModelBucket", {
            omit: [
                "layers"
            ]
        }), Mo(Jv, "Tiled3dModelFeature");
        const i_ = {
            circle: class extends kl {
                constructor(t1, e, r, n){
                    super(t1, yh, e, r, n);
                }
                createBucket(t1) {
                    return new Kc(t1);
                }
                queryRadius(t1) {
                    const e = t1;
                    return hh("circle-radius", this, e) + hh("circle-stroke-width", this, e) + ph(this.paint.get("circle-translate"));
                }
                queryIntersectsFeature(t1, e, r, n, i, s, a, o) {
                    const l = dh(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), u = this.paint.get("circle-radius").evaluate(e, r) + this.paint.get("circle-stroke-width").evaluate(e, r);
                    return np(t1, n, s, a, o, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l, u);
                }
                getProgramIds() {
                    return [
                        "circle"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    const n = rp(this);
                    return {
                        config: new Ku(this, {
                            zoom: e,
                            lut: r
                        }),
                        defines: n,
                        overrideFog: !1
                    };
                }
            },
            heatmap: class extends kl {
                createBucket(t1) {
                    return new lp(t1);
                }
                constructor(t1, e, r, n){
                    super(t1, yp, e, r, n), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    "heatmap-color" === t1 && this._updateColorRamp();
                }
                _updateColorRamp() {
                    this.colorRamp = gp({
                        expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                        evaluationKey: "heatmapDensity",
                        image: this.colorRamp
                    }), this.colorRampTexture = null;
                }
                resize() {
                    this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
                }
                queryRadius(t1) {
                    return hh("heatmap-radius", this, t1);
                }
                queryIntersectsFeature(t1, e, r, n, i, s, a, o) {
                    const l = this.paint.get("heatmap-radius").evaluate(e, r);
                    return np(t1, n, s, a, o, !0, !0, new Ne(0, 0), l);
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
                }
                getProgramIds() {
                    return [
                        "heatmap",
                        "heatmapTexture"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    return "heatmap" === t1 ? {
                        config: new Ku(this, {
                            zoom: e,
                            lut: r
                        }),
                        overrideFog: !1
                    } : {};
                }
            },
            hillshade: class extends kl {
                constructor(t1, e, r, n){
                    super(t1, bp, e, r, n);
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
                }
                getProgramIds() {
                    return [
                        "hillshade",
                        "hillshadePrepare"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    return {
                        overrideFog: !1
                    };
                }
            },
            fill: class extends kl {
                constructor(t1, e, r, n){
                    super(t1, Qp, e, r, n);
                }
                getProgramIds() {
                    const t1 = this.paint.get("fill-pattern"), e = t1 && t1.constantOr(1), r = [
                        e ? "fillPattern" : "fill"
                    ];
                    return this.paint.get("fill-antialias") && r.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r;
                }
                getDefaultProgramParams(t1, e, r) {
                    return {
                        config: new Ku(this, {
                            zoom: e,
                            lut: r
                        }),
                        overrideFog: !1
                    };
                }
                recalculate(t1, e) {
                    super.recalculate(t1, e);
                    const r = this.paint._values["fill-outline-color"];
                    "constant" === r.value.kind && void 0 === r.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
                }
                createBucket(t1) {
                    return new Wp(t1);
                }
                queryRadius() {
                    return ph(this.paint.get("fill-translate"));
                }
                queryIntersectsFeature(t1, e, r, n, i, s) {
                    return !t1.queryGeometry.isAboveHorizon && Qc(fh(t1.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), n);
                }
                isTileClipped() {
                    return !0;
                }
            },
            "fill-extrusion": class extends kl {
                constructor(t1, e, r, n){
                    super(t1, zd, e, r, n), this._stats = {
                        numRenderedVerticesInShadowPass: 0,
                        numRenderedVerticesInTransparentPass: 0
                    };
                }
                createBucket(t1) {
                    return new xd(t1);
                }
                queryRadius() {
                    return ph(this.paint.get("fill-extrusion-translate"));
                }
                is3D() {
                    return !0;
                }
                hasShadowPass() {
                    return !0;
                }
                cutoffRange() {
                    return this.paint.get("fill-extrusion-cutoff-fade-range");
                }
                canCastShadows() {
                    return !0;
                }
                getProgramIds() {
                    return [
                        this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"
                    ];
                }
                queryIntersectsFeature(e, r, n, i, s, a, o, l, u) {
                    const c = dh(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a.angle, e.pixelToTileUnitsFactor), h = this.paint.get("fill-extrusion-height").evaluate(r, n), p = this.paint.get("fill-extrusion-base").evaluate(r, n), f = [
                        0,
                        0
                    ], d = l && a.elevation, m = a.elevation ? a.elevation.exaggeration() : 1, y = e.tile.getBucket(this);
                    if (d && y instanceof xd) {
                        const t1 = y.centroidVertexArray, e = u + 1;
                        e < t1.length && (f[0] = t1.geta_centroid_pos0(e), f[1] = t1.geta_centroid_pos1(e));
                    }
                    if (0 === f[0] && 1 === f[1]) return !1;
                    "globe" === a.projection.name && (i = Td([
                        i
                    ], [
                        new Ne(0, 0),
                        new Ne(ps, ps)
                    ], e.tileID.canonical).map((t1)=>t1.polygon).flat());
                    const g = d ? l : null, [x, b] = function(e, r, n, i, s, a, o, l, u, c, h) {
                        return "globe" === e.projection.name ? function(e, r, n, i, s, a, o, l, u, c, h) {
                            const p = [], f = [], d = e.projection.upVectorScale(h, e.center.lat, e.worldSize).metersToTile, m = [
                                0,
                                0,
                                0,
                                1
                            ], y = [
                                0,
                                0,
                                0,
                                1
                            ], g = (t1, e, r, n)=>{
                                t1[0] = e, t1[1] = r, t1[2] = n, t1[3] = 1;
                            }, x = Id();
                            n > 0 && (n += x), i += x;
                            for (const x of r){
                                const r = [], b = [];
                                for (const p of x){
                                    const f = p.x + s.x, x = p.y + s.y, v = e.projection.projectTilePoint(f, x, h), _ = e.projection.upVector(h, p.x, p.y);
                                    let w = n, M = i;
                                    if (o) {
                                        const t1 = Dd(f, x, n, i, o, l, u, c);
                                        w += t1.base, M += t1.top;
                                    }
                                    0 !== n ? g(m, v.x + _[0] * d * w, v.y + _[1] * d * w, v.z + _[2] * d * w) : g(m, v.x, v.y, v.z), g(y, v.x + _[0] * d * M, v.y + _[1] * d * M, v.z + _[2] * d * M), t1._.transformMat4(m, m, a), t1._.transformMat4(y, y, a), r.push(new If(m[0], m[1], m[2])), b.push(new If(y[0], y[1], y[2]));
                                }
                                p.push(r), f.push(b);
                            }
                            return [
                                p,
                                f
                            ];
                        }(e, r, n, i, s, a, o, l, u, c, h) : o ? function(e, r, n, i, s, a, o, l, u) {
                            const c = [], h = [], p = [
                                0,
                                0,
                                0,
                                1
                            ];
                            for (const f of e){
                                const e = [], d = [];
                                for (const c of f){
                                    const h = c.x + i.x, f = c.y + i.y, m = Dd(h, f, r, n, a, o, l, u);
                                    p[0] = h, p[1] = f, p[2] = m.base, p[3] = 1, t1.aA.transformMat4(p, p, s), p[3] = Math.max(p[3], 1e-5);
                                    const y = new If(p[0] / p[3], p[1] / p[3], p[2] / p[3]);
                                    p[0] = h, p[1] = f, p[2] = m.top, p[3] = 1, t1.aA.transformMat4(p, p, s), p[3] = Math.max(p[3], 1e-5);
                                    const g = new If(p[0] / p[3], p[1] / p[3], p[2] / p[3]);
                                    e.push(y), d.push(g);
                                }
                                c.push(e), h.push(d);
                            }
                            return [
                                c,
                                h
                            ];
                        }(r, n, i, s, a, o, l, u, c) : function(t1, e, r, n, i) {
                            const s = [], a = [], o = i[8] * e, l = i[9] * e, u = i[10] * e, c = i[11] * e, h = i[8] * r, p = i[9] * r, f = i[10] * r, d = i[11] * r;
                            for (const e of t1){
                                const t1 = [], r = [];
                                for (const s of e){
                                    const e = s.x + n.x, a = s.y + n.y, m = i[0] * e + i[4] * a + i[12], y = i[1] * e + i[5] * a + i[13], g = i[2] * e + i[6] * a + i[14], x = i[3] * e + i[7] * a + i[15], b = m + o, v = y + l, _ = g + u, w = Math.max(x + c, 1e-5), M = m + h, A = y + p, S = g + f, I = Math.max(x + d, 1e-5);
                                    t1.push(new If(b / w, v / w, _ / w)), r.push(new If(M / I, A / I, S / I));
                                }
                                s.push(t1), a.push(r);
                            }
                            return [
                                s,
                                a
                            ];
                        }(r, n, i, s, a);
                    }(a, i, p, h, c, o, g, f, m, a.center.lat, e.tileID.canonical), v = e.queryGeometry;
                    return function(t1, e, r) {
                        let n = 1 / 0;
                        Qc(r, e) && (n = Bd(r, e[0]));
                        for(let i = 0; i < e.length; i++){
                            const s = e[i], a = t1[i];
                            for(let t1 = 0; t1 < s.length - 1; t1++){
                                const e = s[t1], i = [
                                    e,
                                    s[t1 + 1],
                                    a[t1 + 1],
                                    a[t1],
                                    e
                                ];
                                Wc(r, i) && (n = Math.min(n, Bd(r, i)));
                            }
                        }
                        return n !== 1 / 0 && n;
                    }(x, b, v.isPointQuery() ? v.screenBounds : v.screenGeometry);
                }
            },
            line: class extends kl {
                constructor(t1, e, r, n){
                    super(t1, nm, e, r, n), nm.layout && (this.layout = new nl(nm.layout)), this.gradientVersion = 0;
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    if ("line-gradient" === t1) {
                        const t1 = this._transitionablePaint._values["line-gradient"].value.expression;
                        this.stepInterpolant = t1._styleExpression && t1._styleExpression.expression instanceof ea, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
                    }
                }
                gradientExpression() {
                    return this._transitionablePaint._values["line-gradient"].value.expression;
                }
                widthExpression() {
                    return this._transitionablePaint._values["line-width"].value.expression;
                }
                recalculate(t1, e) {
                    super.recalculate(t1, e), this.paint._values["line-floorwidth"] = rb.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t1);
                }
                createBucket(t1) {
                    return new tm(t1);
                }
                getProgramIds() {
                    return [
                        this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    const n = om(this);
                    return {
                        config: new Ku(this, {
                            zoom: e,
                            lut: r
                        }),
                        defines: n,
                        overrideFog: !1
                    };
                }
                queryRadius(t1) {
                    const e = t1, r = nb(hh("line-width", this, e), hh("line-gap-width", this, e)), n = hh("line-offset", this, e);
                    return r / 2 + Math.abs(n) + ph(this.paint.get("line-translate"));
                }
                queryIntersectsFeature(t1, e, r, n, i, s) {
                    if (t1.queryGeometry.isAboveHorizon) return !1;
                    const a = fh(t1.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), o = t1.pixelToTileUnitsFactor / 2 * nb(this.paint.get("line-width").evaluate(e, r), this.paint.get("line-gap-width").evaluate(e, r)), l = this.paint.get("line-offset").evaluate(e, r);
                    return l && (n = function(t1, e) {
                        const r = [], n = new Ne(0, 0);
                        for(let i = 0; i < t1.length; i++){
                            const s = t1[i], a = [];
                            for(let t1 = 0; t1 < s.length; t1++){
                                const r = s[t1], i = s[t1 + 1], o = 0 === t1 ? n : r.sub(s[t1 - 1])._unit()._perp(), l = t1 === s.length - 1 ? n : i.sub(r)._unit()._perp(), u = o._add(l)._unit();
                                u._mult(1 / (u.x * l.x + u.y * l.y)), a.push(u._mult(e)._add(r));
                            }
                            r.push(a);
                        }
                        return r;
                    }(n, l * t1.pixelToTileUnitsFactor)), function(t1, e, r) {
                        for(let n = 0; n < e.length; n++){
                            const i = e[n];
                            if (t1.length >= 3) {
                                for(let e = 0; e < i.length; e++)if (ah(t1, i[e])) return !0;
                            }
                            if (th(t1, i, r)) return !0;
                        }
                        return !1;
                    }(a, n, o);
                }
                isTileClipped() {
                    return !0;
                }
                isDraped(t1) {
                    const e = this.layout.get("line-z-offset");
                    return e.isConstant() && !e.constantOr(0);
                }
            },
            symbol: ob,
            background: class extends kl {
                constructor(t1, e, r, n){
                    super(t1, ub, e, r, n);
                }
                getProgramIds() {
                    return [
                        this.paint.get("background-pattern") ? "backgroundPattern" : "background"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    return {
                        overrideFog: !1
                    };
                }
            },
            raster: gb,
            "raster-particle": vb,
            sky: class extends kl {
                constructor(t1, e, r, n){
                    super(t1, Mb, e, r, n), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    "sky-gradient" === t1 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t1 && "sky-atmosphere-halo-color" !== t1 && "sky-atmosphere-color" !== t1 && "sky-atmosphere-sun-intensity" !== t1 || (this._skyboxInvalidated = !0);
                }
                _updateColorRamp() {
                    this.colorRamp = gp({
                        expression: this._transitionablePaint._values["sky-gradient"].value.expression,
                        evaluationKey: "skyRadialProgress"
                    }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
                }
                needsSkyboxCapture(t1) {
                    if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;
                    if (!this.paint.get("sky-atmosphere-sun")) {
                        const e = t1.style.light.properties.get("position");
                        return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;
                    }
                    return !1;
                }
                getCenter(t1, e) {
                    if ("atmosphere" === this.paint.get("sky-type")) {
                        const r = this.paint.get("sky-atmosphere-sun"), n = !r, i = t1.style.light, s = i.properties.get("position");
                        return n && "viewport" === i.properties.get("anchor") && fr("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n ? Ab(s.azimuthal, 90 - s.polar, e) : Ab(r[0], 90 - r[1], e);
                    }
                    const r = this.paint.get("sky-gradient-center");
                    return Ab(r[0], 90 - r[1], e);
                }
                isSky() {
                    return !0;
                }
                markSkyboxValid(t1) {
                    this._skyboxInvalidated = !1, this._lightPosition = t1.style.light.properties.get("position");
                }
                hasOffscreenPass() {
                    return !0;
                }
                getProgramIds() {
                    const t1 = this.paint.get("sky-type");
                    return "atmosphere" === t1 ? [
                        "skyboxCapture",
                        "skybox"
                    ] : "gradient" === t1 ? [
                        "skyboxGradient"
                    ] : null;
                }
            },
            slot: class extends kl {
                constructor(t1, e, r, n){
                    super(t1, Sb, e, null);
                }
            },
            model: class extends kl {
                constructor(t1, e, r, n){
                    super(t1, Hb, e, r, n), this._stats = {
                        numRenderedVerticesInShadowPass: 0,
                        numRenderedVerticesInTransparentPass: 0
                    };
                }
                createBucket(t1) {
                    return new Xb(t1);
                }
                getProgramIds() {
                    return [
                        "model"
                    ];
                }
                is3D() {
                    return !0;
                }
                hasShadowPass() {
                    return !0;
                }
                canCastShadows() {
                    return !0;
                }
                hasLightBeamPass() {
                    return !0;
                }
                cutoffRange() {
                    return this.paint.get("model-cutoff-fade-range");
                }
                queryRadius(t1) {
                    return t1 instanceof Qv ? ps - 1 : 0;
                }
                queryIntersectsFeature(e, r, n, i, s, a) {
                    if (!this.modelManager) return !1;
                    const o = this.modelManager, l = e.tile.getBucket(this);
                    if (!(l && l instanceof Xb)) return !1;
                    const u = l;
                    for(const n in u.instancesPerModel){
                        const i = u.instancesPerModel[n], s = void 0 !== r.id ? r.id : r.properties && r.properties.hasOwnProperty("id") ? r.properties.id : void 0;
                        if (i.idToFeaturesIndex.hasOwnProperty(s)) {
                            const r = i.features[i.idToFeaturesIndex[s]], l = o.getModel(n, this.scope);
                            if (!l) return !1;
                            let c = t1.ad.create();
                            const h = new mc(0, 0), p = u.canonical;
                            let f = Number.MAX_VALUE;
                            for(let n = 0; n < r.instancedDataCount; ++n){
                                const s = 16 * (r.instancedDataOffset + n), o = i.instancedDataArray.float32, u = [
                                    o[s + 4],
                                    o[s + 5],
                                    o[s + 6]
                                ];
                                n_(p, h, o[s], 0 | o[s + 1]), Jb(c, l, a, h, r.rotation, r.scale, u, !1, !1, !1), "globe" === a.projection.name && (c = Cb(c, a));
                                const d = t1.ad.multiply([], a.projMatrix, c), m = e.queryGeometry, y = Rb(m.isPointQuery() ? m.screenBounds : m.screenGeometry, a, d, l.aabb);
                                null != y && (f = Math.min(y, f));
                            }
                            return f !== Number.MAX_VALUE && f;
                        }
                    }
                    return !1;
                }
                _handleOverridablePaintPropertyUpdate(t1, e, r) {
                    return !(!this.layout || e.isDataDriven() || r.isDataDriven() || "model-color" !== t1 && "model-color-mix-intensity" !== t1 && "model-rotation" !== t1 && "model-scale" !== t1 && "model-translation" !== t1 && "model-emissive-strength" !== t1);
                }
                _isPropertyZoomDependent(t1) {
                    const e = this._transitionablePaint._values[t1];
                    return null != e && null != e.value && null != e.value.expression && e.value.expression instanceof fo;
                }
                isZoomDependent() {
                    return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
                }
                queryIntersectsMatchingFeature(e, r, n, i) {
                    const s = e.tile, a = s.getBucket(this);
                    let o = null, l = Number.MAX_VALUE;
                    if (!(a && a instanceof Qv)) return {
                        queryFeature: o,
                        intersectionZ: l
                    };
                    const u = a.getNodesInfo()[r];
                    if (u.hiddenByReplacement || !u.node.meshes || !n.filter(new Ho(s.tileID.overscaledZ), u.feature, s.tileID.canonical)) return {
                        queryFeature: o,
                        intersectionZ: l
                    };
                    const c = u.node, h = i.calculatePosMatrix(s.tileID.toUnwrapped(), i.worldSize), p = u.evaluatedScale;
                    let f = 0;
                    i.elevation && c.elevation && (f = c.elevation * i.elevation.exaggeration()), t1.ad.translate(h, h, [
                        (c.anchor ? c.anchor[0] : 0) * (p[0] - 1),
                        (c.anchor ? c.anchor[1] : 0) * (p[1] - 1),
                        f
                    ]), t1.ad.scale(h, h, p), t1.ad.multiply(h, h, c.matrix);
                    const d = e.queryGeometry, m = d.isPointQuery() ? d.screenBounds : d.screenGeometry, y = function(e) {
                        const r = t1.ad.multiply([], h, e.matrix), n = t1.ad.multiply(r, i.expandedFarZProjMatrix, r);
                        for(let t1 = 0; t1 < e.meshes.length; ++t1){
                            const r = e.meshes[t1];
                            if (t1 === e.lightMeshIndex) continue;
                            const s = Rb(m, i, n, r.aabb);
                            null != s && (l = Math.min(s, l));
                        }
                        if (e.children) for (const t1 of e.children)y(t1);
                    };
                    if (y(c), l === Number.MAX_VALUE) return {
                        queryFeature: o,
                        intersectionZ: l
                    };
                    const g = new mc(0, 0);
                    return n_(s.tileID.canonical, g, u.node.anchor[0], u.node.anchor[1]), o = {
                        type: "Feature",
                        geometry: {
                            type: "Point",
                            coordinates: [
                                g.lng,
                                g.lat
                            ]
                        },
                        properties: u.feature.properties,
                        id: u.feature.id,
                        state: {},
                        layer: this.serialize()
                    }, {
                        queryFeature: o,
                        intersectionZ: l
                    };
                }
            },
            clip: class extends kl {
                constructor(t1, e, r, n){
                    super(t1, sf, e, r, n);
                }
                recalculate(t1, e) {
                    super.recalculate(t1, e);
                }
                createBucket(t1) {
                    return new rf(t1);
                }
                isTileClipped() {
                    return !0;
                }
                is3D() {
                    return !0;
                }
            }
        };
        Mo(Hx, "MRTDecodingBatch", {
            omit: [
                "_onCancel",
                "_onComplete"
            ]
        });
        const s_ = [
            Int8Array,
            Uint8Array,
            Uint8ClampedArray,
            Int16Array,
            Uint16Array,
            Int32Array,
            Uint32Array,
            Float32Array,
            Float64Array
        ];
        class a_ {
            static from(t1) {
                if (!(t1 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
                const [e, r] = new Uint8Array(t1, 0, 2);
                if (219 !== e) throw new Error("Data does not appear to be in a KDBush format.");
                const n = r >> 4;
                if (1 !== n) throw new Error(`Got v${n} data when expected v1.`);
                const i = s_[15 & r];
                if (!i) throw new Error("Unrecognized array type.");
                const [s] = new Uint16Array(t1, 2, 1), [a] = new Uint32Array(t1, 4, 1);
                return new a_(a, s, i, t1);
            }
            constructor(t1, e = 64, r = Float64Array, n){
                if (isNaN(t1) || t1 < 0) throw new Error(`Unpexpected numItems value: ${t1}.`);
                this.numItems = +t1, this.nodeSize = Math.min(Math.max(+e, 2), 65535), this.ArrayType = r, this.IndexArrayType = t1 < 65536 ? Uint16Array : Uint32Array;
                const i = s_.indexOf(this.ArrayType), s = 2 * t1 * this.ArrayType.BYTES_PER_ELEMENT, a = t1 * this.IndexArrayType.BYTES_PER_ELEMENT, o = (8 - a % 8) % 8;
                if (i < 0) throw new Error(`Unexpected typed array class: ${r}.`);
                n && n instanceof ArrayBuffer ? (this.data = n, this.ids = new this.IndexArrayType(this.data, 8, t1), this.coords = new this.ArrayType(this.data, 8 + a + o, 2 * t1), this._pos = 2 * t1, this._finished = !0) : (this.data = new ArrayBuffer(8 + s + a + o), this.ids = new this.IndexArrayType(this.data, 8, t1), this.coords = new this.ArrayType(this.data, 8 + a + o, 2 * t1), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([
                    219,
                    16 + i
                ]), new Uint16Array(this.data, 2, 1)[0] = e, new Uint32Array(this.data, 4, 1)[0] = t1);
            }
            add(t1, e) {
                const r = this._pos >> 1;
                return this.ids[r] = r, this.coords[this._pos++] = t1, this.coords[this._pos++] = e, r;
            }
            finish() {
                const t1 = this._pos >> 1;
                if (t1 !== this.numItems) throw new Error(`Added ${t1} items when expected ${this.numItems}.`);
                return o_(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
            }
            range(t1, e, r, n) {
                if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
                const { ids: i, coords: s, nodeSize: a } = this, o = [
                    0,
                    i.length - 1,
                    0
                ], l = [];
                for(; o.length;){
                    const u = o.pop() || 0, c = o.pop() || 0, h = o.pop() || 0;
                    if (c - h <= a) {
                        for(let a = h; a <= c; a++){
                            const o = s[2 * a], u = s[2 * a + 1];
                            o >= t1 && o <= r && u >= e && u <= n && l.push(i[a]);
                        }
                        continue;
                    }
                    const p = h + c >> 1, f = s[2 * p], d = s[2 * p + 1];
                    f >= t1 && f <= r && d >= e && d <= n && l.push(i[p]), (0 === u ? t1 <= f : e <= d) && (o.push(h), o.push(p - 1), o.push(1 - u)), (0 === u ? r >= f : n >= d) && (o.push(p + 1), o.push(c), o.push(1 - u));
                }
                return l;
            }
            within(t1, e, r) {
                if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
                const { ids: n, coords: i, nodeSize: s } = this, a = [
                    0,
                    n.length - 1,
                    0
                ], o = [], l = r * r;
                for(; a.length;){
                    const u = a.pop() || 0, c = a.pop() || 0, h = a.pop() || 0;
                    if (c - h <= s) {
                        for(let r = h; r <= c; r++)h_(i[2 * r], i[2 * r + 1], t1, e) <= l && o.push(n[r]);
                        continue;
                    }
                    const p = h + c >> 1, f = i[2 * p], d = i[2 * p + 1];
                    h_(f, d, t1, e) <= l && o.push(n[p]), (0 === u ? t1 - r <= f : e - r <= d) && (a.push(h), a.push(p - 1), a.push(1 - u)), (0 === u ? t1 + r >= f : e + r >= d) && (a.push(p + 1), a.push(c), a.push(1 - u));
                }
                return o;
            }
        }
        function o_(t1, e, r, n, i, s) {
            if (i - n <= r) return;
            const a = n + i >> 1;
            l_(t1, e, a, n, i, s), o_(t1, e, r, n, a - 1, 1 - s), o_(t1, e, r, a + 1, i, 1 - s);
        }
        function l_(t1, e, r, n, i, s) {
            for(; i > n;){
                if (i - n > 600) {
                    const a = i - n + 1, o = r - n + 1, l = Math.log(a), u = .5 * Math.exp(2 * l / 3), c = .5 * Math.sqrt(l * u * (a - u) / a) * (o - a / 2 < 0 ? -1 : 1);
                    l_(t1, e, r, Math.max(n, Math.floor(r - o * u / a + c)), Math.min(i, Math.floor(r + (a - o) * u / a + c)), s);
                }
                const a = e[2 * r + s];
                let o = n, l = i;
                for(u_(t1, e, n, r), e[2 * i + s] > a && u_(t1, e, n, i); o < l;){
                    for(u_(t1, e, o, l), o++, l--; e[2 * o + s] < a;)o++;
                    for(; e[2 * l + s] > a;)l--;
                }
                e[2 * n + s] === a ? u_(t1, e, n, l) : (l++, u_(t1, e, l, i)), l <= r && (n = l + 1), r <= l && (i = l - 1);
            }
        }
        function u_(t1, e, r, n) {
            c_(t1, r, n), c_(e, 2 * r, 2 * n), c_(e, 2 * r + 1, 2 * n + 1);
        }
        function c_(t1, e, r) {
            const n = t1[e];
            t1[e] = t1[r], t1[r] = n;
        }
        function h_(t1, e, r, n) {
            const i = t1 - r, s = e - n;
            return i * i + s * s;
        }
        t1.$ = We, t1.A = Hs, t1.B = Ys, t1.C = qn, t1.D = Bi, t1.E = Ln, t1.G = hl, t1.H = eo, t1.I = Ig, t1.J = Ja, t1.K = function(t1) {
            const e = t1.value;
            let r = [];
            if (!e) return r;
            const n = Ti(e);
            return "string" !== n ? (r = r.concat([
                new qb(t1.key, e, `string expected, "${n}" found`)
            ]), r) : ($b(e, !0) || (r = r.concat([
                new qb(t1.key, e, `invalid url "${e}"`)
            ])), r);
        }, t1.L = ll, t1.M = class {
            constructor(t1, e, r, n){
                this.id = t1, this.position = null != e ? new mc(e[0], e[1]) : new mc(0, 0), this.orientation = null != r ? r : [
                    0,
                    0,
                    0
                ], this.nodes = n, this.uploaded = !1, this.aabb = new Ah([
                    1 / 0,
                    1 / 0,
                    1 / 0
                ], [
                    -1 / 0,
                    -1 / 0,
                    -1 / 0
                ]), this.matrix = [];
            }
            _applyTransformations(e, r) {
                if (t1.ad.multiply(e.matrix, r, e.matrix), e.meshes) for (const t1 of e.meshes){
                    const r = Ah.applyTransformFast(t1.aabb, e.matrix);
                    this.aabb.encapsulate(r);
                }
                if (e.children) for (const t1 of e.children)this._applyTransformations(t1, e.matrix);
            }
            computeBoundsAndApplyParent() {
                const e = t1.ad.identity([]);
                for (const t1 of this.nodes)this._applyTransformations(t1, e);
            }
            computeModelMatrix(t1, e, r, n, i, s, a = !1) {
                Jb(this.matrix, this, t1.transform, this.position, e, r, n, i, s, a);
            }
            upload(t1) {
                if (!this.uploaded) {
                    for (const e of this.nodes)ev(e, t1);
                    for (const t1 of this.nodes)rv(t1);
                    this.uploaded = !0;
                }
            }
            destroy() {
                for (const t1 of this.nodes)nv(t1);
            }
        }, t1.N = ol, t1.O = il, t1.P = Ne, t1.Q = class {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e) {
                return yr(t1.expression.evaluate(e));
            }
            interpolate(t1, e, r) {
                return {
                    x: Gn(t1.x, e.x, r),
                    y: Gn(t1.y, e.y, r),
                    z: Gn(t1.z, e.z, r),
                    azimuthal: Gn(t1.azimuthal, e.azimuthal, r),
                    polar: Gn(t1.polar, e.polar, r)
                };
            }
        }, t1.R = Wr, t1.S = uu, t1.T = Gg, t1.U = Jo, t1.V = qb, t1.W = er, t1.X = Ho, t1.Y = Oc, t1.Z = fo, t1.a = Eg, t1.a$ = function(t1) {
            const { x: e, y: r } = t1.point, { lng: n, lat: i } = t1._center;
            return Zh(e, r, t1.worldSize, n, i);
        }, t1.a0 = nl, t1.a1 = Hh, t1.a2 = Gn, t1.a3 = ps, t1.a4 = Yn, t1.a5 = class {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e) {
                return function([t1, e]) {
                    const r = yr([
                        1,
                        t1,
                        e
                    ]);
                    return {
                        x: r.x,
                        y: r.y,
                        z: r.z
                    };
                }(t1.expression.evaluate(e));
            }
            interpolate(t1, e, r) {
                return {
                    x: Gn(t1.x, e.x, r),
                    y: Gn(t1.y, e.y, r),
                    z: Gn(t1.z, e.z, r)
                };
            }
        }, t1.a6 = Uu, t1.a7 = Du, t1.a8 = Ru, t1.a9 = Ou, t1.aB = function(e, r) {
            const { x: n, y: i } = e.point, s = Zh(n, i, e.worldSize / e._pixelsPerMercatorPixel, 0, 0);
            return t1.ad.multiply(s, s, Gh(Ch(r)));
        }, t1.aD = qm, t1.aE = ty, t1.aF = jm, t1.aG = function(t1, e, r, n, i) {
            const s = 5 * e + 2;
            t1.float32[s + 0] = r, t1.float32[s + 1] = n, t1.float32[s + 2] = i;
        }, t1.aH = Ug, t1.aI = mc, t1.aJ = Sg, t1.aK = vc, t1.aL = _c, t1.aM = Mh, t1.aN = Tb, t1.aO = bc, t1.aP = Oh, t1.aQ = function(t1, e, r, n, i, s, a, o, l) {
            if ("globe" === l.name) return Oh(t1, e, new bc(r, n, i), !1);
            const u = ng({
                z: r,
                x: n,
                y: i
            }, l);
            return new Ah([
                (s + u.x / u.scale) * e,
                e * (u.y / u.scale),
                a
            ], [
                (s + u.x2 / u.scale) * e,
                e * (u.y2 / u.scale),
                o
            ]);
        }, t1.aR = function(t1, e, r) {
            let n = 0;
            for(let r = 0; r < 2; ++r){
                const i = 0;
                t1[r] > i && (n += (t1[r] - i) * (t1[r] - i)), e[r] < i && (n += (i - e[r]) * (i - e[r]));
            }
            return n;
        }, t1.aS = Dc, t1.aT = gh, t1.aU = sc, t1.aV = function(e) {
            const r = t1.ad.identity(new Float64Array(16));
            t1.ad.multiply(r, e.pixelMatrix, e.globeMatrix);
            const n = [
                0,
                uc,
                0
            ], i = [
                0,
                cc,
                0
            ];
            return t1._.transformMat4(n, n, r), t1._.transformMat4(i, i, r), [
                n[0] > 0 && n[0] <= e.width && n[1] > 0 && n[1] <= e.height && !Wh(e, new mc(e.center.lat, 90)),
                i[0] > 0 && i[0] <= e.width && i[1] > 0 && i[1] <= e.height && !Wh(e, new mc(e.center.lat, -90))
            ];
        }, t1.aW = function(e, r) {
            const { scale: n } = e.tileTransform, i = n * ps / (e.tileSize * Math.pow(2, r.zoom - e.tileID.overscaledZ + e.tileID.canonical.z));
            return t1.aC.scale(new Float32Array(4), r.inverseAdjustmentMatrix, [
                i,
                i
            ]);
        }, t1.aX = kb, t1.aY = Ib, t1.aZ = function(e) {
            const r = Ib(e, !0);
            return t1.aC.invert([], [
                r[0],
                r[1],
                r[4],
                r[5]
            ]);
        }, t1.a_ = xh, t1.aa = Cu, t1.ab = $e, t1.ac = function(t1, e, r) {
            const n = Math.sqrt(t1 * t1 + e * e + r * r), i = n > 0 ? Math.acos(r / n) * qe : 0;
            let s = 0 !== t1 || 0 !== e ? Math.atan2(-e, -t1) * qe + 90 : 0;
            return s < 0 && (s += 360), [
                n,
                s,
                i
            ];
        }, t1.ae = Tg, t1.af = Cg, t1.ag = Pg, t1.ah = function(t1, e) {
            const r = {};
            for(let n = 0; n < e.length; n++){
                const i = e[n];
                i in t1 && (r[i] = t1[i]);
            }
            return r;
        }, t1.ai = yc, t1.aj = Tc, t1.ak = kc, t1.al = Sl, t1.am = function(t1) {
            qr++, qr > Or && (t1.getActor().send("enforceCacheSizeLimit", Lr), qr = 0);
        }, t1.an = gn, t1.ao = class {
            constructor(t1){
                this.entries = {}, this.scheduler = t1;
            }
            request(t1, e, r, n) {
                const i = this.entries[t1] = this.entries[t1] || {
                    callbacks: []
                };
                if (i.result) {
                    const [t1, r] = i.result;
                    return this.scheduler ? this.scheduler.add(()=>{
                        n(t1, r);
                    }, e) : n(t1, r), ()=>{};
                }
                return i.callbacks.push(n), i.cancel || (i.cancel = r((r, n)=>{
                    i.result = [
                        r,
                        n
                    ];
                    for (const t1 of i.callbacks)this.scheduler ? this.scheduler.add(()=>{
                        t1(r, n);
                    }, e) : t1(r, n);
                    setTimeout(()=>delete this.entries[t1], 3e3);
                })), ()=>{
                    i.result || (i.callbacks = i.callbacks.filter((t1)=>t1 !== n), i.callbacks.length || (i.cancel(), delete this.entries[t1]));
                };
            }
        }, t1.ap = function(t1, e, r) {
            const n = JSON.stringify(t1.request);
            return t1.data && (this.deduped.entries[n] = {
                result: [
                    null,
                    t1.data
                ]
            }), this.deduped.request(n, {
                type: "parseTile",
                isSymbolTile: t1.isSymbolTile,
                zoom: t1.tileZoom
            }, (e)=>{
                const n = en(t1.request, (t1, n, i, s)=>{
                    t1 ? e(t1) : n && e(null, {
                        vectorTile: r ? void 0 : new Af(new Bm(n)),
                        rawData: n,
                        cacheControl: i,
                        expires: s
                    });
                });
                return ()=>{
                    n.cancel(), e();
                };
            }, e);
        }, t1.aq = Vu, t1.ar = class extends Bu {
            constructor(t1){
                super(t1), this.current = Nu;
            }
            set(t1, e, r) {
                if (this.fetchUniformLocation(t1, e)) {
                    for(let t1 = 0; t1 < 9; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix3fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }, t1.as = Lu, t1.at = Ke, t1.au = Je, t1.aw = Tr, t1.ax = Pc, t1.ay = Ec, t1.az = function(t1, e, r) {
            t1[4 * e + 0] = r[0], t1[4 * e + 1] = r[1], t1[4 * e + 2] = r[2], t1[4 * e + 3] = r[3];
        }, t1.b = Au, t1.b$ = od, t1.b0 = Ge, t1.b1 = ic, t1.b2 = function(t1) {
            const e = Math.round((t1 + 45 + 360) % 360 / 90) % 4;
            return Ye[e];
        }, t1.b3 = 45, t1.b4 = Ic, t1.b5 = Lc, t1.b6 = Ah, t1.b7 = yr, t1.b8 = function(t1) {
            return [
                Math.pow(t1[0], 1 / 2.2),
                Math.pow(t1[1], 1 / 2.2),
                Math.pow(t1[2], 1 / 2.2)
            ];
        }, t1.b9 = Xe, t1.bA = function(t1, e) {
            return [
                Math.pow(t1[0], 2.2) * e,
                Math.pow(t1[1], 2.2) * e,
                Math.pow(t1[2], 2.2) * e
            ];
        }, t1.bB = im, t1.bD = Xh, t1.bE = Er, t1.bF = zr, t1.bG = 256, t1.bH = function(e, r) {
            const n = [
                0,
                0,
                0
            ], i = $h(Ch(r.canonical));
            return t1._.transformMat4(n, n, i), t1._.transformMat4(n, n, e), n;
        }, t1.bI = (t1)=>({
                u_camera_to_center_distance: new Cu(t1),
                u_extrude_scale: new qu(t1),
                u_device_pixel_ratio: new Cu(t1),
                u_matrix: new Uu(t1),
                u_inv_rot_matrix: new Uu(t1),
                u_merc_center: new Ru(t1),
                u_tile_id: new Vu(t1),
                u_zoom_transition: new Cu(t1),
                u_up_dir: new Vu(t1),
                u_emissive_strength: new Cu(t1)
            }), t1.bJ = (t1)=>({
                u_matrix: new Uu(t1),
                u_pixels_to_tile_units: new qu(t1),
                u_device_pixel_ratio: new Cu(t1),
                u_units_to_pixels: new Ru(t1),
                u_dash_image: new Du(t1),
                u_gradient_image: new Du(t1),
                u_image_height: new Cu(t1),
                u_texsize: new Ru(t1),
                u_tile_units_to_pixels: new Cu(t1),
                u_alpha_discard_threshold: new Cu(t1),
                u_trim_offset: new Ru(t1),
                u_trim_fade_range: new Ru(t1),
                u_trim_color: new Lu(t1),
                u_emissive_strength: new Cu(t1)
            }), t1.bK = (t1)=>({
                u_matrix: new Uu(t1),
                u_texsize: new Ru(t1),
                u_pixels_to_tile_units: new qu(t1),
                u_device_pixel_ratio: new Cu(t1),
                u_image: new Du(t1),
                u_units_to_pixels: new Ru(t1),
                u_tile_units_to_pixels: new Cu(t1),
                u_alpha_discard_threshold: new Cu(t1),
                u_trim_offset: new Ru(t1)
            }), t1.bL = Wl, t1.bM = Hd, t1.bN = Fm, t1.bO = $m, t1.bP = Yy, t1.bQ = hy, t1.bR = rp, t1.bS = (t1, e, r, n, i, s)=>{
            const a = t1.transform, o = "globe" === a.projection.name;
            let l;
            if ("map" === s.paint.get("circle-pitch-alignment")) {
                if (o) {
                    const t1 = Xh(a.zoom, e.canonical) * a._pixelsPerMercatorPixel;
                    l = Float32Array.from([
                        t1,
                        0,
                        0,
                        t1
                    ]);
                } else l = a.calculatePixelsToTileUnitsMatrix(r);
            } else l = new Float32Array([
                a.pixelsToGLUnits[0],
                0,
                0,
                a.pixelsToGLUnits[1]
            ]);
            const u = {
                u_camera_to_center_distance: t1.transform.getCameraToCenterDistance(a.projection),
                u_matrix: t1.translatePosMatrix(e.projMatrix, r, s.paint.get("circle-translate"), s.paint.get("circle-translate-anchor")),
                u_device_pixel_ratio: Dr.devicePixelRatio,
                u_extrude_scale: l,
                u_inv_rot_matrix: ep,
                u_merc_center: [
                    0,
                    0
                ],
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_up_dir: [
                    0,
                    0,
                    0
                ],
                u_emissive_strength: s.paint.get("circle-emissive-strength")
            };
            if (o) {
                u.u_inv_rot_matrix = n, u.u_merc_center = i, u.u_tile_id = [
                    e.canonical.x,
                    e.canonical.y,
                    1 << e.canonical.z
                ], u.u_zoom_transition = Hh(a.zoom);
                const t1 = i[0] * ps, r = i[1] * ps;
                u.u_up_dir = a.projection.upVector(new bc(0, 0, 0), t1, r);
            }
            return u;
        }, t1.bT = om, t1.bU = (t1, e, r, n, i, s)=>{
            const a = t1.transform;
            return {
                u_matrix: am(t1, e, r, n),
                u_texsize: e.imageAtlasTexture ? e.imageAtlasTexture.size : [
                    0,
                    0
                ],
                u_pixels_to_tile_units: a.calculatePixelsToTileUnitsMatrix(e),
                u_device_pixel_ratio: i,
                u_image: 0,
                u_tile_units_to_pixels: sm(e, a),
                u_units_to_pixels: [
                    1 / a.pixelsToGLUnits[0],
                    1 / a.pixelsToGLUnits[1]
                ],
                u_alpha_discard_threshold: 0,
                u_trim_offset: s
            };
        }, t1.bV = (t1, e, r, n, i, s, a)=>{
            const o = t1.transform, l = o.calculatePixelsToTileUnitsMatrix(e);
            return {
                u_matrix: am(t1, e, r, n),
                u_pixels_to_tile_units: l,
                u_device_pixel_ratio: s,
                u_units_to_pixels: [
                    1 / o.pixelsToGLUnits[0],
                    1 / o.pixelsToGLUnits[1]
                ],
                u_dash_image: 0,
                u_gradient_image: 1,
                u_image_height: i,
                u_texsize: lm(r) && e.lineAtlasTexture ? e.lineAtlasTexture.size : [
                    0,
                    0
                ],
                u_tile_units_to_pixels: sm(e, t1.transform),
                u_alpha_discard_threshold: 0,
                u_trim_offset: a,
                u_trim_fade_range: r.paint.get("line-trim-fade-range"),
                u_trim_color: r.paint.get("line-trim-color").toRenderColor(r.lut).toArray01(),
                u_emissive_strength: r.paint.get("line-emissive-strength")
            };
        }, t1.bW = sr, t1.bX = gp, t1.bY = Id, t1.bZ = Mc, t1.b_ = xd, t1.ba = function(t1, e, r) {
            const n = Hh(r.zoom), i = t1.style.map._antialias, s = e.options.extStandardDerivativesForceOff || t1.terrain && t1.terrain.exaggeration() > 0;
            return 0 === n && !i && !s;
        }, t1.bb = function(e) {
            const r = e.pixelsPerMeter, n = r / Pc(1, e.center.lat), i = t1.ad.identity(new Float64Array(16));
            return t1.ad.translate(i, i, [
                e.point.x,
                e.point.y,
                0
            ]), t1.ad.scale(i, i, [
                n,
                n,
                r
            ]), Float32Array.from(i);
        }, t1.bc = Fh, t1.bd = function(t1) {
            const e = Dc - 5;
            t1 = Ke(t1, -e, e) / e * 90;
            const r = Math.pow(Math.abs(Math.sin($e(t1))), 3);
            return Math.round(r * (lc.length - 1));
        }, t1.be = function(e, r, n, i) {
            const s = r.getNorth(), a = r.getSouth(), o = r.getWest(), l = r.getEast(), u = 1 << e.z, c = l - o, h = s - a, p = c / oc, f = -h / lc[n], d = [
                0,
                p,
                0,
                f,
                0,
                0,
                s,
                o,
                0
            ];
            if (e.z > 0) {
                const e = 180 / i;
                t1.bC.multiply(d, d, [
                    e / c + 1,
                    0,
                    0,
                    0,
                    e / h + 1,
                    0,
                    -0.5 * e / p,
                    .5 * e / f,
                    1
                ]);
            }
            return d[2] = u, d[5] = e.x, d[8] = e.y, d;
        }, t1.bf = $h, t1.bg = Ch, t1.bh = function(e, r, n) {
            const i = t1.ad.identity(new Float64Array(16)), s = (r / (1 << e) - .5) * Math.PI * 2;
            return t1.ad.rotateY(i, n.globeMatrix, s), Float32Array.from(i);
        }, t1.bi = Br, t1.bj = function(t1) {
            return t1 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t1) / Math.LN2));
        }, t1.bk = gb, t1.bl = vb, t1.bm = mb, t1.bn = function(t1, e) {
            const r = document.createElement("video");
            r.muted = !0, r.onloadstart = function() {
                e(null, r);
            };
            for(let e = 0; e < t1.length; e++){
                const n = document.createElement("source");
                rn(t1[e]) || (r.crossOrigin = "Anonymous"), n.src = t1[e], r.appendChild(n);
            }
            return {
                cancel: ()=>{}
            };
        }, t1.bo = Yg, t1.bp = or, t1.bq = class {
            isDataAvailableAtPoint(t1) {
                const e = this._source();
                if (this.isUsingMockSource() || !e || t1.y < 0 || t1.y > 1) return !1;
                const r = e.getSource().maxzoom, n = 1 << r, i = Math.floor(t1.x), s = Math.floor((t1.x - i) * n), a = Math.floor(t1.y * n), o = this.findDEMTileFor(new _c(r, i, r, s, a));
                return !(!o || !o.dem);
            }
            getAtPointOrZero(t1, e = 0) {
                return this.getAtPoint(t1, e) || 0;
            }
            getAtPoint(t1, e, r = !0) {
                if (this.isUsingMockSource()) return null;
                null == e && (e = null);
                const n = this._source();
                if (!n) return e;
                if (t1.y < 0 || t1.y > 1) return e;
                const i = n.getSource().maxzoom, s = 1 << i, a = Math.floor(t1.x), o = t1.x - a, l = new _c(i, a, i, Math.floor(o * s), Math.floor(t1.y * s)), u = this.findDEMTileFor(l);
                if (!u || !u.dem) return e;
                const c = u.dem, h = 1 << u.tileID.canonical.z, p = (o * h - u.tileID.canonical.x) * c.dim, f = (t1.y * h - u.tileID.canonical.y) * c.dim, d = Math.floor(p), m = Math.floor(f);
                return (r ? this.exaggeration() : 1) * Gn(Gn(c.get(d, m), c.get(d, m + 1), f - m), Gn(c.get(d + 1, m), c.get(d + 1, m + 1), f - m), p - d);
            }
            getAtTileOffset(t1, e, r) {
                const n = 1 << t1.canonical.z;
                return this.getAtPointOrZero(new Oc(t1.wrap + (t1.canonical.x + e / ps) / n, (t1.canonical.y + r / ps) / n));
            }
            getAtTileOffsetFunc(e, r, n, i) {
                return (s)=>{
                    const a = this.getAtTileOffset(e, s.x, s.y), o = i.upVector(e.canonical, s.x, s.y), l = i.upVectorScale(e.canonical, r, n).metersToTile;
                    return t1._.scale(o, o, a * l), o;
                };
            }
            getForTilePoints(t1, e, r, n) {
                if (this.isUsingMockSource()) return !1;
                const i = Qf.create(this, t1, n);
                return !!i && (e.forEach((t1)=>{
                    t1[2] = this.exaggeration() * i.getElevationAt(t1[0], t1[1], r);
                }), !0);
            }
            getMinMaxForTile(t1) {
                if (this.isUsingMockSource()) return null;
                const e = this.findDEMTileFor(t1);
                if (!e || !e.dem) return null;
                const r = e.dem.tree, n = e.tileID, i = 1 << t1.canonical.z - n.canonical.z;
                let s = t1.canonical.x / i - n.canonical.x, a = t1.canonical.y / i - n.canonical.y, o = 0;
                for(let e = 0; e < t1.canonical.z - n.canonical.z && !r.leaves[o]; e++){
                    s *= 2, a *= 2;
                    const t1 = 2 * Math.floor(a) + Math.floor(s);
                    o = r.childOffsets[o] + t1, s %= 1, a %= 1;
                }
                return {
                    min: this.exaggeration() * r.minimums[o],
                    max: this.exaggeration() * r.maximums[o]
                };
            }
            getMinElevationBelowMSL() {
                throw new Error("Pure virtual method called.");
            }
            raycast(t1, e, r) {
                throw new Error("Pure virtual method called.");
            }
            pointCoordinate(t1) {
                throw new Error("Pure virtual method called.");
            }
            _source() {
                throw new Error("Pure virtual method called.");
            }
            isUsingMockSource() {
                throw new Error("Pure virtual method called.");
            }
            exaggeration() {
                throw new Error("Pure virtual method called.");
            }
            findDEMTileFor(t1) {
                throw new Error("Pure virtual method called.");
            }
            get visibleDemTiles() {
                throw new Error("Getter must be implemented in subclass.");
            }
            getMinMaxForVisibleTiles() {
                const t1 = this.visibleDemTiles;
                if (0 === t1.length) return null;
                let e = !1, r = Number.MAX_VALUE, n = Number.MIN_VALUE;
                for (const i of t1){
                    const t1 = this.getMinMaxForTile(i.tileID);
                    t1 && (r = Math.min(r, t1.min), n = Math.max(n, t1.max), e = !0);
                }
                return e ? {
                    min: r,
                    max: n
                } : null;
            }
        }, t1.br = kh, t1.bs = Ph, t1.bt = Cl, t1.bu = Ql, t1.bv = Jx, t1.bw = ov, t1.bx = fv, t1.by = nx, t1.bz = dp, t1.c = $v, t1.c$ = tn, t1.c0 = 450, t1.c1 = 7, t1.c2 = yb, t1.c3 = Kx, t1.c4 = 256, t1.c5 = Vh, t1.c6 = Gh, t1.c7 = Bl, t1.c8 = Ul, t1.c9 = ru, t1.cA = function(t1) {
            let e = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0;
            for (const s of t1)e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);
            return {
                min: new Ne(e, r),
                max: new Ne(n, i)
            };
        }, t1.cB = ah, t1.cC = Uc, t1.cD = nc, t1.cE = [
            "type",
            "source",
            "source-layer",
            "minzoom",
            "maxzoom",
            "filter",
            "layout"
        ], t1.cF = My, t1.cG = Wc, t1.cH = Ff, t1.cI = Uf, t1.cJ = Xy, t1.cK = a_, t1.cL = function(t1) {
            return t1({
                pluginStatus: No,
                pluginURL: jo
            }), Go.on("pluginStateChange", t1), t1;
        }, t1.cM = Dy, t1.cN = By, t1.cO = Qr, t1.cP = qo, t1.cQ = s, t1.cR = Rr, t1.cS = Bn, t1.cT = hr, t1.cU = function(t1) {
            const e = t1.indexOf(Al);
            return e >= 0 ? t1.slice(0, e) : t1;
        }, t1.cV = function(t1) {
            return t1.indexOf(Al) >= 0;
        }, t1.cW = function(t1) {
            const e = t1.indexOf(Al);
            return e >= 0 ? t1.slice(e + 1) : "";
        }, t1.cX = function(t1) {
            const e = [], r = t1.id;
            return void 0 === r && e.push({
                message: `layers.${r}: missing required property "id"`
            }), void 0 === t1.render && e.push({
                message: `layers.${r}: missing required method "render"`
            }), t1.renderingMode && "2d" !== t1.renderingMode && "3d" !== t1.renderingMode && e.push({
                message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
            }), e;
        }, t1.cY = function(t1, e, r, n) {
            return "custom" === t1.type ? new _b(t1, e) : new i_[t1.type](t1, e, r, n);
        }, t1.cZ = cr, t1.c_ = Go, t1.ca = 1, t1.cb = zg, t1.cc = 0, t1.cd = nu, t1.ce = function(t1, e, r, n, i) {
            return Ke((t1 - e) / (r - e) * (i - n) + n, n, i);
        }, t1.cf = Na, t1.cg = Rc, t1.ch = class {
            constructor(t1, e, r, n){
                this.context = t1, this.format = n, this.size = r, this.texture = t1.gl.createTexture();
                const [i, s, a] = this.size, { gl: o } = t1;
                o.bindTexture(o.TEXTURE_3D, this.texture), t1.pixelStoreUnpackFlipY.set(!1), t1.pixelStoreUnpack.set(1), t1.pixelStoreUnpackPremultiplyAlpha.set(!1);
                let l = this.format, u = o.UNSIGNED_BYTE;
                this.format === o.DEPTH_COMPONENT && (l = o.DEPTH_COMPONENT16, u = o.UNSIGNED_SHORT), this.format === o.R8 && (n = o.RED), this.format === o.R32F && (u = o.FLOAT, n = o.RED), o.texImage3D(o.TEXTURE_3D, 0, l, i, s, a, 0, n, u, e.data);
            }
            bind(t1, e) {
                const { context: r } = this, { gl: n } = r;
                n.bindTexture(n.TEXTURE_3D, this.texture), t1 !== this.minFilter && (n.texParameteri(n.TEXTURE_3D, n.TEXTURE_MAG_FILTER, t1), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_MIN_FILTER, t1), this.minFilter = t1), e !== this.wrapS && (n.texParameteri(n.TEXTURE_3D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_WRAP_T, e), this.wrapS = e);
            }
            destroy() {
                const { gl: t1 } = this.context;
                t1.deleteTexture(this.texture), this.texture = null;
            }
        }, t1.ci = Cb, t1.cj = [
            1,
            1,
            1
        ], t1.ck = Qf, t1.cl = Wb, t1.cm = Zl, t1.cn = iu, t1.co = class {
            constructor(){
                this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = {
                    min: new Ne(1 / 0, 1 / 0),
                    max: new Ne(-1 / 0, -1 / 0)
                };
            }
            clear() {
                this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
            }
            get updateTime() {
                return this._updateTime;
            }
            getReplacementRegionsForTile(t1, e = !1) {
                const r = Rf(new Ne(0, 0), new Ne(ps, ps), t1), n = [];
                if (e && !Df(r, this._globalClipBounds)) return n;
                for (const e of this._activeRegions){
                    if (e.hiddenByOverlap) continue;
                    if (!Df(r, e)) continue;
                    const i = Vf(e.min, e.max, t1);
                    n.push({
                        min: i.min,
                        max: i.max,
                        sourceId: this._sourceIds[e.priority],
                        footprint: e.footprint,
                        footprintTileId: e.tileId,
                        order: e.order,
                        clipMask: e.clipMask
                    });
                }
                return n;
            }
            setSources(t1) {
                this._setSources(t1.map((t1)=>({
                        getSourceId: ()=>t1.cache.id,
                        getFootprints: ()=>{
                            const e = [];
                            for (const r of t1.cache.getVisibleCoordinates()){
                                const n = t1.cache.getTile(r).buckets[t1.layer];
                                n && n.updateFootprints(r.toUnwrapped(), e);
                            }
                            return e;
                        },
                        getOrder: ()=>t1.order,
                        getClipMask: ()=>t1.clipMask
                    })));
            }
            _addSource(t1) {
                const e = t1.getFootprints();
                if (0 === e.length) return;
                const r = t1.getOrder(), n = t1.getClipMask();
                for (const t1 of e){
                    if (!t1.footprint) continue;
                    const e = Rf(t1.footprint.min, t1.footprint.max, t1.id);
                    this._activeRegions.push({
                        min: e.min,
                        max: e.max,
                        hiddenByOverlap: !1,
                        priority: this._sourceIds.length,
                        tileId: t1.id,
                        footprint: t1.footprint,
                        order: r,
                        clipMask: n
                    });
                }
                this._sourceIds.push(t1.getSourceId());
            }
            _computeReplacement() {
                this._activeRegions.sort((t1, e)=>t1.priority - e.priority || Ef(t1.min, e.min) || Ef(t1.max, e.max));
                let t1 = this._activeRegions.length !== this._prevRegions.length;
                if (!t1) {
                    let e = 0;
                    for(; !t1 && e !== this._activeRegions.length;){
                        const r = this._activeRegions[e], n = this._prevRegions[e];
                        t1 = r.priority !== n.priority || !Bf(r, n) || r.order !== n.order || r.clipMask !== n.clipMask, ++e;
                    }
                }
                if (t1) {
                    ++this._updateTime;
                    for (const t1 of this._activeRegions)t1.order !== 1 / 0 && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, t1.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, t1.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, t1.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, t1.max.y));
                    const t1 = (t1)=>{
                        const e = this._activeRegions;
                        if (t1 >= e.length) return t1;
                        const r = e[t1].priority;
                        for(; t1 < e.length && e[t1].priority === r;)++t1;
                        return t1;
                    };
                    if (this._sourceIds.length > 1) {
                        let e = 0, r = t1(e);
                        for(; e !== r;){
                            let n = e;
                            const i = e;
                            for(; n !== r;){
                                const t1 = this._activeRegions[n];
                                t1.hiddenByOverlap = !1;
                                for(let e = 0; e < i; e++){
                                    const r = this._activeRegions[e];
                                    if (!r.hiddenByOverlap && t1.order === 1 / 0 && Df(t1, r) && (t1.hiddenByOverlap = Of(t1.footprint, t1.tileId, r.footprint, r.tileId), t1.hiddenByOverlap)) break;
                                }
                                ++n;
                            }
                            e = r, r = t1(e);
                        }
                    }
                }
            }
            _setSources(t1) {
                [this._prevRegions, this._activeRegions] = [
                    this._activeRegions,
                    []
                ], this._sourceIds = [];
                for(let e = t1.length - 1; e >= 0; e--)this._addSource(t1[e]);
                this._computeReplacement();
            }
        }, t1.cp = Vl, t1.cq = tx, t1.cr = au, t1.cs = class {
            constructor(t1){
                this._createGrid(t1), this._createPoles(t1);
            }
            destroy() {
                this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
                for (const t1 of this._poleSegments)t1.destroy();
                for (const t1 of this._gridSegments)t1.withSkirts.destroy(), t1.withoutSkirts.destroy();
            }
            _fillGridMeshWithLods(t1, e) {
                const r = new Cl, n = new Ql, i = [], s = t1 + 1 + 2, a = e[0] + 1, o = e[0] + 1 + (1 + e.length), l = (t1, e, r)=>{
                    let n = t1 === s - 1 ? t1 - 2 : 0 === t1 ? t1 : t1 - 1;
                    return n += r ? 24575 : 0, [
                        n,
                        e
                    ];
                };
                for(let t1 = 0; t1 < s; ++t1)r.emplaceBack(...l(t1, 0, !0));
                for(let t1 = 0; t1 < a; ++t1)for(let e = 0; e < s; ++e)r.emplaceBack(...l(e, t1, (0 === e || e === s - 1) && !0));
                for(let t1 = 0; t1 < e.length; ++t1){
                    const n = e[t1];
                    for(let t1 = 0; t1 < s; ++t1)r.emplaceBack(...l(t1, n, !0));
                }
                for(let t1 = 0; t1 < e.length; ++t1){
                    const a = n.length, l = e[t1] + 1 + 2, u = new Ql;
                    for(let r = 0; r < l - 1; r++){
                        const i = r === l - 2, a = i ? s * (o - e.length + t1 - r) : s;
                        for(let t1 = 0; t1 < s - 1; t1++){
                            const e = r * s + t1;
                            0 === r || i || 0 === t1 || t1 === s - 2 ? (u.emplaceBack(e + 1, e, e + a), u.emplaceBack(e + a, e + a + 1, e + 1)) : (n.emplaceBack(e + 1, e, e + a), n.emplaceBack(e + a, e + a + 1, e + 1));
                        }
                    }
                    const c = Au.simpleSegment(0, a, r.length, n.length - a);
                    for(let t1 = 0; t1 < u.uint16.length; t1 += 3)n.emplaceBack(u.uint16[t1], u.uint16[t1 + 1], u.uint16[t1 + 2]);
                    const h = Au.simpleSegment(0, a, r.length, n.length - a);
                    i.push({
                        withoutSkirts: c,
                        withSkirts: h
                    });
                }
                return {
                    vertices: r,
                    indices: n,
                    segments: i
                };
            }
            _createGrid(t1) {
                const e = this._fillGridMeshWithLods(oc, lc);
                this._gridSegments = e.segments, this._gridBuffer = t1.createVertexBuffer(e.vertices, kh.members), this._gridIndexBuffer = t1.createIndexBuffer(e.indices, !0);
            }
            _createPoles(t1) {
                const e = new Ql;
                for(let t1 = 0; t1 <= oc; t1++)e.emplaceBack(0, t1 + 1, t1 + 2);
                this._poleIndexBuffer = t1.createIndexBuffer(e, !0);
                const r = new ru, n = new ru, i = new ru, s = new ru;
                this._poleSegments = [];
                for(let t1 = 0, e = 0; t1 < ic; t1++){
                    const a = 360 / (1 << t1);
                    r.emplaceBack(0, -nc, 0, .5, 0), n.emplaceBack(0, -nc, 0, .5, 1), i.emplaceBack(0, -nc, 0, .5, .5), s.emplaceBack(0, -nc, 0, .5, .5);
                    for(let t1 = 0; t1 <= oc; t1++){
                        let e = t1 / oc, o = 0;
                        const l = Gn(0, a, e), [u, c, h] = hc(Qh, tp, l, nc);
                        r.emplaceBack(u, c, h, e, o), n.emplaceBack(u, c, h, e, 1 - o);
                        const p = $e(l);
                        e = .5 + .5 * Math.sin(p), o = .5 + .5 * Math.cos(p), i.emplaceBack(u, c, h, e, o), s.emplaceBack(u, c, h, e, 1 - o);
                    }
                    this._poleSegments.push(Au.simpleSegment(e, 0, 66, 64)), e += 66;
                }
                this._poleNorthVertexBuffer = t1.createVertexBuffer(r, Ih, !1), this._poleSouthVertexBuffer = t1.createVertexBuffer(n, Ih, !1), this._texturedPoleNorthVertexBuffer = t1.createVertexBuffer(i, Ih, !1), this._texturedPoleSouthVertexBuffer = t1.createVertexBuffer(s, Ih, !1);
            }
            getGridBuffers(t1, e) {
                return [
                    this._gridBuffer,
                    this._gridIndexBuffer,
                    e ? this._gridSegments[t1].withSkirts : this._gridSegments[t1].withoutSkirts
                ];
            }
            getPoleBuffers(t1, e) {
                return [
                    e ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer,
                    e ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer,
                    this._poleIndexBuffer,
                    this._poleSegments[t1]
                ];
            }
        }, t1.ct = function(t1) {
            return In.has(t1);
        }, t1.cu = td, t1.cv = function(t1, e, r = 0, n = !0) {
            const i = new Ne(r, r), s = t1.sub(i), a = e.add(i), o = [
                s,
                new Ne(a.x, s.y),
                a,
                new Ne(s.x, a.y)
            ];
            return n && o.push(s.clone()), o;
        }, t1.cw = function(t1, e) {
            const r = [];
            for(let n = 0; n < t1.length; n++){
                const i = Je(n - 1, -1, t1.length - 1), s = Je(n + 1, -1, t1.length - 1), a = t1[n], o = t1[s], l = t1[i].sub(a).unit(), u = o.sub(a).unit(), c = u.angleWithSep(l.x, l.y), h = l.add(u).unit().mult(-1 * e / Math.sin(c / 2));
                r.push(a.add(h));
            }
            return r;
        }, t1.cx = ig, t1.cy = oh, t1.cz = function(e, r, n = 0) {
            return t1._.fromValues(((r.x - n) * e.scale - e.x) * ps, (r.y * e.scale - e.y) * ps, Bc(r.z, r.y));
        }, t1.d = Cn, t1.d$ = Fe, t1.d0 = Ze, t1.d1 = function() {
            return !!document.fullscreenElement || !!document.webkitFullscreenElement;
        }, t1.d2 = He, t1.d3 = Vc, t1.d4 = pc, t1.d5 = function([t1, e, r]) {
            const n = Math.hypot(t1, e, r), i = Math.atan2(t1, r), s = .5 * Math.PI - Math.acos(-e / n);
            return new mc(Ge(i), Ge(s));
        }, t1.d6 = zc, t1.d7 = fc, t1.d8 = n, t1.d9 = Wh, t1.dA = function(t1) {
            const e = Nr();
            if (!e) return;
            const r = e.delete(Vr);
            t1 && r.catch(t1).then(()=>t1());
        }, t1.dB = lv, t1.dC = vv, t1.dD = function(t1) {
            mv = Dr.resolveURL(t1), bv || (bv = new ov(fv(), new Ln)), bv.broadcast("setDracoUrl", mv);
        }, t1.dE = _v, t1.dF = function(t1) {
            gv = Dr.resolveURL(t1), bv || (bv = new ov(fv(), new Ln)), bv.broadcast("setMeshoptUrl", gv);
        }, t1.dG = tr, t1.dH = Mo, t1.dI = pp, t1.dJ = Ey, t1.dK = ng, t1.dL = pu, t1.dM = um, t1.dN = Vm, t1.dO = Kd, t1.dP = ur, t1.dQ = Ty, t1.dR = $g, t1.dS = function(t1, e, r, n, i, s, a, o, l, u, c) {
            t1.createArrays(), t1.tilePixelRatio = ps / (512 * t1.overscaling), t1.compareText = {}, t1.iconsNeedLinear = !1;
            const h = t1.layers[0].layout, p = t1.layers[0]._unevaluatedLayout._values, f = {};
            if ("composite" === t1.textSizeData.kind) {
                const { minZoom: e, maxZoom: r } = t1.textSizeData;
                f.compositeTextSizes = [
                    p["text-size"].possiblyEvaluate(new Ho(e), o),
                    p["text-size"].possiblyEvaluate(new Ho(r), o)
                ];
            }
            if ("composite" === t1.iconSizeData.kind) {
                const { minZoom: e, maxZoom: r } = t1.iconSizeData;
                f.compositeIconSizes = [
                    p["icon-size"].possiblyEvaluate(new Ho(e), o),
                    p["icon-size"].possiblyEvaluate(new Ho(r), o)
                ];
            }
            f.layoutTextSize = p["text-size"].possiblyEvaluate(new Ho(l + 1), o), f.layoutIconSize = p["icon-size"].possiblyEvaluate(new Ho(l + 1), o), f.textMaxSize = p["text-size"].possiblyEvaluate(new Ho(18), o);
            const d = "map" === h.get("text-rotation-alignment") && "point" !== h.get("symbol-placement"), m = h.get("text-size");
            let y = !1;
            for (const e of t1.features)if (e.icon && e.icon.nameSecondary) {
                y = !0;
                break;
            }
            for (const s of t1.features){
                const l = h.get("text-font").evaluate(s, {}, o).join(","), p = m.evaluate(s, {}, o), g = f.layoutTextSize.evaluate(s, {}, o), x = (f.layoutIconSize.evaluate(s, {}, o), {
                    horizontal: {},
                    vertical: void 0
                }), b = s.text;
                let v, _ = [
                    0,
                    0
                ];
                if (b) {
                    const n = b.toString(), a = h.get("text-letter-spacing").evaluate(s, {}, o) * Fm, u = h.get("text-line-height").evaluate(s, {}, o) * Fm, c = zo(n) ? a : 0, f = h.get("text-anchor").evaluate(s, {}, o), m = h.get("text-variable-anchor");
                    if (!m) {
                        const t1 = h.get("text-radial-offset").evaluate(s, {}, o);
                        _ = t1 ? Yy(f, [
                            t1 * Fm,
                            $y
                        ]) : h.get("text-offset").evaluate(s, {}, o).map((t1)=>t1 * Fm);
                    }
                    let y = d ? "center" : h.get("text-justify").evaluate(s, {}, o);
                    const v = "point" === h.get("symbol-placement"), w = v ? h.get("text-max-width").evaluate(s, {}, o) * Fm : 1 / 0, M = (s)=>{
                        t1.allowVerticalPlacement && Po(n) && (x.vertical = ny(b, e, r, i, l, w, u, f, s, c, _, ty.vertical, !0, g, p));
                    };
                    if (!d && m) {
                        const t1 = "auto" === y ? m.map((t1)=>Xy(t1)) : [
                            y
                        ];
                        let n = !1;
                        for(let s = 0; s < t1.length; s++){
                            const a = t1[s];
                            if (!x.horizontal[a]) {
                                if (n) x.horizontal[a] = x.horizontal[0];
                                else {
                                    const t1 = ny(b, e, r, i, l, w, u, "center", a, c, _, ty.horizontal, !1, g, p);
                                    t1 && (x.horizontal[a] = t1, n = 1 === t1.positionedLines.length);
                                }
                            }
                        }
                        M("left");
                    } else {
                        if ("auto" === y && (y = Xy(f)), v || h.get("text-writing-mode").indexOf("horizontal") >= 0 || !Po(n)) {
                            const t1 = ny(b, e, r, i, l, w, u, f, y, c, _, ty.horizontal, !1, g, p);
                            t1 && (x.horizontal[y] = t1);
                        }
                        M(v ? "left" : y);
                    }
                }
                let w = !1;
                if (s.icon && s.icon.namePrimary) {
                    const e = n[s.icon.namePrimary];
                    e && (v = fy(i[s.icon.namePrimary], s.icon.nameSecondary ? i[s.icon.nameSecondary] : void 0, h.get("icon-offset").evaluate(s, {}, o), h.get("icon-anchor").evaluate(s, {}, o)), w = e.sdf, void 0 === t1.sdfIcons ? t1.sdfIcons = e.sdf : t1.sdfIcons !== e.sdf && fr("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e.pixelRatio !== t1.pixelRatio || 0 !== h.get("icon-rotate").constantOr(1)) && (t1.iconsNeedLinear = !0));
                }
                const M = Jy(x.horizontal) || x.vertical;
                t1.iconsInText || (t1.iconsInText = !!M && M.iconsInText), (M || v) && Zy(t1, s, x, v, n, f, g, 0, _, w, a, o, u, c, y);
            }
            s && t1.generateCollisionDebugBuffers(l, t1.collisionBoxArray);
        }, t1.dT = tm, t1.dU = Wp, t1.dV = Af, t1.dW = Bm, t1.dX = Jf, t1.dY = Xx, t1.dZ = Sf, t1.d_ = pf, t1.da = Kh, t1.db = function(e) {
            const r = [
                0,
                0,
                0
            ], n = t1.ad.identity(new Float64Array(16));
            return t1.ad.multiply(n, e.pixelMatrix, e.globeMatrix), t1._.transformMat4(r, r, n), new Ne(r[0], r[1]);
        }, t1.dc = c, t1.dd = u, t1.de = function(t1) {
            const e = t1.navigator ? t1.navigator.userAgent : null;
            return !!function(t1) {
                if (null == Sr) {
                    const e = t1.navigator ? t1.navigator.userAgent : null;
                    Sr = !!t1.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
                }
                return Sr;
            }(t1) && e && (e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
        }, t1.df = nr, t1.dg = class {
            constructor(t1, e, r){
                this._transformRequestFn = t1, this._customAccessToken = e, this._silenceAuthErrors = !!r, this._createSkuToken();
            }
            _createSkuToken() {
                const t1 = function() {
                    let t1 = "";
                    for(let e = 0; e < 10; e++)t1 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                    return {
                        token: [
                            "1",
                            ln,
                            t1
                        ].join(""),
                        tokenExpiresAt: Date.now() + 432e5
                    };
                }();
                this._skuToken = t1.token, this._skuTokenExpiresAt = t1.tokenExpiresAt;
            }
            _isSkuTokenExpired() {
                return Date.now() > this._skuTokenExpiresAt;
            }
            transformRequest(t1, e) {
                return this._transformRequestFn && this._transformRequestFn(t1, e) || {
                    url: t1
                };
            }
            normalizeStyleURL(t1, r) {
                if (!s(t1)) return t1;
                const n = hn(t1);
                return n.params.push(`sdk=js-${e}`), n.path = `/styles/v1${n.path}`, this._makeAPIURL(n, this._customAccessToken || r);
            }
            normalizeGlyphsURL(t1, e) {
                if (!s(t1)) return t1;
                const r = hn(t1);
                return r.path = `/fonts/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e);
            }
            normalizeModelURL(t1, e) {
                if (!s(t1)) return t1;
                const r = hn(t1);
                return r.path = `/models/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e);
            }
            normalizeSourceURL(t1, e, r, n) {
                if (!s(t1)) return t1;
                const i = hn(t1);
                return i.path = `/v4/${i.authority}.json`, i.params.push("secure"), r && i.params.push(`language=${r}`), n && i.params.push(`worldview=${n}`), this._makeAPIURL(i, this._customAccessToken || e);
            }
            normalizeSpriteURL(t1, e, r, n) {
                const i = hn(t1);
                return s(t1) ? (i.path = `/styles/v1${i.path}/sprite${e}${r}`, this._makeAPIURL(i, this._customAccessToken || n)) : (i.path += `${e}${r}`, pn(i));
            }
            normalizeTileURL(t1, e, r) {
                if (this._isSkuTokenExpired() && this._createSkuToken(), t1 && !s(t1)) return t1;
                const i = hn(t1);
                i.path = i.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e || r && "raster" !== i.authority && 512 === r ? "@2x" : ""}${$r.supported ? ".webp" : "$1"}`), "raster" === i.authority ? i.path = `/${n.RASTER_URL_PREFIX}${i.path}` : "rasterarrays" === i.authority ? i.path = `/${n.RASTERARRAYS_URL_PREFIX}${i.path}` : "3dtiles" === i.authority ? i.path = `/${n.TILES3D_URL_PREFIX}${i.path}` : (i.path = i.path.replace(/^.+\/v4\//, "/"), i.path = `/${n.TILE_URL_VERSION}${i.path}`);
                const a = this._customAccessToken || function(t1) {
                    for (const e of t1){
                        const t1 = e.match(/^access_token=(.*)$/);
                        if (t1) return t1[1];
                    }
                    return null;
                }(i.params) || n.ACCESS_TOKEN;
                return n.REQUIRE_ACCESS_TOKEN && a && this._skuToken && i.params.push(`sku=${this._skuToken}`), this._makeAPIURL(i, a);
            }
            canonicalizeTileURL(t1, e) {
                const r = hn(t1);
                if (!r.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !r.path.match(/\.[\w]+$/)) return t1;
                let i = "mapbox://";
                r.path.match(/^\/raster\/v1\//) ? i += `raster/${r.path.replace(`/${n.RASTER_URL_PREFIX}/`, "")}` : r.path.match(/^\/rasterarrays\/v1\//) ? i += `rasterarrays/${r.path.replace(`/${n.RASTERARRAYS_URL_PREFIX}/`, "")}` : i += `tiles/${r.path.replace(`/${n.TILE_URL_VERSION}/`, "")}`;
                let s = r.params;
                return e && (s = s.filter((t1)=>!t1.match(/^access_token=/))), s.length && (i += `?${s.join("&")}`), i;
            }
            canonicalizeTileset(t1, e) {
                const r = !!e && s(e), n = [];
                for (const e of t1.tiles || [])i(e) ? n.push(this.canonicalizeTileURL(e, r)) : n.push(e);
                return n;
            }
            _makeAPIURL(t1, e) {
                const r = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", i = hn(n.API_URL);
                if (t1.protocol = i.protocol, t1.authority = i.authority, "http" === t1.protocol) {
                    const e = t1.params.indexOf("secure");
                    e >= 0 && t1.params.splice(e, 1);
                }
                if ("/" !== i.path && (t1.path = `${i.path}${t1.path}`), !n.REQUIRE_ACCESS_TOKEN) return pn(t1);
                if (e = e || n.ACCESS_TOKEN, !this._silenceAuthErrors) {
                    if (!e) throw new Error(`An API access token is required to use Mapbox GL. ${r}`);
                    if ("s" === e[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r}`);
                }
                return t1.params = t1.params.filter((t1)=>-1 === t1.indexOf("access_token")), t1.params.push(`access_token=${e || ""}`), pn(t1);
            }
        }, t1.dh = function(t1, e) {
            e ? In.add(t1) : In.delete(t1);
        }, t1.di = $r, t1.dj = Mn, t1.dk = Sn, t1.dl = un, t1.dm = bn, t1.dn = _n, t1.dp = function(t1) {
            In.delete(t1);
        }, t1.dq = An, t1.dr = xn, t1.ds = Qe, t1.dt = e, t1.du = function(t1, e) {
            Lr = t1, Or = e;
        }, t1.dv = function(t1, e, r = !1) {
            if (No === Lo || No === Oo || No === Fo) throw new Error("setRTLTextPlugin cannot be called multiple times.");
            jo = Dr.resolveURL(t1), No = Lo, Uo = e, $o(), r || Xo();
        }, t1.dw = Yo, t1.dx = function() {
            fv().acquire(cv);
        }, t1.dy = function() {
            const t1 = pv;
            t1 && (t1.isPreloaded() && 1 === t1.numActive() ? (t1.release(cv), pv = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, t1.dz = hv, t1.e = Dr, t1.e0 = hm, t1.e1 = p, t1.e2 = en, t1.e3 = function(t1) {
            let e = 0;
            if (new Uint32Array(t1, 0, 1)[0] !== zv) {
                const r = new Uint32Array(t1, 0, 7), [, , n, i, s, a] = r;
                e = r.byteLength + i + s + a + s, (n !== t1.byteLength || e >= t1.byteLength) && fr("Invalid b3dm header information.");
            }
            return Vv(t1, e);
        }, t1.e4 = function(t1, e) {
            const r = $v(t1);
            for (const t1 of r){
                for (const e of t1.meshes)Gv(e);
                t1.lights && (t1.lightMeshIndex = t1.meshes.length, t1.meshes.push(Yv(t1.lights, e)));
            }
            return r;
        }, t1.e5 = Qv, t1.e6 = av, t1.e7 = Zo, t1.e8 = function(t1) {
            jr(), Fr && Fr.then((e)=>{
                e.keys().then((r)=>{
                    for(let n = 0; n < r.length - t1; n++)e.delete(r[n]);
                });
            });
        }, t1.f = Dn, t1.g = function(t1, e) {
            return tn(er(t1, {
                type: "json"
            }), e);
        }, t1.h = on, t1.i = fp, t1.j = Ay, t1.k = Iy, t1.l = function(t1) {
            return fetch(t1).then((t1)=>t1.arrayBuffer()).then((e)=>Vv(e, 0, t1));
        }, t1.m = class extends qb {
        }, t1.n = Ti, t1.o = Zn, t1.p = ex, t1.q = Wa, t1.r = Qa, t1.s = to, t1.t = co, t1.u = ul, t1.v = cl, t1.w = fr, t1.x = mo, t1.y = ho, t1.z = Xs;
    });
    define([
        "./shared"
    ], function(e) {
        function t1(e) {
            const t1 = e ? e.url.toString() : void 0;
            return t1 ? performance.getEntriesByName(t1) : [];
        }
        function s(e) {
            if ("number" == typeof e || "boolean" == typeof e || "string" == typeof e || null == e) return JSON.stringify(e);
            if (Array.isArray(e)) {
                let t1 = "[";
                for (const o of e)t1 += `${s(o)},`;
                return `${t1}]`;
            }
            let t1 = "{";
            for (const o of Object.keys(e).sort())t1 += `${o}:${s(e[o])},`;
            return `${t1}}`;
        }
        function o(t1) {
            let o = "";
            for (const i of e.cE)o += `/${s(t1[i])}`;
            return o;
        }
        class i {
            constructor(e){
                this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e && this.replace(e);
            }
            replace(e, t1) {
                this._layerConfigs = {}, this._layers = {}, this.update(e, [], t1);
            }
            update(t1, s, i) {
                this._options = i;
                for (const s of t1)this._layerConfigs[s.id] = s, (this._layers[s.id] = e.cY(s, this.scope, null, this._options)).compileFilter(), this.keyCache[s.id] && delete this.keyCache[s.id];
                for (const e of s)delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e];
                this.familiesBySource = {};
                const n = function(e, t1) {
                    const s = {};
                    for(let i = 0; i < e.length; i++){
                        const n = t1 && t1[e[i].id] || o(e[i]);
                        t1 && (t1[e[i].id] = n);
                        let r = s[n];
                        r || (r = s[n] = []), r.push(e[i]);
                    }
                    const i = [];
                    for(const e in s)i.push(s[e]);
                    return i;
                }(e.dG(this._layerConfigs), this.keyCache);
                for (const e of n){
                    const t1 = e.map((e)=>this._layers[e.id]), s = t1[0];
                    if ("none" === s.visibility) continue;
                    const o = s.source || "";
                    let i = this.familiesBySource[o];
                    i || (i = this.familiesBySource[o] = {});
                    const n = s.sourceLayer || "_geojsonTileLayer";
                    let r = i[n];
                    r || (r = i[n] = []), r.push(t1);
                }
            }
        }
        const n = 1 * e.dJ;
        class r {
            constructor(t1){
                const s = {}, o = [];
                for(const e in t1){
                    const i = t1[e], r = s[e] = {};
                    for(const e in i.glyphs){
                        const t1 = i.glyphs[+e];
                        if (!t1 || 0 === t1.bitmap.width || 0 === t1.bitmap.height) continue;
                        const s = t1.metrics.localGlyph ? n : 1, a = {
                            x: 0,
                            y: 0,
                            w: t1.bitmap.width + 2 * s,
                            h: t1.bitmap.height + 2 * s
                        };
                        o.push(a), r[e] = a;
                    }
                }
                const { w: i, h: r } = e.j(o), a = new e.dI({
                    width: i || 1,
                    height: r || 1
                });
                for(const o in t1){
                    const i = t1[o];
                    for(const t1 in i.glyphs){
                        const r = i.glyphs[+t1];
                        if (!r || 0 === r.bitmap.width || 0 === r.bitmap.height) continue;
                        const l = s[o][t1], c = r.metrics.localGlyph ? n : 1;
                        e.dI.copy(r.bitmap, a, {
                            x: 0,
                            y: 0
                        }, {
                            x: l.x + c,
                            y: l.y + c
                        }, r.bitmap);
                    }
                }
                this.image = a, this.positions = s;
            }
        }
        e.dH(r, "GlyphAtlas");
        class a {
            constructor(t1){
                this.tileID = new e.aL(t1.tileID.overscaledZ, t1.tileID.wrap, t1.tileID.canonical.z, t1.tileID.canonical.x, t1.tileID.canonical.y), this.tileZoom = t1.tileZoom, this.uid = t1.uid, this.zoom = t1.zoom, this.lut = t1.lut, this.canonical = t1.tileID.canonical, this.pixelRatio = t1.pixelRatio, this.tileSize = t1.tileSize, this.source = t1.source, this.scope = t1.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t1.showCollisionBoxes, this.collectResourceTiming = !!t1.collectResourceTiming, this.promoteId = t1.promoteId, this.isSymbolTile = t1.isSymbolTile, this.tileTransform = e.dK(t1.tileID.canonical, t1.projection), this.projection = t1.projection, this.brightness = t1.brightness, this.extraShadowCaster = !!t1.extraShadowCaster, this.tessellationStep = t1.tessellationStep;
            }
            parse(t1, s, o, i, n) {
                this.status = "parsing", this.data = t1, this.collisionBoxArray = new e.dL;
                const a = new e.dM(Object.keys(t1.layers).sort()), c = new e.dN(this.tileID, this.promoteId);
                c.bucketLayerIDs = [];
                const h = {}, u = new e.dO(256, 256), d = {
                    featureIndex: c,
                    iconDependencies: {},
                    patternDependencies: {},
                    glyphDependencies: {},
                    lineAtlas: u,
                    availableImages: o,
                    brightness: this.brightness
                }, f = s.familiesBySource[this.source];
                for(const s in f){
                    const i = t1.layers[s];
                    if (!i) continue;
                    let n = !1, r = !1, u = !1;
                    for (const e of f[s])"symbol" === e[0].type ? n = !0 : r = !0, e[0].is3D() && "model" !== e[0].type && (u = !0);
                    if (this.extraShadowCaster && !u) continue;
                    if (!0 === this.isSymbolTile && !n) continue;
                    if (!1 === this.isSymbolTile && !r) continue;
                    1 === i.version && e.w(`Vector tile source "${this.source}" layer "${s}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                    const p = a.encode(s), g = [];
                    for(let e = 0; e < i.length; e++){
                        const t1 = i.feature(e), o = c.getId(t1, s);
                        g.push({
                            feature: t1,
                            id: o,
                            index: e,
                            sourceLayerIndex: p
                        });
                    }
                    for (const e of f[s]){
                        const t1 = e[0];
                        (!this.extraShadowCaster || t1.is3D() && "model" !== t1.type) && (void 0 !== this.isSymbolTile && "symbol" === t1.type !== this.isSymbolTile || t1.minzoom && this.zoom < Math.floor(t1.minzoom) || t1.maxzoom && this.zoom >= t1.maxzoom || "none" !== t1.visibility && (l(e, this.zoom, d.brightness, o), (h[t1.id] = t1.createBucket({
                            index: c.bucketLayerIDs.length,
                            layers: e,
                            zoom: this.zoom,
                            lut: this.lut,
                            canonical: this.canonical,
                            pixelRatio: this.pixelRatio,
                            overscaling: this.overscaling,
                            collisionBoxArray: this.collisionBoxArray,
                            sourceLayerIndex: p,
                            sourceID: this.source,
                            projection: this.projection.spec,
                            tessellationStep: this.tessellationStep
                        })).populate(g, d, this.tileID.canonical, this.tileTransform), c.bucketLayerIDs.push(e.map((e)=>e.id))));
                    }
                }
                let p, g, m, y;
                u.trim();
                const x = {
                    type: "maybePrepare",
                    isSymbolTile: this.isSymbolTile,
                    zoom: this.zoom
                }, w = ()=>{
                    if (p) return this.status = "done", n(p);
                    if (this.extraShadowCaster) this.status = "done", n(null, {
                        buckets: e.dG(h).filter((e)=>!e.isEmpty()),
                        featureIndex: c,
                        collisionBoxArray: null,
                        glyphAtlasImage: null,
                        lineAtlas: null,
                        imageAtlas: null,
                        brightness: d.brightness,
                        glyphMap: null,
                        iconMap: null,
                        glyphPositions: null
                    });
                    else if (g && m && y) {
                        const t1 = new r(g), s = new e.dQ(m, y, this.lut);
                        for(const i in h){
                            const n = h[i];
                            n instanceof e.dR ? (l(n.layers, this.zoom, d.brightness, o), e.dS(n, g, t1.positions, m, s.iconPositions, this.showCollisionBoxes, o, this.tileID.canonical, this.tileZoom, this.projection, this.brightness)) : n.hasPattern && (n instanceof e.dT || n instanceof e.dU || n instanceof e.b_) && (l(n.layers, this.zoom, d.brightness, o), n.addFeatures(d, this.tileID.canonical, s.patternPositions, o, this.tileTransform, this.brightness));
                        }
                        this.status = "done", n(null, {
                            buckets: e.dG(h).filter((e)=>!e.isEmpty()),
                            featureIndex: c,
                            collisionBoxArray: this.collisionBoxArray,
                            glyphAtlasImage: t1.image,
                            lineAtlas: u,
                            imageAtlas: s,
                            brightness: d.brightness
                        });
                    }
                };
                if (!this.extraShadowCaster) {
                    const t1 = e.dP(d.glyphDependencies, (e)=>Object.keys(e).map(Number));
                    Object.keys(t1).length ? i.send("getGlyphs", {
                        uid: this.uid,
                        stacks: t1,
                        scope: this.scope
                    }, (e, t1)=>{
                        p || (p = e, g = t1, w());
                    }, void 0, !1, x) : g = {};
                    const s = Object.keys(d.iconDependencies);
                    s.length ? i.send("getImages", {
                        icons: s,
                        source: this.source,
                        scope: this.scope,
                        tileID: this.tileID,
                        type: "icons"
                    }, (e, t1)=>{
                        p || (p = e, m = t1, w());
                    }, void 0, !1, x) : m = {};
                    const o = Object.keys(d.patternDependencies);
                    o.length ? i.send("getImages", {
                        icons: o,
                        source: this.source,
                        scope: this.scope,
                        tileID: this.tileID,
                        type: "patterns"
                    }, (e, t1)=>{
                        p || (p = e, y = t1, w());
                    }, void 0, !1, x) : y = {};
                }
                w();
            }
        }
        function l(t1, s, o, i) {
            const n = new e.X(s, {
                brightness: o
            });
            for (const e of t1)e.recalculate(n, i);
        }
        class c extends e.E {
            constructor(t1, s, o, i, n, r){
                super(), this.actor = t1, this.layerIndex = s, this.availableImages = o, this.loadVectorData = n || e.ap, this.loading = {}, this.loaded = {}, this.deduped = new e.ao(t1.scheduler), this.isSpriteLoaded = i, this.scheduler = t1.scheduler, this.brightness = r;
            }
            loadTile(s, o) {
                const i = s.uid, n = s && s.request, r = n && n.collectResourceTiming, l = this.loading[i] = new a(s);
                l.abort = this.loadVectorData(s, (a, c)=>{
                    const h = !this.loading[i];
                    if (delete this.loading[i], h || a || !c) return l.status = "done", h || (this.loaded[i] = l), o(a);
                    const u = c.rawData, d = {};
                    c.expires && (d.expires = c.expires), c.cacheControl && (d.cacheControl = c.cacheControl), l.vectorTile = c.vectorTile || new e.dV(new e.dW(u));
                    const f = ()=>{
                        l.parse(l.vectorTile, this.layerIndex, this.availableImages, this.actor, (s, i)=>{
                            if (s || !i) return o(s);
                            const a = {};
                            if (r) {
                                const e = t1(n);
                                e.length > 0 && (a.resourceTiming = JSON.parse(JSON.stringify(e)));
                            }
                            o(null, e.W({
                                rawTileData: u.slice(0)
                            }, i, d, a));
                        });
                    };
                    this.isSpriteLoaded ? f() : this.once("isSpriteLoaded", ()=>{
                        this.scheduler ? this.scheduler.add(f, {
                            type: "parseTile",
                            isSymbolTile: s.isSymbolTile,
                            zoom: s.tileZoom
                        }) : f();
                    }), this.loaded = this.loaded || {}, this.loaded[i] = l;
                });
            }
            reloadTile(t1, s) {
                const o = this.loaded, i = t1.uid;
                if (o && o[i]) {
                    const n = o[i];
                    n.showCollisionBoxes = t1.showCollisionBoxes, n.projection = t1.projection, n.brightness = t1.brightness, n.tileTransform = e.dK(t1.tileID.canonical, t1.projection), n.extraShadowCaster = t1.extraShadowCaster, n.lut = t1.lut;
                    const r = (e, t1)=>{
                        const o = n.reloadCallback;
                        o && (delete n.reloadCallback, n.parse(n.vectorTile, this.layerIndex, this.availableImages, this.actor, o)), s(e, t1);
                    };
                    "parsing" === n.status ? n.reloadCallback = r : "done" === n.status && (n.vectorTile ? n.parse(n.vectorTile, this.layerIndex, this.availableImages, this.actor, r) : r());
                } else s(null, void 0);
            }
            abortTile(e, t1) {
                const s = e.uid, o = this.loading[s];
                o && (o.abort && o.abort(), delete this.loading[s]), t1();
            }
            removeTile(e, t1) {
                const s = this.loaded, o = e.uid;
                s && s[o] && delete s[o], t1();
            }
        }
        class h {
            loadTile(t1, s) {
                const { uid: o, encoding: i, rawImageData: n, padding: r } = t1, a = ImageBitmap && n instanceof ImageBitmap ? this.getImageData(n, r) : n;
                s(null, new e.dX(o, a, i, r < 1));
            }
            getImageData(e, t1) {
                this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width, e.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", {
                    willReadFrequently: !0
                })), this.offscreenCanvas.width = e.width, this.offscreenCanvas.height = e.height, this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height);
                const s = this.offscreenCanvasContext.getImageData(-t1, -t1, e.width + 2 * t1, e.height + 2 * t1);
                return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), s;
            }
        }
        class u {
            decodeRasterArray({ task: t1, buffer: s }, o) {
                e.dY.performDecoding(s, t1).then((e)=>{
                    o(null, e);
                }, (e)=>{
                    o(e);
                });
            }
        }
        const d = e.dZ.prototype.toGeoJSON;
        let f = class {
            constructor(t1){
                this._feature = t1, this.extent = e.a3, this.type = t1.type, this.properties = t1.tags, "id" in t1 && !isNaN(t1.id) && (this.id = parseInt(t1.id, 10));
            }
            loadGeometry() {
                if (1 === this._feature.type) {
                    const t1 = [];
                    for (const s of this._feature.geometry)t1.push([
                        new e.P(s[0], s[1])
                    ]);
                    return t1;
                }
                {
                    const t1 = [];
                    for (const s of this._feature.geometry){
                        const o = [];
                        for (const t1 of s)o.push(new e.P(t1[0], t1[1]));
                        t1.push(o);
                    }
                    return t1;
                }
            }
            toGeoJSON(e, t1, s) {
                return d.call(this, e, t1, s);
            }
        }, p = class {
            constructor(t1){
                this.layers = {
                    _geojsonTileLayer: this
                }, this.name = "_geojsonTileLayer", this.extent = e.a3, this.length = t1.length, this._features = t1;
            }
            feature(e) {
                return new f(this._features[e]);
            }
        };
        const g = 64 / 4096;
        class m {
            constructor(){
                this.features = new Map;
            }
            clear() {
                this.features.clear();
            }
            load(e = [], t1) {
                for (const s of e){
                    const e = s.id;
                    if (null == e) continue;
                    let o = this.features.get(e);
                    o && this.updateCache(o, t1), s.geometry ? (o = x(s), this.updateCache(o, t1), this.features.set(e, o)) : this.features.delete(e), this.updateCache(o, t1);
                }
            }
            updateCache(e, t1) {
                for (const { canonical: s, uid: o } of Object.values(t1)){
                    const { z: i, x: n, y: r } = s;
                    y(e, Math.pow(2, i), n, r) && delete t1[o];
                }
            }
            getTile(e, t1, s) {
                const o = Math.pow(2, e), i = [];
                for (const e of this.features.values())y(e, o, t1, s) && i.push(v(e, o, t1, s));
                return {
                    features: i
                };
            }
            getFeatures() {
                return [
                    ...this.features.values()
                ];
            }
        }
        function y({ minX: e, minY: t1, maxX: s, maxY: o }, i, n, r) {
            return e < (n + 1 + g) / i && t1 < (r + 1 + g) / i && s > (n - g) / i && o > (r - g) / i;
        }
        function x(e) {
            const { id: t1, geometry: s, properties: o } = e;
            if (!s) return;
            if ("GeometryCollection" === s.type) throw new Error("GeometryCollection not supported in dynamic mode.");
            const { type: i, coordinates: n } = s, r = {
                id: t1,
                type: 1,
                geometry: [],
                tags: o,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            }, a = r.geometry;
            if ("Point" === i) w(n, a, r);
            else if ("MultiPoint" === i) for (const e of n)w(e, a, r);
            else if ("LineString" === i) r.type = 2, S(n, a, r);
            else if ("MultiLineString" === i) r.type = 2, b(n, a, r);
            else if ("Polygon" === i) r.type = 3, b(n, a, r, !0);
            else {
                if ("MultiPolygon" !== i) throw new Error("Input data is not a valid GeoJSON object.");
                r.type = 3;
                for (const e of n)b(e, a, r, !0);
            }
            return r;
        }
        function w([t1, s], o, i) {
            const n = e.aj(t1);
            let r = e.ak(s);
            r = r < 0 ? 0 : r > 1 ? 1 : r, o.push(n, r), i.minX = Math.min(i.minX, n), i.minY = Math.min(i.minY, r), i.maxX = Math.max(i.maxX, n), i.maxY = Math.max(i.maxY, r);
        }
        function S(e, t1, s, o = !1, i = !1) {
            const n = [];
            for (const t1 of e)w(t1, n, s);
            t1.push(n), o && function(e, t1) {
                let s = 0;
                for(let t1 = 0, o = e.length, i = o - 2; t1 < o; i = t1, t1 += 2)s += (e[t1] - e[i]) * (e[t1 + 1] + e[i + 1]);
                if (s > 0 === t1) for(let t1 = 0, s = e.length; t1 < s / 2; t1 += 2){
                    const o = e[t1], i = e[t1 + 1];
                    e[t1] = e[s - 2 - t1], e[t1 + 1] = e[s - 1 - t1], e[s - 2 - t1] = o, e[s - 1 - t1] = i;
                }
            }(n, i);
        }
        function b(e, t1, s, o = !1) {
            for(let i = 0; i < e.length; i++)S(e[i], t1, s, o, 0 === i);
        }
        function v(e, t1, s, o) {
            const { id: i, type: n, geometry: r, tags: a } = e, l = [];
            if (1 === n) I(r, t1, s, o, l);
            else for (const e of r)l.push(I(e, t1, s, o));
            return {
                id: i,
                type: n,
                geometry: l,
                tags: a
            };
        }
        function I(e, t1, s, o, i = []) {
            for(let n = 0; n < e.length; n += 2)i.push(M(e[n], e[n + 1], t1, s, o));
            return i;
        }
        function M(t1, s, o, i, n) {
            return [
                Math.round(e.a3 * (t1 * o - i)),
                Math.round(e.a3 * (s * o - n))
            ];
        }
        var k = {
            exports: {}
        }, T = e.d$, P = e.d_.VectorTileFeature, C = _;
        function _(e, t1) {
            this.options = t1 || {}, this.features = e, this.length = e.length;
        }
        function L(e, t1) {
            this.id = "number" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [
                e.geometry
            ] : e.geometry, this.properties = e.tags, this.extent = t1 || 4096;
        }
        _.prototype.feature = function(e) {
            return new L(this.features[e], this.options.extent);
        }, L.prototype.loadGeometry = function() {
            var e = this.rawGeometry;
            this.geometry = [];
            for(var t1 = 0; t1 < e.length; t1++){
                for(var s = e[t1], o = [], i = 0; i < s.length; i++)o.push(new T(s[i][0], s[i][1]));
                this.geometry.push(o);
            }
            return this.geometry;
        }, L.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for(var e = this.geometry, t1 = 1 / 0, s = -1 / 0, o = 1 / 0, i = -1 / 0, n = 0; n < e.length; n++)for(var r = e[n], a = 0; a < r.length; a++){
                var l = r[a];
                t1 = Math.min(t1, l.x), s = Math.max(s, l.x), o = Math.min(o, l.y), i = Math.max(i, l.y);
            }
            return [
                t1,
                o,
                s,
                i
            ];
        }, L.prototype.toGeoJSON = P.prototype.toGeoJSON;
        var D = e.e0, j = C;
        function O(e) {
            var t1 = new D;
            return function(e, t1) {
                for(var s in e.layers)t1.writeMessage(3, z, e.layers[s]);
            }(e, t1), t1.finish();
        }
        function z(e, t1) {
            var s;
            t1.writeVarintField(15, e.version || 1), t1.writeStringField(1, e.name || ""), t1.writeVarintField(5, e.extent || 4096);
            var o = {
                keys: [],
                values: [],
                keycache: {},
                valuecache: {}
            };
            for(s = 0; s < e.length; s++)o.feature = e.feature(s), t1.writeMessage(2, Z, o);
            var i = o.keys;
            for(s = 0; s < i.length; s++)t1.writeStringField(3, i[s]);
            var n = o.values;
            for(s = 0; s < n.length; s++)t1.writeMessage(4, Y, n[s]);
        }
        function Z(e, t1) {
            var s = e.feature;
            void 0 !== s.id && t1.writeVarintField(1, s.id), t1.writeMessage(2, E, e), t1.writeVarintField(3, s.type), t1.writeMessage(4, X, s);
        }
        function E(e, t1) {
            var s = e.feature, o = e.keys, i = e.values, n = e.keycache, r = e.valuecache;
            for(var a in s.properties){
                var l = s.properties[a], c = n[a];
                if (null !== l) {
                    void 0 === c && (o.push(a), n[a] = c = o.length - 1), t1.writeVarint(c);
                    var h = typeof l;
                    "string" !== h && "boolean" !== h && "number" !== h && (l = JSON.stringify(l));
                    var u = h + ":" + l, d = r[u];
                    void 0 === d && (i.push(l), r[u] = d = i.length - 1), t1.writeVarint(d);
                }
            }
        }
        function A(e, t1) {
            return (t1 << 3) + (7 & e);
        }
        function N(e) {
            return e << 1 ^ e >> 31;
        }
        function X(e, t1) {
            for(var s = e.loadGeometry(), o = e.type, i = 0, n = 0, r = s.length, a = 0; a < r; a++){
                var l = s[a], c = 1;
                1 === o && (c = l.length), t1.writeVarint(A(1, c));
                for(var h = 3 === o ? l.length - 1 : l.length, u = 0; u < h; u++){
                    1 === u && 1 !== o && t1.writeVarint(A(2, h - 1));
                    var d = l[u].x - i, f = l[u].y - n;
                    t1.writeVarint(N(d)), t1.writeVarint(N(f)), i += d, n += f;
                }
                3 === o && t1.writeVarint(A(7, 1));
            }
        }
        function Y(e, t1) {
            var s = typeof e;
            "string" === s ? t1.writeStringField(1, e) : "boolean" === s ? t1.writeBooleanField(7, e) : "number" === s && (e % 1 != 0 ? t1.writeDoubleField(3, e) : e < 0 ? t1.writeSVarintField(6, e) : t1.writeVarintField(5, e));
        }
        k.exports = O, k.exports.fromVectorTileJs = O, k.exports.fromGeojsonVt = function(e, t1) {
            t1 = t1 || {};
            var s = {};
            for(var o in e)s[o] = new j(e[o].features, t1), s[o].name = o, s[o].version = t1.version, s[o].extent = t1.extent;
            return O({
                layers: s
            });
        }, k.exports.GeoJSONWrapper = j;
        var F = e.e1(k.exports);
        const G = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: (e)=>e
        }, J = Math.fround || (W = new Float32Array(1), (e)=>(W[0] = +e, W[0]));
        var W;
        const B = 3, R = 5, V = 6;
        class $ {
            constructor(e){
                this.options = Object.assign(Object.create(G), e), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
            }
            load(e) {
                const { log: t1, minZoom: s, maxZoom: o } = this.options;
                t1 && console.time("total time");
                const i = `prepare ${e.length} points`;
                t1 && console.time(i), this.points = e;
                const n = [];
                for(let t1 = 0; t1 < e.length; t1++){
                    const s = e[t1];
                    if (!s.geometry) continue;
                    const [o, i] = s.geometry.coordinates, r = J(K(o)), a = J(H(i));
                    n.push(r, a, 1 / 0, t1, -1, 1), this.options.reduce && n.push(0);
                }
                let r = this.trees[o + 1] = this._createTree(n);
                t1 && console.timeEnd(i);
                for(let e = o; e >= s; e--){
                    const s = +Date.now();
                    r = this.trees[e] = this._createTree(this._cluster(r, e)), t1 && console.log("z%d: %d clusters in %dms", e, r.numItems, +Date.now() - s);
                }
                return t1 && console.timeEnd("total time"), this;
            }
            getClusters(e, t1) {
                let s = ((e[0] + 180) % 360 + 360) % 360 - 180;
                const o = Math.max(-90, Math.min(90, e[1]));
                let i = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;
                const n = Math.max(-90, Math.min(90, e[3]));
                if (e[2] - e[0] >= 360) s = -180, i = 180;
                else if (s > i) {
                    const e = this.getClusters([
                        s,
                        o,
                        180,
                        n
                    ], t1), r = this.getClusters([
                        -180,
                        o,
                        i,
                        n
                    ], t1);
                    return e.concat(r);
                }
                const r = this.trees[this._limitZoom(t1)], a = r.range(K(s), H(n), K(i), H(o)), l = r.data, c = [];
                for (const e of a){
                    const t1 = this.stride * e;
                    c.push(l[t1 + R] > 1 ? U(l, t1, this.clusterProps) : this.points[l[t1 + B]]);
                }
                return c;
            }
            getChildren(e) {
                const t1 = this._getOriginId(e), s = this._getOriginZoom(e), o = "No cluster with the specified id.", i = this.trees[s];
                if (!i) throw new Error(o);
                const n = i.data;
                if (t1 * this.stride >= n.length) throw new Error(o);
                const r = this.options.radius / (this.options.extent * Math.pow(2, s - 1)), a = i.within(n[t1 * this.stride], n[t1 * this.stride + 1], r), l = [];
                for (const t1 of a){
                    const s = t1 * this.stride;
                    n[s + 4] === e && l.push(n[s + R] > 1 ? U(n, s, this.clusterProps) : this.points[n[s + B]]);
                }
                if (0 === l.length) throw new Error(o);
                return l;
            }
            getLeaves(e, t1, s) {
                const o = [];
                return this._appendLeaves(o, e, t1 = t1 || 10, s = s || 0, 0), o;
            }
            getTile(e, t1, s) {
                const o = this.trees[this._limitZoom(e)], i = Math.pow(2, e), { extent: n, radius: r } = this.options, a = r / n, l = (s - a) / i, c = (s + 1 + a) / i, h = {
                    features: []
                };
                return this._addTileFeatures(o.range((t1 - a) / i, l, (t1 + 1 + a) / i, c), o.data, t1, s, i, h), 0 === t1 && this._addTileFeatures(o.range(1 - a / i, l, 1, c), o.data, i, s, i, h), t1 === i - 1 && this._addTileFeatures(o.range(0, l, a / i, c), o.data, -1, s, i, h), h.features.length ? h : null;
            }
            getClusterExpansionZoom(e) {
                let t1 = this._getOriginZoom(e) - 1;
                for(; t1 <= this.options.maxZoom;){
                    const s = this.getChildren(e);
                    if (t1++, 1 !== s.length) break;
                    e = s[0].properties.cluster_id;
                }
                return t1;
            }
            _appendLeaves(e, t1, s, o, i) {
                const n = this.getChildren(t1);
                for (const t1 of n){
                    const n = t1.properties;
                    if (n && n.cluster ? i + n.point_count <= o ? i += n.point_count : i = this._appendLeaves(e, n.cluster_id, s, o, i) : i < o ? i++ : e.push(t1), e.length === s) break;
                }
                return i;
            }
            _createTree(t1) {
                const s = new e.cK(t1.length / this.stride | 0, this.options.nodeSize, Float32Array);
                for(let e = 0; e < t1.length; e += this.stride)s.add(t1[e], t1[e + 1]);
                return s.finish(), s.data = t1, s;
            }
            _addTileFeatures(e, t1, s, o, i, n) {
                for (const r of e){
                    const e = r * this.stride, a = t1[e + R] > 1;
                    let l, c, h;
                    if (a) l = q(t1, e, this.clusterProps), c = t1[e], h = t1[e + 1];
                    else {
                        const s = this.points[t1[e + B]];
                        l = s.properties;
                        const [o, i] = s.geometry.coordinates;
                        c = K(o), h = H(i);
                    }
                    const u = {
                        type: 1,
                        geometry: [
                            [
                                Math.round(this.options.extent * (c * i - s)),
                                Math.round(this.options.extent * (h * i - o))
                            ]
                        ],
                        tags: l
                    };
                    let d;
                    d = a || this.options.generateId ? t1[e + B] : this.points[t1[e + B]].id, void 0 !== d && (u.id = d), n.features.push(u);
                }
            }
            _limitZoom(e) {
                return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));
            }
            _cluster(e, t1) {
                const { radius: s, extent: o, reduce: i, minPoints: n } = this.options, r = s / (o * Math.pow(2, t1)), a = e.data, l = [], c = this.stride;
                for(let s = 0; s < a.length; s += c){
                    if (a[s + 2] <= t1) continue;
                    a[s + 2] = t1;
                    const o = a[s], h = a[s + 1], u = e.within(a[s], a[s + 1], r), d = a[s + R];
                    let f = d;
                    for (const e of u){
                        const s = e * c;
                        a[s + 2] > t1 && (f += a[s + R]);
                    }
                    if (f > d && f >= n) {
                        let e, n = o * d, r = h * d, p = -1;
                        const g = (s / c << 5) + (t1 + 1) + this.points.length;
                        for (const o of u){
                            const l = o * c;
                            if (a[l + 2] <= t1) continue;
                            a[l + 2] = t1;
                            const h = a[l + R];
                            n += a[l] * h, r += a[l + 1] * h, a[l + 4] = g, i && (e || (e = this._map(a, s, !0), p = this.clusterProps.length, this.clusterProps.push(e)), i(e, this._map(a, l)));
                        }
                        a[s + 4] = g, l.push(n / f, r / f, 1 / 0, g, -1, f), i && l.push(p);
                    } else {
                        for(let e = 0; e < c; e++)l.push(a[s + e]);
                        if (f > 1) for (const e of u){
                            const s = e * c;
                            if (!(a[s + 2] <= t1)) {
                                a[s + 2] = t1;
                                for(let e = 0; e < c; e++)l.push(a[s + e]);
                            }
                        }
                    }
                }
                return l;
            }
            _getOriginId(e) {
                return e - this.points.length >> 5;
            }
            _getOriginZoom(e) {
                return (e - this.points.length) % 32;
            }
            _map(e, t1, s) {
                if (e[t1 + R] > 1) {
                    const o = this.clusterProps[e[t1 + V]];
                    return s ? Object.assign({}, o) : o;
                }
                const o = this.points[e[t1 + B]].properties, i = this.options.map(o);
                return s && i === o ? Object.assign({}, i) : i;
            }
        }
        function U(e, t1, s) {
            var o;
            return {
                type: "Feature",
                id: e[t1 + B],
                properties: q(e, t1, s),
                geometry: {
                    type: "Point",
                    coordinates: [
                        (o = e[t1], 360 * (o - .5)),
                        Q(e[t1 + 1])
                    ]
                }
            };
        }
        function q(e, t1, s) {
            const o = e[t1 + R], i = o >= 1e4 ? `${Math.round(o / 1e3)}k` : o >= 1e3 ? Math.round(o / 100) / 10 + "k" : o, n = e[t1 + V], r = -1 === n ? {} : Object.assign({}, s[n]);
            return Object.assign(r, {
                cluster: !0,
                cluster_id: e[t1 + B],
                point_count: o,
                point_count_abbreviated: i
            });
        }
        function K(e) {
            return e / 360 + .5;
        }
        function H(e) {
            const t1 = Math.sin(e * Math.PI / 180), s = .5 - .25 * Math.log((1 + t1) / (1 - t1)) / Math.PI;
            return s < 0 ? 0 : s > 1 ? 1 : s;
        }
        function Q(e) {
            const t1 = (180 - 360 * e) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t1)) / Math.PI - 90;
        }
        function ee(e, t1, s, o) {
            let i = o;
            const n = t1 + (s - t1 >> 1);
            let r, a = s - t1;
            const l = e[t1], c = e[t1 + 1], h = e[s], u = e[s + 1];
            for(let o = t1 + 3; o < s; o += 3){
                const t1 = te(e[o], e[o + 1], l, c, h, u);
                if (t1 > i) r = o, i = t1;
                else if (t1 === i) {
                    const e = Math.abs(o - n);
                    e < a && (r = o, a = e);
                }
            }
            i > o && (r - t1 > 3 && ee(e, t1, r, o), e[r + 2] = i, s - r > 3 && ee(e, r, s, o));
        }
        function te(e, t1, s, o, i, n) {
            let r = i - s, a = n - o;
            if (0 !== r || 0 !== a) {
                const l = ((e - s) * r + (t1 - o) * a) / (r * r + a * a);
                l > 1 ? (s = i, o = n) : l > 0 && (s += r * l, o += a * l);
            }
            return r = e - s, a = t1 - o, r * r + a * a;
        }
        function se(e, t1, s, o) {
            const i = {
                id: e ?? null,
                type: t1,
                geometry: s,
                tags: o,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            };
            if ("Point" === t1 || "MultiPoint" === t1 || "LineString" === t1) oe(i, s);
            else if ("Polygon" === t1) oe(i, s[0]);
            else if ("MultiLineString" === t1) for (const e of s)oe(i, e);
            else if ("MultiPolygon" === t1) for (const e of s)oe(i, e[0]);
            return i;
        }
        function oe(e, t1) {
            for(let s = 0; s < t1.length; s += 3)e.minX = Math.min(e.minX, t1[s]), e.minY = Math.min(e.minY, t1[s + 1]), e.maxX = Math.max(e.maxX, t1[s]), e.maxY = Math.max(e.maxY, t1[s + 1]);
        }
        function ie(e, t1, s, o) {
            if (!t1.geometry) return;
            const i = t1.geometry.coordinates;
            if (i && 0 === i.length) return;
            const n = t1.geometry.type, r = Math.pow(s.tolerance / ((1 << s.maxZoom) * s.extent), 2);
            let a = [], l = t1.id;
            if (s.promoteId ? l = t1.properties[s.promoteId] : s.generateId && (l = o || 0), "Point" === n) ne(i, a);
            else if ("MultiPoint" === n) for (const e of i)ne(e, a);
            else if ("LineString" === n) re(i, a, r, !1);
            else if ("MultiLineString" === n) {
                if (s.lineMetrics) {
                    for (const s of i)a = [], re(s, a, r, !1), e.push(se(l, "LineString", a, t1.properties));
                    return;
                }
                ae(i, a, r, !1);
            } else if ("Polygon" === n) ae(i, a, r, !0);
            else {
                if ("MultiPolygon" !== n) {
                    if ("GeometryCollection" === n) {
                        for (const i of t1.geometry.geometries)ie(e, {
                            id: l,
                            geometry: i,
                            properties: t1.properties
                        }, s, o);
                        return;
                    }
                    throw new Error("Input data is not a valid GeoJSON object.");
                }
                for (const e of i){
                    const t1 = [];
                    ae(e, t1, r, !0), a.push(t1);
                }
            }
            e.push(se(l, n, a, t1.properties));
        }
        function ne(e, t1) {
            t1.push(le(e[0]), ce(e[1]), 0);
        }
        function re(e, t1, s, o) {
            let i, n, r = 0;
            for(let s = 0; s < e.length; s++){
                const a = le(e[s][0]), l = ce(e[s][1]);
                t1.push(a, l, 0), s > 0 && (r += o ? (i * l - a * n) / 2 : Math.sqrt(Math.pow(a - i, 2) + Math.pow(l - n, 2))), i = a, n = l;
            }
            const a = t1.length - 3;
            t1[2] = 1, ee(t1, 0, a, s), t1[a + 2] = 1, t1.size = Math.abs(r), t1.start = 0, t1.end = t1.size;
        }
        function ae(e, t1, s, o) {
            for(let i = 0; i < e.length; i++){
                const n = [];
                re(e[i], n, s, o), t1.push(n);
            }
        }
        function le(e) {
            return e / 360 + .5;
        }
        function ce(e) {
            const t1 = Math.sin(e * Math.PI / 180), s = .5 - .25 * Math.log((1 + t1) / (1 - t1)) / Math.PI;
            return s < 0 ? 0 : s > 1 ? 1 : s;
        }
        function he(e, t1, s, o, i, n, r, a) {
            if (o /= t1, n >= (s /= t1) && r < o) return e;
            if (r < s || n >= o) return null;
            const l = [];
            for (const t1 of e){
                const e = t1.geometry;
                let n = t1.type;
                const r = 0 === i ? t1.minX : t1.minY, c = 0 === i ? t1.maxX : t1.maxY;
                if (r >= s && c < o) {
                    l.push(t1);
                    continue;
                }
                if (c < s || r >= o) continue;
                let h = [];
                if ("Point" === n || "MultiPoint" === n) ue(e, h, s, o, i);
                else if ("LineString" === n) de(e, h, s, o, i, !1, a.lineMetrics);
                else if ("MultiLineString" === n) pe(e, h, s, o, i, !1);
                else if ("Polygon" === n) pe(e, h, s, o, i, !0);
                else if ("MultiPolygon" === n) for (const t1 of e){
                    const e = [];
                    pe(t1, e, s, o, i, !0), e.length && h.push(e);
                }
                if (h.length) {
                    if (a.lineMetrics && "LineString" === n) {
                        for (const e of h)l.push(se(t1.id, n, e, t1.tags));
                        continue;
                    }
                    "LineString" !== n && "MultiLineString" !== n || (1 === h.length ? (n = "LineString", h = h[0]) : n = "MultiLineString"), "Point" !== n && "MultiPoint" !== n || (n = 3 === h.length ? "Point" : "MultiPoint"), l.push(se(t1.id, n, h, t1.tags));
                }
            }
            return l.length ? l : null;
        }
        function ue(e, t1, s, o, i) {
            for(let n = 0; n < e.length; n += 3){
                const r = e[n + i];
                r >= s && r <= o && ge(t1, e[n], e[n + 1], e[n + 2]);
            }
        }
        function de(e, t1, s, o, i, n, r) {
            let a = fe(e);
            const l = 0 === i ? me : ye;
            let c, h, u = e.start;
            for(let d = 0; d < e.length - 3; d += 3){
                const f = e[d], p = e[d + 1], g = e[d + 2], m = e[d + 3], y = e[d + 4], x = 0 === i ? f : p, w = 0 === i ? m : y;
                let S = !1;
                r && (c = Math.sqrt(Math.pow(f - m, 2) + Math.pow(p - y, 2))), x < s ? w > s && (h = l(a, f, p, m, y, s), r && (a.start = u + c * h)) : x > o ? w < o && (h = l(a, f, p, m, y, o), r && (a.start = u + c * h)) : ge(a, f, p, g), w < s && x >= s && (h = l(a, f, p, m, y, s), S = !0), w > o && x <= o && (h = l(a, f, p, m, y, o), S = !0), !n && S && (r && (a.end = u + c * h), t1.push(a), a = fe(e)), r && (u += c);
            }
            let d = e.length - 3;
            const f = e[d], p = e[d + 1], g = 0 === i ? f : p;
            g >= s && g <= o && ge(a, f, p, e[d + 2]), d = a.length - 3, n && d >= 3 && (a[d] !== a[0] || a[d + 1] !== a[1]) && ge(a, a[0], a[1], a[2]), a.length && t1.push(a);
        }
        function fe(e) {
            const t1 = [];
            return t1.size = e.size, t1.start = e.start, t1.end = e.end, t1;
        }
        function pe(e, t1, s, o, i, n) {
            for (const r of e)de(r, t1, s, o, i, n, !1);
        }
        function ge(e, t1, s, o) {
            e.push(t1, s, o);
        }
        function me(e, t1, s, o, i, n) {
            const r = (n - t1) / (o - t1);
            return ge(e, n, s + (i - s) * r, 1), r;
        }
        function ye(e, t1, s, o, i, n) {
            const r = (n - s) / (i - s);
            return ge(e, t1 + (o - t1) * r, n, 1), r;
        }
        function xe(e, t1) {
            const s = [];
            for(let o = 0; o < e.length; o++){
                const i = e[o], n = i.type;
                let r;
                if ("Point" === n || "MultiPoint" === n || "LineString" === n) r = we(i.geometry, t1);
                else if ("MultiLineString" === n || "Polygon" === n) {
                    r = [];
                    for (const e of i.geometry)r.push(we(e, t1));
                } else if ("MultiPolygon" === n) {
                    r = [];
                    for (const e of i.geometry){
                        const s = [];
                        for (const o of e)s.push(we(o, t1));
                        r.push(s);
                    }
                }
                s.push(se(i.id, n, r, i.tags));
            }
            return s;
        }
        function we(e, t1) {
            const s = [];
            s.size = e.size, void 0 !== e.start && (s.start = e.start, s.end = e.end);
            for(let o = 0; o < e.length; o += 3)s.push(e[o] + t1, e[o + 1], e[o + 2]);
            return s;
        }
        function Se(e, t1) {
            if (e.transformed) return e;
            const s = 1 << e.z, o = e.x, i = e.y;
            for (const n of e.features){
                const e = n.geometry, r = n.type;
                if (n.geometry = [], 1 === r) for(let r = 0; r < e.length; r += 2)n.geometry.push(be(e[r], e[r + 1], t1, s, o, i));
                else for(let r = 0; r < e.length; r++){
                    const a = [];
                    for(let n = 0; n < e[r].length; n += 2)a.push(be(e[r][n], e[r][n + 1], t1, s, o, i));
                    n.geometry.push(a);
                }
            }
            return e.transformed = !0, e;
        }
        function be(e, t1, s, o, i, n) {
            return [
                Math.round(s * (e * o - i)),
                Math.round(s * (t1 * o - n))
            ];
        }
        function ve(e, t1, s, o, i) {
            const n = t1 === i.maxZoom ? 0 : i.tolerance / ((1 << t1) * i.extent), r = {
                features: [],
                numPoints: 0,
                numSimplified: 0,
                numFeatures: e.length,
                source: null,
                x: s,
                y: o,
                z: t1,
                transformed: !1,
                minX: 2,
                minY: 1,
                maxX: -1,
                maxY: 0
            };
            for (const t1 of e)Ie(r, t1, n, i);
            return r;
        }
        function Ie(e, t1, s, o) {
            const i = t1.geometry, n = t1.type, r = [];
            if (e.minX = Math.min(e.minX, t1.minX), e.minY = Math.min(e.minY, t1.minY), e.maxX = Math.max(e.maxX, t1.maxX), e.maxY = Math.max(e.maxY, t1.maxY), "Point" === n || "MultiPoint" === n) for(let t1 = 0; t1 < i.length; t1 += 3)r.push(i[t1], i[t1 + 1]), e.numPoints++, e.numSimplified++;
            else if ("LineString" === n) Me(r, i, e, s, !1, !1);
            else if ("MultiLineString" === n || "Polygon" === n) for(let t1 = 0; t1 < i.length; t1++)Me(r, i[t1], e, s, "Polygon" === n, 0 === t1);
            else if ("MultiPolygon" === n) for(let t1 = 0; t1 < i.length; t1++){
                const o = i[t1];
                for(let t1 = 0; t1 < o.length; t1++)Me(r, o[t1], e, s, !0, 0 === t1);
            }
            if (r.length) {
                let s = t1.tags || null;
                if ("LineString" === n && o.lineMetrics) {
                    s = {};
                    for(const e in t1.tags)s[e] = t1.tags[e];
                    s.mapbox_clip_start = i.start / i.size, s.mapbox_clip_end = i.end / i.size;
                }
                const a = {
                    geometry: r,
                    type: "Polygon" === n || "MultiPolygon" === n ? 3 : "LineString" === n || "MultiLineString" === n ? 2 : 1,
                    tags: s
                };
                null !== t1.id && (a.id = t1.id), e.features.push(a);
            }
        }
        function Me(e, t1, s, o, i, n) {
            const r = o * o;
            if (o > 0 && t1.size < (i ? r : o)) return void (s.numPoints += t1.length / 3);
            const a = [];
            for(let e = 0; e < t1.length; e += 3)(0 === o || t1[e + 2] > r) && (s.numSimplified++, a.push(t1[e], t1[e + 1])), s.numPoints++;
            i && function(e, t1) {
                let s = 0;
                for(let t1 = 0, o = e.length, i = o - 2; t1 < o; i = t1, t1 += 2)s += (e[t1] - e[i]) * (e[t1 + 1] + e[i + 1]);
                if (s > 0 === t1) for(let t1 = 0, s = e.length; t1 < s / 2; t1 += 2){
                    const o = e[t1], i = e[t1 + 1];
                    e[t1] = e[s - 2 - t1], e[t1 + 1] = e[s - 1 - t1], e[s - 2 - t1] = o, e[s - 1 - t1] = i;
                }
            }(a, n), e.push(a);
        }
        const ke = {
            maxZoom: 14,
            indexMaxZoom: 5,
            indexMaxPoints: 1e5,
            tolerance: 3,
            extent: 4096,
            buffer: 64,
            lineMetrics: !1,
            promoteId: null,
            generateId: !1,
            debug: 0
        };
        class Te {
            constructor(e, t1){
                const s = (t1 = this.options = function(e, t1) {
                    for(const s in t1)e[s] = t1[s];
                    return e;
                }(Object.create(ke), t1)).debug;
                if (s && console.time("preprocess data"), t1.maxZoom < 0 || t1.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
                if (t1.promoteId && t1.generateId) throw new Error("promoteId and generateId cannot be used together.");
                let o = function(e, t1) {
                    const s = [];
                    if ("FeatureCollection" === e.type) for(let o = 0; o < e.features.length; o++)ie(s, e.features[o], t1, o);
                    else ie(s, "Feature" === e.type ? e : {
                        geometry: e
                    }, t1);
                    return s;
                }(e, t1);
                this.tiles = {}, this.tileCoords = [], s && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t1.indexMaxZoom, t1.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), o = function(e, t1) {
                    const s = t1.buffer / t1.extent;
                    let o = e;
                    const i = he(e, 1, -1 - s, s, 0, -1, 2, t1), n = he(e, 1, 1 - s, 2 + s, 0, -1, 2, t1);
                    return (i || n) && (o = he(e, 1, -s, 1 + s, 0, -1, 2, t1) || [], i && (o = xe(i, 1).concat(o)), n && (o = o.concat(xe(n, -1)))), o;
                }(o, t1), o.length && this.splitTile(o, 0, 0, 0), s && (o.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
            }
            splitTile(e, t1, s, o, i, n, r) {
                const a = [
                    e,
                    t1,
                    s,
                    o
                ], l = this.options, c = l.debug;
                for(; a.length;){
                    o = a.pop(), s = a.pop(), t1 = a.pop(), e = a.pop();
                    const h = 1 << t1, u = Pe(t1, s, o);
                    let d = this.tiles[u];
                    if (!d && (c > 1 && console.time("creation"), d = this.tiles[u] = ve(e, t1, s, o, l), this.tileCoords.push({
                        z: t1,
                        x: s,
                        y: o
                    }), c)) {
                        c > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t1, s, o, d.numFeatures, d.numPoints, d.numSimplified), console.timeEnd("creation"));
                        const e = `z${t1}`;
                        this.stats[e] = (this.stats[e] || 0) + 1, this.total++;
                    }
                    if (d.source = e, null == i) {
                        if (t1 === l.indexMaxZoom || d.numPoints <= l.indexMaxPoints) continue;
                    } else {
                        if (t1 === l.maxZoom || t1 === i) continue;
                        if (null != i) {
                            const e = i - t1;
                            if (s !== n >> e || o !== r >> e) continue;
                        }
                    }
                    if (d.source = null, 0 === e.length) continue;
                    c > 1 && console.time("clipping");
                    const f = .5 * l.buffer / l.extent, p = .5 - f, g = .5 + f, m = 1 + f;
                    let y = null, x = null, w = null, S = null, b = he(e, h, s - f, s + g, 0, d.minX, d.maxX, l), v = he(e, h, s + p, s + m, 0, d.minX, d.maxX, l);
                    e = null, b && (y = he(b, h, o - f, o + g, 1, d.minY, d.maxY, l), x = he(b, h, o + p, o + m, 1, d.minY, d.maxY, l), b = null), v && (w = he(v, h, o - f, o + g, 1, d.minY, d.maxY, l), S = he(v, h, o + p, o + m, 1, d.minY, d.maxY, l), v = null), c > 1 && console.timeEnd("clipping"), a.push(y || [], t1 + 1, 2 * s, 2 * o), a.push(x || [], t1 + 1, 2 * s, 2 * o + 1), a.push(w || [], t1 + 1, 2 * s + 1, 2 * o), a.push(S || [], t1 + 1, 2 * s + 1, 2 * o + 1);
                }
            }
            getTile(e, t1, s) {
                e = +e, t1 = +t1, s = +s;
                const o = this.options, { extent: i, debug: n } = o;
                if (e < 0 || e > 24) return null;
                const r = 1 << e, a = Pe(e, t1 = t1 + r & r - 1, s);
                if (this.tiles[a]) return Se(this.tiles[a], i);
                n > 1 && console.log("drilling down to z%d-%d-%d", e, t1, s);
                let l, c = e, h = t1, u = s;
                for(; !l && c > 0;)c--, h >>= 1, u >>= 1, l = this.tiles[Pe(c, h, u)];
                return l && l.source ? (n > 1 && (console.log("found parent tile z%d-%d-%d", c, h, u), console.time("drilling down")), this.splitTile(l.source, c, h, u, e, t1, s), n > 1 && console.timeEnd("drilling down"), this.tiles[a] ? Se(this.tiles[a], i) : null) : null;
            }
        }
        function Pe(e, t1, s) {
            return 32 * ((1 << e) * s + t1) + e;
        }
        function Ce(e, t1) {
            const s = e.tileID.canonical;
            if (!this._geoJSONIndex) return t1(null, null);
            const o = this._geoJSONIndex.getTile(s.z, s.x, s.y);
            if (!o) return t1(null, null);
            const i = new p(o.features);
            let n = F(i);
            0 === n.byteOffset && n.byteLength === n.buffer.byteLength || (n = new Uint8Array(n)), t1(null, {
                vectorTile: i,
                rawData: n.buffer
            });
        }
        class _e extends c {
            constructor(e, t1, s, o, i, n){
                super(e, t1, s, o, Ce, n), i && (this.loadGeoJSON = i), this._dynamicIndex = new m;
            }
            loadData(s, o) {
                const i = s && s.request, n = i && i.collectResourceTiming;
                this.loadGeoJSON(s, (r, a)=>{
                    if (r || !a) return o(r);
                    if ("object" != typeof a) return o(new Error(`Input data given to '${s.source}' is not a valid GeoJSON object.`));
                    {
                        try {
                            if (s.filter) {
                                const t1 = e.y(s.filter, {
                                    type: "boolean",
                                    "property-type": "data-driven",
                                    overridable: !1,
                                    transition: !1
                                });
                                if ("error" === t1.result) throw new Error(t1.value.map((e)=>`${e.key}: ${e.message}`).join(", "));
                                a.features = a.features.filter((e)=>t1.value.evaluate({
                                        zoom: 0
                                    }, e));
                            }
                            s.dynamic ? ("Feature" === a.type && (a = {
                                type: "FeatureCollection",
                                features: [
                                    a
                                ]
                            }), s.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(a.features, this.loaded), s.cluster && (a.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = s.cluster ? new $(function({ superclusterOptions: t1, clusterProperties: s }) {
                                if (!s || !t1) return t1;
                                const o = {}, i = {}, n = {
                                    accumulated: null,
                                    zoom: 0
                                }, r = {
                                    properties: null
                                }, a = Object.keys(s);
                                for (const t1 of a){
                                    const [n, r] = s[t1], a = e.y(r), l = e.y("string" == typeof n ? [
                                        n,
                                        [
                                            "accumulated"
                                        ],
                                        [
                                            "get",
                                            t1
                                        ]
                                    ] : n);
                                    o[t1] = a.value, i[t1] = l.value;
                                }
                                return t1.map = (e)=>{
                                    r.properties = e;
                                    const t1 = {};
                                    for (const e of a)t1[e] = o[e].evaluate(n, r);
                                    return t1;
                                }, t1.reduce = (e, t1)=>{
                                    r.properties = t1;
                                    for (const t1 of a)n.accumulated = e[t1], e[t1] = i[t1].evaluate(n, r);
                                }, t1;
                            }(s)).load(a.features) : s.dynamic ? this._dynamicIndex : function(e, t1) {
                                return new Te(e, t1);
                            }(a, s.geojsonVtOptions);
                        } catch (e) {
                            return o(e);
                        }
                        const r = {};
                        if (n) {
                            const e = t1(i);
                            e && (r.resourceTiming = {}, r.resourceTiming[s.source] = JSON.parse(JSON.stringify(e)));
                        }
                        o(null, r);
                    }
                });
            }
            reloadTile(e, t1) {
                const s = this.loaded;
                return s && s[e.uid] ? e.partial ? t1(null, void 0) : super.reloadTile(e, t1) : this.loadTile(e, t1);
            }
            loadGeoJSON(t1, s) {
                if (t1.request) e.g(t1.request, s);
                else {
                    if ("string" != typeof t1.data) return s(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                    try {
                        return s(null, JSON.parse(t1.data));
                    } catch (e) {
                        return s(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                    }
                }
            }
            getClusterExpansionZoom(e, t1) {
                try {
                    t1(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));
                } catch (e) {
                    t1(e);
                }
            }
            getClusterChildren(e, t1) {
                try {
                    t1(null, this._geoJSONIndex.getChildren(e.clusterId));
                } catch (e) {
                    t1(e);
                }
            }
            getClusterLeaves(e, t1) {
                try {
                    t1(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));
                } catch (e) {
                    t1(e);
                }
            }
        }
        class Le {
            constructor(t1, s){
                this.tileID = new e.aL(t1.tileID.overscaledZ, t1.tileID.wrap, t1.tileID.canonical.z, t1.tileID.canonical.x, t1.tileID.canonical.y), this.tileZoom = t1.tileZoom, this.uid = t1.uid, this.zoom = t1.zoom, this.canonical = t1.tileID.canonical, this.pixelRatio = t1.pixelRatio, this.tileSize = t1.tileSize, this.source = t1.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t1.projection, this.brightness = s;
            }
            parse(t1, s, o, i) {
                this.status = "parsing";
                const n = new e.aL(o.tileID.overscaledZ, o.tileID.wrap, o.tileID.canonical.z, o.tileID.canonical.x, o.tileID.canonical.y), r = {}, a = s.familiesBySource[o.source], l = new e.dN(n, o.promoteId);
                return l.bucketLayerIDs = [], l.is3DTile = !0, e.e3(t1).then((t1)=>{
                    if (!t1) return i(new Error("Could not parse tile"));
                    const s = e.e4(t1, 1 / e.b5(o.tileID.canonical)), c = t1.json.extensionsUsed && t1.json.extensionsUsed.includes("MAPBOX_mesh_features") || t1.json.asset.extras && t1.json.asset.extras.MAPBOX_mesh_features, h = t1.json.extensionsUsed && t1.json.extensionsUsed.includes("EXT_meshopt_compression"), u = new e.X(this.zoom, {
                        brightness: this.brightness
                    });
                    for(const t1 in a)for (const o of a[t1]){
                        const t1 = o[0];
                        l.bucketLayerIDs.push(o.map((e)=>e.id)), t1.recalculate(u, []);
                        const i = new e.e5(s, n, c, h, this.brightness, l);
                        c || (i.needsUpload = !0), r[t1.fqid] = i, i.evaluate(t1);
                    }
                    this.status = "done", i(null, {
                        buckets: r,
                        featureIndex: l
                    });
                }).catch((e)=>i(new Error(e.message)));
            }
        }
        class De {
            constructor(e, t1, s, o, i, n){
                this.actor = e, this.layerIndex = t1, this.brightness = n, this.loading = {}, this.loaded = {};
            }
            loadTile(t1, s) {
                const o = t1.uid, i = this.loading[o] = new Le(t1, this.brightness);
                e.e2(t1.request, (e, n)=>{
                    const r = !this.loading[o];
                    return delete this.loading[o], r || e ? (i.status = "done", r || (this.loaded[o] = i), s(e)) : n && 0 !== n.byteLength ? void i.parse(n, this.layerIndex, t1, (e, t1)=>{
                        i.status = "done", this.loaded = this.loaded || {}, this.loaded[o] = i, e || !t1 ? s(e) : s(null, t1);
                    }) : (i.status = "done", this.loaded[o] = i, s());
                });
            }
            reloadTile(e, t1) {
                const s = this.loaded, o = e.uid;
                if (s && s[o]) {
                    const i = s[o];
                    i.projection = e.projection, i.brightness = e.brightness;
                    const n = (s, o)=>{
                        i.reloadCallback && (delete i.reloadCallback, this.loadTile(e, t1)), t1(s, o);
                    };
                    "parsing" === i.status ? i.reloadCallback = n : "done" === i.status && this.loadTile(e, t1);
                }
            }
            abortTile(e, t1) {
                const s = e.uid;
                this.loading[s] && delete this.loading[s], t1();
            }
            removeTile(e, t1) {
                const s = this.loaded, o = e.uid;
                s && s[o] && delete s[o], t1();
            }
        }
        class je {
            constructor(t1){
                this.self = t1, this.actor = new e.e6(t1, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e.aJ({
                    name: "mercator"
                }), this.workerSourceTypes = {
                    vector: c,
                    geojson: _e,
                    "batched-model": De
                }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e, t1)=>{
                    if (this.workerSourceTypes[e]) throw new Error(`Worker source with name "${e}" already registered.`);
                    this.workerSourceTypes[e] = t1;
                }, this.self.registerRTLTextPlugin = (t1)=>{
                    if (e.e7.isParsed()) throw new Error("RTL text plugin already registered.");
                    e.e7.applyArabicShaping = t1.applyArabicShaping, e.e7.processBidirectionalText = t1.processBidirectionalText, e.e7.processStyledBidirectionalText = t1.processStyledBidirectionalText;
                };
            }
            clearCaches(e, t1, s) {
                delete this.layerIndexes[e], delete this.availableImages[e], delete this.workerSources[e], delete this.demWorkerSources[e], delete this.rasterArrayWorkerSource, s();
            }
            checkIfReady(e, t1, s) {
                s();
            }
            setReferrer(e, t1) {
                this.referrer = t1;
            }
            spriteLoaded(t1, { scope: s, isLoaded: o }) {
                if (this.isSpriteLoaded[t1] || (this.isSpriteLoaded[t1] = {}), this.isSpriteLoaded[t1][s] = o, this.workerSources[t1] && this.workerSources[t1][s]) for(const i in this.workerSources[t1][s]){
                    const n = this.workerSources[t1][s][i];
                    for(const t1 in n){
                        const s = n[t1];
                        s instanceof c && (s.isSpriteLoaded = o, s.fire(new e.f("isSpriteLoaded")));
                    }
                }
            }
            setImages(e, { scope: t1, images: s }, o) {
                if (this.availableImages[e] || (this.availableImages[e] = {}), this.availableImages[e][t1] = s, this.workerSources[e] && this.workerSources[e][t1]) {
                    for(const o in this.workerSources[e][t1]){
                        const i = this.workerSources[e][t1][o];
                        for(const e in i)i[e].availableImages = s;
                    }
                    o();
                } else o();
            }
            setProjection(t1, s) {
                this.projections[t1] = e.aJ(s);
            }
            setBrightness(e, t1, s) {
                this.brightness = t1, s();
            }
            setLayers(e, t1, s) {
                this.getLayerIndex(e, t1.scope).replace(t1.layers, t1.options), s();
            }
            updateLayers(e, t1, s) {
                this.getLayerIndex(e, t1.scope).update(t1.layers, t1.removedIds, t1.options), s();
            }
            loadTile(e, t1, s) {
                t1.projection = this.projections[e] || this.defaultProjection, this.getWorkerSource(e, t1.type, t1.source, t1.scope).loadTile(t1, s);
            }
            loadDEMTile(e, t1, s) {
                this.getDEMWorkerSource(e, t1.source, t1.scope).loadTile(t1, s);
            }
            decodeRasterArray(e, t1, s) {
                this.getRasterArrayWorkerSource().decodeRasterArray(t1, s);
            }
            reloadTile(e, t1, s) {
                t1.projection = this.projections[e] || this.defaultProjection, this.getWorkerSource(e, t1.type, t1.source, t1.scope).reloadTile(t1, s);
            }
            abortTile(e, t1, s) {
                this.getWorkerSource(e, t1.type, t1.source, t1.scope).abortTile(t1, s);
            }
            removeTile(e, t1, s) {
                this.getWorkerSource(e, t1.type, t1.source, t1.scope).removeTile(t1, s);
            }
            removeSource(e, t1, s) {
                if (!(this.workerSources[e] && this.workerSources[e][t1.scope] && this.workerSources[e][t1.scope][t1.type] && this.workerSources[e][t1.scope][t1.type][t1.source])) return;
                const o = this.workerSources[e][t1.scope][t1.type][t1.source];
                delete this.workerSources[e][t1.scope][t1.type][t1.source], void 0 !== o.removeSource ? o.removeSource(t1, s) : s();
            }
            loadWorkerSource(e, t1, s) {
                try {
                    this.self.importScripts(t1.url), s();
                } catch (e) {
                    s(e.toString());
                }
            }
            syncRTLPluginState(t1, s, o) {
                try {
                    e.e7.setState(s);
                    const t1 = e.e7.getPluginURL();
                    if (e.e7.isLoaded() && !e.e7.isParsed() && null != t1) {
                        this.self.importScripts(t1);
                        const s = e.e7.isParsed();
                        o(s ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t1}`), s);
                    }
                } catch (e) {
                    o(e.toString());
                }
            }
            setDracoUrl(e, t1) {
                this.dracoUrl = t1;
            }
            getAvailableImages(e, t1) {
                this.availableImages[e] || (this.availableImages[e] = {});
                let s = this.availableImages[e][t1];
                return s || (s = []), s;
            }
            getLayerIndex(e, t1) {
                this.layerIndexes[e] || (this.layerIndexes[e] = {});
                let s = this.layerIndexes[e][t1];
                return s || (s = this.layerIndexes[e][t1] = new i, s.scope = t1), s;
            }
            getWorkerSource(e, t1, s, o) {
                return this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][o] || (this.workerSources[e][o] = {}), this.workerSources[e][o][t1] || (this.workerSources[e][o][t1] = {}), this.isSpriteLoaded[e] || (this.isSpriteLoaded[e] = {}), this.workerSources[e][o][t1][s] || (this.workerSources[e][o][t1][s] = new this.workerSourceTypes[t1]({
                    send: (t1, s, o, i, n, r)=>{
                        this.actor.send(t1, s, o, e, n, r);
                    },
                    scheduler: this.actor.scheduler
                }, this.getLayerIndex(e, o), this.getAvailableImages(e, o), this.isSpriteLoaded[e][o], void 0, this.brightness)), this.workerSources[e][o][t1][s];
            }
            getDEMWorkerSource(e, t1, s) {
                return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][s] || (this.demWorkerSources[e][s] = {}), this.demWorkerSources[e][s][t1] || (this.demWorkerSources[e][s][t1] = new h), this.demWorkerSources[e][s][t1];
            }
            getRasterArrayWorkerSource() {
                return this.rasterArrayWorkerSource || (this.rasterArrayWorkerSource = new u), this.rasterArrayWorkerSource;
            }
            enforceCacheSizeLimit(t1, s) {
                e.e8(s);
            }
            getWorkerPerformanceMetrics(e, t1, s) {
                s(void 0, void 0);
            }
        }
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new je(self)), je;
    });
    define([
        "./shared"
    ], function(e) {
        function t1(e, i) {
            if (Array.isArray(e)) {
                if (!Array.isArray(i) || e.length !== i.length) return !1;
                for(let o = 0; o < e.length; o++)if (!t1(e[o], i[o])) return !1;
                return !0;
            }
            if ("object" == typeof e && null !== e && null !== i) {
                if ("object" != typeof i) return !1;
                if (Object.keys(e).length !== Object.keys(i).length) return !1;
                for(const o in e)if (!t1(e[o], i[o])) return !1;
                return !0;
            }
            return e === i;
        }
        var i = o;
        function o(e) {
            return !function(e) {
                var t1;
                return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : function() {
                    if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;
                    var e, t1, i = new Blob([
                        ""
                    ], {
                        type: "text/javascript"
                    }), o = URL.createObjectURL(i);
                    try {
                        t1 = new Worker(o), e = !0;
                    } catch (t1) {
                        e = !1;
                    }
                    return t1 && t1.terminate(), URL.revokeObjectURL(o), e;
                }() ? function() {
                    var e = document.createElement("canvas");
                    e.width = e.height = 1;
                    var t1 = e.getContext("2d");
                    if (!t1) return !1;
                    var i = t1.getImageData(0, 0, 1, 1);
                    return i && i.width === e.width;
                }() ? (void 0 === r[t1 = e && e.failIfMajorPerformanceCaveat] && (r[t1] = function(e) {
                    var t1, i = function(e) {
                        var t1 = document.createElement("canvas"), i = Object.create(o.webGLContextAttributes);
                        return i.failIfMajorPerformanceCaveat = e, t1.getContext("webgl2", i);
                    }(e);
                    if (!i) return !1;
                    try {
                        t1 = i.createShader(i.VERTEX_SHADER);
                    } catch (e) {
                        return !1;
                    }
                    return !(!t1 || i.isContextLost()) && (i.shaderSource(t1, "void main() {}"), i.compileShader(t1), !0 === i.getShaderParameter(t1, i.COMPILE_STATUS));
                }(t1)), r[t1] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
            }(e);
        }
        var r = {};
        function a(e, t1, i) {
            const o = document.createElement(e);
            return null != t1 && (o.className = t1), i && i.appendChild(o), o;
        }
        function n(e, t1, i) {
            const o = document.createElementNS("http://www.w3.org/2000/svg", e);
            for (const e of Object.keys(t1))o.setAttributeNS(null, e, String(t1[e]));
            return i && i.appendChild(o), o;
        }
        o.webGLContextAttributes = {
            antialias: !1,
            alpha: !0,
            stencil: !0,
            depth: !0
        };
        const s = "undefined" != typeof document ? document.documentElement && document.documentElement.style : null, l = s && void 0 !== s.userSelect ? "userSelect" : "WebkitUserSelect";
        let c;
        function h() {
            s && l && (c = s[l], s[l] = "none");
        }
        function _() {
            s && l && (s[l] = c);
        }
        function u(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", u, !0);
        }
        function d() {
            window.addEventListener("click", u, !0), window.setTimeout(()=>{
                window.removeEventListener("click", u, !0);
            }, 0);
        }
        function p(e, t1) {
            const i = e.getBoundingClientRect();
            return g(e, i, t1);
        }
        function f(e, t1) {
            const i = e.getBoundingClientRect(), o = [];
            for(let r = 0; r < t1.length; r++)o.push(g(e, i, t1[r]));
            return o;
        }
        function m(e) {
            return void 0 !== window.InstallTrigger && 2 === e.button && e.ctrlKey && window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e.button;
        }
        function g(t1, i, o) {
            const r = t1.offsetWidth === i.width ? 1 : t1.offsetWidth / i.width;
            return new e.P((o.clientX - i.left) * r, (o.clientY - i.top) * r);
        }
        class v {
            constructor(){
                this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = new Set, this._updatedImages = new Set;
            }
            isDirty() {
                return this._changed;
            }
            setDirty() {
                this._changed = !0;
            }
            getUpdatedSourceCaches() {
                return this._updatedSourceCaches;
            }
            updateSourceCache(e, t1) {
                this._updatedSourceCaches[e] = t1, this.setDirty();
            }
            discardSourceCacheUpdate(e) {
                delete this._updatedSourceCaches[e];
            }
            updateLayer(e) {
                const t1 = e.scope;
                this._updatedLayers[t1] = this._updatedLayers[t1] || new Set, this._updatedLayers[t1].add(e.id), this.setDirty();
            }
            removeLayer(e) {
                const t1 = e.scope;
                this._removedLayers[t1] = this._removedLayers[t1] || {}, this._updatedLayers[t1] = this._updatedLayers[t1] || new Set, this._removedLayers[t1][e.id] = e, this._updatedLayers[t1].delete(e.id), this._updatedPaintProps.delete(e.fqid), this.setDirty();
            }
            getRemovedLayer(e) {
                return this._removedLayers[e.scope] ? this._removedLayers[e.scope][e.id] : null;
            }
            discardLayerRemoval(e) {
                this._removedLayers[e.scope] && delete this._removedLayers[e.scope][e.id];
            }
            getLayerUpdatesByScope() {
                const e = {};
                for(const t1 in this._updatedLayers)e[t1] = e[t1] || {}, e[t1].updatedIds = Array.from(this._updatedLayers[t1].values());
                for(const t1 in this._removedLayers)e[t1] = e[t1] || {}, e[t1].removedIds = Object.keys(this._removedLayers[t1]);
                return e;
            }
            getUpdatedPaintProperties() {
                return this._updatedPaintProps;
            }
            updatePaintProperties(e) {
                this._updatedPaintProps.add(e.fqid), this.setDirty();
            }
            getUpdatedImages() {
                return Array.from(this._updatedImages.values());
            }
            updateImage(e) {
                this._updatedImages.add(e), this.setDirty();
            }
            resetUpdatedImages() {
                this._updatedImages.clear();
            }
            reset() {
                this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages.clear();
            }
        }
        const x = {
            Int8: "BYTE",
            Uint8: "UNSIGNED_BYTE",
            Int16: "SHORT",
            Uint16: "UNSIGNED_SHORT",
            Int32: "INT",
            Uint32: "UNSIGNED_INT",
            Float32: "FLOAT"
        };
        class y {
            constructor(e, t1, i, o, r, a){
                this.length = t1.length, this.attributes = i, this.itemSize = t1.bytesPerElement, this.dynamicDraw = o, this.instanceCount = a, this.context = e;
                const n = e.gl;
                this.buffer = n.createBuffer(), e.bindVertexBuffer.set(this.buffer), n.bufferData(n.ARRAY_BUFFER, t1.arrayBuffer, this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW), this.dynamicDraw || r || t1.destroy();
            }
            bind() {
                this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(e) {
                const t1 = this.context.gl;
                this.bind(), t1.bufferSubData(t1.ARRAY_BUFFER, 0, e.arrayBuffer);
            }
            enableAttributes(e, t1) {
                for(let i = 0; i < this.attributes.length; i++){
                    const o = t1.attributes[this.attributes[i].name];
                    void 0 !== o && e.enableVertexAttribArray(o);
                }
            }
            setVertexAttribPointers(e, t1, i) {
                for(let o = 0; o < this.attributes.length; o++){
                    const r = this.attributes[o], a = t1.attributes[r.name];
                    void 0 !== a && e.vertexAttribPointer(a, r.components, e[x[r.type]], !1, this.itemSize, r.offset + this.itemSize * (i || 0));
                }
            }
            setVertexAttribDivisor(e, t1, i) {
                for(let o = 0; o < this.attributes.length; o++){
                    const r = t1.attributes[this.attributes[o].name];
                    void 0 !== r && this.instanceCount && this.instanceCount > 0 && e.vertexAttribDivisor(r, i);
                }
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }
        class b {
            constructor(e){
                this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
            }
            get() {
                return this.current;
            }
            set(e) {}
            getDefault() {
                return this.default;
            }
            setDefault() {
                this.set(this.default);
            }
        }
        class w extends b {
            getDefault() {
                return e.C.transparent;
            }
            set(e) {
                const t1 = this.current;
                (e.r !== t1.r || e.g !== t1.g || e.b !== t1.b || e.a !== t1.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
            }
        }
        class T extends b {
            getDefault() {
                return 1;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
            }
        }
        class E extends b {
            getDefault() {
                return 0;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
            }
        }
        class C extends b {
            getDefault() {
                return [
                    !0,
                    !0,
                    !0,
                    !0
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || e[2] !== t1[2] || e[3] !== t1[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
            }
        }
        class S extends b {
            getDefault() {
                return !0;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
            }
        }
        class I extends b {
            getDefault() {
                return 255;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
            }
        }
        class L extends b {
            getDefault() {
                return {
                    func: this.gl.ALWAYS,
                    ref: 0,
                    mask: 255
                };
            }
            set(e) {
                const t1 = this.current;
                (e.func !== t1.func || e.ref !== t1.ref || e.mask !== t1.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
            }
        }
        class P extends b {
            getDefault() {
                const e = this.gl;
                return [
                    e.KEEP,
                    e.KEEP,
                    e.KEEP
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || e[2] !== t1[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
            }
        }
        class A extends b {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                e ? t1.enable(t1.STENCIL_TEST) : t1.disable(t1.STENCIL_TEST), this.current = e, this.dirty = !1;
            }
        }
        class R extends b {
            getDefault() {
                return [
                    0,
                    1
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
            }
        }
        class D extends b {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                e ? t1.enable(t1.DEPTH_TEST) : t1.disable(t1.DEPTH_TEST), this.current = e, this.dirty = !1;
            }
        }
        class M extends b {
            getDefault() {
                return this.gl.LESS;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
            }
        }
        class z extends b {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                e ? t1.enable(t1.BLEND) : t1.disable(t1.BLEND), this.current = e, this.dirty = !1;
            }
        }
        class O extends b {
            getDefault() {
                const e = this.gl;
                return [
                    e.ONE,
                    e.ZERO,
                    e.ONE,
                    e.ZERO
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || e[2] !== t1[2] || e[3] !== t1[3] || this.dirty) && (this.gl.blendFuncSeparate(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
            }
        }
        class F extends b {
            getDefault() {
                return e.C.transparent;
            }
            set(e) {
                const t1 = this.current;
                (e.r !== t1.r || e.g !== t1.g || e.b !== t1.b || e.a !== t1.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
            }
        }
        class B extends b {
            getDefault() {
                return this.gl.FUNC_ADD;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e, e), this.current = e, this.dirty = !1);
            }
        }
        class k extends b {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                e ? t1.enable(t1.CULL_FACE) : t1.disable(t1.CULL_FACE), this.current = e, this.dirty = !1;
            }
        }
        class N extends b {
            getDefault() {
                return this.gl.BACK;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
            }
        }
        class U extends b {
            getDefault() {
                return this.gl.CCW;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
            }
        }
        let G = class extends b {
            getDefault() {
                return null;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
            }
        };
        class j extends b {
            getDefault() {
                return this.gl.TEXTURE0;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
            }
        }
        class V extends b {
            getDefault() {
                const e = this.gl;
                return [
                    0,
                    0,
                    e.drawingBufferWidth,
                    e.drawingBufferHeight
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || e[2] !== t1[2] || e[3] !== t1[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
            }
        }
        class W extends b {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindFramebuffer(t1.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class Z extends b {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindRenderbuffer(t1.RENDERBUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class q extends b {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindTexture(t1.TEXTURE_2D, e), this.current = e, this.dirty = !1;
            }
        }
        class H extends b {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindBuffer(t1.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class $ extends b {
            getDefault() {
                return null;
            }
            set(e) {
                const t1 = this.gl;
                t1.bindBuffer(t1.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class X extends b {
            getDefault() {
                return null;
            }
            set(e) {
                this.gl && (e !== this.current || this.dirty) && (this.gl.bindVertexArray(e), this.current = e, this.dirty = !1);
            }
        }
        class Y extends b {
            getDefault() {
                return 4;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
            }
        }
        class K extends b {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
            }
        }
        class Q extends b {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
            }
        }
        class J extends b {
            constructor(e, t1){
                super(e), this.context = e, this.parent = t1;
            }
            getDefault() {
                return null;
            }
        }
        class ee extends J {
            setDirty() {
                this.dirty = !0;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t1 = this.gl;
                t1.framebufferTexture2D(t1.FRAMEBUFFER, t1.COLOR_ATTACHMENT0, t1.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
            }
        }
        class te extends J {
            attachment() {
                return this.gl.DEPTH_ATTACHMENT;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t1 = this.gl;
                t1.framebufferRenderbuffer(t1.FRAMEBUFFER, this.attachment(), t1.RENDERBUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class ie extends J {
            attachment() {
                return this.gl.DEPTH_ATTACHMENT;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t1 = this.gl;
                t1.framebufferTexture2D(t1.FRAMEBUFFER, this.attachment(), t1.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
            }
        }
        class oe extends te {
            attachment() {
                return this.gl.DEPTH_STENCIL_ATTACHMENT;
            }
        }
        class re {
            constructor(e, t1, i, o, r){
                this.context = e, this.width = t1, this.height = i;
                const a = this.framebuffer = e.gl.createFramebuffer();
                o && (this.colorAttachment = new ee(e, a)), r && (this.depthAttachmentType = r, this.depthAttachment = "renderbuffer" === r ? new te(e, a) : new ie(e, a));
            }
            destroy() {
                const e = this.context.gl;
                if (this.colorAttachment) {
                    const t1 = this.colorAttachment.get();
                    t1 && e.deleteTexture(t1);
                }
                if (this.depthAttachment && this.depthAttachmentType) {
                    if ("renderbuffer" === this.depthAttachmentType) {
                        const t1 = this.depthAttachment.get();
                        t1 && e.deleteRenderbuffer(t1);
                    } else {
                        const t1 = this.depthAttachment.get();
                        t1 && e.deleteTexture(t1);
                    }
                }
                e.deleteFramebuffer(this.framebuffer);
            }
        }
        class ae {
            constructor(e, t1){
                this.gl = e, this.clearColor = new w(this), this.clearDepth = new T(this), this.clearStencil = new E(this), this.colorMask = new C(this), this.depthMask = new S(this), this.stencilMask = new I(this), this.stencilFunc = new L(this), this.stencilOp = new P(this), this.stencilTest = new A(this), this.depthRange = new R(this), this.depthTest = new D(this), this.depthFunc = new M(this), this.blend = new z(this), this.blendFunc = new O(this), this.blendColor = new F(this), this.blendEquation = new B(this), this.cullFace = new k(this), this.cullFaceSide = new N(this), this.frontFace = new U(this), this.program = new G(this), this.activeTexture = new j(this), this.viewport = new V(this), this.bindFramebuffer = new W(this), this.bindRenderbuffer = new Z(this), this.bindTexture = new q(this), this.bindVertexBuffer = new H(this), this.bindElementBuffer = new $(this), this.bindVertexArrayOES = new X(this), this.pixelStoreUnpack = new Y(this), this.pixelStoreUnpackPremultiplyAlpha = new K(this), this.pixelStoreUnpackFlipY = new Q(this), this.options = t1 ? {
                    ...t1
                } : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = e.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = e.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), this.maxPointSize = e.getParameter(e.ALIASED_POINT_SIZE_RANGE)[1];
            }
            setDefault() {
                this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
                this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArrayOES.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
            }
            createIndexBuffer(t1, i, o) {
                return new e.I(this, t1, i, o);
            }
            createVertexBuffer(e, t1, i, o, r) {
                return new y(this, e, t1, i, o, r);
            }
            createRenderbuffer(e, t1, i) {
                const o = this.gl, r = o.createRenderbuffer();
                return this.bindRenderbuffer.set(r), o.renderbufferStorage(o.RENDERBUFFER, e, t1, i), this.bindRenderbuffer.set(null), r;
            }
            createFramebuffer(e, t1, i, o) {
                return new re(this, e, t1, i, o);
            }
            clear({ color: e, depth: t1, stencil: i, colorMask: o }) {
                const r = this.gl;
                let a = 0;
                e && (a |= r.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set(o || [
                    !0,
                    !0,
                    !0,
                    !0
                ])), void 0 !== t1 && (a |= r.DEPTH_BUFFER_BIT, this.depthRange.set([
                    0,
                    1
                ]), this.clearDepth.set(t1), this.depthMask.set(!0)), void 0 !== i && (a |= r.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), r.clear(a);
            }
            setCullFace(e) {
                !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
            }
            setDepthMode(e) {
                e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
            }
            setStencilMode(e) {
                e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([
                    e.fail,
                    e.depthFail,
                    e.pass
                ]), this.stencilFunc.set({
                    func: e.test.func,
                    ref: e.ref,
                    mask: e.test.mask
                })) : this.stencilTest.set(!1);
            }
            setColorMode(i) {
                t1(i.blendFunction, e.a.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(i.blendFunction), this.blendColor.set(i.blendColor), i.blendEquation ? this.blendEquation.set(i.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(i.mask);
            }
            unbindVAO() {
                this.bindVertexArrayOES.set(null);
            }
        }
        class ne {
            constructor(e){
                this._gl = e.gl, this._query = this._gl.createQuery(), this._isFree = !0;
            }
            begin() {
                this._gl.beginQuery(this._gl.ANY_SAMPLES_PASSED, this._query), this._isFree = !1;
            }
            end() {
                this._gl.endQuery(this._gl.ANY_SAMPLES_PASSED);
            }
            isResultAvailable() {
                return this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT_AVAILABLE);
            }
            consumeResult() {
                const e = this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT);
                return this._isFree = !0, e;
            }
            isFree() {
                return this._isFree;
            }
            destroy() {
                this._gl.deleteQuery(this._query);
            }
        }
        class se {
            constructor(e){
                this.useOcclusionQueries = !0, this.visualizeOcclusions = "none", this.occlusionQueryFrameWindow = 5, this.occluderSize = 32, this.fadeSpeed = 7, this.depthOffset = -0.0001, e.registerParameter(this, [
                    "Symbols"
                ], "useOcclusionQueries"), e.registerParameter(this, [
                    "Symbols"
                ], "visualizeOcclusions", {
                    options: {
                        none: "none",
                        zPass: "zPass",
                        zTest: "zTest"
                    }
                }), e.registerParameter(this, [
                    "Symbols"
                ], "occlusionQueryFrameWindow", {
                    min: 1,
                    max: 30,
                    step: 1
                }), e.registerParameter(this, [
                    "Symbols"
                ], "occluderSize", {
                    min: 1,
                    max: 100,
                    step: 1
                }), e.registerParameter(this, [
                    "Symbols"
                ], "fadeSpeed", {
                    min: .1,
                    max: 50,
                    step: .1
                }), e.registerParameter(this, [
                    "Symbols"
                ], "depthOffset", {
                    min: -0.001,
                    max: 0,
                    step: 1e-4
                });
            }
        }
        class le {
            constructor(t1, i, o, r){
                const a = {
                    width: o[0],
                    height: o[1],
                    data: null
                }, n = t1.gl;
                this.targetColorTexture = new e.T(t1, a, n.RGBA, {
                    useMipmap: !1
                }), this.backgroundColorTexture = new e.T(t1, a, n.RGBA, {
                    useMipmap: !1
                }), this.context = t1, this.updateParticleTexture(i, r), this.lastInvalidatedAt = 0;
            }
            updateParticleTexture(t1, i) {
                if (this.particleTextureDimension === i.width) return;
                (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
                const o = this.context.gl, r = i.width * i.height;
                this.particleTexture0 = new e.T(this.context, i, o.RGBA, {
                    premultiply: !1,
                    useMipmap: !1
                }), this.particleTexture1 = new e.T(this.context, i, o.RGBA, {
                    premultiply: !1,
                    useMipmap: !1
                });
                const a = new e.S;
                a.reserve(r);
                for(let e = 0; e < r; e++)a.emplaceBack(e);
                this.particleIndexBuffer = this.context.createVertexBuffer(a, e.p.members, !0), this.particleSegment = e.b.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = i.width;
            }
            update(t1) {
                return !(this.lastInvalidatedAt < t1 && (this.lastInvalidatedAt = e.e.now(), 1));
            }
            destroy() {
                this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();
            }
        }
        class ce extends e.E {
            constructor(e){
                super(), this.requestManager = e, this.models = {
                    "": {}
                }, this.numModelsLoading = {};
            }
            loadModel(t1, i) {
                return e.l(this.requestManager.transformRequest(i, e.R.Model).url).then((i)=>{
                    if (!i) return;
                    const o = e.c(i), r = new e.M(t1, void 0, void 0, o);
                    return r.computeBoundsAndApplyParent(), r;
                }).catch((o)=>{
                    if (o && 404 === o.status) return null;
                    this.fire(new e.d(new Error(`Could not load model ${t1} from ${i}: ${o.message}`)));
                });
            }
            load(t1, i) {
                this.models[i] || (this.models[i] = {});
                const o = Object.keys(t1);
                this.numModelsLoading[i] = (this.numModelsLoading[i] || 0) + o.length;
                const r = [];
                for (const e of o)r.push(this.loadModel(e, t1[e]));
                Promise.allSettled(r).then((t1)=>{
                    for(let e = 0; e < t1.length; e++){
                        const { status: r, value: a } = t1[e];
                        "fulfilled" === r && a && (this.models[i][o[e]] = {
                            model: a,
                            numReferences: 1
                        });
                    }
                    this.numModelsLoading[i] -= o.length, this.fire(new e.f("data", {
                        dataType: "style"
                    }));
                }).catch((t1)=>{
                    this.fire(new e.d(new Error(`Could not load models: ${t1.message}`)));
                });
            }
            isLoaded() {
                for(const e in this.numModelsLoading)if (this.numModelsLoading[e] > 0) return !1;
                return !0;
            }
            hasModel(e, t1) {
                return !!this.getModel(e, t1);
            }
            getModel(e, t1) {
                return this.models[t1] || (this.models[t1] = {}), this.models[t1][e] ? this.models[t1][e].model : void 0;
            }
            addModel(e, t1, i) {
                this.models[i] || (this.models[i] = {}), this.hasModel(e, i) && this.models[i][e].numReferences++, this.load({
                    [e]: this.requestManager.normalizeModelURL(t1)
                }, i);
            }
            addModels(e, t1) {
                this.models[t1] || (this.models[t1] = {});
                const i = {};
                for(const o in e)this.models[t1][o] = {}, i[o] = this.requestManager.normalizeModelURL(e[o]);
                this.load(i, t1);
            }
            addModelsFromBucket(e, t1) {
                this.models[t1] || (this.models[t1] = {});
                const i = {};
                for (const o of e)this.hasModel(o, t1) ? this.models[t1][o].numReferences++ : i[o] = this.requestManager.normalizeModelURL(o);
                this.load(i, t1);
            }
            removeModel(e, t1) {
                if (this.models[t1] && this.models[t1][e] && (this.models[t1][e].numReferences--, 0 === this.models[t1][e].numReferences)) {
                    const i = this.models[t1][e].model;
                    delete this.models[t1][e], i.destroy();
                }
            }
            listModels(e) {
                return this.models[e] || (this.models[e] = {}), Object.keys(this.models[e]);
            }
            upload(e, t1) {
                this.models[t1] || (this.models[t1] = {});
                for(const i in this.models[t1])this.models[t1][i].model && this.models[t1][i].model.upload(e.context);
            }
        }
        function he(e) {
            const { userImage: t1 } = e;
            return !!(t1 && t1.render && t1.render()) && (e.data.replace(new Uint8Array(t1.data.buffer)), !0);
        }
        class _e extends e.E {
            constructor(){
                super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = {}, this.requestors = [], this.patterns = {}, this.atlasImage = {}, this.atlasTexture = {}, this.dirty = !0;
            }
            createScope(t1) {
                this.images[t1] = {}, this.loaded[t1] = !1, this.updatedImages[t1] = {}, this.patterns[t1] = {}, this.callbackDispatchedThisFrame[t1] = {}, this.atlasImage[t1] = new e.i({
                    width: 1,
                    height: 1
                });
            }
            isLoaded() {
                for(const e in this.loaded)if (!this.loaded[e]) return !1;
                return !0;
            }
            setLoaded(e, t1) {
                if (this.loaded[t1] !== e && (this.loaded[t1] = e, e)) {
                    for (const { ids: e, callback: i } of this.requestors)this._notify(e, t1, i);
                    this.requestors = [];
                }
            }
            hasImage(e, t1) {
                return !!this.getImage(e, t1);
            }
            getImage(e, t1) {
                return this.images[t1][e];
            }
            addImage(e, t1, i) {
                this._validate(e, i) && (this.images[t1][e] = i);
            }
            _validate(t1, i) {
                let o = !0;
                return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new e.d(new Error(`Image "${t1}" has invalid "stretchX" value`))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new e.d(new Error(`Image "${t1}" has invalid "stretchY" value`))), o = !1), this._validateContent(i.content, i) || (this.fire(new e.d(new Error(`Image "${t1}" has invalid "content" value`))), o = !1), o;
            }
            _validateStretch(e, t1) {
                if (!e) return !0;
                let i = 0;
                for (const o of e){
                    if (o[0] < i || o[1] < o[0] || t1 < o[1]) return !1;
                    i = o[1];
                }
                return !0;
            }
            _validateContent(e, t1) {
                return !(e && (4 !== e.length || e[0] < 0 || t1.data.width < e[0] || e[1] < 0 || t1.data.height < e[1] || e[2] < 0 || t1.data.width < e[2] || e[3] < 0 || t1.data.height < e[3] || e[2] < e[0] || e[3] < e[1]));
            }
            updateImage(e, t1, i) {
                i.version = this.images[t1][e].version + 1, this.images[t1][e] = i, this.updatedImages[t1][e] = !0;
            }
            removeImage(e, t1) {
                const i = this.images[t1][e];
                delete this.images[t1][e], delete this.patterns[t1][e], i.userImage && i.userImage.onRemove && i.userImage.onRemove();
            }
            listImages(e) {
                return Object.keys(this.images[e]);
            }
            getImages(e, t1, i) {
                let o = !0;
                const r = !!this.loaded[t1];
                if (!r) for (const i of e)this.images[t1][i] || (o = !1);
                r || o ? this._notify(e, t1, i) : this.requestors.push({
                    ids: e,
                    scope: t1,
                    callback: i
                });
            }
            getUpdatedImages(e) {
                return this.updatedImages[e];
            }
            _notify(t1, i, o) {
                const r = {};
                for (const o of t1){
                    this.images[i][o] || this.fire(new e.f("styleimagemissing", {
                        id: o
                    }));
                    const t1 = this.images[i][o];
                    t1 ? r[o] = {
                        data: t1.data.clone(),
                        pixelRatio: t1.pixelRatio,
                        sdf: t1.sdf,
                        version: t1.version,
                        stretchX: t1.stretchX,
                        stretchY: t1.stretchY,
                        content: t1.content,
                        hasRenderCallback: Boolean(t1.userImage && t1.userImage.render)
                    } : e.w(`Image "${o}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
                }
                o(null, r);
            }
            getPixelSize(e) {
                const { width: t1, height: i } = this.atlasImage[e];
                return {
                    width: t1,
                    height: i
                };
            }
            getPattern(t1, i, o) {
                const r = this.patterns[i][t1], a = this.getImage(t1, i);
                if (!a) return null;
                if (r && r.position.version === a.version) return r.position;
                if (r) r.position.version = a.version;
                else {
                    const o = {
                        w: a.data.width + 2,
                        h: a.data.height + 2,
                        x: 0,
                        y: 0
                    }, r = new e.k(o, a);
                    this.patterns[i][t1] = {
                        bin: o,
                        position: r
                    };
                }
                return this._updatePatternAtlas(i, o), this.patterns[i][t1].position;
            }
            bind(t1, i) {
                const o = t1.gl;
                let r = this.atlasTexture[i];
                r ? this.dirty && (r.update(this.atlasImage[i]), this.dirty = !1) : (r = new e.T(t1, this.atlasImage[i], o.RGBA), this.atlasTexture[i] = r), r.bind(o.LINEAR, o.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas(t1, i) {
                const o = [];
                for(const e in this.patterns[t1])o.push(this.patterns[t1][e].bin);
                const { w: r, h: a } = e.j(o), n = this.atlasImage[t1];
                n.resize({
                    width: r || 1,
                    height: a || 1
                });
                for(const o in this.patterns[t1]){
                    const { bin: r } = this.patterns[t1][o], a = r.x + 1, s = r.y + 1, l = this.images[t1][o].data, c = l.width, h = l.height;
                    e.i.copy(l, n, {
                        x: 0,
                        y: 0
                    }, {
                        x: a,
                        y: s
                    }, {
                        width: c,
                        height: h
                    }, i), e.i.copy(l, n, {
                        x: 0,
                        y: h - 1
                    }, {
                        x: a,
                        y: s - 1
                    }, {
                        width: c,
                        height: 1
                    }, i), e.i.copy(l, n, {
                        x: 0,
                        y: 0
                    }, {
                        x: a,
                        y: s + h
                    }, {
                        width: c,
                        height: 1
                    }, i), e.i.copy(l, n, {
                        x: c - 1,
                        y: 0
                    }, {
                        x: a - 1,
                        y: s
                    }, {
                        width: 1,
                        height: h
                    }, i), e.i.copy(l, n, {
                        x: 0,
                        y: 0
                    }, {
                        x: a + c,
                        y: s
                    }, {
                        width: 1,
                        height: h
                    }, i);
                }
                this.dirty = !0;
            }
            beginFrame() {
                for(const e in this.images)this.callbackDispatchedThisFrame[e] = {};
            }
            dispatchRenderCallbacks(e, t1) {
                for (const i of e){
                    if (this.callbackDispatchedThisFrame[t1][i]) continue;
                    this.callbackDispatchedThisFrame[t1][i] = !0;
                    const e = this.images[t1][i];
                    he(e) && this.updateImage(i, t1, e);
                }
            }
        }
        function ue(t1) {
            const i = t1.key, o = t1.value, r = t1.valueSpec || {}, a = t1.objectElementValidators || {}, n = t1.style, s = t1.styleSpec;
            let l = [];
            const c = e.n(o);
            if ("object" !== c) return [
                new e.V(i, o, `object expected, ${c} found`)
            ];
            for(const t1 in o){
                const c = t1.split(".")[0];
                let h;
                a[c] ? h = a[c] : r[c] ? h = ze : a["*"] ? h = a["*"] : r["*"] && (h = ze), h ? l = l.concat(h({
                    key: (i ? `${i}.` : i) + t1,
                    value: o[t1],
                    valueSpec: r[c] || r["*"],
                    style: n,
                    styleSpec: s,
                    object: o,
                    objectKey: t1
                }, o)) : l.push(new e.m(i, o[t1], `unknown property "${t1}"`));
            }
            for(const t1 in r)a[t1] || r[t1].required && void 0 === r[t1].default && void 0 === o[t1] && l.push(new e.V(i, o, `missing required property "${t1}"`));
            return l;
        }
        function de(t1) {
            const i = t1.value, o = t1.valueSpec, r = t1.style, a = t1.styleSpec, n = t1.key, s = t1.arrayElementValidator || ze;
            if ("array" !== e.n(i)) return [
                new e.V(n, i, `array expected, ${e.n(i)} found`)
            ];
            if (o.length && i.length !== o.length) return [
                new e.V(n, i, `array length ${o.length} expected, length ${i.length} found`)
            ];
            if (o["min-length"] && i.length < o["min-length"]) return [
                new e.V(n, i, `array length at least ${o["min-length"]} expected, length ${i.length} found`)
            ];
            let l = {
                type: o.value,
                values: o.values,
                minimum: o.minimum,
                maximum: o.maximum,
                function: void 0
            };
            a.$version < 7 && (l.function = o.function), "object" === e.n(o.value) && (l = o.value);
            let c = [];
            for(let e = 0; e < i.length; e++)c = c.concat(s({
                array: i,
                arrayIndex: e,
                value: i[e],
                valueSpec: l,
                style: r,
                styleSpec: a,
                key: `${n}[${e}]`
            }, !0));
            return c;
        }
        function pe(t1) {
            const i = t1.key, o = t1.value, r = t1.valueSpec;
            let a = e.n(o);
            if ("number" === a && o != o && (a = "NaN"), "number" !== a) return [
                new e.V(i, o, `number expected, ${a} found`)
            ];
            if ("minimum" in r) {
                let a = r.minimum;
                if ("array" === e.n(r.minimum) && (a = r.minimum[t1.arrayIndex]), o < a) return [
                    new e.V(i, o, `${o} is less than the minimum value ${a}`)
                ];
            }
            if ("maximum" in r) {
                let a = r.maximum;
                if ("array" === e.n(r.maximum) && (a = r.maximum[t1.arrayIndex]), o > a) return [
                    new e.V(i, o, `${o} is greater than the maximum value ${a}`)
                ];
            }
            return [];
        }
        function fe(t1) {
            const i = t1.valueSpec, o = e.u(t1.value.type);
            let r, a, n, s = {};
            const l = "categorical" !== o && void 0 === t1.value.property, c = !l, h = "array" === e.n(t1.value.stops) && "array" === e.n(t1.value.stops[0]) && "object" === e.n(t1.value.stops[0][0]), _ = ue({
                key: t1.key,
                value: t1.value,
                valueSpec: t1.styleSpec.function,
                style: t1.style,
                styleSpec: t1.styleSpec,
                objectElementValidators: {
                    stops: function(t1) {
                        if ("identity" === o) return [
                            new e.V(t1.key, t1.value, 'identity function may not have a "stops" property')
                        ];
                        let i = [];
                        const r = t1.value;
                        return i = i.concat(de({
                            key: t1.key,
                            value: r,
                            valueSpec: t1.valueSpec,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            arrayElementValidator: u
                        })), "array" === e.n(r) && 0 === r.length && i.push(new e.V(t1.key, r, "array must have at least one stop")), i;
                    },
                    default: function(e) {
                        return ze({
                            key: e.key,
                            value: e.value,
                            valueSpec: i,
                            style: e.style,
                            styleSpec: e.styleSpec
                        });
                    }
                }
            });
            return "identity" === o && l && _.push(new e.V(t1.key, t1.value, 'missing required property "property"')), "identity" === o || t1.value.stops || _.push(new e.V(t1.key, t1.value, 'missing required property "stops"')), "exponential" === o && t1.valueSpec.expression && !e.s(t1.valueSpec) && _.push(new e.V(t1.key, t1.value, "exponential functions not supported")), t1.styleSpec.$version >= 8 && (c && !e.q(t1.valueSpec) ? _.push(new e.V(t1.key, t1.value, "property functions not supported")) : l && !e.r(t1.valueSpec) && _.push(new e.V(t1.key, t1.value, "zoom functions not supported"))), "categorical" !== o && !h || void 0 !== t1.value.property || _.push(new e.V(t1.key, t1.value, '"property" property is required')), _;
            function u(t1) {
                let o = [];
                const r = t1.value, l = t1.key;
                if ("array" !== e.n(r)) return [
                    new e.V(l, r, `array expected, ${e.n(r)} found`)
                ];
                if (2 !== r.length) return [
                    new e.V(l, r, `array length 2 expected, length ${r.length} found`)
                ];
                if (h) {
                    if ("object" !== e.n(r[0])) return [
                        new e.V(l, r, `object expected, ${e.n(r[0])} found`)
                    ];
                    if (void 0 === r[0].zoom) return [
                        new e.V(l, r, "object stop key must have zoom")
                    ];
                    if (void 0 === r[0].value) return [
                        new e.V(l, r, "object stop key must have value")
                    ];
                    const i = e.u(r[0].zoom);
                    if ("number" != typeof i) return [
                        new e.V(l, r[0].zoom, "stop zoom values must be numbers")
                    ];
                    if (n && n > i) return [
                        new e.V(l, r[0].zoom, "stop zoom values must appear in ascending order")
                    ];
                    i !== n && (n = i, a = void 0, s = {}), o = o.concat(ue({
                        key: `${l}[0]`,
                        value: r[0],
                        valueSpec: {
                            zoom: {}
                        },
                        style: t1.style,
                        styleSpec: t1.styleSpec,
                        objectElementValidators: {
                            zoom: pe,
                            value: d
                        }
                    }));
                } else o = o.concat(d({
                    key: `${l}[0]`,
                    value: r[0],
                    valueSpec: {},
                    style: t1.style,
                    styleSpec: t1.styleSpec
                }, r));
                return e.t(e.v(r[1])) ? o.concat([
                    new e.V(`${l}[1]`, r[1], "expressions are not allowed in function stops.")
                ]) : o.concat(ze({
                    key: `${l}[1]`,
                    value: r[1],
                    valueSpec: i,
                    style: t1.style,
                    styleSpec: t1.styleSpec
                }));
            }
            function d(t1, n) {
                const l = e.n(t1.value), c = e.u(t1.value), h = null !== t1.value ? t1.value : n;
                if (r) {
                    if (l !== r) return [
                        new e.V(t1.key, h, `${l} stop domain type must match previous stop domain type ${r}`)
                    ];
                } else r = l;
                if ("number" !== l && "string" !== l && "boolean" !== l && "number" != typeof c && "string" != typeof c && "boolean" != typeof c) return [
                    new e.V(t1.key, h, "stop domain value must be a number, string, or boolean")
                ];
                if ("number" !== l && "categorical" !== o) {
                    let r = `number expected, ${l} found`;
                    return e.q(i) && void 0 === o && (r += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [
                        new e.V(t1.key, h, r)
                    ];
                }
                return "categorical" !== o || "number" !== l || "number" == typeof c && isFinite(c) && Math.floor(c) === c ? "categorical" !== o && "number" === l && "number" == typeof c && "number" == typeof a && void 0 !== a && c < a ? [
                    new e.V(t1.key, h, "stop domain values must appear in ascending order")
                ] : (a = c, "categorical" === o && c in s ? [
                    new e.V(t1.key, h, "stop domain values must be unique")
                ] : (s[c] = !0, [])) : [
                    new e.V(t1.key, h, `integer expected, found ${String(c)}`)
                ];
            }
        }
        function me(t1) {
            const i = ("property" === t1.expressionContext ? e.x : e.y)(e.v(t1.value), t1.valueSpec);
            if ("error" === i.result) return i.value.map((i)=>new e.V(`${t1.key}${i.key}`, t1.value, i.message));
            const o = i.value.expression || i.value._styleExpression.expression;
            if ("property" === t1.expressionContext && "text-font" === t1.propertyKey && !o.outputDefined()) return [
                new e.V(t1.key, t1.value, `Invalid data expression for "${t1.propertyKey}". Output values must be contained as literals within the expression.`)
            ];
            if ("property" === t1.expressionContext && "layout" === t1.propertyType && !e.z(o)) return [
                new e.V(t1.key, t1.value, '"feature-state" data expressions are not supported with layout properties.')
            ];
            if ("filter" === t1.expressionContext) return ge(o, t1);
            if (t1.expressionContext && 0 === t1.expressionContext.indexOf("cluster")) {
                if (!e.A(o, [
                    "zoom",
                    "feature-state"
                ])) return [
                    new e.V(t1.key, t1.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')
                ];
                if ("cluster-initial" === t1.expressionContext && !e.B(o)) return [
                    new e.V(t1.key, t1.value, "Feature data expressions are not supported with initial expression part of cluster properties.")
                ];
            }
            return [];
        }
        function ge(t1, i) {
            const o = new Set([
                "zoom",
                "feature-state",
                "pitch",
                "distance-from-center"
            ]);
            if (i.valueSpec && i.valueSpec.expression) for (const e of i.valueSpec.expression.parameters)o.delete(e);
            if (0 === o.size) return [];
            const r = [];
            return t1 instanceof e.D && o.has(t1.name) ? [
                new e.V(i.key, i.value, `["${t1.name}"] expression is not supported in a filter for a ${i.object.type} layer with id: ${i.object.id}`)
            ] : (t1.eachChild((e)=>{
                r.push(...ge(e, i));
            }), r);
        }
        function ve(t1) {
            const i = t1.key, o = t1.value, r = t1.valueSpec, a = [];
            return Array.isArray(r.values) ? -1 === r.values.indexOf(e.u(o)) && a.push(new e.V(i, o, `expected one of [${r.values.join(", ")}], ${JSON.stringify(o)} found`)) : -1 === Object.keys(r.values).indexOf(e.u(o)) && a.push(new e.V(i, o, `expected one of [${Object.keys(r.values).join(", ")}], ${JSON.stringify(o)} found`)), a;
        }
        function xe(t1) {
            return e.G(e.v(t1.value)) ? me(e.o({}, t1, {
                expressionContext: "filter",
                valueSpec: t1.styleSpec[`filter_${t1.layerType || "fill"}`]
            })) : ye(t1);
        }
        function ye(t1) {
            const i = t1.value, o = t1.key;
            if ("array" !== e.n(i)) return [
                new e.V(o, i, `array expected, ${e.n(i)} found`)
            ];
            const r = t1.styleSpec;
            let a, n = [];
            if (i.length < 1) return [
                new e.V(o, i, "filter array must have at least 1 element")
            ];
            switch(n = n.concat(ve({
                key: `${o}[0]`,
                value: i[0],
                valueSpec: r.filter_operator,
                style: t1.style,
                styleSpec: t1.styleSpec
            })), e.u(i[0])){
                case "<":
                case "<=":
                case ">":
                case ">=":
                    i.length >= 2 && "$type" === e.u(i[1]) && n.push(new e.V(o, i, `"$type" cannot be use with operator "${i[0]}"`));
                case "==":
                case "!=":
                    3 !== i.length && n.push(new e.V(o, i, `filter array for operator "${i[0]}" must have 3 elements`));
                case "in":
                case "!in":
                    i.length >= 2 && (a = e.n(i[1]), "string" !== a && n.push(new e.V(`${o}[1]`, i[1], `string expected, ${a} found`)));
                    for(let s = 2; s < i.length; s++)a = e.n(i[s]), "$type" === e.u(i[1]) ? n = n.concat(ve({
                        key: `${o}[${s}]`,
                        value: i[s],
                        valueSpec: r.geometry_type,
                        style: t1.style,
                        styleSpec: t1.styleSpec
                    })) : "string" !== a && "number" !== a && "boolean" !== a && n.push(new e.V(`${o}[${s}]`, i[s], `string, number, or boolean expected, ${a} found`));
                    break;
                case "any":
                case "all":
                case "none":
                    for(let e = 1; e < i.length; e++)n = n.concat(ye({
                        key: `${o}[${e}]`,
                        value: i[e],
                        style: t1.style,
                        styleSpec: t1.styleSpec
                    }));
                    break;
                case "has":
                case "!has":
                    a = e.n(i[1]), 2 !== i.length ? n.push(new e.V(o, i, `filter array for "${i[0]}" operator must have 2 elements`)) : "string" !== a && n.push(new e.V(`${o}[1]`, i[1], `string expected, ${a} found`));
            }
            return n;
        }
        function be(t1, i) {
            const o = t1.key, r = t1.style, a = t1.layer, n = t1.styleSpec, s = t1.value, l = t1.objectKey, c = n[`${i}_${t1.layerType}`];
            if (!c) return [];
            const h = l.match(/^(.*)-transition$/);
            if ("paint" === i && h && c[h[1]] && c[h[1]].transition) return ze({
                key: o,
                value: s,
                valueSpec: n.transition,
                style: r,
                styleSpec: n
            });
            const _ = t1.valueSpec || c[l];
            if (!_) return [
                new e.m(o, s, `unknown property "${l}"`)
            ];
            let u;
            if ("string" === e.n(s) && e.q(_) && !_.tokens && (u = /^{([^}]+)}$/.exec(s))) {
                const t1 = `\`{ "type": "identity", "property": ${u ? JSON.stringify(u[1]) : '"_"'} }\``;
                return [
                    new e.V(o, s, `"${l}" does not support interpolation syntax\nUse an identity property function instead: ${t1}.`)
                ];
            }
            const d = [];
            if ("symbol" === t1.layerType) "text-field" !== l || !r || r.glyphs || r.imports || d.push(new e.V(o, s, 'use of "text-field" requires a style "glyphs" property')), "text-font" === l && e.H(e.v(s)) && "identity" === e.u(s.type) && d.push(new e.V(o, s, '"text-font" does not support identity functions'));
            else if ("model" === t1.layerType && "paint" === i && a && a.layout && a.layout.hasOwnProperty("model-id") && e.q(_) && (e.J(_) || e.r(_))) {
                const t1 = e.x(e.v(s), _), i = t1.value.expression || t1.value._styleExpression.expression;
                i && !e.A(i, [
                    "measure-light"
                ]) && ("model-emissive-strength" === l && e.B(i) && e.z(i) || d.push(new e.V(o, s, `${l} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
            }
            return d.concat(ze({
                key: t1.key,
                value: s,
                valueSpec: _,
                style: r,
                styleSpec: n,
                expressionContext: "property",
                propertyType: i,
                propertyKey: l
            }));
        }
        function we(e) {
            return be(e, "paint");
        }
        function Te(e) {
            return be(e, "layout");
        }
        function Ee(t1) {
            let i = [];
            const o = t1.value, r = t1.key, a = t1.style, n = t1.styleSpec;
            o.type || o.ref || i.push(new e.V(r, o, 'either "type" or "ref" is required'));
            let s = e.u(o.type);
            const l = e.u(o.ref);
            if (o.id) {
                const n = e.u(o.id);
                for(let s = 0; s < t1.arrayIndex; s++){
                    const t1 = a.layers[s];
                    e.u(t1.id) === n && i.push(new e.V(r, o.id, `duplicate layer id "${o.id}", previously used at line ${t1.id.__line__}`));
                }
            }
            if ("ref" in o) {
                let t1;
                [
                    "type",
                    "source",
                    "source-layer",
                    "filter",
                    "layout"
                ].forEach((t1)=>{
                    t1 in o && i.push(new e.V(r, o[t1], `"${t1}" is prohibited for ref layers`));
                }), a.layers.forEach((i)=>{
                    e.u(i.id) === l && (t1 = i);
                }), t1 ? t1.ref ? i.push(new e.V(r, o.ref, "ref cannot reference another ref layer")) : s = e.u(t1.type) : "string" == typeof l && i.push(new e.V(r, o.ref, `ref layer "${l}" not found`));
            } else if ("background" !== s && "sky" !== s && "slot" !== s) {
                if (o.source) {
                    const t1 = a.sources && a.sources[o.source], n = t1 && e.u(t1.type);
                    t1 ? "vector" === n && "raster" === s ? i.push(new e.V(r, o.source, `layer "${o.id}" requires a raster source`)) : "raster" === n && "raster" !== s ? i.push(new e.V(r, o.source, `layer "${o.id}" requires a vector source`)) : "vector" !== n || o["source-layer"] ? "raster-dem" === n && "hillshade" !== s ? i.push(new e.V(r, o.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "raster-array" !== n || [
                        "raster",
                        "raster-particle"
                    ].includes(s) ? "line" !== s || !o.paint || !o.paint["line-gradient"] && !o.paint["line-trim-offset"] || "geojson" === n && t1.lineMetrics ? "raster-particle" === s && "raster-array" !== n && i.push(new e.V(r, o.source, `layer "${o.id}" requires a 'raster-array' source.`)) : i.push(new e.V(r, o, `layer "${o.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : i.push(new e.V(r, o.source, "raster-array source can only be used with layer type 'raster'.")) : i.push(new e.V(r, o, `layer "${o.id}" must specify a "source-layer"`)) : i.push(new e.V(r, o.source, `source "${o.source}" not found`));
                } else i.push(new e.V(r, o, 'missing required property "source"'));
            }
            return i = i.concat(ue({
                key: r,
                value: o,
                valueSpec: n.layer,
                style: t1.style,
                styleSpec: t1.styleSpec,
                objectElementValidators: {
                    "*": ()=>[],
                    type: ()=>ze({
                            key: `${r}.type`,
                            value: o.type,
                            valueSpec: n.layer.type,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            object: o,
                            objectKey: "type"
                        }),
                    filter: (t1)=>xe(e.o({
                            layerType: s
                        }, t1)),
                    layout: (t1)=>ue({
                            layer: o,
                            key: t1.key,
                            value: t1.value,
                            valueSpec: {},
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            objectElementValidators: {
                                "*": (t1)=>Te(e.o({
                                        layerType: s
                                    }, t1))
                            }
                        }),
                    paint: (t1)=>ue({
                            layer: o,
                            key: t1.key,
                            value: t1.value,
                            valueSpec: {},
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            objectElementValidators: {
                                "*": (t1)=>we(e.o({
                                        layerType: s,
                                        layer: o
                                    }, t1))
                            }
                        })
                }
            })), i;
        }
        function Ce(t1) {
            const i = t1.value, o = t1.key, r = e.n(i);
            return "string" !== r ? [
                new e.V(o, i, `string expected, ${r} found`)
            ] : [];
        }
        const Se = {
            promoteId: function({ key: t1, value: i }) {
                if ("string" === e.n(i)) return Ce({
                    key: t1,
                    value: i
                });
                {
                    const e = [];
                    for(const o in i)e.push(...Ce({
                        key: `${t1}.${o}`,
                        value: i[o]
                    }));
                    return e;
                }
            }
        };
        function Ie(t1) {
            const i = t1.value, o = t1.key, r = t1.styleSpec, a = t1.style;
            if (!i.type) return [
                new e.V(o, i, '"type" is required')
            ];
            const n = e.u(i.type);
            let s = [];
            switch([
                "vector",
                "raster",
                "raster-dem",
                "raster-array"
            ].includes(n) && (i.url || i.tiles || s.push(new e.m(o, i, 'Either "url" or "tiles" is required.'))), n){
                case "vector":
                case "raster":
                case "raster-dem":
                case "raster-array":
                    return s = s.concat(ue({
                        key: o,
                        value: i,
                        valueSpec: r[`source_${n.replace("-", "_")}`],
                        style: t1.style,
                        styleSpec: r,
                        objectElementValidators: Se
                    })), s;
                case "geojson":
                    if (s = ue({
                        key: o,
                        value: i,
                        valueSpec: r.source_geojson,
                        style: a,
                        styleSpec: r,
                        objectElementValidators: Se
                    }), i.cluster) for(const e in i.clusterProperties){
                        const [t1, r] = i.clusterProperties[e], a = "string" == typeof t1 ? [
                            t1,
                            [
                                "accumulated"
                            ],
                            [
                                "get",
                                e
                            ]
                        ] : t1;
                        s.push(...me({
                            key: `${o}.${e}.map`,
                            value: r,
                            expressionContext: "cluster-map"
                        })), s.push(...me({
                            key: `${o}.${e}.reduce`,
                            value: a,
                            expressionContext: "cluster-reduce"
                        }));
                    }
                    return s;
                case "video":
                    return ue({
                        key: o,
                        value: i,
                        valueSpec: r.source_video,
                        style: a,
                        styleSpec: r
                    });
                case "image":
                    return ue({
                        key: o,
                        value: i,
                        valueSpec: r.source_image,
                        style: a,
                        styleSpec: r
                    });
                case "canvas":
                    return [
                        new e.V(o, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")
                    ];
                default:
                    return ve({
                        key: `${o}.type`,
                        value: i.type,
                        valueSpec: {
                            values: Le(r)
                        },
                        style: a,
                        styleSpec: r
                    });
            }
        }
        function Le(e) {
            return e.source.reduce((t1, i)=>{
                const o = e[i];
                return "enum" === o.type.type && (t1 = t1.concat(Object.keys(o.type.values))), t1;
            }, []);
        }
        function Pe(t1) {
            const i = t1.value, o = t1.styleSpec, r = o.light, a = t1.style;
            let n = [];
            const s = e.n(i);
            if (void 0 === i) return n;
            if ("object" !== s) return n = n.concat([
                new e.V("light", i, `object expected, ${s} found`)
            ]), n;
            for(const t1 in i){
                const s = t1.match(/^(.*)-transition$/);
                n = n.concat(s && r[s[1]] && r[s[1]].transition ? ze({
                    key: t1,
                    value: i[t1],
                    valueSpec: o.transition,
                    style: a,
                    styleSpec: o
                }) : r[t1] ? ze({
                    key: t1,
                    value: i[t1],
                    valueSpec: r[t1],
                    style: a,
                    styleSpec: o
                }) : [
                    new e.V(t1, i[t1], `unknown property "${t1}"`)
                ]);
            }
            return n;
        }
        function Ae(t1) {
            const i = t1.value;
            let o = [];
            if (!i) return o;
            const r = e.n(i);
            if ("object" !== r) return o = o.concat([
                new e.V("light-3d", i, `object expected, ${r} found`)
            ]), o;
            const a = t1.styleSpec, n = a["light-3d"], s = t1.key, l = t1.style, c = t1.style.lights;
            for (const t1 of [
                "type",
                "id"
            ])if (!(t1 in i)) return o = o.concat([
                new e.V("light-3d", i, `missing property ${t1} on light`)
            ]), o;
            if (i.type && c) for(let r = 0; r < t1.arrayIndex; r++){
                const t1 = e.u(i.type), a = c[r];
                e.u(a.type) === t1 && o.push(new e.V(s, i.id, `duplicate light type "${i.type}", previously defined at line ${a.id.__line__}`));
            }
            const h = `properties_light_${i.type}`;
            if (!(h in a)) return o = o.concat([
                new e.V("light-3d", i, `Invalid light type ${i.type}`)
            ]), o;
            const _ = a[h];
            for(const r in i)if ("properties" === r) {
                const n = i[r], s = e.n(n);
                if ("object" !== s) return o = o.concat([
                    new e.V("properties", n, `object expected, ${s} found`)
                ]), o;
                for(const i in n)o = o.concat(_[i] ? ze({
                    key: i,
                    value: n[i],
                    valueSpec: _[i],
                    style: l,
                    styleSpec: a
                }) : [
                    new e.m(t1.key, n[i], `unknown property "${i}"`)
                ]);
            } else {
                const t1 = r.match(/^(.*)-transition$/);
                o = o.concat(t1 && n[t1[1]] && n[t1[1]].transition ? ze({
                    key: r,
                    value: i[r],
                    valueSpec: a.transition,
                    style: l,
                    styleSpec: a
                }) : n[r] ? ze({
                    key: r,
                    value: i[r],
                    valueSpec: n[r],
                    style: l,
                    styleSpec: a
                }) : [
                    new e.m(r, i[r], `unknown property "${r}"`)
                ]);
            }
            return o;
        }
        function Re(t1) {
            const i = t1.value, o = t1.key, r = t1.style, a = t1.styleSpec, n = a.terrain;
            let s = [];
            const l = e.n(i);
            if (void 0 === i) return s;
            if ("null" === l) return s;
            if ("object" !== l) return s = s.concat([
                new e.V("terrain", i, `object expected, ${l} found`)
            ]), s;
            for(const t1 in i){
                const o = t1.match(/^(.*)-transition$/);
                s = s.concat(o && n[o[1]] && n[o[1]].transition ? ze({
                    key: t1,
                    value: i[t1],
                    valueSpec: a.transition,
                    style: r,
                    styleSpec: a
                }) : n[t1] ? ze({
                    key: t1,
                    value: i[t1],
                    valueSpec: n[t1],
                    style: r,
                    styleSpec: a
                }) : [
                    new e.m(t1, i[t1], `unknown property "${t1}"`)
                ]);
            }
            if (i.source) {
                const t1 = r.sources && r.sources[i.source], a = t1 && e.u(t1.type);
                t1 ? "raster-dem" !== a && s.push(new e.V(o, i.source, `terrain cannot be used with a source of type ${String(a)}, it only be used with a "raster-dem" source type`)) : s.push(new e.V(o, i.source, `source "${i.source}" not found`));
            } else s.push(new e.V(o, i, 'terrain is missing required property "source"'));
            return s;
        }
        function De(t1) {
            const i = t1.value, o = t1.style, r = t1.styleSpec, a = r.fog;
            let n = [];
            const s = e.n(i);
            if (void 0 === i) return n;
            if ("object" !== s) return n = n.concat([
                new e.V("fog", i, `object expected, ${s} found`)
            ]), n;
            for(const t1 in i){
                const s = t1.match(/^(.*)-transition$/);
                n = n.concat(s && a[s[1]] && a[s[1]].transition ? ze({
                    key: t1,
                    value: i[t1],
                    valueSpec: r.transition,
                    style: o,
                    styleSpec: r
                }) : a[t1] ? ze({
                    key: t1,
                    value: i[t1],
                    valueSpec: a[t1],
                    style: o,
                    styleSpec: r
                }) : [
                    new e.m(t1, i[t1], `unknown property "${t1}"`)
                ]);
            }
            return n;
        }
        const Me = {
            "*": ()=>[],
            array: de,
            boolean: function(t1) {
                const i = t1.value, o = t1.key, r = e.n(i);
                return "boolean" !== r ? [
                    new e.V(o, i, `boolean expected, ${r} found`)
                ] : [];
            },
            number: pe,
            color: function(t1) {
                const i = t1.key, o = t1.value, r = e.n(o);
                return "string" !== r ? [
                    new e.V(i, o, `color expected, ${r} found`)
                ] : null === e.F(o) ? [
                    new e.V(i, o, `color expected, "${o}" found`)
                ] : [];
            },
            enum: ve,
            filter: xe,
            function: fe,
            layer: Ee,
            object: ue,
            source: Ie,
            model: e.K,
            light: Pe,
            "light-3d": Ae,
            terrain: Re,
            fog: De,
            string: Ce,
            formatted: function(e) {
                return 0 === Ce(e).length ? [] : me(e);
            },
            resolvedImage: function(e) {
                return 0 === Ce(e).length ? [] : me(e);
            },
            projection: function(t1) {
                const i = t1.value, o = t1.styleSpec, r = o.projection, a = t1.style;
                let n = [];
                const s = e.n(i);
                if ("object" === s) for(const e in i)n = n.concat(ze({
                    key: e,
                    value: i[e],
                    valueSpec: r[e],
                    style: a,
                    styleSpec: o
                }));
                else "string" !== s && (n = n.concat([
                    new e.V("projection", i, `object or string expected, ${s} found`)
                ]));
                return n;
            },
            import: function(t1) {
                const { value: i, styleSpec: o } = t1, { data: r, ...a } = i;
                Object.defineProperty(a, "__line__", {
                    value: i.__line__,
                    enumerable: !1
                });
                let n = ue(e.o({}, t1, {
                    value: a,
                    valueSpec: o.import
                }));
                return "" === e.u(a.id) && n.push(new e.V(`${t1.key}.id`, a, "import id can't be an empty string")), r && (n = n.concat(Fe(r, o, {
                    key: `${t1.key}.data`
                }))), n;
            }
        };
        function ze(t1, i = !1) {
            const o = t1.value, r = t1.valueSpec, a = t1.styleSpec;
            if (r.expression && e.H(e.u(o))) return fe(t1);
            if (r.expression && e.t(e.v(o))) return me(t1);
            if (r.type && Me[r.type]) {
                const o = Me[r.type](t1);
                return !0 === i && o.length > 0 && "array" === e.n(t1.value) ? me(t1) : o;
            }
            return ue(e.o({}, t1, {
                valueSpec: r.type ? a[r.type] : r
            }));
        }
        function Oe(t1) {
            const i = t1.value, o = t1.key, r = Ce(t1);
            return r.length || (-1 === i.indexOf("{fontstack}") && r.push(new e.V(o, i, '"glyphs" url must include a "{fontstack}" token')), -1 === i.indexOf("{range}") && r.push(new e.V(o, i, '"glyphs" url must include a "{range}" token'))), r;
        }
        function Fe(t1, i = e.L, o = {}) {
            return ze({
                key: o.key || "",
                value: t1,
                valueSpec: i.$root,
                styleSpec: i,
                style: t1,
                objectElementValidators: {
                    glyphs: Oe,
                    "*": ()=>[]
                }
            });
        }
        function Be(t1, i = e.L) {
            return $e(Fe(t1, i));
        }
        const ke = (e)=>$e(Ie(e)), Ne = (e)=>$e(Pe(e)), Ue = (e)=>$e(Ae(e)), Ge = (e)=>$e(Re(e)), je = (e)=>$e(De(e)), Ve = (e)=>$e(Ee(e)), We = (e)=>$e(xe(e)), Ze = (e)=>$e(we(e)), qe = (e)=>$e(Te(e)), He = (t1)=>$e(e.K(t1));
        function $e(e) {
            return e.slice().sort((e, t1)=>e.line && t1.line ? e.line - t1.line : 0);
        }
        function Xe(t1, i) {
            let o = !1;
            if (i && i.length) for (const r of i)r instanceof e.m ? e.w(r.message) : (t1.fire(new e.d(new Error(r.message))), o = !0);
            return o;
        }
        const Ye = new e.N({
            anchor: new e.O(e.L.light.anchor),
            position: new e.Q(e.L.light.position),
            color: new e.O(e.L.light.color),
            intensity: new e.O(e.L.light.intensity)
        });
        class Ke extends e.E {
            constructor(t1, i = "flat"){
                super(), this._transitionable = new e.U(Ye), this.setLight(t1, i), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
                return this._transitionable.serialize();
            }
            setLight(e, t1, i = {}) {
                this._validate(Ne, e, i) || (this._transitionable.setTransitionOrValue(e), this.id = t1);
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && Xe(this, t1.call(Be, e.W({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e.L
                })));
            }
        }
        const Qe = new e.N({
            source: new e.O(e.L.terrain.source),
            exaggeration: new e.O(e.L.terrain.exaggeration)
        });
        let Je = class extends e.E {
            constructor(t1, i, o, r){
                super(), this.scope = o, this._transitionable = new e.U(Qe, o, r), this._transitionable.setTransitionOrValue(t1, r), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i;
            }
            get() {
                return this._transitionable.serialize();
            }
            set(e, t1) {
                this._transitionable.setTransitionOrValue(e, t1);
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            getExaggeration(t1) {
                return this._transitioning.possiblyEvaluate(new e.X(t1)).get("exaggeration");
            }
            isZoomDependent() {
                const t1 = this._transitionable._values.exaggeration;
                return null != t1 && null != t1.value && null != t1.value.expression && t1.value.expression instanceof e.Z;
            }
        };
        const et = 45, tt = 65, it = .05;
        function ot(t1, i, o, r) {
            const a = e.$(et, tt, o), [n, s] = rt(t1, r);
            let l = 1 - Math.min(1, Math.exp((i - n) / (s - n) * -6));
            return l *= l * l, l = Math.min(1, 1.00747 * l), l * a * t1.alpha;
        }
        function rt(e, t1) {
            const i = .5 / Math.tan(.5 * t1);
            return [
                e.range[0] + i,
                e.range[1] + i
            ];
        }
        function at(t1, i, o, r, a) {
            const n = e._.transformMat4([], [
                i,
                o,
                r
            ], a.mercatorFogMatrix);
            return ot(t1, e._.length(n), a.pitch, a._fov);
        }
        function nt(t1, i, o, r, a, n, s) {
            const l = [
                [
                    o,
                    r,
                    0
                ],
                [
                    a,
                    r,
                    0
                ],
                [
                    a,
                    n,
                    0
                ],
                [
                    o,
                    n,
                    0
                ]
            ];
            let c = Number.MAX_VALUE, h = -Number.MAX_VALUE;
            for (const t1 of l){
                const o = e._.transformMat4([], t1, i), r = e._.length(o);
                c = Math.min(c, r), h = Math.max(h, r);
            }
            return [
                ot(t1, c, s.pitch, s._fov),
                ot(t1, h, s.pitch, s._fov)
            ];
        }
        const st = new e.N({
            range: new e.O(e.L.fog.range),
            color: new e.O(e.L.fog.color),
            "high-color": new e.O(e.L.fog["high-color"]),
            "space-color": new e.O(e.L.fog["space-color"]),
            "horizon-blend": new e.O(e.L.fog["horizon-blend"]),
            "star-intensity": new e.O(e.L.fog["star-intensity"]),
            "vertical-range": new e.O(e.L.fog["vertical-range"])
        });
        class lt extends e.E {
            constructor(t1, i, o, r){
                super(), this._transitionable = new e.U(st, o, new Map(r)), this.set(t1, r), this._transitioning = this._transitionable.untransitioned(), this._transform = i, this.properties = new e.a0(st), this.scope = o;
            }
            get state() {
                const t1 = this._transform, i = "globe" === t1.projection.name, o = e.a1(t1.zoom), r = this.properties.get("range"), a = [
                    .5,
                    3
                ];
                return {
                    range: i ? [
                        e.a2(a[0], r[0], o),
                        e.a2(a[1], r[1], o)
                    ] : r,
                    horizonBlend: this.properties.get("horizon-blend"),
                    alpha: this.properties.get("color").a
                };
            }
            get() {
                return this._transitionable.serialize();
            }
            set(t1, i, o = {}) {
                if (this._validate(je, t1, o)) return;
                const r = e.W({}, t1);
                for (const t1 of Object.keys(e.L.fog))void 0 === r[t1] && (r[t1] = e.L.fog[t1].default);
                this._options = r, this._transitionable.setTransitionOrValue(this._options, i);
            }
            getOpacity(t1) {
                if (!this._transform.projection.supportsFog) return 0;
                const i = this.properties && this.properties.get("color") || 1;
                return ("globe" === this._transform.projection.name ? 1 : e.$(et, tt, t1)) * i.a;
            }
            getOpacityAtLatLng(t1, i) {
                return this._transform.projection.supportsFog ? function(t1, i, o) {
                    const r = e.Y.fromLngLat(i), a = o.elevation ? o.elevation.getAtPointOrZero(r) : 0;
                    return at(t1, r.x, r.y, a, o);
                }(this.state, t1, i) : 0;
            }
            getOpacityForTile(t1) {
                if (!this._transform.projection.supportsFog) return [
                    1,
                    1
                ];
                const i = this._transform.calculateFogTileMatrix(t1.toUnwrapped());
                return nt(this.state, i, 0, 0, e.a3, e.a3, this._transform);
            }
            getOpacityForBounds(e, t1, i, o, r) {
                return this._transform.projection.supportsFog ? nt(this.state, e, t1, i, o, r, this._transform) : [
                    1,
                    1
                ];
            }
            getFovAdjustedRange(e) {
                return this._transform.projection.supportsFog ? rt(this.state, e) : [
                    0,
                    1
                ];
            }
            isVisibleOnFrustum(t1) {
                if (!this._transform.projection.supportsFog) return !1;
                const i = [
                    4,
                    5,
                    6,
                    7
                ];
                for (const o of i){
                    const i = t1.points[o];
                    let r;
                    if (i[2] >= 0) r = i;
                    else {
                        const a = t1.points[o - 4];
                        r = e.a4(a, i, a[2] / (a[2] - i[2]));
                    }
                    if (at(this.state, r[0], r[1], 0, this._transform) >= it) return !0;
                }
                return !1;
            }
            updateConfig(e) {
                this._transitionable.setTransitionOrValue(this._options, new Map(e));
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && Xe(this, t1.call(Be, e.W({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e.L
                })));
            }
        }
        class ct extends e.E {
            constructor(t1, i, o, r){
                super(), this.scope = o, this._options = t1, this.properties = new e.a0(i), this._transitionable = new e.U(i, o, new Map(r)), this._transitionable.setTransitionOrValue(t1.properties), this._transitioning = this._transitionable.untransitioned();
            }
            updateConfig(e) {
                this._transitionable.setTransitionOrValue(this._options.properties, new Map(e));
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            get() {
                return this._options.properties = this._transitionable.serialize(), this._options;
            }
            set(e, t1) {
                this._options = e, this._transitionable.setTransitionOrValue(e.properties, t1);
            }
            shadowsEnabled() {
                return !!this.properties && !0 === this.properties.get("cast-shadows");
            }
        }
        const ht = new e.N({
            color: new e.O(e.L.properties_light_ambient.color),
            intensity: new e.O(e.L.properties_light_ambient.intensity)
        }), _t = new e.N({
            direction: new e.a5(e.L.properties_light_directional.direction),
            color: new e.O(e.L.properties_light_directional.color),
            intensity: new e.O(e.L.properties_light_directional.intensity),
            "cast-shadows": new e.O(e.L.properties_light_directional["cast-shadows"]),
            "shadow-intensity": new e.O(e.L.properties_light_directional["shadow-intensity"])
        });
        var ut = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif", dt = "\nout vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec2 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color) {\n#ifdef INDICATOR_CUTOUT\nfloat holeMinOpacity=u_indicator_cutout_params.x;float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\ngl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\n#endif\nvec4 textureLodCustom(sampler2D image,vec2 pos,vec2 lod_coord) {vec2 size=vec2(textureSize(image,0));vec2 dx=dFdx(lod_coord.xy*size);vec2 dy=dFdy(lod_coord.xy*size);float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}", pt = "\n#define EXTENT 8192.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}", ft = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", mt = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform highp sampler2D u_depth;uniform vec2 u_depth_size_inv;uniform vec2 u_depth_range_unpack;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\n#ifdef TERRAIN_DEPTH_D24\nfloat unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}\n#else\nhighp float unpack_depth_rgba(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;\n#ifdef TERRAIN_DEPTH_D24\nfloat depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);\n#else\nfloat depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));\n#endif\nreturn coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;\n#ifdef TERRAIN_DEPTH_D24\nvec4 depth=vec4(\ntexture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r\n);depth=unpack_depth4(depth);\n#else\nvec4 depth=vec4(\nunpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))\n);\n#endif\nreturn dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", gt = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", vt = "highp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}\n#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {\n#ifdef FOG_DITHERING\nvec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);\n#else\nreturn color;\n#endif\n}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", xt = "#ifdef RASTER_ARRAY\nuniform sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\n#endif", yt = "#ifdef RASTER_ARRAY\nuniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}\n#endif\nuniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}", bt = "#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif//RENDER_SHADOWS", wt = "#ifdef RENDER_SHADOWS\n#ifdef DEPTH_TEXTURE\nuniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;\n#else\nuniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;\n#endif\nuniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_1,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_0,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;\n#ifdef NATIVE\nhighp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));\n#else\nhighp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(\nshadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)\n);\n#endif\nvec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {\n#ifdef SHADOWS_SINGLE_CASCADE\nlight_view_pos0.xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);\n#else\nlight_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";
        const Tt = [];
        Pt(ut, Tt), Pt(pt, Tt), Pt(dt, Tt);
        const Et = {
            "_prelude_fog.vertex.glsl": gt,
            "_prelude_terrain.vertex.glsl": mt,
            "_prelude_shadow.vertex.glsl": bt,
            "_prelude_fog.fragment.glsl": vt,
            "_prelude_shadow.fragment.glsl": wt,
            "_prelude_lighting.glsl": "\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif//LIGHTING_3D_MODE",
            "_prelude_raster_array.glsl": xt,
            "_prelude_raster_particle.glsl": yt
        }, Ct = {};
        At("", mt), At(vt, gt), At(wt, bt), At(xt, ""), At(yt, "");
        const St = At(dt, pt), It = ut;
        var Lt = {
            background: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nin vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_lighting.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            backgroundPattern: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            circle: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\nglFragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}'),
            clippingMask: At("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
            heatmap: At('#include "_prelude_fog.fragment.glsl"\nuniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'),
            heatmapTexture: At("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
            collisionBox: At("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", '#include "_prelude_terrain.vertex.glsl"\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in float a_size_scale;in vec2 a_padding;in float a_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(a_z_offset+elevation(a_anchor_pos)),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'),
            collisionCircle: At("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", "in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
            debug: At("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", '#include "_prelude_terrain.vertex.glsl"\nin vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;\n#endif\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}'),
            fill: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            fillOutline: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            fillOutlinePattern: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;in highp vec2 v_pos;in highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;out highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            fillPattern: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;in vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            fillExtrusion: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in vec4 v_flat;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nin vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nin highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nin float v_flood_radius;in float v_has_floodlight;\n#endif\nuniform float u_emissive_strength;in float v_height;void main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor;\n#ifdef RENDER_CUTOFF\nshadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}\n#else\nshadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);\n#endif\ncolor.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor.rgb=mix(color.rgb,v_flat.rgb,u_emissive_strength);color*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nout vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nout highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nout float v_flood_radius;out float v_has_floodlight;\n#endif\nout float v_height;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat cutoff=1.0;vec3 scaled_pos=pos;\n#ifdef RENDER_CUTOFF\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=cutoff_opacity(u_cutoff_params,ground.z);if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0));gl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);v_flat=vec4(linearProduct(color.rgb,vec3(calculate_NdotL(normal))),1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'),
            fillExtrusionDepth: At("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_vertical_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\nout highp float v_depth;void main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base);pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'),
            fillExtrusionPattern: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nin vec3 v_normal;\n#endif\nin vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nout vec2 v_pos;out vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nout vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}'),
            groundShadow: At('#include "_prelude_shadow.fragment.glsl"\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0)).r);\n#endif\nglFragColor=vec4(shadow,1.0);}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}'),
            fillExtrusionGroundEffect: At("uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nin highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\nglFragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\nglFragColor=color;\n#endif\nHANDLE_WIREFRAME_DEBUG;\n#endif\n}", '#include "_prelude_fog.vertex.glsl"\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\n#ifdef FOG\nout highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(1.0,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'),
            hillshadePrepare: At("precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
            hillshade: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\n#endif\n#ifdef FOG\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            line: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform lowp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;in vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trim_alpha=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/clamp(u_trim_fade_range[0],1e-4,1.0)));float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/clamp(u_trim_fade_range[1],1e-4,1.0)));float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=out_color.a;}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color.rgb=mix(border_color.rgb*border_color.a*trim_alpha,out_color.rgb,smoothAlpha);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define EXTRUDE_SCALE 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED)\nin float a_z_offset;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nin highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nin float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);\n#if defined(ELEVATED)\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 halfCellProgress=normal.yx*32.0;float ele0=elevation(pos);float ele_line=max(ele0,max(elevation(pos+halfCellProgress),elevation(pos-halfCellProgress)));float ele1=elevation(pos+offsetTile);float ele2=elevation(pos-offsetTile);float ele_max=max(ele_line,0.5*(ele1+ele2));float ele=ele_max-ele0+ele1+a_z_offset ;gl_Position=u_matrix*vec4(pos+offsetTile,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*0.1*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);\n#else\ngl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'),
            linePattern: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform highp float u_device_pixel_ratio;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec4 v_uv;\n#endif\n#ifdef LINE_JOIN_NONE\nin vec2 v_pattern_data;\n#endif\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define mediump float pixel_ratio\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize mediump float pixel_ratio\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;float x=mod(pattern_x,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {color=vec4(0,0,0,0);}}\n#endif\n#ifdef LINE_JOIN_NONE\nfloat pattern_len=pattern_size/aspect;float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}\n#endif\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_ground(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED)\nin float a_z_offset;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec4 a_packed;\n#endif\nin highp float a_linesofar;\n#ifdef LINE_JOIN_NONE\nin highp vec3 a_pattern_data;out vec2 v_pattern_data;\n#endif\nuniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nout highp vec4 v_uv;\n#endif\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\n#pragma mapbox: define mediump float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define mediump float floorwidth\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define mediump float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\n#pragma mapbox: initialize mediump float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize mediump float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize mediump float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);\n#if defined(ELEVATED)\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 halfCellProgress=normal.yx*32.0;float ele0=elevation(pos);float ele_line=max(ele0,max(elevation(pos+halfCellProgress),elevation(pos-halfCellProgress)));float ele1=elevation(pos+offsetTile);float ele2=elevation(pos-offsetTile);float ele_max=max(ele_line,0.5*(ele1+ele2));float ele=ele_max-ele0+ele1+a_z_offset ;gl_Position=u_matrix*vec4(pos+offsetTile,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*0.1*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);\n#else\ngl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nfloat a_uv_x=a_packed[0];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];v_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef LINE_JOIN_NONE\nv_width=floorwidth+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'),
            raster: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_raster_array.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nin float v_split_fade;\n#endif\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\n#ifndef RASTER_ARRAY\nuniform sampler2D u_image0;uniform sampler2D u_image1;\n#endif\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\n#endif\nvoid main() {vec4 color0,color1,color;vec2 value;\n#ifdef RASTER_COLOR\n#ifdef RASTER_ARRAY\n#ifdef RASTER_ARRAY_LINEAR\nvalue=mix(\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#else\nvalue=mix(\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#endif\nif (value.y > 0.0) value.x/=value.y;\n#else\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\n#endif\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\n#else\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;\n#ifdef GLOBE_POLES\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\n#endif\nvec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef PROJECTION_GLOBE_VIEW\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\n#endif\n#ifdef RENDER_CUTOFF\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;in vec2 a_texture_pos;\n#endif\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nout float v_split_fade;\n#endif\nvoid main() {vec2 uv;\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\n#ifdef RENDER_CUTOFF\nv_depth=gl_Position.z;\n#endif\n}'),
            rasterParticle: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\nuv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'),
            rasterParticleDraw: At("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", '#include "_prelude_raster_particle.glsl"\nin float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(\nmod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}'),
            rasterParticleTexture: At("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"),
            rasterParticleUpdate: At('#include "_prelude_raster_particle.glsl"\nuniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(\nlinearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)\n);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}', "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"),
            symbolIcon: At('#include "_prelude_lighting.glsl"\nuniform sampler2D u_texture;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\nin float v_fade_opacity;in vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nin vec2 v_tex_b;\n#endif\n#ifdef COLOR_ADJUSTMENT\nuniform mat4 u_color_adj_mat;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float emissive_strength\nlowp float alpha=opacity*v_fade_opacity;vec4 out_color;\n#ifdef ICON_TRANSITION\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);\n#else\nout_color=texture(u_texture,v_tex_a);\n#endif\n#ifdef COLOR_ADJUSTMENT\nout_color=u_color_adj_mat*out_color;\n#endif\nout_color*=alpha;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef OCCLUSION_QUERIES\nin float a_occlusion_query_opacity;\n#endif\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nin vec2 a_texb;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nout vec2 v_tex_b;\n#endif\nout float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float emissive_strength\n#pragma mapbox: define lowp float occlusion_opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float emissive_strength\n#pragma mapbox: initialize lowp float occlusion_opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;vec2 a;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;\n#endif\nvec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=globe_occlusion_fade;\n#ifdef SYMBOL_OCCLUSION_BY_TERRAIN_DEPTH\nocclusion_fade*=occlusionFade(projected_point);\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nv_tex_a=a_tex/u_texsize;\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\nv_fade_opacity=out_fade_opacity;\n#ifdef OCCLUSION_QUERIES\nfloat occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);v_fade_opacity*=occludedFadeMultiplier;\n#endif\n}'),
            symbolSDF: At('#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\nuniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;in float v_draw_halo;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef OCCLUSION_QUERIES\nin float a_occlusion_query_opacity;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout float v_draw_halo;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\n#pragma mapbox: define lowp float occlusion_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\n#pragma mapbox: initialize lowp float occlusion_opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;\n#endif\nvec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=globe_occlusion_fade;\n#ifdef SYMBOL_OCCLUSION_BY_TERRAIN_DEPTH\nocclusion_fade*=occlusionFade(projected_point);\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;\n#ifdef OCCLUSION_QUERIES\nfloat occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;\n#endif\nfloat alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,out_fade_opacity);}'),
            symbolTextAndIcon: At('#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_halo;in float v_draw_halo;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef OCCLUSION_QUERIES\nin float a_occlusion_query_opacity;\n#endif\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout float v_draw_halo;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\n#pragma mapbox: define lowp float occlusion_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\n#pragma mapbox: initialize lowp float occlusion_opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=globe_occlusion_fade;\n#ifdef SYMBOL_OCCLUSION_BY_TERRAIN_DEPTH\nocclusion_fade*=occlusionFade(projected_point);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nfloat out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;\n#ifdef OCCLUSION_QUERIES\nfloat occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;\n#endif\nfloat alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+ xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,out_fade_opacity,is_sdf);}'),
            terrainRaster: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;in vec2 v_pos0;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\n#endif\n}'),
            terrainDepth: At("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'),
            skybox: At('#include "_prelude_fog.fragment.glsl"\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', ft),
            skyboxGradient: At('#include "_prelude_fog.fragment.glsl"\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', ft),
            skyboxCapture: At("\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}", "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
            globeRaster: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(raster.rgb*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;\n#endif\nout vec2 v_pos0;void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}'),
            globeAtmosphere: At('#include "_prelude_fog.fragment.glsl"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\nglFragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\nglFragColor=vec4(1,1,1,1);\n#else\nglFragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;\n#ifndef NATIVE\nc=dither(c,gl_FragCoord.xy+u_temporal_offset);\n#endif\nglFragColor=vec4(c*t,t);\n#endif\n}', "in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"),
            model: At('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nuniform vec4 u_occlusionTextureTransform;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nin highp float v_depth;uniform highp sampler2D u_depthTexture;uniform vec2 u_inv_depth_size;uniform vec2 u_depth_range_unpack;\n#ifdef TERRAIN_DEPTH_D24\nfloat unpack_depth(float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}\n#else\nhighp float unpack_depth_rgba(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded() {vec2 coord=gl_FragCoord.xy*u_inv_depth_size;\n#ifdef TERRAIN_DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depthTexture,coord).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));\n#endif\nreturn v_depth > depth+0.0005;}\n#endif\n#define saturate(_x) clamp(_x,0.,1.)\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\n#endif\nvec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);\n#ifdef APPLY_LUT_ON_GPU\ncolor=applyLUT(u_lutTexture,color);\n#endif\nreturn color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\n#else\nvec2 uv=uv_2f;\n#endif\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\n#endif\n#ifdef APPLY_LUT_ON_GPU\nfloat emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;\n#ifdef APPLY_LUT_ON_GPU\ncolor_mix=applyLUT(u_lutTexture,color_mix);\n#endif\ncolor=mix(color,color_mix,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor);\n#endif\nglFragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nout vec4 v_position_height;out lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nout highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normalize(normal_3f));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;\n#endif\n}'),
            modelDepth: At("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}"),
            stars: At("in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}", "\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}"),
            occlusion: At("uniform vec4 u_color;void main() {glFragColor=u_color;}", '#include "_prelude_terrain.vertex.glsl"\nin highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;\n#ifdef TERRAIN\nfloat e=elevation(world_pos.xy);world_pos.z+=e;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}')
        };
        function Pt(e, t1) {
            const i = e.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
            for (let e of i)if (e = e.trim(), "#" === e[0] && e.includes("if") && !e.includes("endif")) {
                e = e.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
                const i = e.split(" ");
                for (const e of i)t1.includes(e) || t1.push(e);
            }
        }
        function At(e, t1) {
            const i = /#include\s+"([^"]+)"/g, o = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
            let r = t1.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
            r && (r = r.map((e)=>{
                const t1 = e.split(" ");
                return t1[t1.length - 1];
            }), r = [
                ...new Set(r)
            ]);
            const a = {}, n = [], s = [];
            if (e = e.replace(i, (e, t1)=>(s.push(t1), "")), (t1 = t1.replace(i, (e, t1)=>(n.push(t1), ""))).includes("flat out")) return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');
            let l = [
                ...Tt
            ];
            Pt(e, l), Pt(t1, l);
            for (const e of [
                ...n,
                ...s
            ])Et[e] || console.error(`Undefined include: ${e}`), Ct[e] || (Ct[e] = [], Pt(Et[e], Ct[e])), l = [
                ...l,
                ...Ct[e]
            ];
            return {
                fragmentSource: e = e.replace(o, (e, t1, i, o, r)=>(a[r] = !0, "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${r}\nin ${i} ${o} ${r};\n#else\nuniform ${i} ${o} u_${r};\n#endif\n` : "initialize" === t1 ? `\n#ifdef HAS_UNIFORM_u_${r}\n    ${i} ${o} ${r} = u_${r};\n#endif\n` : "define-attribute" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${r}\n    in ${i} ${o} ${r};\n#endif\n` : "initialize-attribute" === t1 ? "" : void 0)),
                vertexSource: t1 = t1.replace(o, (e, t1, i, o, r)=>{
                    const n = "float" === o ? "vec2" : o, s = r.match(/color/) ? "color" : n;
                    return "define-attribute-vertex-shader-only" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${r}\nin ${i} ${o} a_${r};\n#endif\n` : a[r] ? "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${r}\nuniform lowp float u_${r}_t;\nin ${i} ${n} a_${r};\nout ${i} ${o} ${r};\n#else\nuniform ${i} ${o} u_${r};\n#endif\n` : "initialize" === t1 ? "vec4" === s ? `\n#ifndef HAS_UNIFORM_u_${r}\n    ${r} = a_${r};\n#else\n    ${i} ${o} ${r} = u_${r};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${r}\n    ${r} = unpack_mix_${s}(a_${r}, u_${r}_t);\n#else\n    ${i} ${o} ${r} = u_${r};\n#endif\n` : "define-attribute" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${r}\n    in ${i} ${o} a_${r};\n    out ${i} ${o} ${r};\n#endif\n` : "initialize-attribute" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${r}\n    ${r} = a_${r};\n#endif\n` : void 0 : "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${r}\nuniform lowp float u_${r}_t;\nin ${i} ${n} a_${r};\n#else\nuniform ${i} ${o} u_${r};\n#endif\n` : "define-instanced" === t1 ? "mat4" === s ? `\n#ifdef INSTANCED_ARRAYS\nin vec4 a_${r}0;\nin vec4 a_${r}1;\nin vec4 a_${r}2;\nin vec4 a_${r}3;\n#else\nuniform ${i} ${o} u_${r};\n#endif\n` : `\n#ifdef INSTANCED_ARRAYS\nin ${i} ${n} a_${r};\n#else\nuniform ${i} ${o} u_${r};\n#endif\n` : "initialize-attribute-custom" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${r}\n    ${i} ${o} ${r} = a_${r};\n#endif\n` : "vec4" === s ? `\n#ifndef HAS_UNIFORM_u_${r}\n    ${i} ${o} ${r} = a_${r};\n#else\n    ${i} ${o} ${r} = u_${r};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${r}\n    ${i} ${o} ${r} = unpack_mix_${s}(a_${r}, u_${r}_t);\n#else\n    ${i} ${o} ${r} = u_${r};\n#endif\n`;
                }),
                staticAttributes: r,
                usedDefines: l,
                vertexIncludes: n,
                fragmentIncludes: s
            };
        }
        class Rt {
            constructor(){
                this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
            }
            bind(e, t1, i, o, r, a, n, s) {
                this.context = e;
                let l = this.boundPaintVertexBuffers.length !== o.length;
                for(let e = 0; !l && e < o.length; e++)this.boundPaintVertexBuffers[e] !== o[e] && (l = !0);
                let c = this.boundDynamicVertexBuffers.length !== n.length;
                for(let e = 0; !c && e < n.length; e++)this.boundDynamicVertexBuffers[e] !== n[e] && (c = !0);
                if (!this.vao || this.boundProgram !== t1 || this.boundLayoutVertexBuffer !== i || l || c || this.boundIndexBuffer !== r || this.boundVertexOffset !== a) this.freshBind(t1, i, o, r, a, n, s);
                else {
                    e.bindVertexArrayOES.set(this.vao);
                    for (const i of n)i && (i.bind(), s && i.instanceCount && i.setVertexAttribDivisor(e.gl, t1, s));
                    r && r.dynamicDraw && r.bind();
                }
            }
            freshBind(e, t1, i, o, r, a, n) {
                const s = e.numAttributes, l = this.context, c = l.gl;
                this.vao && this.destroy(), this.vao = l.gl.createVertexArray(), l.bindVertexArrayOES.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = t1, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = r, this.boundDynamicVertexBuffers = a, t1.enableAttributes(c, e), t1.bind(), t1.setVertexAttribPointers(c, e, r);
                for (const t1 of i)t1.enableAttributes(c, e), t1.bind(), t1.setVertexAttribPointers(c, e, r);
                for (const t1 of a)t1 && (t1.enableAttributes(c, e), t1.bind(), t1.setVertexAttribPointers(c, e, r), n && t1.instanceCount && t1.setVertexAttribDivisor(c, e, n));
                o && o.bind(), l.currentNumAttributes = s;
            }
            destroy() {
                this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
            }
        }
        function Dt(t1, i) {
            const o = Math.pow(2, i.canonical.z), r = i.canonical.y;
            return [
                new e.Y(0, r / o).toLngLat().lat,
                new e.Y(0, (r + 1) / o).toLngLat().lat
            ];
        }
        function Mt(t1, i, o, r, a, n, s) {
            const l = t1.context, c = l.gl, h = o.hillshadeFBO;
            if (!h) return;
            t1.prepareDrawTile();
            const _ = t1.isTileAffectedByFog(i), u = t1.getOrCreateProgram("hillshade", {
                overrideFog: _
            });
            l.activeTexture.set(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, h.colorAttachment.get());
            const d = ((t1, i, o, r)=>{
                const a = o.paint.get("hillshade-shadow-color"), n = o.paint.get("hillshade-highlight-color"), s = o.paint.get("hillshade-accent-color"), l = o.paint.get("hillshade-emissive-strength");
                let c = e.ab(o.paint.get("hillshade-illumination-direction"));
                if ("viewport" === o.paint.get("hillshade-illumination-anchor")) c -= t1.transform.angle;
                else if (t1.style && t1.style.enable3dLights() && t1.style.directionalLight) {
                    const i = t1.style.directionalLight.properties.get("direction"), o = e.ac(i.x, i.y, i.z);
                    c = e.ab(o[1]);
                }
                const h = !t1.options.moving;
                return {
                    u_matrix: r || t1.transform.calculateProjMatrix(i.tileID.toUnwrapped(), h),
                    u_image: 0,
                    u_latrange: Dt(0, i.tileID),
                    u_light: [
                        o.paint.get("hillshade-exaggeration"),
                        c
                    ],
                    u_shadow: a.toRenderColor(o.lut),
                    u_highlight: n.toRenderColor(o.lut),
                    u_emissive_strength: l,
                    u_accent: s.toRenderColor(o.lut)
                };
            })(t1, o, r, t1.terrain ? i.projMatrix : null);
            t1.uploadCommonUniforms(l, u, i.toUnwrapped());
            const { tileBoundsBuffer: p, tileBoundsIndexBuffer: f, tileBoundsSegments: m } = t1.getTileBoundsBuffers(o);
            u.draw(t1, c.TRIANGLES, a, n, s, e.af.disabled, d, r.id, p, f, m);
        }
        function zt(t1, i, o) {
            if (!i.needsDEMTextureUpload) return;
            const r = t1.context, a = r.gl;
            r.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || t1.getTileTexture(o.stride);
            const n = o.getPixels();
            i.demTexture ? i.demTexture.update(n, {
                premultiply: !1
            }) : i.demTexture = new e.T(r, n, a.R32F, {
                premultiply: !1
            }), i.needsDEMTextureUpload = !1;
        }
        function Ot(t1, i, o) {
            const r = t1.context, a = r.gl;
            if (!i.dem) return;
            const n = i.dem;
            if (r.activeTexture.set(a.TEXTURE1), zt(t1, i, n), !i.demTexture) return;
            i.demTexture.bind(a.NEAREST, a.CLAMP_TO_EDGE);
            const s = n.dim;
            r.activeTexture.set(a.TEXTURE0);
            let l = i.hillshadeFBO;
            if (!l) {
                const t1 = new e.T(r, {
                    width: s,
                    height: s,
                    data: null
                }, a.RGBA);
                t1.bind(a.LINEAR, a.CLAMP_TO_EDGE), l = i.hillshadeFBO = r.createFramebuffer(s, s, !0, "renderbuffer"), l.colorAttachment.set(t1.texture);
            }
            r.bindFramebuffer.set(l.framebuffer), r.viewport.set([
                0,
                0,
                s,
                s
            ]);
            const { tileBoundsBuffer: c, tileBoundsIndexBuffer: h, tileBoundsSegments: _ } = t1.getMercatorTileBoundsBuffers(), u = [];
            t1.linearFloatFilteringSupported() && u.push("TERRAIN_DEM_FLOAT_FORMAT"), t1.getOrCreateProgram("hillshadePrepare", {
                defines: u
            }).draw(t1, a.TRIANGLES, e.ae.disabled, e.ag.disabled, e.a.unblended, e.af.disabled, ((t1, i)=>{
                const o = i.stride, r = e.ad.create();
                return e.ad.ortho(r, 0, e.a3, -e.a3, 0, 0, 1), e.ad.translate(r, r, [
                    0,
                    -e.a3,
                    0
                ]), {
                    u_matrix: r,
                    u_image: 1,
                    u_dimension: [
                        o,
                        o
                    ],
                    u_zoom: t1.overscaledZ
                };
            })(i.tileID, n), o.id, c, h, _), i.needsHillshadePrepare = !1;
        }
        function Ft(t1, i, o, r, a) {
            const n = function(o, r) {
                if (o) return a(o);
                if (r) {
                    if (t1.url && r.tiles && t1.tiles && delete t1.tiles, r.variants) {
                        if (!Array.isArray(r.variants)) return a(new Error("variants must be an array"));
                        for (const t1 of r.variants){
                            if (null == t1 || "object" != typeof t1 || t1.constructor !== Object) return a(new Error("variant must be an object"));
                            if (!Array.isArray(t1.capabilities)) return a(new Error("capabilities must be an array"));
                            if (1 === t1.capabilities.length && "meshopt" === t1.capabilities[0]) {
                                r = e.W(r, t1);
                                break;
                            }
                        }
                    }
                    const o = e.ah(e.W(r, t1), [
                        "tilejson",
                        "tiles",
                        "minzoom",
                        "maxzoom",
                        "attribution",
                        "mapbox_logo",
                        "bounds",
                        "scheme",
                        "tileSize",
                        "encoding"
                    ]);
                    r.vector_layers && (o.vectorLayers = r.vector_layers, o.vectorLayerIds = o.vectorLayers.map((e)=>e.id)), r.raster_layers && (o.rasterLayers = r.raster_layers, o.rasterLayerIds = o.rasterLayers.map((e)=>e.id)), o.tiles = i.canonicalizeTileset(o, t1.url), a(null, o);
                }
            };
            return t1.url ? e.g(i.transformRequest(i.normalizeSourceURL(t1.url, null, o, r), e.R.Source), n) : e.e.frame(()=>n(null, t1));
        }
        class Bt {
            constructor(t1, i, o){
                this.bounds = e.ai.convert(this.validateBounds(t1)), this.minzoom = i || 0, this.maxzoom = o || 24;
            }
            validateBounds(e) {
                return Array.isArray(e) && 4 === e.length ? [
                    Math.max(-180, e[0]),
                    Math.max(-90, e[1]),
                    Math.min(180, e[2]),
                    Math.min(90, e[3])
                ] : [
                    -180,
                    -90,
                    180,
                    90
                ];
            }
            contains(t1) {
                const i = Math.pow(2, t1.z), o = Math.floor(e.aj(this.bounds.getWest()) * i), r = Math.floor(e.ak(this.bounds.getNorth()) * i), a = Math.ceil(e.aj(this.bounds.getEast()) * i), n = Math.ceil(e.ak(this.bounds.getSouth()) * i);
                return t1.x >= o && t1.x < a && t1.y >= r && t1.y < n;
            }
        }
        class kt extends e.E {
            constructor(t1, i, o, r){
                super(), this.id = t1, this.dispatcher = o, this.setEventedParent(r), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = e.W({
                    type: "raster"
                }, i), e.W(this, e.ah(i, [
                    "url",
                    "scheme",
                    "tileSize"
                ]));
            }
            load(t1) {
                this._loaded = !1, this.fire(new e.f("dataloading", {
                    dataType: "source"
                })), this._tileJSONRequest = Ft(this._options, this.map._requestManager, null, null, (i, o)=>{
                    this._tileJSONRequest = null, this._loaded = !0, i ? this.fire(new e.d(i)) : o && (e.W(this, o), o.bounds && (this.tileBounds = new Bt(o.bounds, this.minzoom, this.maxzoom)), e.an(o.tiles), this.fire(new e.f("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e.f("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }))), t1 && t1(i);
                });
            }
            loaded() {
                return this._loaded;
            }
            onAdd(e) {
                this.map = e, this.load();
            }
            reload() {
                this.cancelTileJSONRequest();
                const t1 = e.al(this.id, this.scope);
                this.load(()=>this.map.style.clearSource(t1));
            }
            setTiles(e) {
                return this._options.tiles = e, this.reload(), this;
            }
            setUrl(e) {
                return this.url = e, this._options.url = e, this.reload(), this;
            }
            onRemove(e) {
                this.cancelTileJSONRequest();
            }
            serialize() {
                return e.W({}, this._options);
            }
            hasTile(e) {
                return !this.tileBounds || this.tileBounds.contains(e.canonical);
            }
            loadTile(t1, i) {
                const o = e.e.devicePixelRatio >= 2, r = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), o, this.tileSize);
                t1.request = e.h(this.map._requestManager.transformRequest(r, e.R.Tile), (o, r, a, n)=>(delete t1.request, t1.aborted ? (t1.state = "unloaded", i(null)) : o ? (t1.state = "errored", i(o)) : r ? (this.map._refreshExpiredTiles && t1.setExpiryData({
                        cacheControl: a,
                        expires: n
                    }), t1.setTexture(r, this.map.painter), t1.state = "loaded", e.am(this.dispatcher), void i(null)) : i(null)));
            }
            abortTile(e, t1) {
                e.request && (e.request.cancel(), delete e.request), t1 && t1();
            }
            unloadTile(t1, i) {
                t1.texture && t1.texture instanceof e.T ? (t1.destroy(!0), t1.texture && t1.texture instanceof e.T && this.map.painter.saveTileTexture(t1.texture)) : t1.destroy(), i && i();
            }
            hasTransition() {
                return !1;
            }
            cancelTileJSONRequest() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
        }
        class Nt extends e.E {
            constructor(t1, i, o, r){
                if (super(), this.id = t1, this.dispatcher = o, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, e.W(this, e.ah(i, [
                    "url",
                    "scheme",
                    "tileSize",
                    "promoteId"
                ])), this._options = e.W({
                    type: "vector"
                }, i), this._collectResourceTiming = !!i.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
                this.setEventedParent(r), this._tileWorkers = {}, this._deduped = new e.ao;
            }
            load(t1) {
                this._loaded = !1, this.fire(new e.f("dataloading", {
                    dataType: "source"
                }));
                const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o = this.map._worldview;
                this._tileJSONRequest = Ft(this._options, this.map._requestManager, i, o, (r, a)=>{
                    this._tileJSONRequest = null, this._loaded = !0, r ? (i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && 2 !== o.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e.d(r))) : a && (e.W(this, a), a.bounds && (this.tileBounds = new Bt(a.bounds, this.minzoom, this.maxzoom)), e.an(a.tiles, this.map._requestManager._customAccessToken), this.fire(new e.f("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e.f("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }))), t1 && t1(r);
                });
            }
            loaded() {
                return this._loaded;
            }
            hasTile(e) {
                return !this.tileBounds || this.tileBounds.contains(e.canonical);
            }
            onAdd(e) {
                this.map = e, this.load();
            }
            reload() {
                this.cancelTileJSONRequest();
                const t1 = e.al(this.id, this.scope);
                this.load(()=>this.map.style.clearSource(t1));
            }
            setTiles(e) {
                return this._options.tiles = e, this.reload(), this;
            }
            setUrl(e) {
                return this.url = e, this._options.url = e, this.reload(), this;
            }
            onRemove(e) {
                this.cancelTileJSONRequest();
            }
            serialize() {
                return e.W({}, this._options);
            }
            loadTile(t1, i) {
                const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme)), r = this.map._requestManager.transformRequest(o, e.R.Tile), a = this.map.style ? this.map.style.getLut(this.scope) : null, n = {
                    request: r,
                    data: void 0,
                    uid: t1.uid,
                    tileID: t1.tileID,
                    tileZoom: t1.tileZoom,
                    zoom: t1.tileID.overscaledZ,
                    lut: a ? {
                        image: a.image.clone()
                    } : null,
                    tileSize: this.tileSize * t1.tileID.overscaleFactor(),
                    type: this.type,
                    source: this.id,
                    scope: this.scope,
                    pixelRatio: e.e.devicePixelRatio,
                    showCollisionBoxes: this.map.showCollisionBoxes,
                    promoteId: this.promoteId,
                    isSymbolTile: t1.isSymbolTile,
                    brightness: this.map.style && this.map.style.getBrightness() || 0,
                    extraShadowCaster: t1.isExtraShadowCaster,
                    tessellationStep: this.map._tessellationStep
                };
                if (n.request.collectResourceTiming = this._collectResourceTiming, t1.actor && "expired" !== t1.state) "loading" === t1.state ? t1.reloadCallback = i : t1.request = t1.actor.send("reloadTile", n, s.bind(this));
                else if (t1.actor = this._tileWorkers[o] = this._tileWorkers[o] || this.dispatcher.getActor(), this.dispatcher.ready) t1.request = t1.actor.send("loadTile", n, s.bind(this), void 0, !0);
                else {
                    const i = e.ap.call({
                        deduped: this._deduped
                    }, n, (e, i)=>{
                        e || !i ? s.call(this, e) : (n.data = {
                            cacheControl: i.cacheControl,
                            expires: i.expires,
                            rawData: i.rawData.slice(0)
                        }, t1.actor && t1.actor.send("loadTile", n, s.bind(this), void 0, !0));
                    }, !0);
                    t1.request = {
                        cancel: i
                    };
                }
                function s(o, r) {
                    return delete t1.request, t1.aborted ? i(null) : o && 404 !== o.status ? i(o) : (r && r.resourceTiming && (t1.resourceTiming = r.resourceTiming), this.map._refreshExpiredTiles && r && t1.setExpiryData(r), t1.loadVectorData(r, this.map.painter), e.am(this.dispatcher), i(null), void (t1.reloadCallback && (this.loadTile(t1, t1.reloadCallback), t1.reloadCallback = null)));
                }
            }
            abortTile(e) {
                e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send("abortTile", {
                    uid: e.uid,
                    type: this.type,
                    source: this.id,
                    scope: this.scope
                });
            }
            unloadTile(e, t1) {
                e.actor && e.actor.send("removeTile", {
                    uid: e.uid,
                    type: this.type,
                    source: this.id,
                    scope: this.scope
                }), e.destroy();
            }
            hasTransition() {
                return !1;
            }
            afterUpdate() {
                this._tileWorkers = {};
            }
            cancelTileJSONRequest() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
        }
        const Ut = (e, t1, i)=>({
                u_matrix: e,
                u_image0: 0,
                u_skirt_height: t1,
                u_ground_shadow_factor: i
            }), Gt = (e, t1, i, o, r, a, n, s, l, c, h, _, u, d, p, f)=>({
                u_proj_matrix: Float32Array.from(e),
                u_globe_matrix: t1,
                u_normalize_matrix: Float32Array.from(o),
                u_merc_matrix: i,
                u_zoom_transition: r,
                u_merc_center: a,
                u_image0: 0,
                u_frustum_tl: n,
                u_frustum_tr: s,
                u_frustum_br: l,
                u_frustum_bl: c,
                u_globe_pos: h,
                u_globe_radius: _,
                u_viewport: u,
                u_grid_matrix: f ? Float32Array.from(f) : new Float32Array(9),
                u_skirt_height: d,
                u_far_z_cutoff: p
            });
        class jt {
            constructor(e = 0, t1 = 0, i = 0, o = 0){
                if (isNaN(e) || e < 0 || isNaN(t1) || t1 < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                this.top = e, this.bottom = t1, this.left = i, this.right = o;
            }
            interpolate(t1, i, o) {
                return null != i.top && null != t1.top && (this.top = e.a2(t1.top, i.top, o)), null != i.bottom && null != t1.bottom && (this.bottom = e.a2(t1.bottom, i.bottom, o)), null != i.left && null != t1.left && (this.left = e.a2(t1.left, i.left, o)), null != i.right && null != t1.right && (this.right = e.a2(t1.right, i.right, o)), this;
            }
            getCenter(t1, i) {
                const o = e.at((this.left + t1 - this.right) / 2, 0, t1), r = e.at((this.top + i - this.bottom) / 2, 0, i);
                return new e.P(o, r);
            }
            equals(e) {
                return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
            }
            clone() {
                return new jt(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
                return {
                    top: this.top,
                    bottom: this.bottom,
                    left: this.left,
                    right: this.right
                };
            }
        }
        function Vt(t1, i) {
            const o = e.aw(t1, 3);
            e.ad.fromQuat(t1, i), e.az(t1, 3, o);
        }
        function Wt(t1, i) {
            const o = e.av.identity([]);
            return e.av.rotateZ(o, o, -i), e.av.rotateX(o, o, -t1), o;
        }
        function Zt(t1, i) {
            const o = [
                t1[0],
                t1[1],
                0
            ], r = [
                i[0],
                i[1],
                0
            ];
            if (e._.length(o) >= 1e-15) {
                const t1 = e._.normalize([], o);
                e._.scale(r, t1, e._.dot(r, t1)), i[0] = r[0], i[1] = r[1];
            }
            const a = e._.cross([], i, t1);
            if (e._.len(a) < 1e-15) return null;
            const n = Math.atan2(-a[1], a[0]);
            return Wt(Math.atan2(Math.sqrt(t1[0] * t1[0] + t1[1] * t1[1]), -t1[2]), n);
        }
        class qt {
            constructor(e, t1){
                this.position = e, this.orientation = t1;
            }
            get position() {
                return this._position;
            }
            set position(t1) {
                if (t1) {
                    const i = t1 instanceof e.Y ? t1 : new e.Y(t1[0], t1[1], t1[2]);
                    this._renderWorldCopies && (i.x = e.au(i.x, 0, 1)), this._position = i;
                } else this._position = null;
            }
            lookAtPoint(t1, i) {
                if (this.orientation = null, !this.position) return;
                const o = this.position, r = this._elevation ? this._elevation.getAtPointOrZero(e.Y.fromLngLat(t1)) : 0, a = e.Y.fromLngLat(t1, r), n = [
                    a.x - o.x,
                    a.y - o.y,
                    a.z - o.z
                ];
                i || (i = [
                    0,
                    0,
                    1
                ]), i[2] = Math.abs(i[2]), this.orientation = Zt(n, i);
            }
            setPitchBearing(t1, i) {
                this.orientation = Wt(e.ab(t1), e.ab(-i));
            }
        }
        class Ht {
            constructor(t1, i){
                this._transform = e.ad.identity([]), this.orientation = i, this.position = t1;
            }
            get mercatorPosition() {
                const t1 = this.position;
                return new e.Y(t1[0], t1[1], t1[2]);
            }
            get position() {
                const t1 = e.aw(this._transform, 3);
                return [
                    t1[0],
                    t1[1],
                    t1[2]
                ];
            }
            set position(t1) {
                var i;
                t1 && e.az(this._transform, 3, [
                    (i = t1)[0],
                    i[1],
                    i[2],
                    1
                ]);
            }
            get orientation() {
                return this._orientation;
            }
            set orientation(t1) {
                this._orientation = t1 || e.av.identity([]), t1 && Vt(this._transform, this._orientation);
            }
            getPitchBearing() {
                const e = this.forward(), t1 = this.right();
                return {
                    bearing: Math.atan2(-t1[1], t1[0]),
                    pitch: Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2])
                };
            }
            setPitchBearing(e, t1) {
                this._orientation = Wt(e, t1), Vt(this._transform, this._orientation);
            }
            forward() {
                const t1 = e.aw(this._transform, 2);
                return [
                    -t1[0],
                    -t1[1],
                    -t1[2]
                ];
            }
            up() {
                const t1 = e.aw(this._transform, 1);
                return [
                    -t1[0],
                    -t1[1],
                    -t1[2]
                ];
            }
            right() {
                const t1 = e.aw(this._transform, 0);
                return [
                    t1[0],
                    t1[1],
                    t1[2]
                ];
            }
            getCameraToWorld(t1, i) {
                const o = new Float64Array(16);
                return e.ad.invert(o, this.getWorldToCamera(t1, i)), o;
            }
            getCameraToWorldMercator() {
                return this._transform;
            }
            getWorldToCameraPosition(t1, i, o) {
                const r = this.position;
                e._.scale(r, r, -t1);
                const a = new Float64Array(16);
                return e.ad.fromScaling(a, [
                    o,
                    o,
                    o
                ]), e.ad.translate(a, a, r), a[10] *= i, a;
            }
            getWorldToCamera(t1, i) {
                const o = new Float64Array(16), r = new Float64Array(4), a = this.position;
                return e.av.conjugate(r, this._orientation), e._.scale(a, a, -t1), e.ad.fromQuat(o, r), e.ad.translate(o, o, a), o[1] *= -1, o[5] *= -1, o[9] *= -1, o[13] *= -1, o[8] *= i, o[9] *= i, o[10] *= i, o[11] *= i, o;
            }
            getCameraToClipPerspective(t1, i, o, r) {
                const a = new Float64Array(16);
                return e.ad.perspective(a, t1, i, o, r), a;
            }
            getCameraToClipOrthographic(t1, i, o, r, a, n) {
                const s = new Float64Array(16);
                return e.ad.ortho(s, t1, i, o, r, a, n), s;
            }
            getDistanceToElevation(t1, i = !1) {
                const o = 0 === t1 ? 0 : e.ax(t1, i ? e.ay(this.position[1]) : this.position[1]), r = this.forward();
                return (o - this.position[2]) / r[2];
            }
            clone() {
                return new Ht([
                    ...this.position
                ], [
                    ...this.orientation
                ]);
            }
        }
        const $t = {
            unknown: 0,
            flipRequired: 1,
            flipNotRequired: 2
        }, Xt = Math.tan(85 * Math.PI / 180);
        function Yt(t1, i, o, r, a, n, s) {
            const l = e.ad.create();
            if (o) {
                if ("globe" === n.name) {
                    const t1 = e.aB(a, i);
                    e.ad.multiply(l, l, t1);
                } else {
                    const t1 = e.aC.invert([], s);
                    l[0] = t1[0], l[1] = t1[1], l[4] = t1[2], l[5] = t1[3], r || e.ad.rotateZ(l, l, a.angle);
                }
            } else e.ad.multiply(l, a.labelPlaneMatrix, t1);
            return l;
        }
        function Kt(e, t1, i, o, r, a, n) {
            const s = Yt(e, t1, i, o, r, a, n);
            return "globe" === a.name && i || (s[2] = s[6] = s[10] = s[14] = 0), s;
        }
        function Qt(t1, i, o, r, a, n, s) {
            if (o) {
                if ("globe" === n.name) {
                    const l = Yt(t1, i, o, r, a, n, s);
                    return e.ad.invert(l, l), e.ad.multiply(l, t1, l), l;
                }
                {
                    const i = e.ad.clone(t1), o = e.ad.identity([]);
                    return o[0] = s[0], o[1] = s[1], o[4] = s[2], o[5] = s[3], e.ad.multiply(i, i, o), r || e.ad.rotateZ(i, i, -a.angle), i;
                }
            }
            return a.glCoordMatrix;
        }
        function Jt(t1, i, o, r) {
            const a = [
                t1,
                i,
                o,
                1
            ];
            o ? e.aA.transformMat4(a, a, r) : hi(a, a, r);
            const n = a[3];
            return a[0] /= n, a[1] /= n, a[2] /= n, a;
        }
        function ei(e, t1) {
            return Math.min(.5 + e / t1 * .5, 1.5);
        }
        function ti(e, t1) {
            const i = e[0] / e[3], o = e[1] / e[3];
            return i >= -t1[0] && i <= t1[0] && o >= -t1[1] && o <= t1[1];
        }
        function ii(t1, i, o, r, a, n, s, l, c, h) {
            const _ = o.transform, u = r ? t1.textSizeData : t1.iconSizeData, d = e.aD(u, o.transform.zoom), p = "globe" === _.projection.name, f = [
                256 / o.width * 2 + 1,
                256 / o.height * 2 + 1
            ], m = r ? t1.text.dynamicLayoutVertexArray : t1.icon.dynamicLayoutVertexArray;
            m.clear();
            let g = null;
            p && (g = r ? t1.text.globeExtVertexArray : t1.icon.globeExtVertexArray);
            const v = t1.lineVertexArray, x = r ? t1.text.placedSymbolArray : t1.icon.placedSymbolArray, y = o.transform.width / o.transform.height;
            let b, w = !1;
            for(let r = 0; r < x.length; r++){
                const p = x.get(r), { numGlyphs: T, writingMode: E } = p;
                if (E !== e.aE.vertical || w || b === e.aE.horizontal || (w = !0), b = E, (p.hidden || E === e.aE.vertical) && !w) {
                    ci(T, m);
                    continue;
                }
                w = !1;
                const C = new e.P(p.tileAnchorX, p.tileAnchorY);
                let { x: S, y: I, z: L } = _.projection.projectTilePoint(C.x, C.y, h.canonical);
                if (c) {
                    const [e, t1, i] = c(C);
                    S += e, I += t1, L += i;
                }
                const P = [
                    S,
                    I,
                    L,
                    1
                ];
                if (e.aA.transformMat4(P, P, i), !ti(P, f)) {
                    ci(T, m);
                    continue;
                }
                const A = P[3], R = ei(o.transform.getCameraToCenterDistance(_.projection), A), D = e.aF(u, d, p), M = s ? D / R : D * R, z = Jt(S, I, L, a);
                if (z[3] <= 0) {
                    ci(T, m);
                    continue;
                }
                let O = {};
                const F = s ? null : c, B = ai(p, M, !1, l, i, a, n, t1.glyphOffsetArray, v, m, g, z, C, O, y, F, _.projection, h, s);
                w = B.useVertical, F && B.needsFlipping && (O = {}), (B.notEnoughRoom || w || B.needsFlipping && ai(p, M, !0, l, i, a, n, t1.glyphOffsetArray, v, m, g, z, C, O, y, F, _.projection, h, s).notEnoughRoom) && ci(T, m);
            }
            r ? (t1.text.dynamicLayoutVertexBuffer.updateData(m), g && t1.text.globeExtVertexBuffer && t1.text.globeExtVertexBuffer.updateData(g)) : (t1.icon.dynamicLayoutVertexBuffer.updateData(m), g && t1.icon.globeExtVertexBuffer && t1.icon.globeExtVertexBuffer.updateData(g));
        }
        function oi(e, t1, i, o, r, a, n, s, l, c, h, _, u, d, p, f) {
            const { lineStartIndex: m, glyphStartIndex: g, segment: v } = s, x = g + s.numGlyphs, y = m + s.lineLength, b = t1.getoffsetX(g), w = t1.getoffsetX(x - 1), T = li(e * b, i, o, r, a, n, v, m, y, l, c, h, _, u, !0, d, p, f);
            if (!T) return null;
            const E = li(e * w, i, o, r, a, n, v, m, y, l, c, h, _, u, !0, d, p, f);
            return E ? {
                first: T,
                last: E
            } : null;
        }
        function ri(t1, i, o, r) {
            return t1 === e.aE.horizontal && Math.abs(r) > Math.abs(o) ? {
                useVertical: !0
            } : t1 === e.aE.vertical ? r > 0 ? {
                needsFlipping: !0
            } : null : i !== $t.unknown && function(e, t1) {
                return 0 === e || Math.abs(t1 / e) > Xt;
            }(o, r) ? i === $t.flipRequired ? {
                needsFlipping: !0
            } : null : o < 0 ? {
                needsFlipping: !0
            } : null;
        }
        function ai(t1, i, o, r, a, n, s, l, c, h, _, u, d, p, f, m, g, v, x) {
            const y = i / 24, b = t1.lineOffsetX * y, w = t1.lineOffsetY * y, { lineStartIndex: T, glyphStartIndex: E, numGlyphs: C, segment: S, writingMode: I, flipState: L } = t1, P = T + t1.lineLength, A = (t1)=>{
                if (_) {
                    const [i, o, r] = t1.up, a = h.length;
                    e.aG(_, a + 0, i, o, r), e.aG(_, a + 1, i, o, r), e.aG(_, a + 2, i, o, r), e.aG(_, a + 3, i, o, r);
                }
                const [i, o, r] = t1.point;
                e.aH(h, i, o, r, t1.angle);
            };
            if (C > 1) {
                const e = oi(y, l, b, w, o, u, d, t1, c, n, p, m, !1, g, v, x);
                if (!e) return {
                    notEnoughRoom: !0
                };
                if (r && !o) {
                    let [i, o, r] = e.first.point, [a, n, l] = e.last.point;
                    [i, o] = Jt(i, o, r, s), [a, n] = Jt(a, n, l, s);
                    const c = ri(I, L, (a - i) * f, n - o);
                    if (t1.flipState = c && c.needsFlipping ? $t.flipRequired : $t.flipNotRequired, c) return c;
                }
                A(e.first);
                for(let e = E + 1; e < E + C - 1; e++){
                    const t1 = li(y * l.getoffsetX(e), b, w, o, u, d, S, T, P, c, n, p, m, !1, !1, g, v, x);
                    if (!t1) return h.length -= 4 * (e - E), {
                        notEnoughRoom: !0
                    };
                    A(t1);
                }
                A(e.last);
            } else {
                if (r && !o) {
                    const i = Jt(d.x, d.y, 0, a), o = T + S + 1, r = new e.P(c.getx(o), c.gety(o)), n = Jt(r.x, r.y, 0, a), s = n[3] > 0 ? n : si(d, r, i, 1, a, void 0, g, v.canonical), l = ri(I, L, (s[0] - i[0]) * f, s[1] - i[1]);
                    if (t1.flipState = l && l.needsFlipping ? $t.flipRequired : $t.flipNotRequired, l) return l;
                }
                const i = li(y * l.getoffsetX(E), b, w, o, u, d, S, T, P, c, n, p, m, !1, !1, g, v, x);
                if (!i) return {
                    notEnoughRoom: !0
                };
                A(i);
            }
            return {};
        }
        function ni(e, t1, i, o, r) {
            const { x: a, y: n, z: s } = o.projectTilePoint(e.x, e.y, t1);
            if (!r) return Jt(a, n, s, i);
            const [l, c, h] = r(e);
            return Jt(a + l, n + c, s + h, i);
        }
        function si(t1, i, o, r, a, n, s, l) {
            const c = ni(t1.sub(i)._unit()._add(t1), l, a, s, n);
            return e._.sub(c, o, c), e._.normalize(c, c), e._.scaleAndAdd(c, o, c, r);
        }
        function li(t1, i, o, r, a, n, s, l, c, h, _, u, d, p, f, m, g, v) {
            const x = r ? t1 - i : t1 + i;
            let y = x > 0 ? 1 : -1, b = 0;
            r && (y *= -1, b = Math.PI), y < 0 && (b += Math.PI);
            let w = l + s + (y > 0 ? 0 : 1) | 0, T = a, E = a, C = 0, S = 0;
            const I = Math.abs(x), L = [], P = [];
            let A = n, R = A;
            const D = ()=>si(R, A, E, I - C + 1, _, d, m, g.canonical);
            for(; C + S <= I;){
                if (w += y, w < l || w >= c) return null;
                if (E = T, R = A, L.push(E), p && P.push(R), A = new e.P(h.getx(w), h.gety(w)), T = u[w], !T) {
                    const e = ni(A, g.canonical, _, m, d);
                    T = e[3] > 0 ? u[w] = e : D();
                }
                C += S, S = e._.distance(E, T);
            }
            f && d && (u[w] && (T = D(), S = e._.distance(E, T)), u[w] = T);
            const M = (I - C) / S, z = A.sub(R)._mult(M)._add(R), O = e._.sub([], T, E), F = e._.scaleAndAdd([], E, O, M);
            let B = [
                0,
                0,
                1
            ], k = O[0], N = O[1];
            if (v && (B = m.upVector(g.canonical, z.x, z.y), 0 !== B[0] || 0 !== B[1] || 1 !== B[2])) {
                const t1 = [
                    B[2],
                    0,
                    -B[0]
                ], i = e._.cross([], B, t1);
                e._.normalize(t1, t1), e._.normalize(i, i), k = e._.dot(O, t1), N = e._.dot(O, i);
            }
            if (o) {
                const t1 = e._.cross([], B, O);
                e._.normalize(t1, t1), e._.scaleAndAdd(F, F, t1, o * y);
            }
            const U = b + Math.atan2(N, k);
            return L.push(F), p && P.push(z), {
                point: F,
                angle: U,
                path: L,
                tilePath: P,
                up: B
            };
        }
        function ci(e, t1) {
            const i = t1.length, o = i + 4 * e;
            t1.resize(o), t1.float32.fill(-1 / 0, 4 * i, 4 * o);
        }
        function hi(e, t1, i) {
            const o = t1[0], r = t1[1];
            return e[0] = i[0] * o + i[4] * r + i[12], e[1] = i[1] * o + i[5] * r + i[13], e[3] = i[3] * o + i[7] * r + i[15], e;
        }
        const _i = (e, t1, i)=>(1 - i) * e + i * t1, ui = (e)=>e * e * e * e * e;
        class di {
            constructor(t1, i, o, r, a, n, s){
                this.tileSize = 512, this._renderWorldCopies = void 0 === a || a, this._minZoom = t1 || 0, this._maxZoom = i || 22, this._minPitch = o ?? 0, this._maxPitch = r ?? 60, this.setProjection(n), this.setMaxBounds(s), this.width = 0, this.height = 0, this._center = new e.aI(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new jt, this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Ht, this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [
                    0,
                    0,
                    0
                ], this._tileCoverLift = 0, this.freezeTileCoverage = !1, this._horizonShift = .1, this._orthographicProjectionAtLowPitch = !1;
            }
            clone() {
                const e = new di(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
                return e._elevation = this._elevation, e._centerAltitude = this._centerAltitude, e._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e.tileSize = this.tileSize, e.mercatorFromTransition = this.mercatorFromTransition, e.width = this.width, e.height = this.height, e.cameraElevationReference = this.cameraElevationReference, e._center = this._center, e._setZoom(this.zoom), e._seaLevelZoom = this._seaLevelZoom, e.angle = this.angle, e._fov = this._fov, e._pitch = this._pitch, e._nearZ = this._nearZ, e._farZ = this._farZ, e._averageElevation = this._averageElevation, e._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e._unmodified = this._unmodified, e._edgeInsets = this._edgeInsets.clone(), e._camera = this._camera.clone(), e._calcMatrices(), e.freezeTileCoverage = this.freezeTileCoverage, e.frustumCorners = this.frustumCorners, e;
            }
            get isOrthographic() {
                return "globe" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < 15;
            }
            get elevation() {
                return this._elevation;
            }
            set elevation(e) {
                this._elevation !== e && (this._elevation = e, this._updateCameraOnTerrain(), this._calcMatrices());
            }
            get depthOcclusionForSymbolsAndCircles() {
                return "globe" !== this.projection.name && !this.isOrthographic;
            }
            updateElevation(e, t1 = !1) {
                const i = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
                (null == this._seaLevelZoom || i) && this._updateCameraOnTerrain(), (e || i) && this._constrainCamera(t1), this._calcMatrices();
            }
            getProjection() {
                return e.ah(this.projection, [
                    "name",
                    "center",
                    "parallels"
                ]);
            }
            setProjection(i) {
                this.projectionOptions = i || {
                    name: "mercator"
                };
                const o = this.projection ? this.getProjection() : void 0;
                this.projection = e.aJ(this.projectionOptions);
                const r = !t1(o, this.getProjection());
                return r && this._calcMatrices(), this.mercatorFromTransition = !1, r;
            }
            setOrthographicProjectionAtLowPitch(e) {
                return this._orthographicProjectionAtLowPitch !== e && (this._orthographicProjectionAtLowPitch = e, this._calcMatrices(), !0);
            }
            setMercatorFromTransition() {
                const t1 = this.projection.name;
                this.mercatorFromTransition = !0, this.projectionOptions = {
                    name: "mercator"
                }, this.projection = e.aJ({
                    name: "mercator"
                });
                const i = t1 !== this.projection.name;
                return i && this._calcMatrices(), i;
            }
            get minZoom() {
                return this._minZoom;
            }
            set minZoom(e) {
                this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));
            }
            get maxZoom() {
                return this._maxZoom;
            }
            set maxZoom(e) {
                this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));
            }
            get minPitch() {
                return this._minPitch;
            }
            set minPitch(e) {
                this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));
            }
            get maxPitch() {
                return this._maxPitch;
            }
            set maxPitch(e) {
                this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));
            }
            get renderWorldCopies() {
                return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies;
            }
            set renderWorldCopies(e) {
                void 0 === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e;
            }
            get worldSize() {
                return this.tileSize * this.scale;
            }
            get cameraWorldSizeForFog() {
                const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));
            }
            get cameraWorldSize() {
                const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));
            }
            get pixelsPerMeter() {
                return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
            }
            get cameraPixelsPerMeter() {
                return e.ax(1, this.center.lat) * this.cameraWorldSizeForFog;
            }
            get centerOffset() {
                return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
                return new e.P(this.width, this.height);
            }
            get bearing() {
                return e.au(this.rotation, -180, 180);
            }
            set bearing(e) {
                this.rotation = e;
            }
            get rotation() {
                return -this.angle / Math.PI * 180;
            }
            set rotation(t1) {
                const i = -t1 * Math.PI / 180;
                this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = e.aC.create(), e.aC.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
                return this._pitch / Math.PI * 180;
            }
            set pitch(t1) {
                const i = e.at(t1, this.minPitch, this.maxPitch) / 180 * Math.PI;
                this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());
            }
            get aspect() {
                return this.width / this.height;
            }
            get fov() {
                return this._fov / Math.PI * 180;
            }
            get fovX() {
                return this._fov;
            }
            get fovY() {
                const e = 1 / Math.tan(.5 * this.fovX);
                return 2 * Math.atan(1 / this.aspect / e);
            }
            set fov(t1) {
                t1 = Math.max(.01, Math.min(60, t1)), this._fov !== t1 && (this._unmodified = !1, this._fov = e.ab(t1), this._calcMatrices());
            }
            get averageElevation() {
                return this._averageElevation;
            }
            set averageElevation(e) {
                this._averageElevation = e, this._calcFogMatrices(), this._distanceTileDataCache = {};
            }
            get zoom() {
                return this._zoom;
            }
            set zoom(e) {
                const t1 = Math.min(Math.max(e, this.minZoom), this.maxZoom);
                this._zoom !== t1 && (this._unmodified = !1, this._setZoom(t1), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
            }
            _setZoom(e) {
                this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom;
            }
            get tileCoverLift() {
                return this._tileCoverLift;
            }
            set tileCoverLift(e) {
                this._tileCoverLift !== e && (this._tileCoverLift = e);
            }
            _updateCameraOnTerrain() {
                const e = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, t1 = this.elevation && e === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
                if (!this._elevation || e === Number.NEGATIVE_INFINITY && (!t1 || !this._centerAltitude)) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
                const i = this._elevation;
                t1 || this._centerAltitude && this._centerAltitudeValidForExaggeration && i.exaggeration() && this._centerAltitudeValidForExaggeration !== i.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i.exaggeration(), this._centerAltitudeValidForExaggeration = i.exaggeration()) : (this._centerAltitude = e || 0, this._centerAltitudeValidForExaggeration = i.exaggeration()), this._updateSeaLevelZoom();
            }
            _updateSeaLevelZoom() {
                void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
            }
            sampleAverageElevation() {
                if (!this._elevation) return 0;
                const t1 = this._elevation, i = [
                    [
                        .5,
                        .2
                    ],
                    [
                        .3,
                        .5
                    ],
                    [
                        .5,
                        .5
                    ],
                    [
                        .7,
                        .5
                    ],
                    [
                        .5,
                        .8
                    ]
                ], o = this.horizonLineFromTop();
                let r = 0, a = 0;
                for(let n = 0; n < i.length; n++){
                    const s = new e.P(i[n][0] * this.width, o + i[n][1] * (this.height - o)), l = t1.pointCoordinate(s);
                    if (!l) continue;
                    const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);
                    r += l[3] * c, a += c;
                }
                return 0 === a ? NaN : r / a;
            }
            get center() {
                return this._center;
            }
            set center(e) {
                e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
            }
            _updateZoomFromElevation() {
                if (null == this._seaLevelZoom || !this._elevation) return;
                const e = this._seaLevelZoom, t1 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i = this.pixelsPerMeter / this.worldSize * t1, o = this._mercatorZfromZoom(e), r = this._mercatorZfromZoom(this._maxZoom), a = Math.max(o - i, r);
                this._setZoom(this._zoomFromMercatorZ(a));
            }
            get padding() {
                return this._edgeInsets.toJSON();
            }
            set padding(e) {
                this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
            }
            computeZoomRelativeTo(t1) {
                const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t1.toAltitude()));
                let o;
                o = t1.z < this._camera.position[2] ? [
                    i.x,
                    i.y,
                    i.z
                ] : [
                    t1.x,
                    t1.y,
                    t1.z
                ];
                const r = e._.length(e._.sub([], this._camera.position, o));
                return e.at(this._zoomFromMercatorZ(r), this._minZoom, this._maxZoom);
            }
            setFreeCameraOptions(t1) {
                if (!this.height) return;
                if (!t1.position && !t1.orientation) return;
                this._updateCameraState();
                let i = !1;
                if (t1.orientation && !e.av.exactEquals(t1.orientation, this._camera.orientation) && (i = this._setCameraOrientation(t1.orientation)), t1.position) {
                    const o = [
                        t1.position.x,
                        t1.position.y,
                        t1.position.z
                    ];
                    e._.exactEquals(o, this._camera.position) || (this._setCameraPosition(o), i = !0);
                }
                i && (this._updateStateFromCamera(), this.recenterOnTerrain());
            }
            getFreeCameraOptions() {
                this._updateCameraState();
                const t1 = this._camera.position, i = new qt;
                return i.position = new e.Y(t1[0], t1[1], t1[2]), i.orientation = this._camera.orientation, i._elevation = this.elevation, i._renderWorldCopies = this.renderWorldCopies, i;
            }
            _setCameraOrientation(t1) {
                if (!e.av.length(t1)) return !1;
                e.av.normalize(t1, t1);
                const i = e._.transformQuat([], [
                    0,
                    0,
                    -1
                ], t1), o = e._.transformQuat([], [
                    0,
                    -1,
                    0
                ], t1);
                if (o[2] < 0) return !1;
                const r = Zt(i, o);
                return !!r && (this._camera.orientation = r, !0);
            }
            _setCameraPosition(t1) {
                const i = this.zoomScale(this.minZoom) * this.tileSize, o = this.zoomScale(this.maxZoom) * this.tileSize, r = this.cameraToCenterDistance;
                t1[2] = e.at(t1[2], r / o, r / i), this._camera.position = t1;
            }
            get centerPoint() {
                return this._edgeInsets.getCenter(this.width, this.height);
            }
            get fovAboveCenter() {
                return this._fov * (.5 + this.centerOffset.y / this.height);
            }
            isPaddingEqual(e) {
                return this._edgeInsets.equals(e);
            }
            interpolatePadding(e, t1, i) {
                this._unmodified = !1, this._edgeInsets.interpolate(e, t1, i), this._constrain(), this._calcMatrices();
            }
            coveringZoomLevel(e) {
                const t1 = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));
                return Math.max(0, t1);
            }
            getVisibleUnwrappedCoordinates(t1) {
                const i = [
                    new e.aK(0, t1)
                ];
                if (this.renderWorldCopies) {
                    const o = this.pointCoordinate(new e.P(0, 0)), r = this.pointCoordinate(new e.P(this.width, 0)), a = this.pointCoordinate(new e.P(this.width, this.height)), n = this.pointCoordinate(new e.P(0, this.height)), s = Math.floor(Math.min(o.x, r.x, a.x, n.x)), l = Math.floor(Math.max(o.x, r.x, a.x, n.x)), c = 1;
                    for(let o = s - c; o <= l + c; o++)0 !== o && i.push(new e.aK(o, t1));
                }
                return i;
            }
            isLODDisabled(e) {
                return (!e || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
            }
            extendTileCoverForShadows(t1, i, o) {
                let r = [];
                if (0 === i[0] && 0 === i[1]) return r;
                for (const o of t1){
                    const t1 = o.canonical, a = o.overscaledZ, n = o.wrap, s = 1 << t1.z, l = t1.x + 1 < s, c = t1.x > 0, h = t1.y + 1 < s, _ = t1.y > 0, u = o.wrap - (c ? 0 : 1), d = o.wrap + (l ? 0 : 1), p = c ? t1.x - 1 : s - 1, f = l ? t1.x + 1 : 0;
                    i[0] < 0 ? (r.push(new e.aL(a, d, t1.z, f, t1.y)), i[1] < 0 && h && (r.push(new e.aL(a, n, t1.z, t1.x, t1.y + 1)), r.push(new e.aL(a, d, t1.z, f, t1.y + 1))), i[1] > 0 && _ && (r.push(new e.aL(a, n, t1.z, t1.x, t1.y - 1)), r.push(new e.aL(a, d, t1.z, f, t1.y - 1)))) : i[0] > 0 ? (r.push(new e.aL(a, u, t1.z, p, t1.y)), i[1] < 0 && h && (r.push(new e.aL(a, n, t1.z, t1.x, t1.y + 1)), r.push(new e.aL(a, u, t1.z, p, t1.y + 1))), i[1] > 0 && _ && (r.push(new e.aL(a, n, t1.z, t1.x, t1.y - 1)), r.push(new e.aL(a, u, t1.z, p, t1.y - 1)))) : i[1] < 0 && h ? r.push(new e.aL(a, n, t1.z, t1.x, t1.y + 1)) : _ && r.push(new e.aL(a, n, t1.z, t1.x, t1.y - 1));
                }
                if (r.length > 1) {
                    r.sort((e, t1)=>e.overscaledZ - t1.overscaledZ || e.wrap - t1.wrap || e.canonical.z - t1.canonical.z || e.canonical.x - t1.canonical.x || e.canonical.y - t1.canonical.y);
                    let e = 0, t1 = 0;
                    for(; t1 < r.length;)r[t1].equals(r[e]) ? ++t1 : r[++e] = r[t1++];
                    r.length = e + 1;
                }
                const a = [];
                for (const e of r)r.some((t1)=>e.isChildOf(t1)) || a.push(e);
                return r = a.filter((e)=>!t1.some((t1)=>!!(e.overscaledZ < o && t1.isChildOf(e)) || e.equals(t1) || e.isChildOf(t1))), r;
            }
            coveringTiles(t1) {
                let i = this.coveringZoomLevel(t1);
                const o = i, r = this.elevation && this.elevation.exaggeration(), a = r && !t1.isTerrainDEM, n = "mercator" === this.projection.name;
                if (void 0 !== t1.minzoom && i < t1.minzoom) return [];
                void 0 !== t1.maxzoom && i > t1.maxzoom && (i = t1.maxzoom);
                const s = this.locationCoordinate(this.center), l = this.center.lat, c = 1 << i, h = [
                    c * s.x,
                    c * s.y,
                    0
                ], _ = "globe" === this.projection.name, u = !_, d = e.aM.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, u), p = _ ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), f = c * e.ax(1, this.center.lat), m = this._camera.position[2] / e.ax(1, this.center.lat), g = [
                    c * p.x,
                    c * p.y,
                    m * (u ? 1 : f)
                ], v = _ || r, x = this.cameraToCenterDistance / t1.tileSize * (t1.roundZoom ? 1 : .502), y = this.isLODDisabled(!0) ? i : 0;
                let b;
                if (this._elevation && t1.isTerrainDEM) b = 1e4 * this._elevation.exaggeration();
                else if (this._elevation) {
                    const e = this._elevation.getMinMaxForVisibleTiles();
                    b = e ? e.max : this._centerAltitude;
                } else b = this._centerAltitude;
                const w = t1.isTerrainDEM ? -b : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, T = this.projection.isReprojectedInTileSpace ? e.aN(this) : 1, E = (t1)=>{
                    const i = 1 / 4e4, o = new e.Y(t1.x + i, t1.y, t1.z), r = new e.Y(t1.x, t1.y + i, t1.z), a = t1.toLngLat(), n = o.toLngLat(), s = r.toLngLat(), l = this.locationCoordinate(a), c = this.locationCoordinate(n), h = this.locationCoordinate(s), _ = Math.hypot(c.x - l.x, c.y - l.y), u = Math.hypot(h.x - l.x, h.y - l.y);
                    return Math.sqrt(_ * u) * T / i;
                }, C = (t1)=>{
                    const i = b, o = w;
                    return {
                        aabb: e.aQ(this, c, 0, 0, 0, t1, o, i, this.projection),
                        zoom: 0,
                        x: 0,
                        y: 0,
                        minZ: o,
                        maxZ: i,
                        wrap: t1,
                        fullyVisible: !1
                    };
                }, S = [];
                let I = [];
                const L = i, P = t1.reparseOverscaled ? o : i, A = (m - this._centerAltitude) * f, R = (e)=>{
                    if (!this._elevation || !e.tileID || !n) return;
                    const t1 = this._elevation.getMinMaxForTile(e.tileID), i = e.aabb;
                    t1 ? (i.min[2] = t1.min, i.max[2] = t1.max, i.center[2] = (i.min[2] + i.max[2]) / 2) : (e.shouldSplit = M(e), e.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude));
                }, D = (e, t1)=>{
                    if (.707 * t1 < e) return 1;
                    const i = t1 / e;
                    return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
                }, M = (t1)=>{
                    if (t1.zoom < y) return !0;
                    if (t1.zoom === L) return !1;
                    if (null != t1.shouldSplit) return t1.shouldSplit;
                    const i = t1.aabb.distanceX(g), r = t1.aabb.distanceY(g);
                    let s = A, c = 1;
                    if (_) {
                        s = t1.aabb.distanceZ(g);
                        const i = Math.pow(2, t1.zoom), o = e.ay((t1.y + 1) / i), r = e.ay(t1.y / i), a = Math.min(Math.max(l, o), r), n = e.b4(a) / e.b4(l);
                        if (c = a === l ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, n / this._mercatorScaleRatio), this.zoom <= e.b1 && t1.zoom === L - 1 && n >= .9) return !0;
                    } else if (a && (s = t1.aabb.distanceZ(g) * f), this.projection.isReprojectedInTileSpace && o <= 5) {
                        const i = Math.pow(2, t1.zoom), o = E(new e.Y((t1.x + .5) / i, (t1.y + .5) / i));
                        c = o > .85 ? 1 : o;
                    }
                    if (!n) {
                        const e = Math.sqrt(i * i + r * r + s * s);
                        let o = (1 << L - t1.zoom) * x * c;
                        return o *= D(Math.max(s, A), e), e < o;
                    }
                    let u = Number.MAX_VALUE, d = 0;
                    const p = t1.aabb.getCorners(), m = [];
                    for (const t1 of p){
                        e._.sub(m, t1, g), _ || (a ? m[2] *= f : m[2] = A);
                        const i = e._.dot(m, this._camera.forward());
                        i < u && (u = i, d = Math.abs(m[2]));
                    }
                    let v = (1 << L - t1.zoom) * x * c;
                    if (v *= D(Math.max(d, A), u), u < v) return !0;
                    const b = t1.aabb.closestPoint(h);
                    return b[0] === h[0] && b[1] === h[1];
                };
                if (this.renderWorldCopies) for(let e = 1; e <= 3; e++)S.push(C(-e)), S.push(C(e));
                for(S.push(C(0)); S.length > 0;){
                    const o = S.pop(), r = o.x, s = o.y;
                    let l = o.fullyVisible;
                    const u = ()=>"globe" === this.projection.name && (0 === o.y || o.y === (1 << o.zoom) - 1);
                    if (!l) {
                        let t1 = v ? o.aabb.intersects(d) : o.aabb.intersectsFlat(d);
                        if (0 === t1 && u()) {
                            const i = new e.aO(o.zoom, r, s);
                            t1 = e.aP(this, c, i, !0).intersects(d);
                        }
                        if (0 === t1) continue;
                        l = 2 === t1;
                    }
                    if (o.zoom !== L && M(o)) for(let t1 = 0; t1 < 4; t1++){
                        const i = (r << 1) + t1 % 2, h = (s << 1) + (t1 >> 1), u = {
                            aabb: n ? o.aabb.quadrant(t1) : e.aQ(this, c, o.zoom + 1, i, h, o.wrap, o.minZ, o.maxZ, this.projection),
                            zoom: o.zoom + 1,
                            x: i,
                            y: h,
                            wrap: o.wrap,
                            fullyVisible: l,
                            tileID: void 0,
                            shouldSplit: void 0,
                            minZ: o.minZ,
                            maxZ: o.maxZ
                        };
                        a && !_ && (u.tileID = new e.aL(o.zoom + 1 === L ? P : o.zoom + 1, o.wrap, o.zoom + 1, i, h), R(u)), S.push(u);
                    }
                    else {
                        const a = o.zoom === L ? P : o.zoom;
                        if (t1.minzoom && t1.minzoom > a) continue;
                        if (!l) {
                            let t1 = v ? o.aabb.intersectsPrecise(d) : o.aabb.intersectsPreciseFlat(d);
                            if (0 === t1 && u()) {
                                const i = new e.aO(o.zoom, r, s);
                                t1 = e.aP(this, c, i, !0).intersectsPrecise(d);
                            }
                            if (0 === t1) continue;
                        }
                        const n = h[0] - (.5 + r + (o.wrap << o.zoom)) * (1 << i - o.zoom), _ = h[1] - .5 - s, p = o.tileID ? o.tileID : new e.aL(a, o.wrap, o.zoom, r, s);
                        I.push({
                            tileID: p,
                            distanceSq: n * n + _ * _
                        });
                    }
                }
                if (this.fogCullDistSq) {
                    const i = this.fogCullDistSq, o = this.horizonLineFromTop();
                    I = I.filter((r)=>{
                        const a = [
                            0,
                            0,
                            0,
                            1
                        ], n = [
                            e.a3,
                            e.a3,
                            0,
                            1
                        ], s = this.calculateFogTileMatrix(r.tileID.toUnwrapped());
                        e.aA.transformMat4(a, a, s), e.aA.transformMat4(n, n, s);
                        const l = e.aA.min([], a, n), c = e.aA.max([], a, n), h = e.aR(l, c);
                        if (0 === h) return !0;
                        let _ = !1;
                        const u = this._elevation;
                        if (u && h > i && 0 !== o) {
                            const i = this.calculateProjMatrix(r.tileID.toUnwrapped());
                            let a;
                            t1.isTerrainDEM || (a = u.getMinMaxForTile(r.tileID)), a || (a = {
                                min: w,
                                max: b
                            });
                            const n = e.b2(this.rotation), s = [
                                n[0] * e.a3,
                                n[1] * e.a3,
                                a.max
                            ];
                            e._.transformMat4(s, s, i), _ = (1 - s[1]) * this.height * .5 < o;
                        }
                        return h < i || _;
                    });
                }
                return I.sort((e, t1)=>e.distanceSq - t1.distanceSq).map((e)=>e.tileID);
            }
            resize(e, t1) {
                this.width = e, this.height = t1, this.pixelsToGLUnits = [
                    2 / e,
                    -2 / t1
                ], this._constrain(), this._calcMatrices();
            }
            get unmodified() {
                return this._unmodified;
            }
            zoomScale(e) {
                return Math.pow(2, e);
            }
            scaleZoom(e) {
                return Math.log(e) / Math.LN2;
            }
            project(t1) {
                const i = e.at(t1.lat, -e.aS, e.aS), o = this.projection.project(t1.lng, i);
                return new e.P(o.x * this.worldSize, o.y * this.worldSize);
            }
            unproject(e) {
                return this.projection.unproject(e.x / this.worldSize, e.y / this.worldSize);
            }
            get point() {
                return this.project(this.center);
            }
            get pointMerc() {
                return this.point._div(this.worldSize);
            }
            get pixelsPerMeterRatio() {
                return this.pixelsPerMeter / e.ax(1, this.center.lat) / this.worldSize;
            }
            setLocationAtPoint(t1, i) {
                let o, r;
                const a = this.centerPoint;
                if ("globe" === this.projection.name) {
                    const e = this.worldSize;
                    o = (i.x - a.x) / e, r = (i.y - a.y) / e;
                } else {
                    const e = this.pointCoordinate(i), t1 = this.pointCoordinate(a);
                    o = e.x - t1.x, r = e.y - t1.y;
                }
                const n = this.locationCoordinate(t1);
                this.setLocation(new e.Y(n.x - o, n.y - r));
            }
            setLocation(e) {
                this.center = this.coordinateLocation(e), this.projection.wrap && (this.center = this.center.wrap());
            }
            locationPoint(e) {
                return this.projection.locationPoint(this, e);
            }
            locationPoint3D(e) {
                return this.projection.locationPoint(this, e, !0);
            }
            pointLocation(e) {
                return this.coordinateLocation(this.pointCoordinate(e));
            }
            pointLocation3D(e) {
                return this.coordinateLocation(this.pointCoordinate3D(e));
            }
            locationCoordinate(t1, i) {
                const o = i ? e.ax(i, t1.lat) : void 0, r = this.projection.project(t1.lng, t1.lat);
                return new e.Y(r.x, r.y, o);
            }
            coordinateLocation(e) {
                return this.projection.unproject(e.x, e.y);
            }
            pointRayIntersection(t1, i) {
                const o = null != i ? i : this._centerAltitude, r = [
                    t1.x,
                    t1.y,
                    0,
                    1
                ], a = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                e.aA.transformMat4(r, r, this.pixelMatrixInverse), e.aA.transformMat4(a, a, this.pixelMatrixInverse);
                const n = a[3];
                e.aA.scale(r, r, 1 / r[3]), e.aA.scale(a, a, 1 / n);
                const s = r[2], l = a[2];
                return {
                    p0: r,
                    p1: a,
                    t: s === l ? 0 : (o - s) / (l - s)
                };
            }
            screenPointToMercatorRay(t1) {
                const i = [
                    t1.x,
                    t1.y,
                    0,
                    1
                ], o = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                return e.aA.transformMat4(i, i, this.pixelMatrixInverse), e.aA.transformMat4(o, o, this.pixelMatrixInverse), e.aA.scale(i, i, 1 / i[3]), e.aA.scale(o, o, 1 / o[3]), i[2] = e.ax(i[2], this._center.lat) * this.worldSize, o[2] = e.ax(o[2], this._center.lat) * this.worldSize, e.aA.scale(i, i, 1 / this.worldSize), e.aA.scale(o, o, 1 / this.worldSize), new e.aT([
                    i[0],
                    i[1],
                    i[2]
                ], e._.normalize([], e._.sub([], o, i)));
            }
            rayIntersectionCoordinate(t1) {
                const { p0: i, p1: o, t: r } = t1, a = e.ax(i[2], this._center.lat), n = e.ax(o[2], this._center.lat);
                return new e.Y(e.a2(i[0], o[0], r) / this.worldSize, e.a2(i[1], o[1], r) / this.worldSize, e.a2(a, n, r));
            }
            pointCoordinate(e, t1 = this._centerAltitude) {
                return this.projection.pointCoordinate(this, e.x, e.y, t1);
            }
            pointCoordinate3D(t1) {
                if (!this.elevation) return this.pointCoordinate(t1);
                let i = this.projection.pointCoordinate3D(this, t1.x, t1.y);
                if (i) return new e.Y(i[0], i[1], i[2]);
                let o = 0, r = this.horizonLineFromTop();
                if (t1.y > r) return this.pointCoordinate(t1);
                const a = .02 * r, n = t1.clone();
                for(let t1 = 0; t1 < 10 && r - o > a; t1++){
                    n.y = e.a2(o, r, .66);
                    const t1 = this.projection.pointCoordinate3D(this, n.x, n.y);
                    t1 ? (r = n.y, i = t1) : o = n.y;
                }
                return i ? new e.Y(i[0], i[1], i[2]) : this.pointCoordinate(t1);
            }
            isPointAboveHorizon(e) {
                return this.projection.isPointAboveHorizon(this, e);
            }
            isPointOnSurface(t1) {
                if (t1.y < 0 || t1.y > this.height || t1.x < 0 || t1.x > this.width) return !1;
                if (this.elevation || this.zoom >= e.aU) return !this.isPointAboveHorizon(t1);
                const i = this.pointCoordinate(t1);
                return i.y >= 0 && i.y <= 1;
            }
            _coordinatePoint(t1, i) {
                const o = i && this.elevation ? this.elevation.getAtPointOrZero(t1, this._centerAltitude) : this._centerAltitude, r = [
                    t1.x * this.worldSize,
                    t1.y * this.worldSize,
                    o + t1.toAltitude(),
                    1
                ];
                return e.aA.transformMat4(r, r, this.pixelMatrix), r[3] > 0 ? new e.P(r[0] / r[3], r[1] / r[3]) : new e.P(Number.MAX_VALUE, Number.MAX_VALUE);
            }
            _getBoundsNonRectangular() {
                const { top: t1, left: i } = this._edgeInsets, o = this.height - this._edgeInsets.bottom, r = this.width - this._edgeInsets.right, a = this.pointLocation3D(new e.P(i, t1)), n = this.pointLocation3D(new e.P(r, t1)), s = this.pointLocation3D(new e.P(r, o)), l = this.pointLocation3D(new e.P(i, o));
                let c = Math.min(a.lng, n.lng, s.lng, l.lng), h = Math.max(a.lng, n.lng, s.lng, l.lng), _ = Math.min(a.lat, n.lat, s.lat, l.lat), u = Math.max(a.lat, n.lat, s.lat, l.lat);
                const d = Math.pow(2, -this.zoom) / 16 * 270, p = "globe" === this.projection.name ? 1 : 4, f = (t1, i, o, r, a)=>{
                    const n = (t1 + o) / 2, s = (i + r) / 2, l = new e.P(n, s), { lng: m, lat: g } = this.pointLocation3D(l), v = Math.max(0, c - m, _ - g, m - h, g - u);
                    c = Math.min(c, m), h = Math.max(h, m), _ = Math.min(_, g), u = Math.max(u, g), (a < p || v > d) && (f(t1, i, n, s, a + 1), f(n, s, o, r, a + 1));
                };
                if (f(i, t1, r, t1, 1), f(r, t1, r, o, 1), f(r, o, i, o, 1), f(i, o, i, t1, 1), "globe" === this.projection.name) {
                    const [t1, i] = e.aV(this);
                    t1 ? (u = 90, h = 180, c = -180) : i && (_ = -90, h = 180, c = -180);
                }
                return new e.ai(new e.aI(c, _), new e.aI(h, u));
            }
            _getBoundsRectangular(t1, i) {
                const { top: o, left: r } = this._edgeInsets, a = this.height - this._edgeInsets.bottom, n = this.width - this._edgeInsets.right, s = new e.P(r, o), l = new e.P(n, o), c = new e.P(n, a), h = new e.P(r, a);
                let _ = this.pointCoordinate(s, t1), u = this.pointCoordinate(l, t1);
                const d = this.pointCoordinate(c, i), p = this.pointCoordinate(h, i), f = (e, t1)=>(t1.y - e.y) / (t1.x - e.x);
                return _.y > 1 && u.y >= 0 ? _ = new e.Y((1 - p.y) / f(p, _) + p.x, 1) : _.y < 0 && u.y <= 1 && (_ = new e.Y(-p.y / f(p, _) + p.x, 0)), u.y > 1 && _.y >= 0 ? u = new e.Y((1 - d.y) / f(d, u) + d.x, 1) : u.y < 0 && _.y <= 1 && (u = new e.Y(-d.y / f(d, u) + d.x, 0)), (new e.ai).extend(this.coordinateLocation(_)).extend(this.coordinateLocation(u)).extend(this.coordinateLocation(p)).extend(this.coordinateLocation(d));
            }
            _getBoundsRectangularTerrain() {
                const e = this.elevation;
                if (!e.visibleDemTiles.length || e.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
                const t1 = e.visibleDemTiles.reduce((e, t1)=>{
                    if (t1.dem) {
                        const i = t1.dem.tree;
                        e.min = Math.min(e.min, i.minimums[0]), e.max = Math.max(e.max, i.maximums[0]);
                    }
                    return e;
                }, {
                    min: Number.MAX_VALUE,
                    max: 0
                });
                return this._getBoundsRectangular(t1.min * e.exaggeration(), t1.max * e.exaggeration());
            }
            getBounds() {
                return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
            }
            horizonLineFromTop(e = !0) {
                const t1 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) - this.centerOffset.y, i = this.height / 2 - t1 * (1 - this._horizonShift);
                return e ? Math.max(0, i) : i;
            }
            getMaxBounds() {
                return this.maxBounds;
            }
            setMaxBounds(t1) {
                this.maxBounds = t1, this.minLat = -e.aS, this.maxLat = e.aS, this.minLng = -180, this.maxLng = 180, t1 && (this.minLat = t1.getSouth(), this.maxLat = t1.getNorth(), this.minLng = t1.getWest(), this.maxLng = t1.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.aj(this.minLng) * this.tileSize, this.worldMaxX = e.aj(this.maxLng) * this.tileSize, this.worldMinY = e.ak(this.maxLat) * this.tileSize, this.worldMaxY = e.ak(this.minLat) * this.tileSize, this._constrain();
            }
            calculatePosMatrix(e, t1) {
                return this.projection.createTileMatrix(this, t1, e);
            }
            calculateDistanceTileData(t1) {
                const i = t1.key, o = this._distanceTileDataCache;
                if (o[i]) return o[i];
                const r = t1.canonical, a = 1 / this.height, n = this.cameraWorldSize, s = n / this.zoomScale(r.z), l = (r.x + Math.pow(2, r.z) * t1.wrap) * s, c = r.y * s, h = this.point;
                h.x *= n / this.worldSize, h.y *= n / this.worldSize;
                const _ = this.angle, u = Math.sin(-_), d = -Math.cos(-_);
                return o[i] = {
                    bearing: [
                        u,
                        d
                    ],
                    center: [
                        (h.x - l) * a,
                        (h.y - c) * a
                    ],
                    scale: s / e.a3 * a
                }, o[i];
            }
            calculateFogTileMatrix(t1) {
                const i = t1.key, o = this._fogTileMatrixCache;
                if (o[i]) return o[i];
                const r = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t1);
                return e.ad.multiply(r, this.worldToFogMatrix, r), o[i] = new Float32Array(r), o[i];
            }
            calculateProjMatrix(t1, i = !1, o = !1) {
                const r = t1.key;
                let a;
                if (a = o ? this._expandedProjMatrixCache : i ? this._alignedProjMatrixCache : this._projMatrixCache, a[r]) return a[r];
                const n = this.calculatePosMatrix(t1, this.worldSize);
                let s;
                return s = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o ? this.expandedFarZProjMatrix : i ? this.alignedProjMatrix : this.projMatrix, e.ad.multiply(n, s, n), a[r] = new Float32Array(n), a[r];
            }
            calculatePixelsToTileUnitsMatrix(t1) {
                const i = t1.tileID.key, o = this._pixelsToTileUnitsCache;
                if (o[i]) return o[i];
                const r = e.aW(t1, this);
                return o[i] = r, o[i];
            }
            customLayerMatrix() {
                return this.mercatorMatrix.slice();
            }
            globeToMercatorMatrix() {
                if ("globe" === this.projection.name) {
                    const t1 = 1 / this.worldSize, i = e.ad.fromScaling([], [
                        t1,
                        t1,
                        t1
                    ]);
                    return e.ad.multiply(i, i, this.globeMatrix), i;
                }
            }
            recenterOnTerrain() {
                if (!this._elevation || "globe" === this.projection.name) return;
                const t1 = this._elevation;
                this._updateCameraState();
                const i = e.ax(1, this._center.lat) * this.worldSize, o = this._computeCameraPosition(i), r = this._camera.forward(), a = e.ax(1, this._center.lat);
                o[2] /= a, r[2] /= a, e._.normalize(r, r);
                const n = t1.raycast(o, r, t1.exaggeration());
                if (n) {
                    const t1 = e._.scaleAndAdd([], o, r, n), i = new e.Y(t1[0], t1[1], e.ax(t1[2], e.ay(t1[1]))), s = (i.z + e._.length([
                        i.x - o[0],
                        i.y - o[1],
                        i.z - o[2] * a
                    ])) * this._pixelsPerMercatorPixel;
                    this._seaLevelZoom = this._zoomFromMercatorZ(s), this._centerAltitude = i.toAltitude(), this._center = this.coordinateLocation(i), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
                }
            }
            _constrainCamera(t1 = !1) {
                if (!this._elevation) return;
                const i = this._elevation, o = e.ax(1, this._center.lat) * this.worldSize, r = this._computeCameraPosition(o), a = i.getAtPointOrZero(new e.Y(...r)), n = this.pixelsPerMeter / this.worldSize * a, s = this._minimumHeightOverTerrain(), l = r[2] - n;
                if (l <= s) {
                    if (l < 0 || t1) {
                        const t1 = this.locationCoordinate(this._center, this._centerAltitude), i = [
                            r[0],
                            r[1],
                            t1.z - r[2]
                        ], o = e._.length(i);
                        i[2] -= (s - l) / this._pixelsPerMercatorPixel;
                        const a = e._.length(i);
                        if (0 === a) return;
                        e._.scale(i, i, o / a * this._pixelsPerMercatorPixel), this._camera.position = [
                            r[0],
                            r[1],
                            t1.z * this._pixelsPerMercatorPixel - i[2]
                        ], this._updateStateFromCamera();
                    } else this._isCameraConstrained = !0;
                }
            }
            _constrain() {
                if (!this.center || !this.width || !this.height || this._constraining) return;
                this._constraining = !0;
                const t1 = "globe" === this.projection.name || this.mercatorFromTransition;
                if (this.projection.isReprojectedInTileSpace || t1) {
                    const i = this.center;
                    return i.lat = e.at(i.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t1) && (i.lng = e.at(i.lng, this.minLng, this.maxLng)), this.center = i, void (this._constraining = !1);
                }
                const i = this._unmodified, { x: o, y: r } = this.point;
                let a = 0, n = o, s = r;
                const l = this.width / 2, c = this.height / 2, h = this.worldMinY * this.scale, _ = this.worldMaxY * this.scale;
                if (r - c < h && (s = h + c), r + c > _ && (s = _ - c), _ - h < this.height && (a = Math.max(a, this.height / (_ - h)), s = (_ + h) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                    const e = this.worldMinX * this.scale, t1 = this.worldMaxX * this.scale, i = this.worldSize / 2 - (e + t1) / 2;
                    n = (o + i + this.worldSize) % this.worldSize - i, n - l < e && (n = e + l), n + l > t1 && (n = t1 - l), t1 - e < this.width && (a = Math.max(a, this.width / (t1 - e)), n = (t1 + e) / 2);
                }
                n === o && s === r || (this.center = this.unproject(new e.P(n, s))), a && (this.zoom += this.scaleZoom(a)), this._constrainCamera(), this._unmodified = i, this._constraining = !1;
            }
            _minZoomForBounds() {
                let e = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
                return this.maxBounds && (e = Math.max(e, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e;
            }
            _maxCameraBoundsDistance() {
                return this._mercatorZfromZoom(this._minZoomForBounds());
            }
            _calcMatrices() {
                if (!this.height) return;
                const t1 = this.centerOffset, i = "globe" === this.projection.name, o = this.pixelsPerMeter;
                "globe" === this.projection.name && (this._mercatorScaleRatio = e.ax(1, this.center.lat) / e.ax(1, e.b3));
                const r = e.aX(this.projection, this.zoom, this.width, this.height, 1024);
                this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, r), this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
                const a = "meters" === this.projection.zAxisUnit ? o : 1, n = this._camera.getWorldToCamera(this.worldSize, a);
                let s;
                const l = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
                if (l[8] = 2 * -t1.x / this.width, l[9] = 2 * t1.y / this.height, this.isOrthographic) {
                    let e = .5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(.5 * this._fov), i = e * this.aspect, o = -i, r = -e;
                    i -= t1.x, o -= t1.x, e += t1.y, r += t1.y, s = this._camera.getCameraToClipOrthographic(o, i, r, e, this._nearZ, this._farZ), ((e, t1, i, o)=>{
                        for(let r = 0; r < 16; r++)e[r] = _i(t1[r], i[r], o);
                    })(s, s, l, ui(this.pitch >= 15 ? 1 : this.pitch / 15));
                } else s = l;
                const c = e.ad.mul([], l, n);
                let h = e.ad.mul([], s, n);
                if (this.projection.isReprojectedInTileSpace) {
                    const t1 = this.locationCoordinate(this.center), i = e.ad.identity([]);
                    e.ad.translate(i, i, [
                        t1.x * this.worldSize,
                        t1.y * this.worldSize,
                        0
                    ]), e.ad.multiply(i, i, e.aY(this)), e.ad.translate(i, i, [
                        -t1.x * this.worldSize,
                        -t1.y * this.worldSize,
                        0
                    ]), e.ad.multiply(h, h, i), e.ad.multiply(c, c, i), this.inverseAdjustmentMatrix = e.aZ(this);
                } else this.inverseAdjustmentMatrix = [
                    1,
                    0,
                    0,
                    1
                ];
                if (this.mercatorMatrix = e.ad.scale([], h, [
                    this.worldSize,
                    this.worldSize,
                    this.worldSize / a,
                    1
                ]), this.projMatrix = h, this.invProjMatrix = e.ad.invert(new Float64Array(16), this.projMatrix), i) {
                    const i = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
                    i[8] = 2 * -t1.x / this.width, i[9] = 2 * t1.y / this.height, this.expandedFarZProjMatrix = e.ad.mul([], i, n);
                } else this.expandedFarZProjMatrix = this.projMatrix;
                const _ = e.ad.invert([], s);
                this.frustumCorners = e.a_.fromInvProjectionMatrix(_, this.horizonLineFromTop(), this.height), this.cameraFrustum = e.aM.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i);
                const u = new Float32Array(16);
                e.ad.identity(u), e.ad.scale(u, u, [
                    1,
                    -1,
                    1
                ]), e.ad.rotateX(u, u, this._pitch), e.ad.rotateZ(u, u, this.angle);
                const d = e.ad.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
                this.starsProjMatrix = e.ad.clone(d);
                const p = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
                d[8] = 2 * -t1.x / this.width, d[9] = 2 * (t1.y + p) / this.height, this.skyboxMatrix = e.ad.multiply(u, d, u);
                const f = this.point, m = f.x, g = f.y, v = this.width % 2 / 2, x = this.height % 2 / 2, y = Math.cos(this.angle), b = Math.sin(this.angle), w = m - Math.round(m) + y * v + b * x, T = g - Math.round(g) + y * x + b * v, E = new Float64Array(h);
                if (e.ad.translate(E, E, [
                    w > .5 ? w - 1 : w,
                    T > .5 ? T - 1 : T,
                    0
                ]), this.alignedProjMatrix = E, h = e.ad.create(), e.ad.scale(h, h, [
                    this.width / 2,
                    -this.height / 2,
                    1
                ]), e.ad.translate(h, h, [
                    1,
                    -1,
                    0
                ]), this.labelPlaneMatrix = h, h = e.ad.create(), e.ad.scale(h, h, [
                    1,
                    -1,
                    1
                ]), e.ad.translate(h, h, [
                    -1,
                    -1,
                    0
                ]), e.ad.scale(h, h, [
                    2 / this.width,
                    2 / this.height,
                    1
                ]), this.glCoordMatrix = h, this.pixelMatrix = e.ad.multiply(new Float64Array(16), this.labelPlaneMatrix, c), this._calcFogMatrices(), this._distanceTileDataCache = {}, h = e.ad.invert(new Float64Array(16), this.pixelMatrix), !h) throw new Error("failed to invert matrix");
                if (this.pixelMatrixInverse = h, "globe" === this.projection.name || this.mercatorFromTransition) {
                    this.globeMatrix = e.a$(this);
                    const t1 = [
                        this.globeMatrix[12],
                        this.globeMatrix[13],
                        this.globeMatrix[14]
                    ];
                    this.globeCenterInViewSpace = e._.transformMat4(t1, t1, n), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
                } else this.globeMatrix = h;
                this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
            }
            _calcFogMatrices() {
                this._fogTileMatrixCache = {};
                const t1 = this.cameraWorldSizeForFog, i = this.cameraPixelsPerMeter, o = this._camera.position, r = 1 / this.height / this._pixelsPerMercatorPixel, a = [
                    t1,
                    t1,
                    i
                ];
                e._.scale(a, a, r), e._.scale(o, o, -1), e._.multiply(o, o, a);
                const n = e.ad.create();
                e.ad.translate(n, n, o), e.ad.scale(n, n, a), this.mercatorFogMatrix = n, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t1, i, r);
            }
            _computeCameraPosition(e) {
                const t1 = (e = e || this.pixelsPerMeter) / this.pixelsPerMeter, i = this._camera.forward(), o = this.point, r = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t1 - e / this.worldSize * this._centerAltitude;
                return [
                    o.x / this.worldSize - i[0] * r,
                    o.y / this.worldSize - i[1] * r,
                    e / this.worldSize * this._centerAltitude - i[2] * r
                ];
            }
            _updateCameraState() {
                this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
            }
            _translateCameraConstrained(t1) {
                const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o = this._camera.position[2], r = t1[2];
                let a = 1;
                this.projection.wrap && (this.center = this.center.wrap()), r > 0 && (a = Math.min((i - o) / r, 1)), this._camera.position = e._.scaleAndAdd([], this._camera.position, t1, a), this._updateStateFromCamera();
            }
            _updateStateFromCamera() {
                const t1 = this._camera.position, i = this._camera.forward(), { pitch: o, bearing: r } = this._camera.getPitchBearing(), a = e.ax(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, n = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.ab(this._maxPitch)), s = Math.max((t1[2] - a) / Math.cos(o), n), l = this._zoomFromMercatorZ(s);
                e._.scaleAndAdd(t1, t1, i, s), this._pitch = e.at(o, e.ab(this.minPitch), e.ab(this.maxPitch)), this.angle = e.au(r, -Math.PI, Math.PI), this._setZoom(e.at(l, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.Y(t1[0], t1[1], t1[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();
            }
            _worldSizeFromZoom(e) {
                return Math.pow(2, e) * this.tileSize;
            }
            _mercatorZfromZoom(e) {
                return this.cameraToCenterDistance / this._worldSizeFromZoom(e);
            }
            _minimumHeightOverTerrain() {
                const e = Math.min(null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
                return this._mercatorZfromZoom(e);
            }
            _zoomFromMercatorZ(e) {
                return this.scaleZoom(this.cameraToCenterDistance / (e * this.tileSize));
            }
            zoomFromMercatorZAdjusted(t1) {
                let i = 0, o = e.aU, r = 0, a = 1 / 0;
                for(; o - i > 1e-6 && o > i;){
                    const e = i + .5 * (o - i), n = this.tileSize * Math.pow(2, e), s = this.getCameraToCenterDistance(this.projection, e, n), l = this.scaleZoom(s / (t1 * this.tileSize)), c = Math.abs(e - l);
                    c < a && (a = c, r = e), e < l ? i = e : o = e;
                }
                return r;
            }
            _terrainEnabled() {
                return !(!this._elevation || !this.projection.supportsTerrain && (e.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
            }
            anyCornerOffEdge(t1, i) {
                const o = Math.min(t1.x, i.x), r = Math.max(t1.x, i.x), a = Math.min(t1.y, i.y), n = Math.max(t1.y, i.y);
                if (a < this.horizonLineFromTop(!1)) return !0;
                if ("mercator" !== this.projection.name) return !1;
                const s = [
                    new e.P(o, a),
                    new e.P(r, n),
                    new e.P(o, n),
                    new e.P(r, a)
                ], l = this.renderWorldCopies ? -3 : 0, c = this.renderWorldCopies ? 4 : 1;
                for (const e of s){
                    const t1 = this.pointRayIntersection(e);
                    if (t1.t < 0) return !0;
                    const i = this.rayIntersectionCoordinate(t1);
                    if (i.x < l || i.y < 0 || i.x > c || i.y > 1) return !0;
                }
                return !1;
            }
            isHorizonVisible() {
                return this.pitch + e.b0(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.P(0, 0), new e.P(this.width, this.height));
            }
            zoomDeltaToMovement(t1, i) {
                const o = e._.length(e._.sub([], this._camera.position, t1)), r = this._zoomFromMercatorZ(o) + i;
                return o - this._mercatorZfromZoom(r);
            }
            getCameraPoint() {
                if ("globe" === this.projection.name) {
                    const t1 = function([t1, i, o], r) {
                        const a = [
                            t1,
                            i,
                            o,
                            1
                        ];
                        e.aA.transformMat4(a, a, r);
                        const n = a[3] = Math.max(a[3], 1e-6);
                        return a[0] /= n, a[1] /= n, a[2] /= n, a;
                    }([
                        this.globeMatrix[12],
                        this.globeMatrix[13],
                        this.globeMatrix[14]
                    ], this.pixelMatrix);
                    return new e.P(t1[0], t1[1]);
                }
                {
                    const t1 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                    return this.centerPoint.add(new e.P(0, t1));
                }
            }
            getCameraToCenterDistance(t1, i = this.zoom, o = this.worldSize) {
                const r = e.aX(t1, i, this.width, this.height, 1024), a = t1.pixelSpaceConversion(this.center.lat, o, r);
                let n = .5 / Math.tan(.5 * this._fov) * this.height * a;
                return this.isOrthographic && (n = _i(1, n, ui(this.pitch >= 15 ? 1 : this.pitch / 15))), n;
            }
            getWorldToCameraMatrix() {
                const t1 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
                return "globe" === this.projection.name && e.ad.multiply(t1, t1, this.globeMatrix), t1;
            }
            getFrustum(t1) {
                return e.aM.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t1, "meters" === this.projection.zAxisUnit);
            }
        }
        const pi = {
            BaseColor: 5,
            MetallicRoughness: 6,
            Normal: 7,
            Occlusion: 8,
            Emission: 9,
            LUT: 10,
            ShadowMap0: 11
        }, fi = (t1, i)=>{
            if (i > 0 && t1.terrain && e.w("Cutoff is currently disabled on terrain"), i <= 0 || t1.terrain) return {
                shouldRenderCutoff: !1,
                uniformValues: {
                    u_cutoff_params: [
                        0,
                        0,
                        0,
                        1
                    ]
                }
            };
            const o = t1.transform, r = Math.max(Math.abs(o._zoom - (t1.minCutoffZoom - 1)), 1), a = o.isLODDisabled(!1) ? e.$(60, 45, o.pitch) : e.$(30, 15, o.pitch), n = o._farZ - o._nearZ, s = i * o.height, l = ((1 - (c = a)) * o.cameraToCenterDistance + c * (o._farZ + s)) * r;
            var c;
            return {
                shouldRenderCutoff: a < 1,
                uniformValues: {
                    u_cutoff_params: [
                        o._nearZ,
                        o._farZ,
                        (l - o._nearZ) / n,
                        (l - s - o._nearZ) / n
                    ]
                }
            };
        }, mi = {
            cascadeCount: 2,
            shadowMapResolution: 2048
        };
        class gi {
            constructor(e, t1){
                this.aabb = e, this.lastCascade = t1;
            }
        }
        class vi {
            add(e, t1) {
                const i = this.receivers[e.key];
                void 0 !== i ? (i.aabb.min[0] = Math.min(i.aabb.min[0], t1.min[0]), i.aabb.min[1] = Math.min(i.aabb.min[1], t1.min[1]), i.aabb.min[2] = Math.min(i.aabb.min[2], t1.min[2]), i.aabb.max[0] = Math.max(i.aabb.max[0], t1.max[0]), i.aabb.max[1] = Math.max(i.aabb.max[1], t1.max[1]), i.aabb.max[2] = Math.max(i.aabb.max[2], t1.max[2])) : this.receivers[e.key] = new gi(t1, null);
            }
            clear() {
                this.receivers = {};
            }
            get(e) {
                return this.receivers[e.key];
            }
            computeRequiredCascades(t1, i, o) {
                const r = e.b6.fromPoints(t1.points);
                let a = 0;
                for(const t1 in this.receivers){
                    const n = this.receivers[t1];
                    if (!n) continue;
                    if (!r.intersectsAabb(n.aabb)) continue;
                    n.aabb.min = r.closestPoint(n.aabb.min), n.aabb.max = r.closestPoint(n.aabb.max);
                    const s = n.aabb.getCorners();
                    for(let t1 = 0; t1 < o.length; t1++){
                        let r = !0;
                        for (const a of s){
                            const n = [
                                a[0] * i,
                                a[1] * i,
                                a[2]
                            ];
                            if (e._.transformMat4(n, n, o[t1].matrix), n[0] < -1 || n[0] > 1 || n[1] < -1 || n[1] > 1) {
                                r = !1;
                                break;
                            }
                        }
                        if (n.lastCascade = t1, a = Math.max(a, t1), r) break;
                    }
                }
                return a + 1;
            }
        }
        class xi {
            constructor(t1){
                this.painter = t1, this._enabled = !1, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new vi, this._depthMode = new e.ae(t1.context.gl.LEQUAL, e.ae.ReadWrite, [
                    0,
                    1
                ]), this._uniformValues = {
                    u_light_matrix_0: new Float32Array(16),
                    u_light_matrix_1: new Float32Array(16),
                    u_shadow_intensity: 0,
                    u_fade_range: [
                        0,
                        0
                    ],
                    u_shadow_normal_offset: [
                        1,
                        1,
                        1
                    ],
                    u_shadow_texel_size: 1,
                    u_shadow_map_resolution: 1,
                    u_shadow_direction: [
                        0,
                        0,
                        1
                    ],
                    u_shadow_bias: [
                        36e-5,
                        .0012,
                        .012
                    ],
                    u_shadowmap_0: 0,
                    u_shadowmap_1: 0
                }, this._forceDisable = !1, this.useNormalOffset = !1, t1.tp.registerParameter(this, [
                    "Shadows"
                ], "_forceDisable", {
                    label: "forceDisable"
                }, ()=>{
                    this.painter.style.map.triggerRepaint();
                }), t1.tp.registerParameter(mi, [
                    "Shadows"
                ], "cascadeCount", {
                    min: 1,
                    max: 2,
                    step: 1
                }), t1.tp.registerParameter(mi, [
                    "Shadows"
                ], "shadowMapResolution", {
                    min: 32,
                    max: 2048,
                    step: 32
                }), t1.tp.registerBinding(this, [
                    "Shadows"
                ], "_numCascadesToRender", {
                    readonly: !0,
                    label: "numCascadesToRender"
                });
            }
            destroy() {
                for (const e of this._cascades)e.texture.destroy(), e.framebuffer.destroy();
                this._cascades = [];
            }
            updateShadowParameters(t1, i) {
                const o = this.painter;
                if (this._enabled = !1, this._shadowLayerCount = 0, this._receivers.clear(), !i || !i.properties) return;
                const r = i.properties.get("shadow-intensity");
                if (!i.shadowsEnabled() || r <= 0) return;
                if (this._shadowLayerCount = o.style.order.reduce((e, i)=>{
                    const r = o.style._mergedLayers[i];
                    return e + (r.hasShadowPass() && !r.isHidden(t1.zoom) ? 1 : 0);
                }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled) return;
                const a = o.context, n = mi.shadowMapResolution, s = mi.shadowMapResolution;
                if (0 === this._cascades.length || mi.shadowMapResolution !== this._cascades[0].texture.size[0]) {
                    this._cascades = [];
                    for(let t1 = 0; t1 < mi.cascadeCount; ++t1){
                        const t1 = o._shadowMapDebug, i = a.gl, r = a.createFramebuffer(n, s, t1, "texture"), l = new e.T(a, {
                            width: n,
                            height: s,
                            data: null
                        }, i.DEPTH_COMPONENT);
                        if (r.depthAttachment.set(l.texture), t1) {
                            const t1 = new e.T(a, {
                                width: n,
                                height: s,
                                data: null
                            }, i.RGBA);
                            r.colorAttachment.set(t1.texture);
                        }
                        this._cascades.push({
                            framebuffer: r,
                            texture: l,
                            matrix: [],
                            far: 0,
                            boundingSphereRadius: 0,
                            frustum: new e.aM,
                            scale: 0
                        });
                    }
                }
                this.shadowDirection = bi(i);
                let l = 0;
                if (t1.elevation) {
                    const e = t1.elevation, i = [
                        1e4,
                        -10000
                    ];
                    e.visibleDemTiles.filter((e)=>e.dem).forEach((e)=>{
                        const t1 = e.dem.tree;
                        i[0] = Math.min(i[0], t1.minimums[0]), i[1] = Math.max(i[1], t1.maximums[0]);
                    }), 1e4 !== i[0] && (l = (i[1] - i[0]) * e.exaggeration());
                }
                const c = 1.5 * t1.cameraToCenterDistance, h = 3 * c, _ = new Float64Array(16);
                for(let i = 0; i < this._cascades.length; ++i){
                    const o = this._cascades[i];
                    let r = t1.height / 50, a = 1;
                    1 === mi.cascadeCount ? a = h : 0 === i ? a = c : (r = c, a = h);
                    const [n, s] = Ti(t1, this.shadowDirection, r, a, mi.shadowMapResolution, l);
                    o.scale = t1.scale, o.matrix = n, o.boundingSphereRadius = s, e.ad.invert(_, o.matrix), o.frustum = e.aM.fromInvProjectionMatrix(_, 1, 0, !0), o.far = a;
                }
                const u = this._cascades.length - 1;
                this._uniformValues.u_fade_range = [
                    .75 * this._cascades[u].far,
                    this._cascades[u].far
                ], this._uniformValues.u_shadow_intensity = r, this._uniformValues.u_shadow_direction = [
                    this.shadowDirection[0],
                    this.shadowDirection[1],
                    this.shadowDirection[2]
                ], this._uniformValues.u_shadow_texel_size = 1 / mi.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = mi.shadowMapResolution, this._uniformValues.u_shadowmap_0 = pi.ShadowMap0, this._uniformValues.u_shadowmap_1 = pi.ShadowMap0 + 1, this._groundShadowTiles = o.transform.coveringTiles({
                    tileSize: 512,
                    renderWorldCopies: !0
                });
                const d = o.transform.elevation;
                for (const e of this._groundShadowTiles){
                    let t1 = {
                        min: 0,
                        max: 0
                    };
                    if (d) {
                        const i = d.getMinMaxForTile(e);
                        i && (t1 = i);
                    }
                    this.addShadowReceiver(e.toUnwrapped(), t1.min, t1.max);
                }
            }
            get enabled() {
                return this._enabled && !this._forceDisable;
            }
            set enabled(e) {
                this._enabled = e;
            }
            drawShadowPass(t1, i) {
                if (!this.enabled) return;
                const o = this.painter, r = o.context;
                this._numCascadesToRender = this._receivers.computeRequiredCascades(o.transform.getFrustum(0), o.transform.worldSize, this._cascades), r.viewport.set([
                    0,
                    0,
                    mi.shadowMapResolution,
                    mi.shadowMapResolution
                ]);
                for(let a = 0; a < this._numCascadesToRender; ++a){
                    o.currentShadowCascade = a, r.bindFramebuffer.set(this._cascades[a].framebuffer.framebuffer), r.clear({
                        color: e.C.white,
                        depth: 1
                    });
                    for (const e of t1.order){
                        const r = t1._mergedLayers[e];
                        if (!r.hasShadowPass() || r.isHidden(o.transform.zoom)) continue;
                        const a = t1.getLayerSourceCache(r), n = a ? i[a.id] : void 0;
                        ("model" === r.type || n && n.length) && o.renderLayer(o, a, r, n);
                    }
                }
                o.currentShadowCascade = 0;
            }
            drawGroundShadows() {
                if (!this.enabled) return;
                const t1 = this.painter, i = t1.style, o = t1.context, r = i.directionalLight, a = i.ambientLight;
                if (!r || !a) return;
                const n = [], s = fi(t1, t1.longestCutoffRange);
                s.shouldRenderCutoff && n.push("RENDER_CUTOFF");
                const l = wi(i, r, a), c = new e.ae(o.gl.LEQUAL, e.ae.ReadOnly, t1.depthRangeFor3D);
                for (const i of this._groundShadowTiles){
                    const r = i.toUnwrapped(), a = t1.isTileAffectedByFog(i), h = t1.getOrCreateProgram("groundShadow", {
                        defines: n,
                        overrideFog: a
                    });
                    this.setupShadows(r, h), t1.uploadCommonUniforms(o, h, r, null, s);
                    const _ = {
                        u_matrix: t1.transform.calculateProjMatrix(r),
                        u_ground_shadow_factor: l
                    };
                    h.draw(t1, o.gl.TRIANGLES, c, e.ag.disabled, e.a.multiply, e.af.disabled, _, "ground_shadow", t1.tileExtentBuffer, t1.quadTriangleIndexBuffer, t1.tileExtentSegments, {}, t1.transform.zoom, null, null);
                }
            }
            getShadowPassColorMode() {
                return this.painter._shadowMapDebug ? e.a.unblended : e.a.disabled;
            }
            getShadowPassDepthMode() {
                return this._depthMode;
            }
            getShadowCastingLayerCount() {
                return this._shadowLayerCount;
            }
            calculateShadowPassMatrixFromTile(t1) {
                const i = this.painter.transform, o = i.calculatePosMatrix(t1, i.worldSize);
                return e.ad.multiply(o, this._cascades[this.painter.currentShadowCascade].matrix, o), Float32Array.from(o);
            }
            calculateShadowPassMatrixFromMatrix(t1) {
                return e.ad.multiply(t1, this._cascades[this.painter.currentShadowCascade].matrix, t1), Float32Array.from(t1);
            }
            setupShadows(t1, i, o, r = 0) {
                if (!this.enabled) return;
                const a = this.painter.transform, n = this.painter.context, s = n.gl, l = this._uniformValues, c = new Float64Array(16), h = a.calculatePosMatrix(t1, a.worldSize);
                for(let t1 = 0; t1 < this._cascades.length; t1++)e.ad.multiply(c, this._cascades[t1].matrix, h), l[0 === t1 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(c), n.activeTexture.set(s.TEXTURE0 + pi.ShadowMap0 + t1), this._cascades[t1].texture.bind(s.NEAREST, s.CLAMP_TO_EDGE);
                if (this.useNormalOffset = !!o, this.useNormalOffset) {
                    const i = e.b5(t1.canonical), n = 2 / a.tileSize * e.a3 / mi.shadowMapResolution, s = n * this._cascades[0].boundingSphereRadius, c = n * this._cascades[this._cascades.length - 1].boundingSphereRadius, h = ("vector-tile" === o ? 1 : 3) / Math.pow(2, r - t1.canonical.z - (1 - a.zoom + Math.floor(a.zoom)));
                    l.u_shadow_normal_offset = [
                        i,
                        s * h,
                        c * h
                    ], l.u_shadow_bias = [
                        6e-5,
                        .0012,
                        .012
                    ];
                } else l.u_shadow_bias = [
                    36e-5,
                    .0012,
                    .012
                ];
                i.setShadowUniformValues(n, l);
            }
            setupShadowsFromMatrix(t1, i, o = !1) {
                if (!this.enabled) return;
                const r = this.painter.context, a = r.gl, n = this._uniformValues, s = new Float64Array(16);
                for(let i = 0; i < mi.cascadeCount; i++)e.ad.multiply(s, this._cascades[i].matrix, t1), n[0 === i ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(s), r.activeTexture.set(a.TEXTURE0 + pi.ShadowMap0 + i), this._cascades[i].texture.bind(a.NEAREST, a.CLAMP_TO_EDGE);
                if (this.useNormalOffset = o, o) {
                    const e = 5;
                    n.u_shadow_normal_offset = [
                        1,
                        e,
                        e
                    ], n.u_shadow_bias = [
                        6e-5,
                        .0012,
                        .012
                    ];
                } else n.u_shadow_bias = [
                    36e-5,
                    .0012,
                    .012
                ];
                i.setShadowUniformValues(r, n);
            }
            getShadowUniformValues() {
                return this._uniformValues;
            }
            getCurrentCascadeFrustum() {
                return this._cascades[this.painter.currentShadowCascade].frustum;
            }
            computeSimplifiedTileShadowVolume(t1, i, o, r) {
                if (r[2] >= 0) return {};
                const a = (function(t1, i, o) {
                    const r = o / (1 << t1.canonical.z);
                    return new e.b6([
                        t1.canonical.x * r + t1.wrap * o,
                        t1.canonical.y * r + t1.wrap * o,
                        0
                    ], [
                        (t1.canonical.x + 1) * r + t1.wrap * o,
                        (t1.canonical.y + 1) * r + t1.wrap * o,
                        i
                    ]);
                })(t1, i, o).getCorners(), n = i / -r[2];
                r[0] < 0 ? (e._.add(a[0], a[0], [
                    r[0] * n,
                    0,
                    0
                ]), e._.add(a[3], a[3], [
                    r[0] * n,
                    0,
                    0
                ])) : r[0] > 0 && (e._.add(a[1], a[1], [
                    r[0] * n,
                    0,
                    0
                ]), e._.add(a[2], a[2], [
                    r[0] * n,
                    0,
                    0
                ])), r[1] < 0 ? (e._.add(a[0], a[0], [
                    0,
                    r[1] * n,
                    0
                ]), e._.add(a[1], a[1], [
                    0,
                    r[1] * n,
                    0
                ])) : r[1] > 0 && (e._.add(a[2], a[2], [
                    0,
                    r[1] * n,
                    0
                ]), e._.add(a[3], a[3], [
                    0,
                    r[1] * n,
                    0
                ]));
                const s = {};
                return s.vertices = a, s.planes = [
                    yi(a[1], a[0], a[4]),
                    yi(a[2], a[1], a[5]),
                    yi(a[3], a[2], a[6]),
                    yi(a[0], a[3], a[7])
                ], s;
            }
            addShadowReceiver(t1, i, o) {
                this._receivers.add(t1, e.b6.fromTileIdAndHeight(t1, i, o));
            }
            getMaxCascadeForTile(e) {
                const t1 = this._receivers.get(e);
                return t1 && t1.lastCascade ? t1.lastCascade : 0;
            }
        }
        function yi(t1, i, o) {
            const r = e._.sub([], o, i), a = e._.sub([], t1, i), n = e._.cross([], r, a), s = e._.length(n);
            return 0 === s ? [
                0,
                0,
                1,
                0
            ] : (e._.scale(n, n, 1 / s), [
                n[0],
                n[1],
                n[2],
                -e._.dot(n, i)
            ]);
        }
        function bi(t1) {
            const i = t1.properties.get("direction"), o = e.ac(i.x, i.y, i.z);
            o[2] = e.at(o[2], 0, 75);
            const r = e.b7([
                o[0],
                o[1],
                o[2]
            ]);
            return e._.fromValues(r.x, r.y, r.z);
        }
        function wi(t1, i, o) {
            const r = i.properties.get("color"), a = i.properties.get("intensity"), n = i.properties.get("direction"), s = [
                n.x,
                n.y,
                n.z
            ], l = o.properties.get("color"), c = o.properties.get("intensity"), h = Math.max(e._.dot([
                0,
                0,
                1
            ], s), 0), _ = [
                0,
                0,
                0
            ];
            e._.scale(_, l.toRenderColor(t1.getLut(i.scope)).toArray01Linear().slice(0, 3), c);
            const u = [
                0,
                0,
                0
            ];
            return e._.scale(u, r.toRenderColor(t1.getLut(o.scope)).toArray01Linear().slice(0, 3), h * a), e.b8([
                _[0] > 0 ? _[0] / (_[0] + u[0]) : 0,
                _[1] > 0 ? _[1] / (_[1] + u[1]) : 0,
                _[2] > 0 ? _[2] / (_[2] + u[2]) : 0
            ]);
        }
        function Ti(t1, i, o, r, a, n) {
            const s = t1.zoom, l = t1.scale, c = t1.worldSize, h = 1 / c, _ = t1.aspect, u = Math.sqrt(1 + _ * _) * Math.tan(.5 * t1.fovX), d = u * u, p = r - o, f = r + o;
            let m, g;
            d > p / f ? (m = r, g = r * u) : (m = .5 * f * (1 + d), g = .5 * Math.sqrt(p * p + 2 * (r * r + o * o) * d + f * f * d * d));
            const v = t1.projection.pixelsPerMeter(t1.center.lat, c), x = t1._camera.getCameraToWorldMercator(), y = [
                0,
                0,
                -m * h
            ];
            e._.transformMat4(y, y, x);
            let b = g * h;
            const w = t1._edgeInsets;
            if (!(0 === w.left && 0 === w.top && 0 === w.right && 0 === w.bottom || w.left === w.right && w.top === w.bottom)) {
                const i = t1._camera.getWorldToCamera(t1.worldSize, "meters" === t1.projection.zAxisUnit ? v : 1), a = t1._camera.getCameraToClipPerspective(t1._fov, t1.width / t1.height, o, r);
                a[8] = 2 * -t1.centerOffset.x / t1.width, a[9] = 2 * t1.centerOffset.y / t1.height;
                const n = new Float64Array(16);
                e.ad.mul(n, a, i);
                const h = new Float64Array(16);
                e.ad.invert(h, n);
                const _ = e.aM.fromInvProjectionMatrix(h, c, s, !0);
                for (const i of _.points){
                    const o = ((T = i)[0] /= l, T[1] /= l, T[2] = e.ax(T[2], t1._center.lat), T);
                    b = Math.max(b, e._.len(e._.subtract([], y, o)));
                }
            }
            var T;
            b *= a / (a - 1);
            const E = Math.acos(i[2]), C = Math.atan2(-i[0], -i[1]), S = new Ht;
            S.position = y, S.setPitchBearing(E, C);
            const I = S.getWorldToCamera(c, v), L = b * c, P = Math.min(t1._mercatorZfromZoom(17) * c * -2, -2 * L), A = S.getCameraToClipOrthographic(-L, L, -L, L, P, (L + n * v) / i[2]), R = new Float64Array(16);
            e.ad.multiply(R, A, I);
            const D = e._.fromValues(Math.floor(1e6 * y[0]) / 1e6 * c, Math.floor(1e6 * y[1]) / 1e6 * c, 0), M = .5 * a, z = [
                0,
                0,
                0
            ];
            e._.transformMat4(z, D, R), e._.scale(z, z, M);
            const O = [
                Math.floor(z[0]),
                Math.floor(z[1]),
                Math.floor(z[2])
            ], F = [
                0,
                0,
                0
            ];
            e._.sub(F, z, O), e._.scale(F, F, -1 / M);
            const B = new Float64Array(16);
            return e.ad.identity(B), e.ad.translate(B, B, F), e.ad.multiply(R, B, R), [
                R,
                L
            ];
        }
        function Ei(e, t1) {
            return null != e && null != t1 && !(!e.hasData() || !t1.hasData()) && null != e.demTexture && null != t1.demTexture && e.tileID.key !== t1.tileID.key;
        }
        const Ci = new class {
            constructor(){
                this.operations = {};
            }
            newMorphing(e, t1, i, o, r) {
                if (e in this.operations) {
                    const t1 = this.operations[e];
                    t1.to.tileID.key !== i.tileID.key && (t1.queued = i);
                } else this.operations[e] = {
                    startTime: o,
                    phase: 0,
                    duration: r,
                    from: t1,
                    to: i,
                    queued: null
                };
            }
            getMorphValuesForProxy(e) {
                if (!(e in this.operations)) return null;
                const t1 = this.operations[e];
                return {
                    from: t1.from,
                    to: t1.to,
                    phase: t1.phase
                };
            }
            update(e) {
                for(const t1 in this.operations){
                    const i = this.operations[t1];
                    for(i.phase = (e - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i);)if (!this._nextOp(i, e)) {
                        delete this.operations[t1];
                        break;
                    }
                }
            }
            _nextOp(e, t1) {
                return !!e.queued && (e.from = e.to, e.to = e.queued, e.queued = null, e.phase = 0, e.startTime = t1, !0);
            }
            _validOp(e) {
                return e.from.hasData() && e.to.hasData();
            }
        }, Si = {
            0: null,
            1: "TERRAIN_VERTEX_MORPHING"
        };
        function Ii(e, t1, i) {
            if (0 === t1) return 0;
            const o = t1 < 1 && 514 === i ? .25 / t1 : 1;
            return 6 * Math.pow(1.5, 22 - e) * Math.max(t1, 1) * o;
        }
        function Li(e, t1) {
            const i = 1 << e.z;
            return !t1 && (0 === e.x || e.x === i - 1) || 0 === e.y || e.y === i - 1;
        }
        const Pi = (e)=>({
                u_matrix: e
            });
        function Ai(t1, i, o, r, a) {
            if (a > 0) {
                const n = e.e.now(), s = (n - t1.timeAdded) / a, l = i ? (n - i.timeAdded) / a : -1, c = o.getSource(), h = r.coveringZoomLevel({
                    tileSize: c.tileSize,
                    roundZoom: c.roundZoom
                }), _ = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(t1.tileID.overscaledZ - h), u = _ && t1.refreshedUponExpiration ? 1 : e.at(_ ? s : 1 - l, 0, 1);
                return t1.refreshedUponExpiration && s >= 1 && (t1.refreshedUponExpiration = !1), i ? {
                    opacity: 1,
                    mix: 1 - u
                } : {
                    opacity: u,
                    mix: 0
                };
            }
            return {
                opacity: 1,
                mix: 0
            };
        }
        class Ri extends kt {
            constructor(t1, i, o, r){
                super(t1, i, o, r), this.type = "raster-array", this.maxzoom = 22, this._options = e.W({
                    type: "raster-array"
                }, i);
            }
            triggerRepaint(e) {
                const t1 = this.map.painter._terrain, i = this.map.style.getSourceCache(this.id);
                t1 && t1.enabled && i && t1._clearRenderCacheForTile(i.id, e.tileID), this.map.triggerRepaint();
            }
            loadTile(t1, i) {
                const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize), r = this.map._requestManager.transformRequest(o, e.R.Tile);
                t1.requestParams = r, t1.actor || (t1.actor = this.dispatcher.getActor()), t1.request = t1.fetchHeader(void 0, (e, o, r, a)=>{
                    if (delete t1.request, t1.aborted) return t1.state = "unloaded", i(null);
                    if (e) {
                        if (20 === e.code) return;
                        return t1.state = "errored", i(e);
                    }
                    this.map._refreshExpiredTiles && t1.setExpiryData({
                        cacheControl: r,
                        expires: a
                    }), t1.state = "empty", i(null);
                });
            }
            unloadTile(t1, i) {
                const o = t1.texture;
                o && o instanceof e.T ? (t1.destroy(!0), this.map.painter.saveTileTexture(o)) : (t1.destroy(), t1.flushQueues(), t1._isHeaderLoaded = !1, delete t1._mrt, delete t1.textureDescriptor), t1.fbo && (t1.fbo.destroy(), delete t1.fbo), delete t1.request, delete t1.requestParams, delete t1.neighboringTiles, t1.state = "unloaded";
            }
            prepareTile(t1, i, o) {
                t1._isHeaderLoaded && ("empty" !== t1.state && (t1.state = "reloading"), t1.fetchBand(i, o, (i, o)=>{
                    if (i) return t1.state = "errored", this.fire(new e.d(i)), void this.triggerRepaint(t1);
                    o && (t1.setTexture(o, this.map.painter), t1.state = "loaded", this.triggerRepaint(t1));
                }));
            }
            getInitialBand(e) {
                if (!this.rasterLayers) return 0;
                const t1 = this.rasterLayers.find(({ id: t1 })=>t1 === e), i = t1 && t1.fields, o = i && i.bands && i.bands;
                return o ? o[0] : 0;
            }
            getTextureDescriptor(t1, i, o) {
                if (!t1) return;
                const r = i.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
                if (!r) return;
                let a = null;
                i instanceof e.bk ? a = i.paint.get("raster-array-band") : i instanceof e.bl && (a = i.paint.get("raster-particle-array-band"));
                const n = a || this.getInitialBand(r);
                if (null != n) {
                    if (t1.textureDescriptor) {
                        if (!t1.updateNeeded(r, n) || o) return Object.assign({}, t1.textureDescriptor, {
                            texture: t1.texture
                        });
                    } else this.prepareTile(t1, r, n);
                }
            }
        }
        const Di = {
            vector: Nt,
            raster: kt,
            "raster-dem": class extends kt {
                constructor(t1, i, o, r){
                    super(t1, i, o, r), this.type = "raster-dem", this.maxzoom = 22, this._options = e.W({
                        type: "raster-dem"
                    }, i), this.encoding = i.encoding || "mapbox";
                }
                loadTile(t1, i) {
                    const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
                    function r(e, o) {
                        e && (t1.state = "errored", i(e)), o && (t1.dem = o, t1.dem.onDeserialize(), t1.needsHillshadePrepare = !0, t1.needsDEMTextureUpload = !0, t1.state = "loaded", i(null));
                    }
                    t1.request = e.h(this.map._requestManager.transformRequest(o, e.R.Tile), (function(o, a, n, s) {
                        if (delete t1.request, t1.aborted) t1.state = "unloaded", i(null);
                        else if (o) t1.state = "errored", i(o);
                        else if (a) {
                            this.map._refreshExpiredTiles && t1.setExpiryData({
                                cacheControl: n,
                                expires: s
                            });
                            const i = ImageBitmap && a instanceof ImageBitmap && e.bi(), o = 1 - (a.width - e.bj(a.width)) / 2;
                            o < 1 || t1.neighboringTiles || (t1.neighboringTiles = this._getNeighboringTiles(t1.tileID));
                            const l = i ? a : e.e.getImageData(a, o), c = {
                                uid: t1.uid,
                                coord: t1.tileID,
                                source: this.id,
                                scope: this.scope,
                                rawImageData: l,
                                encoding: this.encoding,
                                padding: o
                            };
                            t1.actor && "expired" !== t1.state || (t1.actor = this.dispatcher.getActor(), t1.actor.send("loadDEMTile", c, r.bind(this), void 0, !0));
                        }
                    }).bind(this));
                }
                _getNeighboringTiles(t1) {
                    const i = t1.canonical, o = Math.pow(2, i.z), r = (i.x - 1 + o) % o, a = 0 === i.x ? t1.wrap - 1 : t1.wrap, n = (i.x + 1 + o) % o, s = i.x + 1 === o ? t1.wrap + 1 : t1.wrap, l = {};
                    return l[new e.aL(t1.overscaledZ, a, i.z, r, i.y).key] = {
                        backfilled: !1
                    }, l[new e.aL(t1.overscaledZ, s, i.z, n, i.y).key] = {
                        backfilled: !1
                    }, i.y > 0 && (l[new e.aL(t1.overscaledZ, a, i.z, r, i.y - 1).key] = {
                        backfilled: !1
                    }, l[new e.aL(t1.overscaledZ, t1.wrap, i.z, i.x, i.y - 1).key] = {
                        backfilled: !1
                    }, l[new e.aL(t1.overscaledZ, s, i.z, n, i.y - 1).key] = {
                        backfilled: !1
                    }), i.y + 1 < o && (l[new e.aL(t1.overscaledZ, a, i.z, r, i.y + 1).key] = {
                        backfilled: !1
                    }, l[new e.aL(t1.overscaledZ, t1.wrap, i.z, i.x, i.y + 1).key] = {
                        backfilled: !1
                    }, l[new e.aL(t1.overscaledZ, s, i.z, n, i.y + 1).key] = {
                        backfilled: !1
                    }), l;
                }
            },
            "raster-array": Ri,
            geojson: class extends e.E {
                constructor(t1, i, o, r){
                    super(), this.id = t1, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o.getActor(), this.setEventedParent(r), this._data = i.data, this._options = e.W({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), void 0 !== i.minzoom && (this.minzoom = i.minzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId;
                    const a = e.a3 / this.tileSize;
                    this.workerOptions = e.W({
                        source: this.id,
                        scope: this.scope,
                        cluster: i.cluster || !1,
                        geojsonVtOptions: {
                            buffer: (void 0 !== i.buffer ? i.buffer : 128) * a,
                            tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * a,
                            extent: e.a3,
                            maxZoom: this.maxzoom,
                            lineMetrics: i.lineMetrics || !1,
                            generateId: i.generateId || !1
                        },
                        superclusterOptions: {
                            maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,
                            minPoints: Math.max(2, i.clusterMinPoints || 2),
                            extent: e.a3,
                            radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * a,
                            log: !1,
                            generateId: i.generateId || !1
                        },
                        clusterProperties: i.clusterProperties,
                        filter: i.filter,
                        dynamic: i.dynamic
                    }, i.workerOptions);
                }
                onAdd(e) {
                    this.map = e, this.setData(this._data);
                }
                setData(e) {
                    return this._data = e, this._updateWorkerData(), this;
                }
                updateData(t1) {
                    return this._options.dynamic ? "string" != typeof t1 && ("Feature" === t1.type && (t1 = {
                        type: "FeatureCollection",
                        features: [
                            t1
                        ]
                    }), "FeatureCollection" !== t1.type) ? this.fire(new e.d(new Error("Data to update should be a feature or a feature collection."))) : (this._coalesce && "string" != typeof t1 && "string" != typeof this._data && "FeatureCollection" === this._data.type ? this._data.features.push(...t1.features) : this._data = t1, this._updateWorkerData(!0), this) : this.fire(new e.d(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
                }
                getClusterExpansionZoom(e, t1) {
                    return this.actor.send("geojson.getClusterExpansionZoom", {
                        clusterId: e,
                        source: this.id,
                        scope: this.scope
                    }, t1), this;
                }
                getClusterChildren(e, t1) {
                    return this.actor.send("geojson.getClusterChildren", {
                        clusterId: e,
                        source: this.id,
                        scope: this.scope
                    }, t1), this;
                }
                getClusterLeaves(e, t1, i, o) {
                    return this.actor.send("geojson.getClusterLeaves", {
                        source: this.id,
                        scope: this.scope,
                        clusterId: e,
                        limit: t1,
                        offset: i
                    }, o), this;
                }
                _updateWorkerData(t1 = !1) {
                    if (this._pendingLoad) return void (this._coalesce = !0);
                    this.fire(new e.f("dataloading", {
                        dataType: "source"
                    })), this._loaded = !1;
                    const i = e.W({
                        append: t1
                    }, this.workerOptions);
                    i.scope = this.scope;
                    const o = this._data;
                    "string" == typeof o ? (i.request = this.map._requestManager.transformRequest(e.e.resolveURL(o), e.R.Source), i.request.collectResourceTiming = this._collectResourceTiming) : i.data = JSON.stringify(o), this._pendingLoad = this.actor.send(`${this.type}.loadData`, i, (i, o)=>{
                        if (this._loaded = !0, this._pendingLoad = null, i) this.fire(new e.d(i));
                        else {
                            const i = {
                                dataType: "source",
                                sourceDataType: this._metadataFired ? "content" : "metadata"
                            };
                            this._collectResourceTiming && o && o.resourceTiming && o.resourceTiming[this.id] && (i.resourceTiming = o.resourceTiming[this.id]), t1 && (this._partialReload = !0), this.fire(new e.f("data", i)), this._partialReload = !1, this._metadataFired = !0;
                        }
                        this._coalesce && (this._updateWorkerData(t1), this._coalesce = !1);
                    });
                }
                loaded() {
                    return this._loaded;
                }
                loadTile(t1, i) {
                    const o = t1.actor ? "reloadTile" : "loadTile";
                    t1.actor = this.actor;
                    const r = this.map.style ? this.map.style.getLut(this.scope) : null, a = this._partialReload, n = {
                        type: this.type,
                        uid: t1.uid,
                        tileID: t1.tileID,
                        tileZoom: t1.tileZoom,
                        zoom: t1.tileID.overscaledZ,
                        maxZoom: this.maxzoom,
                        tileSize: this.tileSize,
                        source: this.id,
                        lut: r ? {
                            image: r.image.clone()
                        } : null,
                        scope: this.scope,
                        pixelRatio: e.e.devicePixelRatio,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        promoteId: this.promoteId,
                        brightness: this.map.style && this.map.style.getBrightness() || 0,
                        partial: a
                    };
                    t1.request = this.actor.send(o, n, (e, r)=>a && !r ? (t1.state = "loaded", i(null)) : (delete t1.request, t1.destroy(), t1.aborted ? i(null) : e ? i(e) : (t1.loadVectorData(r, this.map.painter, "reloadTile" === o), i(null))), void 0, "loadTile" === o);
                }
                abortTile(e) {
                    e.request && (e.request.cancel(), delete e.request), e.aborted = !0;
                }
                unloadTile(e, t1) {
                    this.actor.send("removeTile", {
                        uid: e.uid,
                        type: this.type,
                        source: this.id,
                        scope: this.scope
                    }), e.destroy();
                }
                onRemove(e) {
                    this._pendingLoad && this._pendingLoad.cancel();
                }
                serialize() {
                    return e.W({}, this._options, {
                        type: this.type,
                        data: this._data
                    });
                }
                hasTransition() {
                    return !1;
                }
            },
            video: class extends e.bm {
                constructor(e, t1, i, o){
                    super(e, t1, i, o), this.roundZoom = !0, this.type = "video", this.options = t1;
                }
                load() {
                    this._loaded = !1;
                    const t1 = this.options;
                    this.urls = [];
                    for (const i of t1.urls)this.urls.push(this.map._requestManager.transformRequest(i, e.R.Source).url);
                    e.bn(this.urls, (t1, i)=>{
                        this._loaded = !0, t1 ? this.fire(new e.d(t1)) : i && (this.video = i, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", ()=>{
                            this.map.triggerRepaint();
                        }), this.map && this.video.play(), this._finishLoading());
                    });
                }
                pause() {
                    this.video && this.video.pause();
                }
                play() {
                    this.video && this.video.play();
                }
                seek(t1) {
                    if (this.video) {
                        const i = this.video.seekable;
                        t1 < i.start(0) || t1 > i.end(0) ? this.fire(new e.d(new e.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = t1;
                    }
                }
                getVideo() {
                    return this.video;
                }
                onAdd(e) {
                    this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
                }
                prepare() {
                    if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
                    const t1 = this.map.painter.context, i = t1.gl;
                    this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new e.T(t1, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t1);
                }
                serialize() {
                    return {
                        type: "video",
                        urls: this.urls,
                        coordinates: this.coordinates
                    };
                }
                hasTransition() {
                    return this.video && !this.video.paused;
                }
            },
            image: e.bm,
            model: class extends e.E {
                constructor(e, t1, i, o){
                    super(), this.id = e, this.type = "model", this.models = [], this._loaded = !1, this._options = t1;
                }
                load() {
                    const t1 = [];
                    for(const i in this._options.models){
                        const o = this._options.models[i], r = e.l(this.map._requestManager.transformRequest(o.uri, e.R.Model).url).then((t1)=>{
                            if (!t1) return;
                            const r = e.c(t1), a = new e.M(i, o.position, o.orientation, r);
                            a.computeBoundsAndApplyParent(), this.models.push(a);
                        }).catch((t1)=>{
                            this.fire(new e.d(new Error(`Could not load model ${i} from ${o.uri}: ${t1.message}`)));
                        });
                        t1.push(r);
                    }
                    return Promise.allSettled(t1).then(()=>{
                        this._loaded = !0, this.fire(new e.f("data", {
                            dataType: "source",
                            sourceDataType: "metadata"
                        }));
                    }).catch((t1)=>{
                        this.fire(new e.d(new Error(`Could not load models: ${t1.message}`)));
                    });
                }
                onAdd(e) {
                    this.map = e, this.load();
                }
                hasTransition() {
                    return !1;
                }
                loaded() {
                    return this._loaded;
                }
                getModels() {
                    return this.models;
                }
                loadTile(e, t1) {}
                serialize() {
                    return {
                        type: "model"
                    };
                }
            },
            "batched-model": class extends e.E {
                constructor(e, t1, i, o){
                    super(), this.type = "batched-model", this.id = e, this.tileSize = 512, this._options = t1, this.tiles = this._options.tiles, this.maxzoom = t1.maxzoom || 19, this.minzoom = t1.minzoom || 0, this.roundZoom = !0, this.usedInConflation = !0, this.dispatcher = i, this.reparseOverscaled = !1, this.scheme = "xyz", this._loaded = !1, this.setEventedParent(o);
                }
                onAdd(e) {
                    this.map = e, this.load();
                }
                load(t1) {
                    this._loaded = !1, this.fire(new e.f("dataloading", {
                        dataType: "source"
                    }));
                    const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o = this.map._worldview;
                    this._tileJSONRequest = Ft(this._options, this.map._requestManager, i, o, (r, a)=>{
                        this._tileJSONRequest = null, this._loaded = !0, r ? (i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && 2 !== o.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e.d(r))) : a && (e.W(this, a), a.bounds && (this.tileBounds = new Bt(a.bounds, this.minzoom, this.maxzoom)), e.an(a.tiles, this.map._requestManager._customAccessToken), this.fire(new e.f("data", {
                            dataType: "source",
                            sourceDataType: "metadata"
                        })), this.fire(new e.f("data", {
                            dataType: "source",
                            sourceDataType: "content"
                        }))), t1 && t1(r);
                    });
                }
                hasTransition() {
                    return !1;
                }
                hasTile(e) {
                    return !this.tileBounds || this.tileBounds.contains(e.canonical);
                }
                loaded() {
                    return this._loaded;
                }
                loadTile(t1, i) {
                    const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme)), r = {
                        request: this.map._requestManager.transformRequest(o, e.R.Tile),
                        data: void 0,
                        uid: t1.uid,
                        tileID: t1.tileID,
                        tileZoom: t1.tileZoom,
                        zoom: t1.tileID.overscaledZ,
                        tileSize: this.tileSize * t1.tileID.overscaleFactor(),
                        type: this.type,
                        source: this.id,
                        scope: this.scope,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        isSymbolTile: t1.isSymbolTile,
                        brightness: this.map.style && this.map.style.getBrightness() || 0
                    };
                    if (t1.actor && "expired" !== t1.state) {
                        if ("loading" === t1.state) t1.reloadCallback = i;
                        else {
                            if (t1.buckets) {
                                const e = Object.values(t1.buckets);
                                for (const t1 of e)t1.dirty = !0;
                                return void (t1.state = "loaded");
                            }
                            t1.request = t1.actor.send("reloadTile", r, a.bind(this));
                        }
                    } else t1.actor = this.dispatcher.getActor(), t1.request = t1.actor.send("loadTile", r, a.bind(this), void 0, !0);
                    function a(e, o) {
                        return t1.aborted ? i(null) : e && 404 !== e.status ? i(e) : (o && (o.resourceTiming && (t1.resourceTiming = o.resourceTiming), this.map._refreshExpiredTiles && t1.setExpiryData(o), t1.buckets = {
                            ...t1.buckets,
                            ...o.buckets
                        }, o.featureIndex && (t1.latestFeatureIndex = o.featureIndex)), t1.state = "loaded", void i(null));
                    }
                }
                serialize() {
                    return e.W({}, this._options);
                }
            },
            canvas: class extends e.bm {
                constructor(t1, i, o, r){
                    super(t1, i, o, r), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some((e)=>!Array.isArray(e) || 2 !== e.length || e.some((e)=>"number" != typeof e)) || this.fire(new e.d(new e.V(`sources.${t1}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.d(new e.V(`sources.${t1}`, null, 'missing required property "coordinates"'))), i.animate && "boolean" != typeof i.animate && this.fire(new e.d(new e.V(`sources.${t1}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? "string" == typeof i.canvas || i.canvas instanceof HTMLCanvasElement || this.fire(new e.d(new e.V(`sources.${t1}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.d(new e.V(`sources.${t1}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = void 0 === i.animate || i.animate;
                }
                load() {
                    this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.d(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                        this._playing = !0, this.map.triggerRepaint();
                    }, this.pause = function() {
                        this._playing && (this.prepare(), this._playing = !1);
                    }, this._finishLoading());
                }
                getCanvas() {
                    return this.canvas;
                }
                onAdd(e) {
                    this.map = e, this.load(), this.canvas && this.animate && this.play();
                }
                onRemove(e) {
                    this.pause();
                }
                prepare() {
                    let t1 = !1;
                    if (this.canvas.width !== this.width && (this.width = this.canvas.width, t1 = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t1 = !0), this._hasInvalidDimensions()) return;
                    if (0 === Object.keys(this.tiles).length) return;
                    const i = this.map.painter.context;
                    this.texture ? !t1 && !this._playing || this.texture instanceof e.bo || this.texture.update(this.canvas, {
                        premultiply: !0
                    }) : this.texture = new e.T(i, this.canvas, i.gl.RGBA, {
                        premultiply: !0
                    }), this._prepareData(i);
                }
                serialize() {
                    return {
                        type: "canvas",
                        coordinates: this.coordinates
                    };
                }
                hasTransition() {
                    return this._playing;
                }
                _hasInvalidDimensions() {
                    for (const e of [
                        this.canvas.width,
                        this.canvas.height
                    ])if (isNaN(e) || e <= 0) return !0;
                    return !1;
                }
            },
            custom: class extends e.E {
                constructor(t1, i, o, r){
                    super(), this.id = t1, this.type = "custom", this._dataType = "raster", this._dispatcher = o, this._implementation = i, this.setEventedParent(r), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e.d(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.d(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new Bt(this._implementation.bounds, this.minzoom, this.maxzoom)), i.update = this._update.bind(this), i.clearTiles = this._clearTiles.bind(this), i.coveringTiles = this._coveringTiles.bind(this), e.W(this, e.ah(i, [
                        "dataType",
                        "scheme",
                        "minzoom",
                        "maxzoom",
                        "tileSize",
                        "attribution",
                        "minTileCacheSize",
                        "maxTileCacheSize"
                    ]));
                }
                serialize() {
                    return e.ah(this, [
                        "type",
                        "scheme",
                        "minzoom",
                        "maxzoom",
                        "tileSize",
                        "attribution"
                    ]);
                }
                load() {
                    this._loaded = !0, this.fire(new e.f("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e.f("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }));
                }
                loaded() {
                    return this._loaded;
                }
                onAdd(t1) {
                    this.map = t1, this._loaded = !1, this.fire(new e.f("dataloading", {
                        dataType: "source"
                    })), this._implementation.onAdd && this._implementation.onAdd(t1), this.load();
                }
                onRemove(e) {
                    this._implementation.onRemove && this._implementation.onRemove(e);
                }
                hasTile(e) {
                    if (this._implementation.hasTile) {
                        const { x: t1, y: i, z: o } = e.canonical;
                        return this._implementation.hasTile({
                            x: t1,
                            y: i,
                            z: o
                        });
                    }
                    return !this.tileBounds || this.tileBounds.contains(e.canonical);
                }
                loadTile(e, t1) {
                    const { x: i, y: o, z: r } = e.tileID.canonical, a = new AbortController;
                    e.request = Promise.resolve(this._implementation.loadTile({
                        x: i,
                        y: o,
                        z: r
                    }, {
                        signal: a.signal
                    })).then((function(i) {
                        return delete e.request, e.aborted ? (e.state = "unloaded", t1(null)) : void 0 === i ? (e.state = "errored", t1(null)) : null === i ? (this.loadTileData(e, {
                            width: this.tileSize,
                            height: this.tileSize,
                            data: null
                        }), e.state = "loaded", t1(null)) : function(e) {
                            return e instanceof ImageData || e instanceof HTMLCanvasElement || e instanceof ImageBitmap || e instanceof HTMLImageElement;
                        }(i) ? (this.loadTileData(e, i), e.state = "loaded", void t1(null)) : (e.state = "errored", t1(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
                    }).bind(this)).catch((i)=>{
                        20 !== i.code && (e.state = "errored", t1(i));
                    }), e.request.cancel = ()=>a.abort();
                }
                loadTileData(e, t1) {
                    e.setTexture(t1, this.map.painter);
                }
                unloadTile(t1, i) {
                    if (t1.texture && t1.texture instanceof e.T ? (t1.destroy(!0), t1.texture && t1.texture instanceof e.T && this.map.painter.saveTileTexture(t1.texture)) : t1.destroy(), this._implementation.unloadTile) {
                        const { x: e, y: i, z: o } = t1.tileID.canonical;
                        this._implementation.unloadTile({
                            x: e,
                            y: i,
                            z: o
                        });
                    }
                    i && i();
                }
                abortTile(e, t1) {
                    e.request && e.request.cancel && (e.request.cancel(), delete e.request), t1 && t1();
                }
                hasTransition() {
                    return !1;
                }
                _coveringTiles() {
                    return this.map.transform.coveringTiles({
                        tileSize: this.tileSize,
                        minzoom: this.minzoom,
                        maxzoom: this.maxzoom,
                        roundZoom: this.roundZoom
                    }).map((e)=>({
                            x: e.canonical.x,
                            y: e.canonical.y,
                            z: e.canonical.z
                        }));
                }
                _clearTiles() {
                    const t1 = e.al(this.id, this.scope);
                    this.map.style.clearSource(t1);
                }
                _update() {
                    this.fire(new e.f("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }));
                }
            }
        }, Mi = function(t1, i, o, r) {
            const a = new Di[i.type](t1, i, o, r);
            if (a.id !== t1) throw new Error(`Expected Source id to be ${t1} instead of ${a.id}`);
            return e.bp([
                "load",
                "abort",
                "unload",
                "serialize",
                "prepare"
            ], a), a;
        };
        class zi extends e.bv {
            constructor(t1){
                const i = {
                    type: "raster-dem",
                    maxzoom: t1.transform.maxZoom
                }, o = new e.bw(e.bx(), null), r = Mi("mock-dem", i, o, t1.style);
                super("mock-dem", r, !1), r.setEventedParent(this), this._sourceLoaded = !0;
            }
            _loadTile(e, t1) {
                e.state = "loaded", t1(null);
            }
        }
        class Oi extends e.bv {
            constructor(t1){
                const i = Mi("proxy", {
                    type: "geojson",
                    maxzoom: t1.transform.maxZoom
                }, new e.bw(e.bx(), null), t1.style);
                super("proxy", i, !1), i.setEventedParent(this), this.map = this.getSource().map = t1, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
            update(t1, i, o) {
                if (t1.freezeTileCoverage) return;
                this.transform = t1;
                const r = t1.coveringTiles({
                    tileSize: this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom,
                    reparseOverscaled: this._source.reparseOverscaled
                }).reduce((i, o)=>{
                    if (i[o.key] = "", !this._tiles[o.key]) {
                        const i = new e.by(o, this._source.tileSize * o.overscaleFactor(), t1.tileZoom);
                        i.state = "loaded", this._tiles[o.key] = i;
                    }
                    return i;
                }, {});
                for(const e in this._tiles)e in r || (this.freeFBO(e), this._tiles[e].unloadVectorData(), delete this._tiles[e]);
            }
            freeFBO(e) {
                const t1 = this.proxyCachedFBO[e];
                if (void 0 !== t1) {
                    const i = Object.values(t1);
                    this.renderCachePool.push(...i), delete this.proxyCachedFBO[e];
                }
            }
            deallocRenderCache() {
                this.renderCache.forEach((e)=>e.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
        }
        class Fi extends e.aL {
            constructor(e, t1, i){
                super(e.overscaledZ, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y), this.proxyTileKey = t1, this.projMatrix = i;
            }
        }
        class Bi extends e.bq {
            constructor(t1, i){
                super(), this._debugParams = {
                    sortTilesHiZFirst: !0,
                    disableRenderCache: !1
                }, t1.tp.registerParameter(this._debugParams, [
                    "Terrain"
                ], "sortTilesHiZFirst", {}, ()=>{
                    this._style.map.triggerRepaint();
                }), t1.tp.registerParameter(this._debugParams, [
                    "Terrain"
                ], "disableRenderCache", {}, ()=>{
                    this._style.map.triggerRepaint();
                }), t1.tp.registerButton([
                    "Terrain"
                ], "Invalidate Render Cache", ()=>{
                    this.invalidateRenderCache = !0, this._style.map.triggerRepaint();
                }), this.painter = t1, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
                const [o, r, a] = function(t1) {
                    const i = new e.bt, o = new e.bu, r = 131;
                    i.reserve(17161), o.reserve(33800);
                    const a = e.a3 / 128, n = e.a3 + a / 2, s = n + a;
                    for(let t1 = -a; t1 < s; t1 += a)for(let o = -a; o < s; o += a){
                        const r = o < 0 || o > n || t1 < 0 || t1 > n ? 24575 : 0, a = e.at(Math.round(o), 0, e.a3), s = e.at(Math.round(t1), 0, e.a3);
                        i.emplaceBack(a + r, s);
                    }
                    const l = (e, t1)=>{
                        const i = t1 * r + e;
                        o.emplaceBack(i + 1, i, i + r), o.emplaceBack(i + r, i + r + 1, i + 1);
                    };
                    for(let e = 1; e < 129; e++)for(let t1 = 1; t1 < 129; t1++)l(t1, e);
                    return [
                        0,
                        129
                    ].forEach((e)=>{
                        for(let t1 = 0; t1 < 130; t1++)l(t1, e), l(e, t1);
                    }), [
                        i,
                        o,
                        32768
                    ];
                }(), n = t1.context;
                this.gridBuffer = n.createVertexBuffer(o, e.br.members), this.gridIndexBuffer = n.createIndexBuffer(r), this.gridSegments = e.b.simpleSegment(0, 0, o.length, r.length), this.gridNoSkirtSegments = e.b.simpleSegment(0, 0, o.length, a), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Oi(i.map), this.orthoMatrix = e.ad.create(), e.ad.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? .015 : 0, e.a3, 0, e.a3, 0, 1);
                const s = n.gl;
                this._overlapStencilMode = new e.ag({
                    func: s.GEQUAL,
                    mask: 255
                }, 0, 255, s.KEEP, s.KEEP, s.REPLACE), this._previousZoom = t1.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new zi(i.map), this._pendingGroundEffectLayers = [];
            }
            set style(e) {
                e.on("data", this._onStyleDataEvent.bind(this)), this._style = e, this._style.map.on("moveend", ()=>{
                    this._clearLineLayersFromRenderCache();
                });
            }
            update(t1, i, o) {
                if (t1 && t1.terrain) {
                    this._style !== t1 && (this.style = t1, this._evaluationZoom = void 0);
                    const r = t1.terrain.properties, a = 0 === t1.terrain.drapeRenderMode, n = t1.terrain.isZoomDependent();
                    this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = e.e.now();
                    const s = t1.terrain && t1.terrain.scope, l = r.get("source"), c = a ? this._mockSourceCache : t1.getSourceCache(l, s);
                    if (!c) return void e.w(`Couldn't find terrain source "${l}".`);
                    if (this.sourceCache = c, this._exaggeration = n ? this.calculateExaggeration(i) : r.get("exaggeration"), !i.projection.requiresDraping && n && 0 === this._exaggeration) return void this._disable();
                    this.enabled = !0;
                    const h = ()=>{
                        this.sourceCache.used && e.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                        const t1 = this.getScaledDemTileSize();
                        this.sourceCache.update(i, t1, !0), this.resetTileLookupCache(this.sourceCache.id);
                    };
                    this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, h(), this._initializing = !0), h(), i.updateElevation(!0, o), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i), this._emptyDEMTextureDirty = !0, this._previousZoom = i.zoom;
                } else this._disable();
            }
            calculateExaggeration(t1) {
                const i = this._previousCameraAltitude, o = t1.getFreeCameraOptions().position.z / t1.pixelsPerMeter * t1.worldSize;
                this._previousCameraAltitude = o;
                const r = null != i ? o - i : Number.MAX_VALUE;
                if (Math.abs(r) < 2) return this._exaggeration;
                const a = t1.zoom, n = this._style.terrain;
                if (!this._previousUpdateTimestamp) return n.getExaggeration(a);
                let s = a - this._previousZoom;
                const l = this._previousUpdateTimestamp;
                let c = a;
                null != this._evaluationZoom && (c = this._evaluationZoom, Math.abs(a - c) > .5 && (s = .5 * (a - c + s)), s * r < 0 && (c += s)), this._evaluationZoom = c;
                const h = n.getExaggeration(c), _ = h === n.getExaggeration(Math.max(0, c - .1));
                if (_ && Math.abs(h - this._exaggeration) < .01) return h;
                let u = Math.min(.1, .00375 * (this._updateTimestamp - l));
                return (_ || h < .1 || Math.abs(s) < 1e-4) && (u = Math.min(.2, 4 * u)), e.a2(this._exaggeration, h, u);
            }
            resetTileLookupCache(e) {
                this._findCoveringTileCache[e] = {};
            }
            getScaledDemTileSize() {
                return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
            }
            _onStyleDataEvent(e) {
                e.coord && "source" === e.dataType ? this._clearRenderCacheForTile(e.sourceCacheId, e.coord) : "style" === e.dataType && (this.invalidateRenderCache = !0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
            }
            _disable() {
                if (this.enabled && (this.enabled = !1, this._emptyDEMTextureDirty = !0, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for(const e in this._style._mergedSourceCaches)this._style._mergedSourceCaches[e].usedForTerrain = !1;
            }
            destroy() {
                this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e)=>e.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
            }
            _source() {
                return this.enabled ? this.sourceCache : null;
            }
            isUsingMockSource() {
                return this.sourceCache === this._mockSourceCache;
            }
            exaggeration() {
                return this.enabled ? this._exaggeration : 0;
            }
            get visibleDemTiles() {
                return this._visibleDemTiles;
            }
            get drapeBufferSize() {
                const e = 2 * this.proxySourceCache.getSource().tileSize;
                return [
                    e,
                    e
                ];
            }
            set useVertexMorphing(e) {
                this._useVertexMorphing = e;
            }
            updateTileBinding(t1) {
                if (!this.enabled) return;
                this.prevTerrainTileForTile = this.terrainTileForTile;
                const i = this.proxySourceCache, o = this.painter.transform;
                this._initializing && (this._initializing = 0 === o._centerAltitude && -1 === this.getAtPointOrZero(e.Y.fromLngLat(o.center), -1), this._emptyDEMTextureDirty = !this._initializing);
                const r = this.proxyCoords = i.getIds().map((e)=>{
                    const t1 = i.getTileByID(e).tileID;
                    return t1.projMatrix = o.calculateProjMatrix(t1.toUnwrapped()), t1;
                });
                !function(t1, i) {
                    const o = i.transform.pointCoordinate(i.transform.getCameraPoint()), r = new e.P(o.x, o.y);
                    t1.sort((t1, i)=>{
                        if (i.overscaledZ - t1.overscaledZ) return i.overscaledZ - t1.overscaledZ;
                        const o = new e.P(t1.canonical.x + (1 << t1.canonical.z) * t1.wrap, t1.canonical.y), a = new e.P(i.canonical.x + (1 << i.canonical.z) * i.wrap, i.canonical.y), n = r.mult(1 << t1.canonical.z);
                        return n.x -= .5, n.y -= .5, n.distSqr(o) - n.distSqr(a);
                    });
                }(r, this.painter);
                const a = this.proxyToSource || {};
                this.proxyToSource = {}, r.forEach((e)=>{
                    this.proxyToSource[e.key] = {};
                }), this.terrainTileForTile = {};
                const n = this._style._mergedSourceCaches;
                for(const e in n){
                    const i = n[e];
                    if (!i.used) continue;
                    if (i !== this.sourceCache && this.resetTileLookupCache(i.id), this._setupProxiedCoordsForOrtho(i, t1[e], a), i.usedForTerrain) continue;
                    const o = t1[e];
                    i.getSource().reparseOverscaled && this._assignTerrainTiles(o);
                }
                this.proxiedCoords[i.id] = r.map((e)=>new Fi(e, e.key, this.orthoMatrix)), this._assignTerrainTiles(r), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(a), this.renderingToTexture = !1;
                const s = {};
                this._visibleDemTiles = [];
                for (const e of this.proxyCoords){
                    const t1 = this.terrainTileForTile[e.key];
                    if (!t1) continue;
                    const i = t1.tileID.key;
                    i in s || (this._visibleDemTiles.push(t1), s[i] = i);
                }
            }
            _assignTerrainTiles(e) {
                this._initializing || e.forEach((e)=>{
                    if (this.terrainTileForTile[e.key]) return;
                    const t1 = this._findTileCoveringTileID(e, this.sourceCache);
                    t1 && (this.terrainTileForTile[e.key] = t1);
                });
            }
            _prepareDEMTextures() {
                const e = this.painter.context, t1 = e.gl;
                for(const i in this.terrainTileForTile){
                    const o = this.terrainTileForTile[i], r = o.dem;
                    !r || o.demTexture && !o.needsDEMTextureUpload || (e.activeTexture.set(t1.TEXTURE1), zt(this.painter, o, r));
                }
            }
            _prepareDemTileUniforms(e, t1, i, o) {
                if (!t1 || null == t1.demTexture) return !1;
                const r = e.tileID.canonical, a = Math.pow(2, t1.tileID.canonical.z - r.z), n = o || "";
                return i[`u_dem_tl${n}`] = [
                    r.x * a % 1,
                    r.y * a % 1
                ], i[`u_dem_scale${n}`] = a, !0;
            }
            get emptyDEMTexture() {
                return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
            }
            get emptyDepthBufferTexture() {
                const t1 = this.painter.context, i = t1.gl;
                if (!this._emptyDepthBufferTexture) {
                    const o = new e.i({
                        width: 1,
                        height: 1
                    }, Uint8Array.of(255, 255, 255, 255));
                    this._emptyDepthBufferTexture = new e.T(t1, o, i.RGBA, {
                        premultiply: !1
                    });
                }
                return this._emptyDepthBufferTexture;
            }
            _getLoadedAreaMinimum() {
                if (!this.enabled) return 0;
                let e = 0;
                const t1 = this._visibleDemTiles.reduce((t1, i)=>{
                    if (!i.dem) return t1;
                    const o = i.dem.tree.minimums[0];
                    return o > 0 && e++, t1 + o;
                }, 0);
                return e ? t1 / e : 0;
            }
            _updateEmptyDEMTexture() {
                const t1 = this.painter.context, i = t1.gl;
                t1.activeTexture.set(i.TEXTURE2);
                const o = this._getLoadedAreaMinimum(), [r, a] = (()=>{
                    const t1 = new e.bz({
                        width: 1,
                        height: 1
                    }, new Float32Array([
                        o
                    ]));
                    return [
                        i.R32F,
                        t1
                    ];
                })();
                this._emptyDEMTextureDirty = !1;
                let n = this._emptyDEMTexture;
                return n ? n.update(a, {
                    premultiply: !1
                }) : n = this._emptyDEMTexture = new e.T(t1, a, r, {
                    premultiply: !1
                }), n;
            }
            setupElevationDraw(t1, i, o) {
                const r = this.painter.context, a = r.gl, n = {
                    u_dem: 2,
                    u_dem_prev: 4,
                    u_dem_tl: [
                        0,
                        0
                    ],
                    u_dem_tl_prev: [
                        0,
                        0
                    ],
                    u_dem_scale: 0,
                    u_dem_scale_prev: 0,
                    u_dem_size: 0,
                    u_dem_lerp: 1,
                    u_depth: 3,
                    u_depth_size_inv: [
                        0,
                        0
                    ],
                    u_depth_range_unpack: [
                        2,
                        0
                    ],
                    u_exaggeration: 0
                };
                n.u_exaggeration = this.exaggeration();
                let s = null, l = null, c = 1;
                if (o && o.morphing && this._useVertexMorphing) {
                    const e = o.morphing.srcDemTile, i = o.morphing.dstDemTile;
                    c = o.morphing.phase, e && i && (this._prepareDemTileUniforms(t1, e, n, "_prev") && (l = e), this._prepareDemTileUniforms(t1, i, n) && (s = i));
                }
                const h = (e)=>e && e.demTexture && this.painter.linearFloatFilteringSupported() ? a.LINEAR : a.NEAREST;
                let _ = null;
                var u, d;
                if (this.enabled ? l && s ? (_ = s.demTexture, r.activeTexture.set(a.TEXTURE4), l.demTexture.bind(h(l), a.CLAMP_TO_EDGE), n.u_dem_lerp = c) : (s = this.terrainTileForTile[t1.tileID.key], _ = this._prepareDemTileUniforms(t1, s, n) ? s.demTexture : this.emptyDEMTexture) : _ = this.emptyDEMTexture, r.activeTexture.set(a.TEXTURE2), _ && (n.u_dem_size = 1 === (u = _).size[0] ? 1 : u.size[0] - 2, _.bind(h(s), a.CLAMP_TO_EDGE)), r.activeTexture.set(a.TEXTURE3), o && o.useDepthForOcclusion && this.painter.terrainDepthTexture && this.painter.terrainDepthFBO ? (this.painter.terrainDepthTexture.bind(a.NEAREST, a.CLAMP_TO_EDGE), n.u_depth_size_inv = [
                    1 / this.painter.terrainDepthFBO.width,
                    1 / this.painter.terrainDepthFBO.height
                ], n.u_depth_range_unpack = [
                    2 / ((d = this.painter.depthRangeFor3D)[1] - d[0]),
                    -1 - 2 * d[0] / (d[1] - d[0])
                ]) : (this.emptyDepthBufferTexture.bind(a.NEAREST, a.CLAMP_TO_EDGE), n.u_depth_range_unpack = [
                    2,
                    0
                ]), r.activeTexture.set(a.TEXTURE0), o && o.useMeterToDem && s) {
                    const t1 = (1 << s.tileID.canonical.z) * e.ax(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                    n.u_meter_to_dem = t1;
                }
                if (o && o.labelPlaneMatrixInv && (n.u_label_plane_matrix_inv = o.labelPlaneMatrixInv), i.setTerrainUniformValues(r, n), "globe" === this.painter.transform.projection.name) {
                    const e = this.globeUniformValues(this.painter.transform, t1.tileID.canonical, o && o.useDenormalizedUpVectorScale);
                    i.setGlobeUniformValues(r, e);
                }
            }
            globeUniformValues(t1, i, o) {
                const r = t1.projection;
                return {
                    u_tile_tl_up: r.upVector(i, 0, 0),
                    u_tile_tr_up: r.upVector(i, e.a3, 0),
                    u_tile_br_up: r.upVector(i, e.a3, e.a3),
                    u_tile_bl_up: r.upVector(i, 0, e.a3),
                    u_tile_up_scale: o ? e.bs(1) : r.upVectorScale(i, t1.center.lat, t1.worldSize).metersToTile
                };
            }
            renderToBackBuffer(t1) {
                const i = this.painter, o = this.painter.context;
                0 !== t1.length && (o.bindFramebuffer.set(null), o.viewport.set([
                    0,
                    0,
                    i.width,
                    i.height
                ]), i.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function(t1, i, o, r, a) {
                    if ("globe" === t1.transform.projection.name) !function(t1, i, o, r, a) {
                        const n = t1.context, s = n.gl;
                        let l, c;
                        const h = t1.transform, _ = e.ba(t1, n, h), u = (e, i)=>{
                            if (c === i) return;
                            const o = [
                                Si[i],
                                "PROJECTION_GLOBE_VIEW"
                            ];
                            _ && o.push("CUSTOM_ANTIALIASING");
                            const r = t1.isTileAffectedByFog(e);
                            l = t1.getOrCreateProgram("globeRaster", {
                                defines: o,
                                overrideFog: r
                            }), c = i;
                        }, d = t1.colorModeForRenderPass(), p = new e.ae(s.LEQUAL, e.ae.ReadWrite, t1.depthRangeFor3D);
                        Ci.update(a);
                        const f = e.bb(h), m = [
                            e.aj(h.center.lng),
                            e.ak(h.center.lat)
                        ], g = t1.globeSharedBuffers, v = [
                            h.width * e.e.devicePixelRatio,
                            h.height * e.e.devicePixelRatio
                        ], x = Float32Array.from(h.globeMatrix), y = {
                            useDenormalizedUpVectorScale: !0
                        };
                        {
                            const h = t1.transform, _ = Ii(h.zoom, i.exaggeration(), i.sourceCache._source.tileSize);
                            c = -1;
                            const b = s.TRIANGLES;
                            for (const c of r){
                                const r = o.getTile(c), w = e.ag.disabled, T = i.prevTerrainTileForTile[c.key], E = i.terrainTileForTile[c.key];
                                Ei(T, E) && Ci.newMorphing(c.key, T, E, a, 250), n.activeTexture.set(s.TEXTURE0), r.texture && r.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE);
                                const C = Ci.getMorphValuesForProxy(c.key), S = C ? 1 : 0;
                                C && e.o(y, {
                                    morphing: {
                                        srcDemTile: C.from,
                                        dstDemTile: C.to,
                                        phase: e.b9(C.phase)
                                    }
                                });
                                const I = e.bc(c.canonical), L = e.bd(I.getCenter().lat), P = e.be(c.canonical, I, L, h.worldSize / h._pixelsPerMercatorPixel), A = e.bf(e.bg(c.canonical)), R = Gt(h.expandedFarZProjMatrix, x, f, A, e.a1(h.zoom), m, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, v, _, h._farZ, P);
                                if (u(c, S), l && (i.setupElevationDraw(r, l, y), t1.uploadCommonUniforms(n, l, c.toUnwrapped()), g)) {
                                    const [i, o, r] = g.getGridBuffers(L, 0 !== _);
                                    l.draw(t1, b, p, w, d, e.af.backCCW, R, "globe_raster", i, o, r);
                                }
                            }
                        }
                        if (g && (t1.renderDefaultNorthPole || t1.renderDefaultSouthPole)) {
                            const a = [
                                "GLOBE_POLES",
                                "PROJECTION_GLOBE_VIEW"
                            ];
                            _ && a.push("CUSTOM_ANTIALIASING"), l = t1.getOrCreateProgram("globeRaster", {
                                defines: a
                            });
                            for (const a of r){
                                const { x: r, y: c, z: _ } = a.canonical, u = 0 === c, f = c === (1 << _) - 1, [x, b, w, T] = g.getPoleBuffers(_, !1);
                                if (T && (u || f)) {
                                    const c = o.getTile(a);
                                    n.activeTexture.set(s.TEXTURE0), c.texture && c.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE);
                                    let g = e.bh(_, r, h);
                                    const E = e.bf(e.bg(a.canonical)), C = (i, o)=>i.draw(t1, s.TRIANGLES, p, e.ag.disabled, d, e.af.disabled, Gt(h.expandedFarZProjMatrix, g, g, E, 0, m, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, v, 0, h._farZ), "globe_pole_raster", o, w, T);
                                    i.setupElevationDraw(c, l, y), t1.uploadCommonUniforms(n, l, a.toUnwrapped()), u && t1.renderDefaultNorthPole && C(l, x), f && t1.renderDefaultSouthPole && (g = e.ad.scale(e.ad.create(), g, [
                                        1,
                                        -1,
                                        1
                                    ]), C(l, b));
                                }
                            }
                        }
                    }(t1, i, o, r, a);
                    else {
                        const n = t1.context, s = n.gl;
                        let l, c;
                        const h = t1.shadowRenderer, _ = fi(t1, t1.longestCutoffRange), u = (e)=>{
                            if (c === e) return;
                            const i = [];
                            i.push(Si[e]), _.shouldRenderCutoff && i.push("RENDER_CUTOFF"), l = t1.getOrCreateProgram("terrainRaster", {
                                defines: i
                            }), c = e;
                        }, d = t1.colorModeForRenderPass(), p = new e.ae(s.LEQUAL, e.ae.ReadWrite, t1.depthRangeFor3D);
                        Ci.update(a);
                        const f = t1.transform, m = Ii(f.zoom, i.exaggeration(), i.sourceCache._source.tileSize);
                        let g = [
                            0,
                            0,
                            0
                        ];
                        if (h) {
                            const e = t1.style.directionalLight, i = t1.style.ambientLight;
                            e && i && (g = wi(t1.style, e, i));
                        }
                        {
                            c = -1;
                            const v = s.TRIANGLES, [x, y] = [
                                i.gridIndexBuffer,
                                i.gridSegments
                            ];
                            for (const c of r){
                                const r = o.getTile(c), b = e.ag.disabled, w = i.prevTerrainTileForTile[c.key], T = i.terrainTileForTile[c.key];
                                Ei(w, T) && Ci.newMorphing(c.key, w, T, a, 250), n.activeTexture.set(s.TEXTURE0), r.texture && r.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE);
                                const E = Ci.getMorphValuesForProxy(c.key), C = E ? 1 : 0;
                                let S;
                                E && (S = {
                                    morphing: {
                                        srcDemTile: E.from,
                                        dstDemTile: E.to,
                                        phase: e.b9(E.phase)
                                    }
                                });
                                const I = Ut(c.projMatrix, Li(c.canonical, f.renderWorldCopies) ? m / 10 : m, g);
                                if (u(C), !l) continue;
                                i.setupElevationDraw(r, l, S);
                                const L = c.toUnwrapped();
                                h && h.setupShadows(L, l), t1.uploadCommonUniforms(n, l, L, null, _), l.draw(t1, v, p, b, d, e.af.backCCW, I, "terrain_raster", i.gridBuffer, x, y);
                            }
                        }
                    }
                }(i, this, this.proxySourceCache, t1, this._updateTimestamp), this.renderingToTexture = !0, i.gpuTimingDeferredRenderEnd(), t1.splice(0, t1.length));
            }
            renderBatch(t1) {
                if (0 === this._drapedRenderBatches.length) return t1 + 1;
                this.renderingToTexture = !0;
                const i = this.painter, o = this.painter.context, r = this.proxySourceCache, a = this.proxiedCoords[r.id], n = this._drapedRenderBatches.shift(), s = i.style.order, l = [];
                let c = 0;
                for (const h of a){
                    const a = r.getTileByID(h.proxyTileKey), _ = r.proxyCachedFBO[h.key] ? r.proxyCachedFBO[h.key][t1] : void 0, u = void 0 !== _ ? r.renderCache[_] : this.pool[c++], d = void 0 !== _;
                    if (a.texture = u.tex, d && !u.dirty) {
                        l.push(a.tileID);
                        continue;
                    }
                    let p;
                    o.bindFramebuffer.set(u.fb.framebuffer), this.renderedToTile = !1, u.dirty && (o.clear({
                        color: e.C.transparent,
                        stencil: 0
                    }), u.dirty = !1);
                    for(let e = n.start; e <= n.end; ++e){
                        const t1 = i.style._mergedLayers[s[e]];
                        if (t1.isHidden(i.transform.zoom)) continue;
                        const r = i.style.getLayerSourceCache(t1), a = r ? this.proxyToSource[h.key][r.id] : [
                            h
                        ];
                        if (!a) continue;
                        const n = a;
                        o.viewport.set([
                            0,
                            0,
                            u.fb.width,
                            u.fb.height
                        ]), p !== (r ? r.id : null) && (this._setupStencil(u, a, t1, r), p = r ? r.id : null), i.renderLayer(i, r, t1, n);
                    }
                    if (0 === this._drapedRenderBatches.length) for (const e of this._pendingGroundEffectLayers){
                        const t1 = i.style._mergedLayers[s[e]];
                        if (t1.isHidden(i.transform.zoom)) continue;
                        const r = i.style.getLayerSourceCache(t1), a = r ? this.proxyToSource[h.key][r.id] : [
                            h
                        ];
                        if (!a) continue;
                        const n = a;
                        o.viewport.set([
                            0,
                            0,
                            u.fb.width,
                            u.fb.height
                        ]), p !== (r ? r.id : null) && (this._setupStencil(u, a, t1, r), p = r ? r.id : null), i.renderLayer(i, r, t1, n);
                    }
                    this.renderedToTile ? (u.dirty = !0, l.push(a.tileID)) : d || --c, 5 === c && (c = 0, this.renderToBackBuffer(l));
                }
                return this.renderToBackBuffer(l), this.renderingToTexture = !1, o.bindFramebuffer.set(null), o.viewport.set([
                    0,
                    0,
                    i.width,
                    i.height
                ]), n.end + 1;
            }
            postRender() {}
            isLayerOrderingCorrect(e) {
                const t1 = e.order.length;
                let i = -1, o = t1;
                for(let r = 0; r < t1; ++r)this._style.isLayerDraped(e._mergedLayers[e.order[r]]) ? i = Math.max(i, r) : o = Math.min(o, r);
                return o > i;
            }
            getMinElevationBelowMSL() {
                let e = 0;
                return this._visibleDemTiles.filter((e)=>e.dem).forEach((t1)=>{
                    e = Math.min(e, t1.dem.tree.minimums[0]);
                }), 0 === e ? e : (e - 30) * this._exaggeration;
            }
            raycast(e, t1, i) {
                if (!this._visibleDemTiles) return null;
                const o = this._visibleDemTiles.filter((e)=>e.dem).map((o)=>{
                    const r = o.tileID, a = 1 << r.overscaledZ, { x: n, y: s } = r.canonical, l = n / a, c = (n + 1) / a, h = s / a, _ = (s + 1) / a;
                    return {
                        minx: l,
                        miny: h,
                        maxx: c,
                        maxy: _,
                        t: o.dem.tree.raycastRoot(l, h, c, _, e, t1, i),
                        tile: o
                    };
                });
                o.sort((e, t1)=>(null !== e.t ? e.t : Number.MAX_VALUE) - (null !== t1.t ? t1.t : Number.MAX_VALUE));
                for (const r of o){
                    if (null == r.t) return null;
                    const o = r.tile.dem.tree.raycast(r.minx, r.miny, r.maxx, r.maxy, e, t1, i);
                    if (null != o) return o;
                }
                return null;
            }
            _createFBO() {
                const t1 = this.painter.context, i = t1.gl, o = this.drapeBufferSize;
                t1.activeTexture.set(i.TEXTURE0);
                const r = new e.T(t1, {
                    width: o[0],
                    height: o[1],
                    data: null
                }, i.RGBA);
                r.bind(i.LINEAR, i.CLAMP_TO_EDGE);
                const a = t1.createFramebuffer(o[0], o[1], !0, null);
                return a.colorAttachment.set(r.texture), a.depthAttachment = new oe(t1, a.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t1.createRenderbuffer(t1.gl.DEPTH_STENCIL, o[0], o[1]), this._stencilRef = 0, a.depthAttachment.set(this._sharedDepthStencil), t1.clear({
                    stencil: 0
                })) : a.depthAttachment.set(this._sharedDepthStencil), t1.extTextureFilterAnisotropic && i.texParameterf(i.TEXTURE_2D, t1.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t1.extTextureFilterAnisotropicMax), {
                    fb: a,
                    tex: r,
                    dirty: !1
                };
            }
            _initFBOPool() {
                for(; this.pool.length < Math.min(5, this.proxyCoords.length);)this.pool.push(this._createFBO());
            }
            _shouldDisableRenderCache() {
                if (this._debugParams.disableRenderCache) return !0;
                if (this._style.hasLightTransitions()) return !0;
                for(const e in this._style._mergedSourceCaches)if (this._style._mergedSourceCaches[e].hasTransition()) return !0;
                return this._style.order.some((e)=>{
                    const t1 = this._style._mergedLayers[e], i = t1.isHidden(this.painter.transform.zoom);
                    return "custom" === t1.type ? !i && t1.shouldRedrape() : !i && t1.hasTransition();
                });
            }
            _clearLineLayersFromRenderCache() {
                let t1 = !1;
                for (const e of this._style.getSources())if (e instanceof Nt) {
                    t1 = !0;
                    break;
                }
                if (!t1) return;
                const i = {};
                for(let t1 = 0; t1 < this._style.order.length; ++t1){
                    const o = this._style._mergedLayers[this._style.order[t1]], r = this._style.getLayerSourceCache(o);
                    if (r && !i[r.id] && !o.isHidden(this.painter.transform.zoom) && "line" === o.type && o.widthExpression() instanceof e.Z) {
                        i[r.id] = !0;
                        for (const e of this.proxyCoords){
                            const t1 = this.proxyToSource[e.key][r.id];
                            if (t1) for (const e of t1)this._clearRenderCacheForTile(r.id, e);
                        }
                    }
                }
            }
            _clearRasterLayersFromRenderCache() {
                let e = !1;
                for(const t1 in this._style._mergedSourceCaches)if (this._style._mergedSourceCaches[t1]._source instanceof kt) {
                    e = !0;
                    break;
                }
                if (!e) return;
                const t1 = {};
                for(let e = 0; e < this._style.order.length; ++e){
                    const i = this._style._mergedLayers[this._style.order[e]], o = this._style.getLayerSourceCache(i);
                    if (!o || t1[o.id]) continue;
                    if (i.isHidden(this.painter.transform.zoom) || "raster" !== i.type) continue;
                    const r = i.paint.get("raster-fade-duration");
                    for (const e of this.proxyCoords){
                        const t1 = this.proxyToSource[e.key][o.id];
                        if (t1) for (const e of t1){
                            const t1 = Ai(o.getTile(e), o.findLoadedParent(e, 0), o, this.painter.transform, r);
                            (1 !== t1.opacity || 0 !== t1.mix) && this._clearRenderCacheForTile(o.id, e);
                        }
                    }
                }
            }
            _setupDrapedRenderBatches() {
                const t1 = this._style.order, i = t1.length;
                if (0 === i) return;
                const o = [];
                this._pendingGroundEffectLayers = [];
                let r, a = 0, n = this._style._mergedLayers[t1[a]];
                for(; !this._style.isLayerDraped(n) && n.isHidden(this.painter.transform.zoom) && ++a < i;)n = this._style._mergedLayers[t1[a]];
                for(; a < i; ++a){
                    const e = this._style._mergedLayers[t1[a]];
                    e.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e) ? void 0 === r && (r = a) : ("fill-extrusion" === e.type && this._pendingGroundEffectLayers.push(a), void 0 !== r && (o.push({
                        start: r,
                        end: a - 1
                    }), r = void 0)));
                }
                if (void 0 !== r && o.push({
                    start: r,
                    end: a - 1
                }), 0 !== o.length) {
                    const t1 = o[o.length - 1];
                    this._pendingGroundEffectLayers.every((e)=>e > t1.end) || e.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
                }
                this._drapedRenderBatches = o;
            }
            _setupRenderCache(e) {
                const t1 = this.proxySourceCache;
                if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
                    if (this.invalidateRenderCache = !1, t1.renderCache.length > t1.renderCachePool.length) {
                        const e = Object.values(t1.proxyCachedFBO);
                        t1.proxyCachedFBO = {};
                        for(let i = 0; i < e.length; ++i){
                            const o = Object.values(e[i]);
                            t1.renderCachePool.push(...o);
                        }
                    }
                    return;
                }
                this._clearRasterLayersFromRenderCache();
                const i = this.proxyCoords, o = this._tilesDirty;
                for(let r = i.length - 1; r >= 0; r--){
                    const a = i[r];
                    if (t1.getTileByID(a.key), void 0 !== t1.proxyCachedFBO[a.key]) {
                        const i = e[a.key], r = this.proxyToSource[a.key];
                        let n = 0;
                        for(const e in r){
                            const t1 = r[e], a = i[e];
                            if (!a || a.length !== t1.length || t1.some((t1, i)=>t1 !== a[i] || o[e] && o[e].hasOwnProperty(t1.key))) {
                                n = -1;
                                break;
                            }
                            ++n;
                        }
                        for(const e in t1.proxyCachedFBO[a.key])t1.renderCache[t1.proxyCachedFBO[a.key][e]].dirty = n < 0 || n !== Object.values(i).length;
                    }
                }
                const r = [
                    ...this._drapedRenderBatches
                ];
                r.sort((e, t1)=>t1.end - t1.start - (e.end - e.start));
                for (const e of r)for (const o of i){
                    if (t1.proxyCachedFBO[o.key]) continue;
                    let i = t1.renderCachePool.pop();
                    void 0 === i && t1.renderCache.length < 50 && (i = t1.renderCache.length, t1.renderCache.push(this._createFBO())), void 0 !== i && (t1.proxyCachedFBO[o.key] = {}, t1.proxyCachedFBO[o.key][e.start] = i, t1.renderCache[i].dirty = !0);
                }
                this._tilesDirty = {};
            }
            _setupStencil(e, t1, i, o) {
                if (!o || !this._sourceTilesOverlap[o.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));
                const r = this.painter.context, a = r.gl;
                if (t1.length <= 1) return void (this._overlapStencilType = !1);
                let n;
                if (i.isTileClipped()) n = t1.length, this._overlapStencilMode.test = {
                    func: a.EQUAL,
                    mask: 255
                }, this._overlapStencilType = "Clip";
                else {
                    if (!(t1[0].overscaledZ > t1[t1.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);
                    n = 1, this._overlapStencilMode.test = {
                        func: a.GREATER,
                        mask: 255
                    }, this._overlapStencilType = "Mask";
                }
                this._stencilRef + n > 255 && (r.clear({
                    stencil: 0
                }), this._stencilRef = 0), this._stencilRef += n, this._overlapStencilMode.ref = this._stencilRef, i.isTileClipped() && this._renderTileClippingMasks(t1, this._overlapStencilMode.ref);
            }
            clipOrMaskOverlapStencilType() {
                return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
            }
            stencilModeForRTTOverlap(t1) {
                return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t1.key]), this._overlapStencilMode) : e.ag.disabled;
            }
            _renderTileClippingMasks(t1, i) {
                const o = this.painter, r = this.painter.context, a = r.gl;
                o._tileClippingMaskIDs = {}, r.setColorMode(e.a.disabled), r.setDepthMode(e.ae.disabled);
                const n = o.getOrCreateProgram("clippingMask");
                for (const r of t1){
                    const t1 = o._tileClippingMaskIDs[r.key] = --i;
                    n.draw(o, a.TRIANGLES, e.ae.disabled, new e.ag({
                        func: a.ALWAYS,
                        mask: 0
                    }, t1, 255, a.KEEP, a.KEEP, a.REPLACE), e.a.disabled, e.af.disabled, Pi(r.projMatrix), "$clipping", o.tileExtentBuffer, o.quadTriangleIndexBuffer, o.tileExtentSegments);
                }
            }
            pointCoordinate(t1) {
                const i = this.painter.transform;
                if (t1.x < 0 || t1.x > i.width || t1.y < 0 || t1.y > i.height) return null;
                const o = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                e.aA.transformMat4(o, o, i.pixelMatrixInverse), e.aA.scale(o, o, 1 / o[3]), o[0] /= i.worldSize, o[1] /= i.worldSize;
                const r = i._camera.position, a = e.ax(1, i.center.lat), n = [
                    r[0],
                    r[1],
                    r[2] / a,
                    0
                ], s = e._.subtract([], o.slice(0, 3), n);
                e._.normalize(s, s);
                const l = this.raycast(n, s, this._exaggeration);
                return null !== l && l ? (e._.scaleAndAdd(n, n, s, l), n[3] = n[2], n[2] *= a, n) : null;
            }
            _setupProxiedCoordsForOrtho(t1, i, o) {
                if (t1.getSource() instanceof e.bm) return this._setupProxiedCoordsForImageSource(t1, i, o);
                this._findCoveringTileCache[t1.id] = this._findCoveringTileCache[t1.id] || {};
                const r = this.proxiedCoords[t1.id] = [], a = this.proxyCoords;
                for(let e = 0; e < a.length; e++){
                    const i = a[e], n = this._findTileCoveringTileID(i, t1);
                    if (n) {
                        const e = this._createProxiedId(i, n, o[i.key] && o[i.key][t1.id]);
                        r.push(e), this.proxyToSource[i.key][t1.id] = [
                            e
                        ];
                    }
                }
                let n = !1;
                const s = new Set;
                for(let e = 0; e < i.length; e++){
                    const a = t1.getTile(i[e]);
                    if (!a || !a.hasData()) continue;
                    const l = this._findTileCoveringTileID(a.tileID, this.proxySourceCache);
                    if (l && l.tileID.canonical.z !== a.tileID.canonical.z) {
                        const e = this.proxyToSource[l.tileID.key][t1.id], i = this._createProxiedId(l.tileID, a, o[l.tileID.key] && o[l.tileID.key][t1.id]);
                        e ? e.splice(e.length - 1, 0, i) : this.proxyToSource[l.tileID.key][t1.id] = [
                            i
                        ];
                        const c = this.proxyToSource[l.tileID.key][t1.id];
                        s.has(c) || s.add(c), r.push(i), n = !0;
                    }
                }
                if (this._sourceTilesOverlap[t1.id] = n, n && this._debugParams.sortTilesHiZFirst) for (const e of s)e.sort((e, t1)=>t1.overscaledZ - e.overscaledZ);
            }
            _setupProxiedCoordsForImageSource(t1, i, o) {
                if (!t1.getSource().loaded()) return;
                const r = this.proxiedCoords[t1.id] = [], a = this.proxyCoords, n = t1.getSource(), s = n.tileID;
                if (!s) return;
                const l = new e.P(s.x, s.y)._div(1 << s.z), c = n.coordinates.map(e.Y.fromLngLat).reduce((e, t1)=>(e.min.x = Math.min(e.min.x, t1.x - l.x), e.min.y = Math.min(e.min.y, t1.y - l.y), e.max.x = Math.max(e.max.x, t1.x - l.x), e.max.y = Math.max(e.max.y, t1.y - l.y), e), {
                    min: new e.P(Number.MAX_VALUE, Number.MAX_VALUE),
                    max: new e.P(-Number.MAX_VALUE, -Number.MAX_VALUE)
                }), h = (t1, i)=>{
                    const o = t1.wrap + t1.canonical.x / (1 << t1.canonical.z), r = t1.canonical.y / (1 << t1.canonical.z), a = e.a3 / (1 << t1.canonical.z), n = i.wrap + i.canonical.x / (1 << i.canonical.z), s = i.canonical.y / (1 << i.canonical.z);
                    return o + a < n + c.min.x || o > n + c.max.x || r + a < s + c.min.y || r > s + c.max.y;
                };
                for(let e = 0; e < a.length; e++){
                    const n = a[e];
                    for(let e = 0; e < i.length; e++){
                        const a = t1.getTile(i[e]);
                        if (!a || !a.hasData()) continue;
                        if (h(n, a.tileID)) continue;
                        const s = this._createProxiedId(n, a, o[n.key] && o[n.key][t1.id]), l = this.proxyToSource[n.key][t1.id];
                        l ? l.push(s) : this.proxyToSource[n.key][t1.id] = [
                            s
                        ], r.push(s);
                    }
                }
            }
            _createProxiedId(t1, i, o) {
                let r = this.orthoMatrix;
                if (o) {
                    const e = o.find((e)=>e.key === i.tileID.key);
                    if (e) return e;
                }
                if (i.tileID.key !== t1.key) {
                    const o = t1.canonical.z - i.tileID.canonical.z;
                    let a, n, s;
                    r = e.ad.create();
                    const l = i.tileID.wrap - t1.wrap << t1.overscaledZ;
                    o > 0 ? (a = e.a3 >> o, n = a * ((i.tileID.canonical.x << o) - t1.canonical.x + l), s = a * ((i.tileID.canonical.y << o) - t1.canonical.y)) : (a = e.a3 << -o, n = e.a3 * (i.tileID.canonical.x - (t1.canonical.x + l << -o)), s = e.a3 * (i.tileID.canonical.y - (t1.canonical.y << -o))), e.ad.ortho(r, 0, a, 0, a, 0, 1), e.ad.translate(r, r, [
                        n,
                        s,
                        0
                    ]);
                }
                return new Fi(i.tileID, t1.key, r);
            }
            _findTileCoveringTileID(t1, i) {
                let o = i.getTile(t1);
                if (o && o.hasData()) return o;
                const r = this._findCoveringTileCache[i.id], a = r[t1.key];
                if (o = a ? i.getTileByID(a) : null, o && o.hasData() || null === a) return o;
                let n = o ? o.tileID : t1, s = n.overscaledZ;
                const l = i.getSource().minzoom, c = [];
                if (!a) {
                    const r = i.getSource().maxzoom;
                    if (t1.canonical.z >= r) {
                        const o = t1.canonical.z - r;
                        i.getSource().reparseOverscaled ? (s = Math.max(t1.canonical.z + 2, i.transform.tileZoom), n = new e.aL(s, t1.wrap, r, t1.canonical.x >> o, t1.canonical.y >> o)) : 0 !== o && (s = r, n = new e.aL(s, t1.wrap, r, t1.canonical.x >> o, t1.canonical.y >> o));
                    }
                    n.key !== t1.key && (c.push(n.key), o = i.getTile(n));
                }
                const h = (e)=>{
                    c.forEach((t1)=>{
                        r[t1] = e;
                    }), c.length = 0;
                };
                for(s -= 1; s >= l && (!o || !o.hasData()); s--){
                    o && h(o.tileID.key);
                    const e = n.calculateScaledKey(s);
                    if (o = i.getTileByID(e), o && o.hasData()) break;
                    const t1 = r[e];
                    if (null === t1) break;
                    void 0 === t1 ? c.push(e) : o = i.getTileByID(t1);
                }
                return h(o ? o.tileID.key : null), o && o.hasData() ? o : null;
            }
            findDEMTileFor(e) {
                return this.enabled ? this._findTileCoveringTileID(e, this.sourceCache) : null;
            }
            prepareDrawTile() {
                this.renderedToTile = !0;
            }
            _clearRenderCacheForTile(e, t1) {
                let i = this._tilesDirty[e];
                i || (i = this._tilesDirty[e] = {}), i[t1.key] = !0;
            }
        }
        function ki(t1, i, o) {
            const r = function(t1, i, o) {
                const r = e._.dot(i, t1), a = e._.dot(o, [
                    .2126,
                    .7152,
                    .0722
                ]), n = (e, t1, i)=>(1 - i) * e + i * t1, s = n(1 - .3 * Math.min(a, 1), 1, Math.min(r + 1, 1));
                return n(.92, 1, Math.asin(e.at(i[2], -1, 1)) / Math.PI + .5) * s;
            }(t1, [
                0,
                0,
                1
            ], i), a = [
                0,
                0,
                0
            ];
            e._.scale(a, o.slice(0, 3), r);
            const n = [
                0,
                0,
                0
            ];
            e._.scale(n, i.slice(0, 3), t1[2]);
            const s = [
                0,
                0,
                0
            ];
            return e._.add(s, a, n), e.b8(s);
        }
        const Ni = [
            "fill",
            "fillOutline",
            "fillPattern",
            "line",
            "linePattern",
            "background",
            "backgroundPattern",
            "hillshade",
            "raster"
        ], Ui = [
            "stars",
            "fillExtrusion",
            "fillExtrusionGroundEffect",
            "model",
            "symbolSDF",
            "symbolIcon",
            "symbolTextAndIcon"
        ];
        class Gi {
            static cacheKey(e, t1, i, o) {
                let r = `${t1}${o ? o.cacheKey : ""}`;
                for (const t1 of i)e.usedDefines.includes(t1) && (r += `/${t1}`);
                return r;
            }
            constructor(t1, i, o, r, a, n){
                const s = t1.gl;
                this.program = s.createProgram(), this.configuration = r, this.name = i, this.fixedDefines = [
                    ...n
                ];
                const l = r ? r.getBinderAttributes() : [], c = (o.staticAttributes || []).concat(l);
                let h = r ? r.defines() : [];
                h = h.concat(n.map((e)=>`#define ${e}`));
                const _ = "#version 300 es\n";
                let u = _ + h.concat("precision mediump float;", It, St.fragmentSource).join("\n");
                for (const e of o.fragmentIncludes)u += `\n${Et[e]}`;
                u += `\n${o.fragmentSource}`;
                let d = _ + h.concat("precision highp float;", It, St.vertexSource).join("\n");
                for (const e of o.vertexIncludes)d += `\n${Et[e]}`;
                d += `\n${o.vertexSource}`;
                const p = s.createShader(s.FRAGMENT_SHADER);
                if (s.isContextLost()) return void (this.failedToCreate = !0);
                s.shaderSource(p, u), s.compileShader(p), s.attachShader(this.program, p);
                const f = s.createShader(s.VERTEX_SHADER);
                if (s.isContextLost()) this.failedToCreate = !0;
                else {
                    s.shaderSource(f, d), s.compileShader(f), s.attachShader(this.program, f), this.attributes = {}, this.numAttributes = c.length;
                    for(let e = 0; e < this.numAttributes; e++)if (c[e]) {
                        const t1 = c[e].startsWith("a_") ? c[e] : `a_${c[e]}`;
                        s.bindAttribLocation(this.program, e, t1), this.attributes[t1] = e;
                    }
                    s.linkProgram(this.program), s.deleteShader(f), s.deleteShader(p), this.fixedUniforms = a(t1), this.binderUniforms = r ? r.getUniforms(t1) : [], n.includes("TERRAIN") && (this.terrainUniforms = ((t1)=>({
                            u_dem: new e.a7(t1),
                            u_dem_prev: new e.a7(t1),
                            u_dem_tl: new e.a8(t1),
                            u_dem_scale: new e.aa(t1),
                            u_dem_tl_prev: new e.a8(t1),
                            u_dem_scale_prev: new e.aa(t1),
                            u_dem_size: new e.aa(t1),
                            u_dem_lerp: new e.aa(t1),
                            u_exaggeration: new e.aa(t1),
                            u_depth: new e.a7(t1),
                            u_depth_size_inv: new e.a8(t1),
                            u_depth_range_unpack: new e.a8(t1),
                            u_meter_to_dem: new e.aa(t1),
                            u_label_plane_matrix_inv: new e.a6(t1)
                        }))(t1)), n.includes("GLOBE") && (this.globeUniforms = ((t1)=>({
                            u_tile_tl_up: new e.aq(t1),
                            u_tile_tr_up: new e.aq(t1),
                            u_tile_br_up: new e.aq(t1),
                            u_tile_bl_up: new e.aq(t1),
                            u_tile_up_scale: new e.aa(t1)
                        }))(t1)), n.includes("FOG") && (this.fogUniforms = ((t1)=>({
                            u_fog_matrix: new e.a6(t1),
                            u_fog_range: new e.a8(t1),
                            u_fog_color: new e.as(t1),
                            u_fog_horizon_blend: new e.aa(t1),
                            u_fog_vertical_limit: new e.a8(t1),
                            u_fog_temporal_offset: new e.aa(t1),
                            u_frustum_tl: new e.aq(t1),
                            u_frustum_tr: new e.aq(t1),
                            u_frustum_br: new e.aq(t1),
                            u_frustum_bl: new e.aq(t1),
                            u_globe_pos: new e.aq(t1),
                            u_globe_radius: new e.aa(t1),
                            u_globe_transition: new e.aa(t1),
                            u_is_globe: new e.a7(t1),
                            u_viewport: new e.a8(t1)
                        }))(t1)), n.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((t1)=>({
                            u_cutoff_params: new e.as(t1)
                        }))(t1)), n.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((t1)=>({
                            u_lighting_ambient_color: new e.aq(t1),
                            u_lighting_directional_dir: new e.aq(t1),
                            u_lighting_directional_color: new e.aq(t1),
                            u_ground_radiance: new e.aq(t1)
                        }))(t1)), n.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((t1)=>({
                            u_light_matrix_0: new e.a6(t1),
                            u_light_matrix_1: new e.a6(t1),
                            u_fade_range: new e.a8(t1),
                            u_shadow_normal_offset: new e.aq(t1),
                            u_shadow_intensity: new e.aa(t1),
                            u_shadow_texel_size: new e.aa(t1),
                            u_shadow_map_resolution: new e.aa(t1),
                            u_shadow_direction: new e.aq(t1),
                            u_shadow_bias: new e.aq(t1),
                            u_shadowmap_0: new e.a7(t1),
                            u_shadowmap_1: new e.a7(t1)
                        }))(t1));
                }
            }
            setTerrainUniformValues(e, t1) {
                if (!this.terrainUniforms) return;
                const i = this.terrainUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e] && i[e].set(this.program, e, t1[e]);
                }
            }
            setGlobeUniformValues(e, t1) {
                if (!this.globeUniforms) return;
                const i = this.globeUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e] && i[e].set(this.program, e, t1[e]);
                }
            }
            setFogUniformValues(e, t1) {
                if (!this.fogUniforms) return;
                const i = this.fogUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e].set(this.program, e, t1[e]);
                }
            }
            setCutoffUniformValues(e, t1) {
                if (!this.cutoffUniforms) return;
                const i = this.cutoffUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e].set(this.program, e, t1[e]);
                }
            }
            setLightsUniformValues(e, t1) {
                if (!this.lightsUniforms) return;
                const i = this.lightsUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e].set(this.program, e, t1[e]);
                }
            }
            setShadowUniformValues(e, t1) {
                if (this.failedToCreate || !this.shadowUniforms) return;
                const i = this.shadowUniforms;
                e.program.set(this.program);
                for(const e in t1)i[e].set(this.program, e, t1[e]);
            }
            _drawDebugWireframe(t1, i, o, r, a, n, s, l, c, h) {
                const _ = t1.options.wireframe;
                if (!1 === _.terrain && !1 === _.layers2D && !1 === _.layers3D) return;
                const u = t1.context;
                if (!(()=>!(!_.terrain || "terrainRaster" !== this.name && "globeRaster" !== this.name) || !(!_.layers2D || t1._terrain && t1._terrain.renderingToTexture || !Ni.includes(this.name)) || !(!_.layers3D || !Ui.includes(this.name)))()) return;
                const d = u.gl, p = t1.wireframeDebugCache.getLinesFromTrianglesBuffer(t1.frameCounter, a, u);
                if (!p) return;
                const f = [
                    ...this.fixedDefines
                ];
                f.push("DEBUG_WIREFRAME");
                const m = t1.getOrCreateProgram(this.name, {
                    config: this.configuration,
                    defines: f
                });
                u.program.set(m.program);
                const g = (e, t1, i)=>{
                    if (t1[e] && i[e]) for(const o in t1[e])i[e][o] && i[e][o].set(i.program, o, t1[e][o].current);
                };
                c && c.setUniforms(m.program, u, m.binderUniforms, s, {
                    zoom: l
                }), g("fixedUniforms", this, m), g("terrainUniforms", this, m), g("globeUniforms", this, m), g("fogUniforms", this, m), g("lightsUniforms", this, m), g("shadowUniforms", this, m), p.bind(), u.setColorMode(new e.a([
                    d.ONE,
                    d.ONE_MINUS_SRC_ALPHA,
                    d.ZERO,
                    d.ONE
                ], e.C.transparent, [
                    !0,
                    !0,
                    !0,
                    !1
                ])), u.setDepthMode(new e.ae(i.func === d.LESS ? d.LEQUAL : i.func, e.ae.ReadOnly, i.range)), u.setStencilMode(e.ag.disabled);
                const v = 3 * n.primitiveLength * 2, x = 3 * n.primitiveOffset * 4;
                h && h > 1 ? d.drawElementsInstanced(d.LINES, v, d.UNSIGNED_SHORT, x, h) : d.drawElements(d.LINES, v, d.UNSIGNED_SHORT, x), a.bind(), u.program.set(this.program), u.setDepthMode(i), u.setStencilMode(o), u.setColorMode(r);
            }
            draw(e, t1, i, o, r, a, n, s, l, c, h, _, u, d, p, f) {
                const m = e.context, g = m.gl;
                if (this.failedToCreate) return;
                m.program.set(this.program), m.setDepthMode(i), m.setStencilMode(o), m.setColorMode(r), m.setCullFace(a);
                for (const e of Object.keys(this.fixedUniforms))this.fixedUniforms[e].set(this.program, e, n[e]);
                d && d.setUniforms(this.program, m, this.binderUniforms, _, {
                    zoom: u
                });
                const v = {
                    [g.POINTS]: 1,
                    [g.LINES]: 2,
                    [g.TRIANGLES]: 3,
                    [g.LINE_STRIP]: 1
                }[t1], x = f && f > 0 ? 1 : void 0;
                for (const a of h.get()){
                    const n = a.vaos || (a.vaos = {});
                    (n[s] || (n[s] = new Rt)).bind(m, this, l, d ? d.getPaintVertexBuffers() : [], c, a.vertexOffset, p || [], x), f && f > 1 ? g.drawElementsInstanced(t1, a.primitiveLength * v, g.UNSIGNED_SHORT, a.primitiveOffset * v * 2, f) : c ? g.drawElements(t1, a.primitiveLength * v, g.UNSIGNED_SHORT, a.primitiveOffset * v * 2) : g.drawArrays(t1, a.vertexOffset, a.vertexLength), t1 === g.TRIANGLES && c && this._drawDebugWireframe(e, i, o, r, c, a, _, u, d, f);
                }
            }
        }
        function ji(t1, i) {
            const o = Math.pow(2, i.tileID.overscaledZ), r = i.tileSize * Math.pow(2, t1.transform.tileZoom) / o, a = r * (i.tileID.canonical.x + i.tileID.wrap * o), n = r * i.tileID.canonical.y;
            return {
                u_image: 0,
                u_texsize: i.imageAtlasTexture ? i.imageAtlasTexture.size : [
                    0,
                    0
                ],
                u_tile_units_to_pixels: 1 / e.bB(i, 1, t1.transform.tileZoom),
                u_pixel_coord_upper: [
                    a >> 16,
                    n >> 16
                ],
                u_pixel_coord_lower: [
                    65535 & a,
                    65535 & n
                ]
            };
        }
        const Vi = e.ad.create(), Wi = (t1, i, o, r, a, n, s, l, c, h, _, u, d, p, f, m)=>{
            const g = i.style.light, v = g.properties.get("position"), x = [
                v.x,
                v.y,
                v.z
            ], y = e.bC.create();
            "viewport" === g.properties.get("anchor") && (e.bC.fromRotation(y, -i.transform.angle), e._.transformMat3(x, x, y));
            const b = g.properties.get("color"), w = i.transform, T = {
                u_matrix: t1,
                u_lightpos: x,
                u_lightintensity: g.properties.get("intensity"),
                u_lightcolor: [
                    b.r,
                    b.g,
                    b.b
                ],
                u_vertical_gradient: +o,
                u_opacity: r,
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_inv_rot_matrix: Vi,
                u_merc_center: [
                    0,
                    0
                ],
                u_up_dir: [
                    0,
                    0,
                    0
                ],
                u_height_lift: 0,
                u_ao: a,
                u_edge_radius: n,
                u_flood_light_color: u,
                u_vertical_scale: d,
                u_flood_light_intensity: p,
                u_ground_shadow_factor: f,
                u_emissive_strength: m
            };
            return "globe" === w.projection.name && (T.u_tile_id = [
                s.canonical.x,
                s.canonical.y,
                1 << s.canonical.z
            ], T.u_zoom_transition = c, T.u_inv_rot_matrix = _, T.u_merc_center = h, T.u_up_dir = w.projection.upVector(new e.aO(0, 0, 0), h[0] * e.a3, h[1] * e.a3), T.u_height_lift = l), T;
        }, Zi = (e, t1, i)=>({
                u_matrix: e,
                u_edge_radius: t1,
                u_vertical_scale: i
            }), qi = (t1, i, o, r, a, n, s, l, c, h, _, u, d, p)=>{
            const f = Wi(t1, i, o, r, a, n, s, c, h, _, u, d, p, 1, [
                0,
                0,
                0
            ], 0), m = {
                u_height_factor: -Math.pow(2, s.overscaledZ) / l.tileSize / 8
            };
            return e.W(f, ji(i, l), m);
        }, Hi = (e, t1)=>({
                u_matrix: e,
                u_emissive_strength: t1
            }), $i = (t1, i, o, r)=>e.W(Hi(t1, i), ji(o, r)), Xi = (e, t1, i)=>({
                u_matrix: e,
                u_world: i,
                u_emissive_strength: t1
            }), Yi = (t1, i, o, r, a)=>e.W($i(t1, i, o, r), {
                u_world: a
            }), Ki = (t1, i, o, r)=>{
            const a = e.a3 / o.tileSize;
            return {
                u_matrix: t1,
                u_camera_to_center_distance: i.getCameraToCenterDistance(r),
                u_extrude_scale: [
                    i.pixelsToGLUnits[0] / a,
                    i.pixelsToGLUnits[1] / a
                ]
            };
        }, Qi = (e, t1, i = 1)=>({
                u_matrix: e,
                u_color: t1.toRenderColor(null),
                u_overlay: 0,
                u_overlay_scale: i
            }), Ji = e.ad.create(), eo = (t1, i, o, r, a, n, s)=>{
            const l = t1.transform, c = "globe" === l.projection.name, h = c ? e.bD(l.zoom, i.canonical) * l._pixelsPerMercatorPixel : e.bB(o, 1, n), _ = {
                u_matrix: i.projMatrix,
                u_extrude_scale: h,
                u_intensity: s,
                u_inv_rot_matrix: Ji,
                u_merc_center: [
                    0,
                    0
                ],
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_up_dir: [
                    0,
                    0,
                    0
                ]
            };
            if (c) {
                _.u_inv_rot_matrix = r, _.u_merc_center = a, _.u_tile_id = [
                    i.canonical.x,
                    i.canonical.y,
                    1 << i.canonical.z
                ], _.u_zoom_transition = e.a1(l.zoom);
                const t1 = a[0] * e.a3, o = a[1] * e.a3;
                _.u_up_dir = l.projection.upVector(new e.aO(0, 0, 0), t1, o);
            }
            return _;
        };
        function to(e, [t1, i, o, r], [a, n]) {
            if (a === n) return [
                0,
                0,
                0,
                0
            ];
            const s = 255 * (e - 1) / (e * (n - a));
            return [
                t1 * s,
                i * s,
                o * s,
                r * s
            ];
        }
        function io(e, t1, [i, o]) {
            return i === o ? 0 : .5 / e + (t1 - i) * (e - 1) / (e * (o - i));
        }
        const oo = (t1, i, o, r, a, n, s, l, c, h, _, u, d, p, f, m, g, v, x, y, b)=>({
                u_matrix: t1,
                u_normalize_matrix: i,
                u_globe_matrix: o,
                u_merc_matrix: r,
                u_grid_matrix: a,
                u_tl_parent: n,
                u_scale_parent: h,
                u_fade_t: _.mix,
                u_opacity: _.opacity * u.paint.get("raster-opacity"),
                u_image0: 0,
                u_image1: 1,
                u_brightness_low: u.paint.get("raster-brightness-min"),
                u_brightness_high: u.paint.get("raster-brightness-max"),
                u_saturation_factor: e.bE(u.paint.get("raster-saturation")),
                u_contrast_factor: e.bF(u.paint.get("raster-contrast")),
                u_spin_weights: ro(u.paint.get("raster-hue-rotate")),
                u_perspective_transform: d,
                u_raster_elevation: p,
                u_zoom_transition: s,
                u_merc_center: l,
                u_cutoff_params: c,
                u_colorization_mix: to(e.bG, m, v),
                u_colorization_offset: io(e.bG, g, v),
                u_color_ramp: f,
                u_texture_offset: [
                    y / (x + 2 * y),
                    x / (x + 2 * y)
                ],
                u_texture_res: [
                    x + 2 * y,
                    x + 2 * y
                ],
                u_emissive_strength: b
            });
        function ro(e) {
            e *= Math.PI / 180;
            const t1 = Math.sin(e), i = Math.cos(e);
            return [
                (2 * i + 1) / 3,
                (-Math.sqrt(3) * t1 - i + 1) / 3,
                (Math.sqrt(3) * t1 - i + 1) / 3
            ];
        }
        const ao = .05, no = (e, t1, i, o, r, a, n, s, l, c, h, _)=>({
                u_matrix: e,
                u_normalize_matrix: t1,
                u_globe_matrix: i,
                u_merc_matrix: o,
                u_grid_matrix: r,
                u_tl_parent: a,
                u_scale_parent: c,
                u_fade_t: h.mix,
                u_opacity: h.opacity,
                u_image0: 0,
                u_image1: 1,
                u_raster_elevation: _,
                u_zoom_transition: n,
                u_merc_center: s,
                u_cutoff_params: l
            }), so = (e, t1, i, o, r, a, n, s, l, c)=>({
                u_particle_texture: e,
                u_particle_texture_side_len: t1,
                u_tile_offset: i,
                u_velocity: o,
                u_color_ramp: a,
                u_velocity_res: r,
                u_max_speed: n,
                u_uv_offset: s,
                u_data_scale: [
                    255 * l[0],
                    255 * l[1]
                ],
                u_data_offset: c,
                u_particle_pos_scale: 1.1,
                u_particle_pos_offset: [
                    ao,
                    ao
                ]
            }), lo = (e, t1, i, o, r, a, n, s, l, c)=>({
                u_particle_texture: e,
                u_particle_texture_side_len: t1,
                u_velocity: i,
                u_velocity_res: o,
                u_max_speed: r,
                u_speed_factor: a,
                u_reset_rate: n,
                u_rand_seed: Math.random(),
                u_uv_offset: s,
                u_data_scale: [
                    255 * l[0],
                    255 * l[1]
                ],
                u_data_offset: c,
                u_particle_pos_scale: 1.1,
                u_particle_pos_offset: [
                    ao,
                    ao
                ]
            }), co = e.ad.create(), ho = (t1, i, o, r, a, n, s, l, c, h, _, u, d, p, f, m, g, v)=>{
            const x = a.transform, y = {
                u_is_size_zoom_constant: +("constant" === t1 || "source" === t1),
                u_is_size_feature_constant: +("constant" === t1 || "camera" === t1),
                u_size_t: i ? i.uSizeT : 0,
                u_size: i ? i.uSize : 0,
                u_camera_to_center_distance: x.getCameraToCenterDistance(m),
                u_rotate_symbol: +o,
                u_aspect_ratio: x.width / x.height,
                u_fade_change: a.options.fadeDuration ? a.symbolFadeChange : 1,
                u_matrix: n,
                u_label_plane_matrix: s,
                u_coord_matrix: l,
                u_is_text: +c,
                u_pitch_with_map: +r,
                u_texsize: h,
                u_texture: 0,
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_inv_rot_matrix: co,
                u_merc_center: [
                    0,
                    0
                ],
                u_camera_forward: [
                    0,
                    0,
                    0
                ],
                u_ecef_origin: [
                    0,
                    0,
                    0
                ],
                u_tile_matrix: co,
                u_up_vector: [
                    0,
                    -1,
                    0
                ],
                u_color_adj_mat: g,
                u_icon_transition: v || 0
            };
            return "globe" === m.name && (y.u_tile_id = [
                _.canonical.x,
                _.canonical.y,
                1 << _.canonical.z
            ], y.u_zoom_transition = u, y.u_inv_rot_matrix = p, y.u_merc_center = d, y.u_camera_forward = x._camera.forward(), y.u_ecef_origin = e.bH(x.globeMatrix, _.toUnwrapped()), y.u_tile_matrix = Float32Array.from(x.globeMatrix), y.u_up_vector = f), y;
        }, _o = (t1, i, o, r, a, n, s, l, c, h, _, u, d, p, f, m, g)=>e.W(ho(t1, i, o, r, a, n, s, l, c, h, u, d, p, f, m, g), {
                u_gamma_scale: r ? a.transform.getCameraToCenterDistance(g) * Math.cos(a.terrain ? 0 : a.transform._pitch) : 1,
                u_device_pixel_ratio: e.e.devicePixelRatio,
                u_is_halo: +_,
                undefined: void 0
            }), uo = (t1, i, o, r, a, n, s, l, c, h, _, u, d, p, f, m)=>e.W(_o(t1, i, o, r, a, n, s, l, !0, c, !0, _, u, d, p, f, m), {
                u_texsize_icon: h,
                u_texture_icon: 1
            }), po = (e, t1, i, o)=>({
                u_matrix: e,
                u_emissive_strength: t1,
                u_opacity: i,
                u_color: o
            }), fo = (t1, i, o, r, a, n, s, l)=>e.W(function(t1, i, o, r, a) {
                const { width: n, height: s } = r.imageManager.getPixelSize(i), l = Math.pow(2, a.tileID.overscaledZ), c = a.tileSize * Math.pow(2, r.transform.tileZoom) / l, h = c * (a.tileID.canonical.x + a.tileID.wrap * l), _ = c * a.tileID.canonical.y;
                return {
                    u_image: 0,
                    u_pattern_tl: o.tl,
                    u_pattern_br: o.br,
                    u_texsize: [
                        n,
                        s
                    ],
                    u_pattern_size: o.displaySize,
                    u_tile_units_to_pixels: 1 / e.bB(a, 1, r.transform.tileZoom),
                    u_pixel_coord_upper: [
                        h >> 16,
                        _ >> 16
                    ],
                    u_pixel_coord_lower: [
                        65535 & h,
                        65535 & _
                    ]
                };
            }(0, n, s, r, l), {
                u_matrix: t1,
                u_emissive_strength: i,
                u_opacity: o
            }), mo = new Float32Array(e.ad.identity([])), go = (t1, i, o, r, a, n, s, l, c, h, _, u, d, p = [
            0,
            0,
            0
        ], f)=>{
            const m = a.style.light, g = m.properties.get("position"), v = [
                -g.x,
                -g.y,
                g.z
            ], x = e.bC.create();
            "viewport" === m.properties.get("anchor") && (e.bC.fromRotation(x, -a.transform.angle), e._.transformMat3(v, v, x));
            const y = "MASK" === _.alphaMode, b = m.properties.get("color").toRenderColor(null), w = d.paint.get("model-ambient-occlusion-intensity"), T = d.paint.get("model-color").constantOr(e.C.white).toRenderColor(null), E = d.paint.get("model-color-mix-intensity").constantOr(0);
            return {
                u_matrix: t1,
                u_lighting_matrix: i,
                u_normal_matrix: o,
                u_node_matrix: r || mo,
                u_lightpos: v,
                u_lightintensity: m.properties.get("intensity"),
                u_lightcolor: [
                    b.r,
                    b.g,
                    b.b
                ],
                u_camera_pos: p,
                u_opacity: n,
                u_baseTextureIsAlpha: 0,
                u_alphaMask: +y,
                u_alphaCutoff: _.alphaCutoff,
                u_baseColorFactor: [
                    s.r,
                    s.g,
                    s.b,
                    s.a
                ],
                u_emissiveFactor: [
                    l[0],
                    l[1],
                    l[2],
                    1
                ],
                u_metallicFactor: c,
                u_roughnessFactor: h,
                u_baseColorTexture: pi.BaseColor,
                u_metallicRoughnessTexture: pi.MetallicRoughness,
                u_normalTexture: pi.Normal,
                u_occlusionTexture: pi.Occlusion,
                u_emissionTexture: pi.Emission,
                u_lutTexture: pi.LUT,
                u_color_mix: [
                    T.r,
                    T.g,
                    T.b,
                    E
                ],
                u_aoIntensity: w,
                u_emissive_strength: u,
                u_occlusionTextureTransform: f || [
                    0,
                    0,
                    0,
                    0
                ]
            };
        }, vo = (e, t1 = mo, i = mo)=>({
                u_matrix: e,
                u_instance: t1,
                u_node_matrix: i
            }), xo = (e, t1, i, o, r)=>({
                u_matrix: Float32Array.from(e),
                u_anchorPos: t1,
                u_screenSizePx: i,
                u_occluderSizePx: o,
                u_color: r
            }), yo = {
            fillExtrusion: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_lightpos: new e.aq(t1),
                    u_lightintensity: new e.aa(t1),
                    u_lightcolor: new e.aq(t1),
                    u_vertical_gradient: new e.aa(t1),
                    u_opacity: new e.aa(t1),
                    u_edge_radius: new e.aa(t1),
                    u_ao: new e.a8(t1),
                    u_tile_id: new e.aq(t1),
                    u_zoom_transition: new e.aa(t1),
                    u_inv_rot_matrix: new e.a6(t1),
                    u_merc_center: new e.a8(t1),
                    u_up_dir: new e.aq(t1),
                    u_height_lift: new e.aa(t1),
                    u_flood_light_color: new e.aq(t1),
                    u_vertical_scale: new e.aa(t1),
                    u_flood_light_intensity: new e.aa(t1),
                    u_ground_shadow_factor: new e.aq(t1),
                    u_emissive_strength: new e.aa(t1)
                }),
            fillExtrusionDepth: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_edge_radius: new e.aa(t1),
                    u_vertical_scale: new e.aa(t1)
                }),
            fillExtrusionPattern: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_lightpos: new e.aq(t1),
                    u_lightintensity: new e.aa(t1),
                    u_lightcolor: new e.aq(t1),
                    u_vertical_gradient: new e.aa(t1),
                    u_height_factor: new e.aa(t1),
                    u_edge_radius: new e.aa(t1),
                    u_ao: new e.a8(t1),
                    u_tile_id: new e.aq(t1),
                    u_zoom_transition: new e.aa(t1),
                    u_inv_rot_matrix: new e.a6(t1),
                    u_merc_center: new e.a8(t1),
                    u_up_dir: new e.aq(t1),
                    u_height_lift: new e.aa(t1),
                    u_image: new e.a7(t1),
                    u_texsize: new e.a8(t1),
                    u_pixel_coord_upper: new e.a8(t1),
                    u_pixel_coord_lower: new e.a8(t1),
                    u_tile_units_to_pixels: new e.aa(t1),
                    u_opacity: new e.aa(t1)
                }),
            fillExtrusionGroundEffect: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_opacity: new e.aa(t1),
                    u_ao_pass: new e.aa(t1),
                    u_meter_to_tile: new e.aa(t1),
                    u_ao: new e.a8(t1),
                    u_flood_light_intensity: new e.aa(t1),
                    u_flood_light_color: new e.aq(t1),
                    u_attenuation: new e.aa(t1),
                    u_edge_radius: new e.aa(t1),
                    u_fb: new e.a7(t1),
                    u_fb_size: new e.aa(t1)
                }),
            fill: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_emissive_strength: new e.aa(t1)
                }),
            fillPattern: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_emissive_strength: new e.aa(t1),
                    u_image: new e.a7(t1),
                    u_texsize: new e.a8(t1),
                    u_pixel_coord_upper: new e.a8(t1),
                    u_pixel_coord_lower: new e.a8(t1),
                    u_tile_units_to_pixels: new e.aa(t1)
                }),
            fillOutline: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_emissive_strength: new e.aa(t1),
                    u_world: new e.a8(t1)
                }),
            fillOutlinePattern: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_emissive_strength: new e.aa(t1),
                    u_world: new e.a8(t1),
                    u_image: new e.a7(t1),
                    u_texsize: new e.a8(t1),
                    u_pixel_coord_upper: new e.a8(t1),
                    u_pixel_coord_lower: new e.a8(t1),
                    u_tile_units_to_pixels: new e.aa(t1)
                }),
            circle: e.bI,
            collisionBox: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_camera_to_center_distance: new e.aa(t1),
                    u_extrude_scale: new e.a8(t1)
                }),
            collisionCircle: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_inv_matrix: new e.a6(t1),
                    u_camera_to_center_distance: new e.aa(t1),
                    u_viewport_size: new e.a8(t1)
                }),
            debug: (t1)=>({
                    u_color: new e.a9(t1),
                    u_matrix: new e.a6(t1),
                    u_overlay: new e.a7(t1),
                    u_overlay_scale: new e.aa(t1)
                }),
            clippingMask: (t1)=>({
                    u_matrix: new e.a6(t1)
                }),
            heatmap: (t1)=>({
                    u_extrude_scale: new e.aa(t1),
                    u_intensity: new e.aa(t1),
                    u_matrix: new e.a6(t1),
                    u_inv_rot_matrix: new e.a6(t1),
                    u_merc_center: new e.a8(t1),
                    u_tile_id: new e.aq(t1),
                    u_zoom_transition: new e.aa(t1),
                    u_up_dir: new e.aq(t1)
                }),
            heatmapTexture: (t1)=>({
                    u_image: new e.a7(t1),
                    u_color_ramp: new e.a7(t1),
                    u_opacity: new e.aa(t1)
                }),
            hillshade: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_image: new e.a7(t1),
                    u_latrange: new e.a8(t1),
                    u_light: new e.a8(t1),
                    u_shadow: new e.a9(t1),
                    u_highlight: new e.a9(t1),
                    u_emissive_strength: new e.aa(t1),
                    u_accent: new e.a9(t1)
                }),
            hillshadePrepare: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_image: new e.a7(t1),
                    u_dimension: new e.a8(t1),
                    u_zoom: new e.aa(t1)
                }),
            line: e.bJ,
            linePattern: e.bK,
            raster: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_normalize_matrix: new e.a6(t1),
                    u_globe_matrix: new e.a6(t1),
                    u_merc_matrix: new e.a6(t1),
                    u_grid_matrix: new e.ar(t1),
                    u_tl_parent: new e.a8(t1),
                    u_scale_parent: new e.aa(t1),
                    u_fade_t: new e.aa(t1),
                    u_opacity: new e.aa(t1),
                    u_image0: new e.a7(t1),
                    u_image1: new e.a7(t1),
                    u_brightness_low: new e.aa(t1),
                    u_brightness_high: new e.aa(t1),
                    u_saturation_factor: new e.aa(t1),
                    u_contrast_factor: new e.aa(t1),
                    u_spin_weights: new e.aq(t1),
                    u_perspective_transform: new e.a8(t1),
                    u_raster_elevation: new e.aa(t1),
                    u_zoom_transition: new e.aa(t1),
                    u_merc_center: new e.a8(t1),
                    u_cutoff_params: new e.as(t1),
                    u_colorization_mix: new e.as(t1),
                    u_colorization_offset: new e.aa(t1),
                    u_color_ramp: new e.a7(t1),
                    u_texture_offset: new e.a8(t1),
                    u_texture_res: new e.a8(t1),
                    u_emissive_strength: new e.aa(t1)
                }),
            rasterParticle: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_normalize_matrix: new e.a6(t1),
                    u_globe_matrix: new e.a6(t1),
                    u_merc_matrix: new e.a6(t1),
                    u_grid_matrix: new e.ar(t1),
                    u_tl_parent: new e.a8(t1),
                    u_scale_parent: new e.aa(t1),
                    u_fade_t: new e.aa(t1),
                    u_opacity: new e.aa(t1),
                    u_image0: new e.a7(t1),
                    u_image1: new e.a7(t1),
                    u_raster_elevation: new e.aa(t1),
                    u_zoom_transition: new e.aa(t1),
                    u_merc_center: new e.a8(t1),
                    u_cutoff_params: new e.as(t1)
                }),
            rasterParticleTexture: (t1)=>({
                    u_texture: new e.a7(t1),
                    u_opacity: new e.aa(t1)
                }),
            rasterParticleDraw: (t1)=>({
                    u_particle_texture: new e.a7(t1),
                    u_particle_texture_side_len: new e.aa(t1),
                    u_tile_offset: new e.a8(t1),
                    u_velocity: new e.a7(t1),
                    u_color_ramp: new e.a7(t1),
                    u_velocity_res: new e.a8(t1),
                    u_max_speed: new e.aa(t1),
                    u_uv_offset: new e.a8(t1),
                    u_data_scale: new e.a8(t1),
                    u_data_offset: new e.aa(t1),
                    u_particle_pos_scale: new e.aa(t1),
                    u_particle_pos_offset: new e.a8(t1)
                }),
            rasterParticleUpdate: (t1)=>({
                    u_particle_texture: new e.a7(t1),
                    u_particle_texture_side_len: new e.aa(t1),
                    u_velocity: new e.a7(t1),
                    u_velocity_res: new e.a8(t1),
                    u_max_speed: new e.aa(t1),
                    u_speed_factor: new e.aa(t1),
                    u_reset_rate: new e.aa(t1),
                    u_rand_seed: new e.aa(t1),
                    u_uv_offset: new e.a8(t1),
                    u_data_scale: new e.a8(t1),
                    u_data_offset: new e.aa(t1),
                    u_particle_pos_scale: new e.aa(t1),
                    u_particle_pos_offset: new e.a8(t1)
                }),
            symbolIcon: (t1)=>({
                    u_is_size_zoom_constant: new e.a7(t1),
                    u_is_size_feature_constant: new e.a7(t1),
                    u_size_t: new e.aa(t1),
                    u_size: new e.aa(t1),
                    u_camera_to_center_distance: new e.aa(t1),
                    u_rotate_symbol: new e.a7(t1),
                    u_aspect_ratio: new e.aa(t1),
                    u_fade_change: new e.aa(t1),
                    u_matrix: new e.a6(t1),
                    u_label_plane_matrix: new e.a6(t1),
                    u_coord_matrix: new e.a6(t1),
                    u_is_text: new e.a7(t1),
                    u_pitch_with_map: new e.a7(t1),
                    u_texsize: new e.a8(t1),
                    u_tile_id: new e.aq(t1),
                    u_zoom_transition: new e.aa(t1),
                    u_inv_rot_matrix: new e.a6(t1),
                    u_merc_center: new e.a8(t1),
                    u_camera_forward: new e.aq(t1),
                    u_tile_matrix: new e.a6(t1),
                    u_up_vector: new e.aq(t1),
                    u_ecef_origin: new e.aq(t1),
                    u_texture: new e.a7(t1),
                    u_icon_transition: new e.aa(t1),
                    u_color_adj_mat: new e.a6(t1)
                }),
            symbolSDF: (t1)=>({
                    u_is_size_zoom_constant: new e.a7(t1),
                    u_is_size_feature_constant: new e.a7(t1),
                    u_size_t: new e.aa(t1),
                    u_size: new e.aa(t1),
                    u_camera_to_center_distance: new e.aa(t1),
                    u_rotate_symbol: new e.a7(t1),
                    u_aspect_ratio: new e.aa(t1),
                    u_fade_change: new e.aa(t1),
                    u_matrix: new e.a6(t1),
                    u_label_plane_matrix: new e.a6(t1),
                    u_coord_matrix: new e.a6(t1),
                    u_is_text: new e.a7(t1),
                    u_pitch_with_map: new e.a7(t1),
                    u_texsize: new e.a8(t1),
                    u_texture: new e.a7(t1),
                    u_gamma_scale: new e.aa(t1),
                    u_device_pixel_ratio: new e.aa(t1),
                    u_tile_id: new e.aq(t1),
                    u_zoom_transition: new e.aa(t1),
                    u_inv_rot_matrix: new e.a6(t1),
                    u_merc_center: new e.a8(t1),
                    u_camera_forward: new e.aq(t1),
                    u_tile_matrix: new e.a6(t1),
                    u_up_vector: new e.aq(t1),
                    u_ecef_origin: new e.aq(t1),
                    u_is_halo: new e.a7(t1)
                }),
            symbolTextAndIcon: (t1)=>({
                    u_is_size_zoom_constant: new e.a7(t1),
                    u_is_size_feature_constant: new e.a7(t1),
                    u_size_t: new e.aa(t1),
                    u_size: new e.aa(t1),
                    u_camera_to_center_distance: new e.aa(t1),
                    u_rotate_symbol: new e.a7(t1),
                    u_aspect_ratio: new e.aa(t1),
                    u_fade_change: new e.aa(t1),
                    u_matrix: new e.a6(t1),
                    u_label_plane_matrix: new e.a6(t1),
                    u_coord_matrix: new e.a6(t1),
                    u_is_text: new e.a7(t1),
                    u_pitch_with_map: new e.a7(t1),
                    u_texsize: new e.a8(t1),
                    u_texsize_icon: new e.a8(t1),
                    u_texture: new e.a7(t1),
                    u_texture_icon: new e.a7(t1),
                    u_gamma_scale: new e.aa(t1),
                    u_device_pixel_ratio: new e.aa(t1),
                    u_is_halo: new e.a7(t1)
                }),
            background: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_emissive_strength: new e.aa(t1),
                    u_opacity: new e.aa(t1),
                    u_color: new e.a9(t1)
                }),
            backgroundPattern: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_emissive_strength: new e.aa(t1),
                    u_opacity: new e.aa(t1),
                    u_image: new e.a7(t1),
                    u_pattern_tl: new e.a8(t1),
                    u_pattern_br: new e.a8(t1),
                    u_texsize: new e.a8(t1),
                    u_pattern_size: new e.a8(t1),
                    u_pixel_coord_upper: new e.a8(t1),
                    u_pixel_coord_lower: new e.a8(t1),
                    u_tile_units_to_pixels: new e.aa(t1)
                }),
            terrainRaster: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_image0: new e.a7(t1),
                    u_skirt_height: new e.aa(t1),
                    u_ground_shadow_factor: new e.aq(t1)
                }),
            skybox: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_sun_direction: new e.aq(t1),
                    u_cubemap: new e.a7(t1),
                    u_opacity: new e.aa(t1),
                    u_temporal_offset: new e.aa(t1)
                }),
            skyboxGradient: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_color_ramp: new e.a7(t1),
                    u_center_direction: new e.aq(t1),
                    u_radius: new e.aa(t1),
                    u_opacity: new e.aa(t1),
                    u_temporal_offset: new e.aa(t1)
                }),
            skyboxCapture: (t1)=>({
                    u_matrix_3f: new e.ar(t1),
                    u_sun_direction: new e.aq(t1),
                    u_sun_intensity: new e.aa(t1),
                    u_color_tint_r: new e.as(t1),
                    u_color_tint_m: new e.as(t1),
                    u_luminance: new e.aa(t1)
                }),
            globeRaster: (t1)=>({
                    u_proj_matrix: new e.a6(t1),
                    u_globe_matrix: new e.a6(t1),
                    u_normalize_matrix: new e.a6(t1),
                    u_merc_matrix: new e.a6(t1),
                    u_zoom_transition: new e.aa(t1),
                    u_merc_center: new e.a8(t1),
                    u_image0: new e.a7(t1),
                    u_grid_matrix: new e.ar(t1),
                    u_skirt_height: new e.aa(t1),
                    u_far_z_cutoff: new e.aa(t1),
                    u_frustum_tl: new e.aq(t1),
                    u_frustum_tr: new e.aq(t1),
                    u_frustum_br: new e.aq(t1),
                    u_frustum_bl: new e.aq(t1),
                    u_globe_pos: new e.aq(t1),
                    u_globe_radius: new e.aa(t1),
                    u_viewport: new e.a8(t1)
                }),
            globeAtmosphere: (t1)=>({
                    u_frustum_tl: new e.aq(t1),
                    u_frustum_tr: new e.aq(t1),
                    u_frustum_br: new e.aq(t1),
                    u_frustum_bl: new e.aq(t1),
                    u_horizon: new e.aa(t1),
                    u_transition: new e.aa(t1),
                    u_fadeout_range: new e.aa(t1),
                    u_color: new e.as(t1),
                    u_high_color: new e.as(t1),
                    u_space_color: new e.as(t1),
                    u_temporal_offset: new e.aa(t1),
                    u_horizon_angle: new e.aa(t1)
                }),
            model: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_lighting_matrix: new e.a6(t1),
                    u_normal_matrix: new e.a6(t1),
                    u_node_matrix: new e.a6(t1),
                    u_lightpos: new e.aq(t1),
                    u_lightintensity: new e.aa(t1),
                    u_lightcolor: new e.aq(t1),
                    u_camera_pos: new e.aq(t1),
                    u_opacity: new e.aa(t1),
                    u_baseColorFactor: new e.as(t1),
                    u_emissiveFactor: new e.as(t1),
                    u_metallicFactor: new e.aa(t1),
                    u_roughnessFactor: new e.aa(t1),
                    u_baseTextureIsAlpha: new e.a7(t1),
                    u_alphaMask: new e.a7(t1),
                    u_alphaCutoff: new e.aa(t1),
                    u_baseColorTexture: new e.a7(t1),
                    u_metallicRoughnessTexture: new e.a7(t1),
                    u_normalTexture: new e.a7(t1),
                    u_occlusionTexture: new e.a7(t1),
                    u_emissionTexture: new e.a7(t1),
                    u_lutTexture: new e.a7(t1),
                    u_color_mix: new e.as(t1),
                    u_aoIntensity: new e.aa(t1),
                    u_emissive_strength: new e.aa(t1),
                    u_occlusionTextureTransform: new e.as(t1)
                }),
            modelDepth: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_instance: new e.a6(t1),
                    u_node_matrix: new e.a6(t1)
                }),
            groundShadow: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_ground_shadow_factor: new e.aq(t1)
                }),
            stars: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_up: new e.aq(t1),
                    u_right: new e.aq(t1),
                    u_intensity_multiplier: new e.aa(t1)
                }),
            occlusion: (t1)=>({
                    u_matrix: new e.a6(t1),
                    u_anchorPos: new e.aq(t1),
                    u_screenSizePx: new e.a8(t1),
                    u_occluderSizePx: new e.a8(t1),
                    u_color: new e.as(t1)
                })
        };
        function bo(t1, i, o) {
            const r = i.createTileMatrix(t1, t1.worldSize, o.toUnwrapped());
            return e.ad.multiply(new Float32Array(16), t1.projMatrix, r);
        }
        function wo(e, t1, i) {
            if (t1.projection.name === i.projection.name) return e.projMatrix;
            const o = i.clone();
            return o.setProjection(t1.projection), bo(o, t1.getProjection(), e);
        }
        function To(e, t1, i) {
            return t1.name === i.projection.name ? e.projMatrix : bo(i, t1, e);
        }
        let Eo;
        function Co(t1, i, o, r, a, n, s) {
            const l = t1.context, c = l.gl, h = t1.transform, _ = t1.getOrCreateProgram("collisionBox"), u = [];
            let d = 0, p = 0;
            for(let l = 0; l < r.length; l++){
                const f = r[l], m = i.getTile(f), g = m.getBucket(o);
                if (!g) continue;
                const v = wo(f, g, h);
                let x = v;
                0 === a[0] && 0 === a[1] || (x = t1.translatePosMatrix(v, m, a, n));
                const y = s ? g.textCollisionBox : g.iconCollisionBox, b = g.collisionCircleArray;
                if (b.length > 0) {
                    const t1 = e.ad.create(), i = x;
                    e.ad.mul(t1, g.placementInvProjMatrix, h.glCoordMatrix), e.ad.mul(t1, t1, g.placementViewportMatrix), u.push({
                        circleArray: b,
                        circleOffset: p,
                        transform: i,
                        invTransform: t1,
                        projection: g.getProjection()
                    }), d += b.length / 4, p = d;
                }
                y && (t1.terrain && t1.terrain.setupElevationDraw(m, _), _.draw(t1, c.LINES, e.ae.disabled, e.ag.disabled, t1.colorModeForRenderPass(), e.af.disabled, Ki(x, h, m, g.getProjection()), o.id, y.layoutVertexBuffer, y.indexBuffer, y.segments, null, h.zoom, null, [
                    y.collisionVertexBuffer,
                    y.collisionVertexBufferExt
                ]));
            }
            if (!s || !u.length) return;
            const f = t1.getOrCreateProgram("collisionCircle"), m = new e.bL;
            m.resize(4 * d), m._trim();
            let g = 0;
            for (const e of u)for(let t1 = 0; t1 < e.circleArray.length / 4; t1++){
                const i = 4 * t1, o = e.circleArray[i + 0], r = e.circleArray[i + 1], a = e.circleArray[i + 2], n = e.circleArray[i + 3];
                m.emplace(g++, o, r, a, n, 0), m.emplace(g++, o, r, a, n, 1), m.emplace(g++, o, r, a, n, 2), m.emplace(g++, o, r, a, n, 3);
            }
            (!Eo || Eo.length < 2 * d) && (Eo = function(t1) {
                const i = 2 * t1, o = new e.bu;
                o.resize(i), o._trim();
                for(let e = 0; e < i; e++){
                    const t1 = 6 * e;
                    o.uint16[t1 + 0] = 4 * e + 0, o.uint16[t1 + 1] = 4 * e + 1, o.uint16[t1 + 2] = 4 * e + 2, o.uint16[t1 + 3] = 4 * e + 2, o.uint16[t1 + 4] = 4 * e + 3, o.uint16[t1 + 5] = 4 * e + 0;
                }
                return o;
            }(d));
            const v = l.createIndexBuffer(Eo, !0), x = l.createVertexBuffer(m, e.bM.members, !0);
            for (const i of u){
                const r = {
                    u_matrix: i.transform,
                    u_inv_matrix: i.invTransform,
                    u_camera_to_center_distance: (y = h).getCameraToCenterDistance(i.projection),
                    u_viewport_size: [
                        y.width,
                        y.height
                    ]
                };
                f.draw(t1, c.TRIANGLES, e.ae.disabled, e.ag.disabled, t1.colorModeForRenderPass(), e.af.disabled, r, o.id, x, v, e.b.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, h.zoom);
            }
            var y;
            x.destroy(), v.destroy();
        }
        const So = e.ad.create();
        function Io(t1) {
            const i = t1._camera.getWorldToCamera(t1.worldSize, 1), o = e.ad.multiply([], i, t1.globeMatrix);
            e.ad.invert(o, o);
            const r = [
                0,
                0,
                0
            ], a = [
                0,
                1,
                0,
                0
            ];
            return e.aA.transformMat4(a, a, o), r[0] = a[0], r[1] = a[1], r[2] = a[2], e._.normalize(r, r), r;
        }
        function Lo({ width: t1, height: i, anchor: o, textOffset: r, textScale: a }, n) {
            const { horizontalAlign: s, verticalAlign: l } = e.bQ(o), c = -(s - .5) * t1, h = -(l - .5) * i, _ = e.bP(o, r);
            return new e.P((c / a + _[0]) * n, (h / a + _[1]) * n);
        }
        function Po(t1, i, o, r, a, n, s, l, c, h, _) {
            const u = t1.text.placedSymbolArray, d = t1.text.dynamicLayoutVertexArray, p = t1.icon.dynamicLayoutVertexArray, f = {}, m = t1.getProjection(), g = To(l, m, n), v = n.elevation, x = m.upVectorScale(l.canonical, n.center.lat, n.worldSize).metersToTile;
            d.clear();
            for(let p = 0; p < u.length; p++){
                const y = u.get(p), { tileAnchorX: b, tileAnchorY: w, numGlyphs: T } = y, E = y.hidden || !y.crossTileID || t1.allowVerticalPlacement && !y.placedOrientation ? null : r[y.crossTileID];
                if (E) {
                    let r = 0, u = 0, p = 0;
                    if (v) {
                        const e = v ? v.getAtTileOffset(l, b, w) : 0, [t1, i, o] = m.upVector(l.canonical, b, w);
                        r = e * t1 * x, u = e * i * x, p = e * o * x;
                    }
                    let [C, S, I, L] = Jt(y.projectedAnchorX + r, y.projectedAnchorY + u, y.projectedAnchorZ + p, o ? g : s);
                    const P = ei(n.getCameraToCenterDistance(m), L);
                    let A = a.evaluateSizeForFeature(t1.textSizeData, h, y) * P / e.bN;
                    o && (A *= t1.tilePixelRatio / c);
                    const R = Lo(E, A);
                    o ? ({ x: C, y: S, z: I } = m.projectTilePoint(b + R.x, w + R.y, l.canonical), [C, S, I] = Jt(C + r, S + u, I + p, s)) : (i && R._rotate(-n.angle), C += R.x, S += R.y, I = 0);
                    const D = t1.allowVerticalPlacement && y.placedOrientation === e.aE.vertical ? Math.PI / 2 : 0;
                    for(let t1 = 0; t1 < T; t1++)e.aH(d, C, S, I, D);
                    _ && y.associatedIconIndex >= 0 && (f[y.associatedIconIndex] = {
                        x: C,
                        y: S,
                        z: I,
                        angle: D
                    });
                } else ci(T, d);
            }
            if (_) {
                p.clear();
                const i = t1.icon.placedSymbolArray;
                for(let t1 = 0; t1 < i.length; t1++){
                    const o = i.get(t1), { numGlyphs: r } = o, a = f[t1];
                    if (o.hidden || !a) ci(r, p);
                    else {
                        const { x: t1, y: i, z: o, angle: n } = a;
                        for(let a = 0; a < r; a++)e.aH(p, t1, i, o, n);
                    }
                }
                t1.icon.dynamicLayoutVertexBuffer.updateData(p);
            }
            t1.text.dynamicLayoutVertexBuffer.updateData(d);
        }
        function Ao(t1, i, o, r, a, n, s = {}) {
            const l = o.paint.get("icon-translate"), c = o.paint.get("text-translate"), h = o.paint.get("icon-translate-anchor"), _ = o.paint.get("text-translate-anchor"), u = o.layout.get("icon-rotation-alignment"), d = o.layout.get("text-rotation-alignment"), p = o.layout.get("icon-pitch-alignment"), f = o.layout.get("text-pitch-alignment"), m = o.layout.get("icon-keep-upright"), g = o.layout.get("text-keep-upright"), v = o.paint.get("icon-color-saturation"), x = o.paint.get("icon-color-contrast"), y = o.paint.get("icon-color-brightness-min"), b = o.paint.get("icon-color-brightness-max"), w = o.paint.get("icon-occlusion-opacity").constantOr(0), T = o.paint.get("text-occlusion-opacity").constantOr(0), E = t1.context, C = E.gl, S = t1.transform, I = "map" === u, L = "map" === d, P = "map" === p, A = "map" === f, R = 1 !== w, D = 1 !== T, M = void 0 !== o.layout.get("symbol-sort-key").constantOr(1);
            let z = !1;
            const O = t1.depthModeForSublayer(0, e.ae.ReadOnly), F = [
                e.aj(S.center.lng),
                e.ak(S.center.lat)
            ], B = o.layout.get("text-variable-anchor"), k = "globe" === S.projection.name, N = [], U = [
                0,
                -1,
                0
            ];
            for (const a of r){
                const r = i.getTile(a), n = r.getBucket(o);
                if (!n) continue;
                if ("mercator" === n.projection.name && k) continue;
                if (n.fullyClipped) continue;
                const u = "globe" === n.projection.name, d = u ? e.a1(S.zoom) : 0, p = To(a, n.getProjection(), S), f = S.calculatePixelsToTileUnitsMatrix(r), w = B && n.hasTextData(), T = n.hasIconTextFit() && w && n.hasIconData(), E = n.getProjection().createInversionMatrix(S, a.canonical), O = ()=>{
                    const i = I && "point" !== o.layout.get("symbol-placement"), s = [];
                    o.hasInitialOcclusionOpacityProperties && R && t1.symbolParams.useOcclusionQueries && !u && !k && s.push("OCCLUSION_QUERIES"), o.hasInitialOcclusionOpacityProperties || s.push("SYMBOL_OCCLUSION_BY_TERRAIN_DEPTH");
                    const c = i || T, _ = o.paint.get("icon-image-cross-fade").constantOr(0);
                    t1.terrainRenderModeElevated() && P && s.push("PITCH_WITH_MAP_TERRAIN"), u && (s.push("PROJECTION_GLOBE_VIEW"), c && s.push("PROJECTED_POS_ON_VIEWPORT")), _ > 0 && s.push("ICON_TRANSITION"), n.icon.zOffsetVertexBuffer && s.push("Z_OFFSET"), s.push("TERRAIN_DEPTH_D24"), 0 === v && 0 === x && 0 === y && 1 === b || s.push("COLOR_ADJUSTMENT");
                    const g = n.icon.programConfigurations.get(o.id), w = t1.getOrCreateProgram(n.sdfIcons ? "symbolSDF" : "symbolIcon", {
                        config: g,
                        defines: s
                    });
                    let L;
                    const A = r.imageAtlasTexture ? r.imageAtlasTexture.size : [
                        0,
                        0
                    ], D = n.iconSizeData, M = e.aD(D, S.zoom), z = P || 0 !== S.pitch, O = Yt(p, r.tileID.canonical, P, I, S, n.getProjection(), f), B = Qt(p, r.tileID.canonical, P, I, S, n.getProjection(), f), N = t1.translatePosMatrix(B, r, l, h, !0), G = t1.translatePosMatrix(p, r, l, h), j = c ? So : O, V = I && !P && !i;
                    let W = U;
                    !k && !S.mercatorFromTransition || I || (W = Io(S));
                    const Z = u ? W : U;
                    if (n.sdfIcons && !n.iconsInText) L = _o(D.kind, M, V, P, t1, G, j, N, !1, A, !0, a, d, F, E, Z, n.getProjection());
                    else {
                        const e = o.getColorAdjustmentMatrix(v, x, y, b);
                        L = ho(D.kind, M, V, P, t1, G, j, N, !1, A, a, d, F, E, Z, n.getProjection(), e, _);
                    }
                    const q = r.imageAtlasTexture ? r.imageAtlasTexture : null, H = 1 !== o.layout.get("icon-size").constantOr(0) || n.iconsNeedLinear, $ = n.sdfIcons || t1.options.rotating || t1.options.zooming || H || z ? C.LINEAR : C.NEAREST, X = n.sdfIcons && 0 !== o.paint.get("icon-halo-width").constantOr(1), Y = t1.terrain && P && i ? e.ad.invert(e.ad.create(), O) : So;
                    if (i && n.icon) {
                        const e = S.elevation, i = e ? e.getAtTileOffsetFunc(a, S.center.lat, S.worldSize, n.getProjection()) : null, o = Kt(p, r.tileID.canonical, P, I, S, n.getProjection(), f);
                        ii(n, p, t1, !1, o, B, P, m, i, a);
                    }
                    return {
                        program: w,
                        buffers: n.icon,
                        uniformValues: L,
                        atlasTexture: q,
                        atlasTextureIcon: null,
                        atlasInterpolation: $,
                        atlasInterpolationIcon: null,
                        isSDF: n.sdfIcons,
                        hasHalo: X,
                        tile: r,
                        labelPlaneMatrixInv: Y
                    };
                }, G = ()=>{
                    const i = L && "point" !== o.layout.get("symbol-placement"), s = [], l = i || B || T;
                    o.hasInitialOcclusionOpacityProperties && D && t1.symbolParams.useOcclusionQueries && !u && !k && s.push("OCCLUSION_QUERIES"), o.hasInitialOcclusionOpacityProperties || s.push("SYMBOL_OCCLUSION_BY_TERRAIN_DEPTH"), t1.terrainRenderModeElevated() && A && s.push("PITCH_WITH_MAP_TERRAIN"), u && (s.push("PROJECTION_GLOBE_VIEW"), l && s.push("PROJECTED_POS_ON_VIEWPORT")), n.text.zOffsetVertexBuffer && s.push("Z_OFFSET"), s.push("TERRAIN_DEPTH_D24");
                    const h = n.text.programConfigurations.get(o.id), m = t1.getOrCreateProgram(n.iconsInText ? "symbolTextAndIcon" : "symbolSDF", {
                        config: h,
                        defines: s
                    });
                    let v, x = [
                        0,
                        0
                    ], y = null;
                    const b = n.textSizeData;
                    n.iconsInText && (x = r.imageAtlasTexture ? r.imageAtlasTexture.size : [
                        0,
                        0
                    ], y = r.imageAtlasTexture ? r.imageAtlasTexture : null, v = A || 0 !== S.pitch || t1.options.rotating || t1.options.zooming || "composite" === b.kind || "camera" === b.kind ? C.LINEAR : C.NEAREST);
                    const w = r.glyphAtlasTexture ? r.glyphAtlasTexture.size : [
                        0,
                        0
                    ], I = e.aD(b, S.zoom), P = Yt(p, r.tileID.canonical, A, L, S, n.getProjection(), f), R = Qt(p, r.tileID.canonical, A, L, S, n.getProjection(), f), M = t1.translatePosMatrix(R, r, c, _, !0), z = t1.translatePosMatrix(p, r, c, _), O = l ? So : P, N = L && !A && !i;
                    let G = U;
                    !k && !S.mercatorFromTransition || L || (G = Io(S));
                    const j = u ? G : U;
                    let V;
                    V = n.iconsInText ? uo(b.kind, I, N, A, t1, z, O, M, w, x, a, d, F, E, j, n.getProjection()) : _o(b.kind, I, N, A, t1, z, O, M, !0, w, !0, a, d, F, E, j, n.getProjection());
                    const W = r.glyphAtlasTexture ? r.glyphAtlasTexture : null, Z = C.LINEAR, q = 0 !== o.paint.get("text-halo-width").constantOr(1), H = t1.terrain && A && i ? e.ad.invert(e.ad.create(), P) : So;
                    if (i && n.text) {
                        const e = S.elevation, i = e ? e.getAtTileOffsetFunc(a, S.center.lat, S.worldSize, n.getProjection()) : null, o = Kt(p, r.tileID.canonical, A, L, S, n.getProjection(), f);
                        ii(n, p, t1, !0, o, R, A, g, i, a);
                    }
                    return {
                        program: m,
                        buffers: n.text,
                        uniformValues: V,
                        atlasTexture: W,
                        atlasTextureIcon: y,
                        atlasInterpolation: Z,
                        atlasInterpolationIcon: v,
                        isSDF: !0,
                        hasHalo: q,
                        tile: r,
                        labelPlaneMatrixInv: H
                    };
                }, j = n.icon.segments.get().length, V = n.text.segments.get().length, W = j && !s.onlyText ? O() : null, Z = V && !s.onlyIcons ? G() : null, q = o.paint.get("icon-opacity").constantOr(1), H = o.paint.get("text-opacity").constantOr(1);
                if (M && n.canOverlap) {
                    z = !0;
                    const t1 = q && !s.onlyText ? n.icon.segments.get() : [], i = H && !s.onlyIcons ? n.text.segments.get() : [];
                    for (const i of t1)N.push({
                        segments: new e.b([
                            i
                        ]),
                        sortKey: i.sortKey,
                        state: W
                    });
                    for (const t1 of i)N.push({
                        segments: new e.b([
                            t1
                        ]),
                        sortKey: t1.sortKey,
                        state: Z
                    });
                } else s.onlyText || N.push({
                    segments: q ? n.icon.segments : new e.b([]),
                    sortKey: 0,
                    state: W
                }), s.onlyIcons || N.push({
                    segments: H ? n.text.segments : new e.b([]),
                    sortKey: 0,
                    state: Z
                });
            }
            z && N.sort((e, t1)=>e.sortKey - t1.sortKey);
            for (const e of N){
                const i = e.state;
                if (i) {
                    if (t1.terrain && t1.terrain.setupElevationDraw(i.tile, i.program, {
                        useDepthForOcclusion: !o.hasInitialOcclusionOpacityProperties && S.depthOcclusionForSymbolsAndCircles,
                        labelPlaneMatrixInv: i.labelPlaneMatrixInv
                    }), E.activeTexture.set(C.TEXTURE0), i.atlasTexture && i.atlasTexture.bind(i.atlasInterpolation, C.CLAMP_TO_EDGE, !0), i.atlasTextureIcon && (E.activeTexture.set(C.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, C.CLAMP_TO_EDGE, !0)), t1.uploadCommonLightUniforms(t1.context, i.program), i.hasHalo) {
                        const r = i.uniformValues;
                        r.u_is_halo = 1, Ro(i.buffers, e.segments, o, t1, i.program, O, a, n, r, 2), r.u_is_halo = 0;
                    } else {
                        if (i.isSDF) {
                            const r = i.uniformValues;
                            i.hasHalo && (r.u_is_halo = 1, Ro(i.buffers, e.segments, o, t1, i.program, O, a, n, r, 1)), r.u_is_halo = 0;
                        }
                        Ro(i.buffers, e.segments, o, t1, i.program, O, a, n, i.uniformValues, 1);
                    }
                }
            }
        }
        function Ro(t1, i, o, r, a, n, s, l, c, h) {
            const _ = r.context.gl, u = [
                t1.dynamicLayoutVertexBuffer,
                t1.opacityVertexBuffer,
                t1.iconTransitioningVertexBuffer,
                t1.globeExtVertexBuffer,
                t1.zOffsetVertexBuffer
            ];
            t1.occlusionQueryOpacityVertexBuffer.length > 0 && u.push(t1.occlusionQueryOpacityVertexBuffer), a.draw(r, _.TRIANGLES, n, s, l, e.af.disabled, c, o.id, t1.layoutVertexBuffer, t1.indexBuffer, i, o.paint, r.transform.zoom, t1.programConfigurations.get(o.id), u, h);
        }
        function Do(t1, i, o, r, a, n, s) {
            const l = t1.context.gl, c = o.paint.get("fill-pattern"), h = c && c.constantOr(1);
            let _, u, d, p, f;
            s ? (u = h && !o.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", _ = l.LINES) : (u = h ? "fillPattern" : "fill", _ = l.TRIANGLES);
            for (const m of r){
                const r = i.getTile(m);
                if (h && !r.patternsLoaded()) continue;
                const g = r.getBucket(o);
                if (!g) continue;
                t1.prepareDrawTile();
                const v = g.programConfigurations.get(o.id), x = t1.isTileAffectedByFog(m), y = t1.getOrCreateProgram(u, {
                    config: v,
                    overrideFog: x
                });
                h && (t1.context.activeTexture.set(l.TEXTURE0), r.imageAtlasTexture && r.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), v.updatePaintBuffers());
                const b = c.constantOr(null);
                if (b && r.imageAtlas) {
                    const e = r.imageAtlas.patternPositions[b.toString()];
                    e && v.setConstantPatternPositions(e);
                }
                const w = t1.translatePosMatrix(m.projMatrix, r, o.paint.get("fill-translate"), o.paint.get("fill-translate-anchor")), T = o.paint.get("fill-emissive-strength");
                if (s) {
                    p = g.indexBuffer2, f = g.segments2;
                    const e = t1.terrain && t1.terrain.renderingToTexture ? t1.terrain.drapeBufferSize : [
                        l.drawingBufferWidth,
                        l.drawingBufferHeight
                    ];
                    d = "fillOutlinePattern" === u && h ? Yi(w, T, t1, r, e) : Xi(w, T, e);
                } else p = g.indexBuffer, f = g.segments, d = h ? $i(w, T, t1, r) : Hi(w, T);
                t1.uploadCommonUniforms(t1.context, y, m.toUnwrapped()), y.draw(t1, _, a, t1.stencilModeForClipping(m), n, e.af.disabled, d, o.id, g.layoutVertexBuffer, p, f, o.paint, t1.transform.zoom, v, void 0);
            }
        }
        function Mo(t1, i, o, r, a, n, s, l) {
            o.resetLayerRenderingStats(t1);
            const c = t1.context, h = c.gl, _ = t1.transform, u = o.paint.get("fill-extrusion-pattern"), d = u.constantOr(1), p = o.paint.get("fill-extrusion-opacity"), f = t1.style.enable3dLights(), m = o.paint.get(f && !d ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), g = [
                o.paint.get("fill-extrusion-ambient-occlusion-intensity"),
                m
            ], v = o.layout.get("fill-extrusion-edge-radius"), x = v > 0 && !o.paint.get("fill-extrusion-rounded-roof"), y = x ? 0 : v, b = "globe" === _.projection.name ? e.bY() : 0, w = "globe" === _.projection.name, T = w ? e.a1(_.zoom) : 0, E = [
                e.aj(_.center.lng),
                e.ak(_.center.lat)
            ], C = o.paint.get("fill-extrusion-flood-light-color").toRenderColor(o.lut).toArray01().slice(0, 3), S = o.paint.get("fill-extrusion-flood-light-intensity"), I = o.paint.get("fill-extrusion-vertical-scale"), L = fi(t1, o.paint.get("fill-extrusion-cutoff-fade-range")), P = o.paint.get("fill-extrusion-emissive-strength"), A = [];
            let R;
            w && A.push("PROJECTION_GLOBE_VIEW"), g[0] > 0 && A.push("FAUX_AO"), x && A.push("ZERO_ROOF_RADIUS"), l && A.push("HAS_CENTROID"), S > 0 && A.push("FLOOD_LIGHT"), L.shouldRenderCutoff && A.push("RENDER_CUTOFF");
            const D = "shadow" === t1.renderPass, M = t1.shadowRenderer, z = D && !!M;
            t1.shadowRenderer && (t1.shadowRenderer.useNormalOffset = !0);
            let O = [
                0,
                0,
                0
            ];
            if (M) {
                const e = t1.style.directionalLight, i = t1.style.ambientLight;
                e && i && (O = wi(t1.style, e, i)), R = A.concat([
                    "SHADOWS_SINGLE_CASCADE"
                ]);
            }
            const F = z ? "fillExtrusionDepth" : d ? "fillExtrusionPattern" : "fillExtrusion", B = o.getLayerRenderingStats();
            for (const f of r){
                const r = i.getTile(f), m = r.getBucket(o);
                if (!m || m.projection.name !== _.projection.name) continue;
                let v = !1;
                M && (v = 0 === M.getMaxCascadeForTile(f.toUnwrapped()));
                const x = t1.isTileAffectedByFog(f), z = m.programConfigurations.get(o.id), k = t1.getOrCreateProgram(F, {
                    config: z,
                    defines: v ? R : A,
                    overrideFog: x
                });
                if (t1.terrain && t1.terrain.setupElevationDraw(r, k, {
                    useMeterToDem: !0
                }), !m.centroidVertexBuffer) {
                    const e = k.attributes.a_centroid_pos;
                    void 0 !== e && h.vertexAttrib2f(e, 0, 0);
                }
                !D && M && M.setupShadows(r.tileID.toUnwrapped(), k, "vector-tile", r.tileID.overscaledZ), d && (t1.context.activeTexture.set(h.TEXTURE0), r.imageAtlasTexture && r.imageAtlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), z.updatePaintBuffers());
                const N = u.constantOr(null);
                if (N && r.imageAtlas) {
                    const e = r.imageAtlas.patternPositions[N.toString()];
                    e && z.setConstantPatternPositions(e);
                }
                const U = o.paint.get("fill-extrusion-vertical-gradient");
                let G;
                if (D && M) {
                    if (No(r.tileID, m, t1)) continue;
                    const e = M.calculateShadowPassMatrixFromTile(r.tileID.toUnwrapped());
                    G = Zi(e, y, I);
                } else {
                    const e = t1.translatePosMatrix(f.expandedProjMatrix, r, o.paint.get("fill-extrusion-translate"), o.paint.get("fill-extrusion-translate-anchor")), i = _.projection.createInversionMatrix(_, f.canonical);
                    G = d ? qi(e, t1, U, p, g, y, f, r, b, T, E, i, C, I) : Wi(e, t1, U, p, g, y, f, b, T, E, i, C, I, S, O, P);
                }
                t1.uploadCommonUniforms(c, k, f.toUnwrapped(), null, L);
                let j = m.segments;
                if ("mercator" === _.projection.name && !D && (j = m.getVisibleSegments(r.tileID, t1.terrain, t1.transform.getFrustum(0)), !j.get().length)) continue;
                if (B) {
                    if (D) for (const e of j.get())B.numRenderedVerticesInShadowPass += e.primitiveLength;
                    else for (const e of j.get())B.numRenderedVerticesInTransparentPass += e.primitiveLength;
                }
                const V = [];
                (t1.terrain || l) && V.push(m.centroidVertexBuffer), w && V.push(m.layoutVertexExtBuffer), k.draw(t1, c.gl.TRIANGLES, a, n, s, e.af.backCCW, G, o.id, m.layoutVertexBuffer, m.indexBuffer, j, o.paint, t1.transform.zoom, z, V);
            }
            t1.shadowRenderer && (t1.shadowRenderer.useNormalOffset = !1);
        }
        function zo(t1, i, o, r, a, n, s, l, c, h, _, u, d, p, f, m, g, v, x) {
            const y = t1.context, b = y.gl, w = t1.transform, T = t1.transform.zoom, E = [], C = fi(t1, o.paint.get("fill-extrusion-cutoff-fade-range"));
            "clear" === h ? (E.push("CLEAR_SUBPASS"), x && (E.push("CLEAR_FROM_TEXTURE"), y.activeTexture.set(b.TEXTURE0), x.bind(b.LINEAR, b.CLAMP_TO_EDGE))) : "sdf" === h && E.push("SDF_SUBPASS"), g && E.push("HAS_CENTROID"), C.shouldRenderCutoff && E.push("RENDER_CUTOFF");
            const S = o.layout.get("fill-extrusion-edge-radius"), I = (e, i, r, h, v)=>{
                const b = i.programConfigurations.get(o.id), w = t1.isTileAffectedByFog(e), I = t1.getOrCreateProgram("fillExtrusionGroundEffect", {
                    config: b,
                    defines: E,
                    overrideFog: w
                }), L = ((e, t1, i, o, r, a, n, s, l, c, h)=>({
                        u_matrix: t1,
                        u_opacity: i,
                        u_ao_pass: o ? 1 : 0,
                        u_meter_to_tile: r,
                        u_ao: a,
                        u_flood_light_intensity: n,
                        u_flood_light_color: s,
                        u_attenuation: l,
                        u_edge_radius: c,
                        u_fb: 0,
                        u_fb_size: h
                    }))(0, h, _, c, v, [
                    u,
                    d * v
                ], p, f, m, T >= 17 ? 0 : S * v, x ? x.size[0] : 0), P = [];
                g && P.push(i.hiddenByLandmarkVertexBuffer), t1.uploadCommonUniforms(y, I, e.toUnwrapped(), null, C), I.draw(t1, y.gl.TRIANGLES, a, n, s, l, L, o.id, i.vertexBuffer, i.indexBuffer, r, o.paint, T, b, P);
            };
            for (const a of r){
                const r = i.getTile(a), n = r.getBucket(o);
                if (!n || n.projection.name !== w.projection.name || !n.groundEffect || n.groundEffect && !n.groundEffect.hasData()) continue;
                const s = n.groundEffect, l = 1 / n.tileToMeter;
                {
                    const e = t1.translatePosMatrix(a.projMatrix, r, o.paint.get("fill-extrusion-translate"), o.paint.get("fill-extrusion-translate-anchor")), i = s.getDefaultSegment();
                    I(a, s, i, e, l);
                }
                if (v) for(let n = 0; n < 4; n++){
                    const s = e.bZ[n](a), c = i.getTile(s);
                    if (!c) continue;
                    const h = c.getBucket(o);
                    if (!h || h.projection.name !== w.projection.name || !h.groundEffect || h.groundEffect && !h.groundEffect.hasData()) continue;
                    const _ = h.groundEffect;
                    let u, d;
                    0 === n ? (u = [
                        -e.a3,
                        0,
                        0
                    ], d = 1) : 1 === n ? (u = [
                        e.a3,
                        0,
                        0
                    ], d = 0) : 2 === n ? (u = [
                        0,
                        -e.a3,
                        0
                    ], d = 3) : (u = [
                        0,
                        e.a3,
                        0
                    ], d = 2);
                    const p = _.regionSegments[d];
                    if (!p) continue;
                    const f = new Float32Array(16);
                    e.ad.translate(f, a.projMatrix, u), I(a, _, p, t1.translatePosMatrix(f, r, o.paint.get("fill-extrusion-translate"), o.paint.get("fill-extrusion-translate-anchor")), l);
                }
            }
        }
        function Oo(t1, i, o, r, a, n, s) {
            0 === r.centroidVertexArray.length && r.createCentroidsBuffer();
            const l = n ? n.findDEMTileFor(o) : null;
            if (!(l && l.dem || s)) return;
            const c = (t1)=>new e.P(Math.ceil((t1 + e.c0) * e.c1), 0), h = (e)=>{
                const t1 = i.getSource().minzoom, o = (e)=>{
                    const t1 = i.getTileByID(e);
                    if (t1 && t1.hasData()) return t1.getBucket(a);
                }, r = [
                    0,
                    -1,
                    1
                ];
                for (const i of r){
                    if (e.overscaledZ + i < t1) continue;
                    const r = o(e.calculateScaledKey(e.overscaledZ + i));
                    if (r) return r;
                }
            }, _ = [
                0,
                0,
                0
            ], u = (t1, i)=>(_[0] = Math.min(t1.min.y, i.min.y), _[1] = Math.max(t1.max.y, i.max.y), _[2] = e.a3 - i.min.x > t1.max.x ? i.min.x - e.a3 : t1.max.x, _), d = (t1, i)=>(_[0] = Math.min(t1.min.x, i.min.x), _[1] = Math.max(t1.max.x, i.max.x), _[2] = e.a3 - i.min.y > t1.max.y ? i.min.y - e.a3 : t1.max.y, _), p = [
                (e, t1)=>u(e, t1),
                (e, t1)=>u(t1, e),
                (e, t1)=>d(e, t1),
                (e, t1)=>d(t1, e)
            ], f = (t1, i, r, a, s, c, h)=>{
                if (!n) return 0;
                const _ = [
                    [
                        c ? r : t1,
                        c ? t1 : r,
                        0
                    ],
                    [
                        c ? r : i,
                        c ? i : r,
                        0
                    ]
                ], u = h < 0 ? e.a3 + h : h, d = [
                    c ? u : (t1 + i) / 2,
                    c ? (t1 + i) / 2 : u,
                    0
                ];
                return 0 === r && h < 0 || 0 !== r && h > 0 ? n.getForTilePoints(s, [
                    d
                ], !0, a) : _.push(d), n.getForTilePoints(o, _, !0, l), Math.max(_[0][2], _[1][2], d[2]) / n.exaggeration();
            };
            for(let t1 = 0; t1 < 4; t1++){
                const i = r.borderFeatureIndices[t1];
                if (0 === i.length) continue;
                const a = e.bZ[t1](o), l = h(a);
                if (!(l && l instanceof e.b_)) continue;
                if (r.borderDoneWithNeighborZ[t1] === l.canonical.z) continue;
                0 === l.centroidVertexArray.length && l.createCentroidsBuffer();
                const _ = n ? n.findDEMTileFor(a) : null;
                if (!(_ && _.dem || s)) continue;
                const u = (t1 < 2 ? 1 : 5) - t1, d = l.borderDoneWithNeighborZ[u] !== r.canonical.z, v = l.borderFeatureIndices[u];
                let x = 0;
                if (r.canonical.z !== l.canonical.z) {
                    for (const e of i)r.showCentroid(r.featuresOnBorder[e]);
                    if (d) for (const e of v)l.showCentroid(l.featuresOnBorder[e]);
                    r.borderDoneWithNeighborZ[t1] = l.canonical.z, l.borderDoneWithNeighborZ[u] = r.canonical.z;
                }
                for (const o of i){
                    const i = r.featuresOnBorder[o], n = r.centroidData[i.centroidDataIndex], h = i.borders[t1];
                    let d;
                    for(; x < v.length;){
                        d = l.featuresOnBorder[v[x]];
                        const e = d.borders[u];
                        if (e[1] > h[0] + 3 || e[0] > h[0] - 3) break;
                        l.showCentroid(d), x++;
                    }
                    if (d && x < v.length) {
                        const o = x;
                        let y = 0;
                        for(; !(d.borders[u][0] > h[1] - 3) && (y++, ++x !== v.length);)d = l.featuresOnBorder[v[x]];
                        if (d = l.featuresOnBorder[v[o]], y > 1) {
                            const e = d.borders[u];
                            Math.abs(h[0] - e[0]) < 3 && Math.abs(h[1] - e[1]) < 3 && (y = 1, x = o + 1);
                        } else if (0 === y) {
                            r.showCentroid(i);
                            continue;
                        }
                        const b = l.centroidData[d.centroidDataIndex];
                        s && 1 === y && (((m = n).flags | (g = b).flags) & e.b$ ? (m.flags |= e.b$, g.flags |= e.b$) : (m.flags &= ~e.b$, g.flags &= ~e.b$));
                        const w = i.intersectsCount() > 1 || d.intersectsCount() > 1;
                        if (y > 1) x = o, n.centroidXY = b.centroidXY = new e.P(0, 0);
                        else if (_ && _.dem && !w) {
                            const i = p[t1](n, b), o = t1 % 2 ? e.a3 - 1 : 0, r = f(i[0], Math.min(e.a3 - 1, i[1]), o, _, a, t1 < 2, i[2]);
                            n.centroidXY = b.centroidXY = c(r);
                        } else w ? n.centroidXY = b.centroidXY = new e.P(0, 0) : (n.centroidXY = r.encodeBorderCentroid(i), b.centroidXY = l.encodeBorderCentroid(d));
                        r.writeCentroidToBuffer(n), l.writeCentroidToBuffer(b);
                    } else r.showCentroid(i);
                }
                r.borderDoneWithNeighborZ[t1] = l.canonical.z, l.borderDoneWithNeighborZ[u] = r.canonical.z;
            }
            var m, g;
            (r.needsCentroidUpdate || !r.centroidVertexBuffer && 0 !== r.centroidVertexArray.length) && r.uploadCentroid(t1);
        }
        const Fo = [
            1,
            0,
            0
        ], Bo = [
            0,
            1,
            0
        ], ko = [
            0,
            0,
            1
        ];
        function No(t1, i, o) {
            const r = o.transform, a = o.shadowRenderer;
            if (!a) return !0;
            const n = t1.toUnwrapped(), s = r.tileSize * a._cascades[o.currentShadowCascade].scale;
            let l = i.maxHeight;
            if (r.elevation) {
                const e = r.elevation.getMinMaxForTile(t1);
                e && (l += e.max);
            }
            const c = [
                ...a.shadowDirection
            ];
            c[2] = -c[2];
            const h = a.computeSimplifiedTileShadowVolume(n, l, s, c);
            if (!h) return !1;
            const _ = [
                Fo,
                Bo,
                ko,
                c,
                [
                    c[0],
                    0,
                    c[2]
                ],
                [
                    0,
                    c[1],
                    c[2]
                ]
            ], u = "globe" === r.projection.name, d = r.scaleZoom(s), p = e.aM.fromInvProjectionMatrix(r.invProjMatrix, r.worldSize, d, !u), f = a.getCurrentCascadeFrustum();
            return 0 === p.intersectsPrecise(h.vertices, h.planes, _) || 0 === f.intersectsPrecise(h.vertices, h.planes, _);
        }
        function Uo(t1) {
            return [
                t1[0] * e.c2,
                t1[1] * e.c2,
                t1[2] * e.c2,
                0
            ];
        }
        function Go(t1, i, o, r, a, n, s, l, c) {
            const h = r.getSource(), _ = o.globeSharedBuffers;
            if (!_) return;
            let u, d, p;
            if (i && (u = r.getTile(i)), h instanceof e.bm ? (d = h.texture, p = e.bh(0, 0, o.transform)) : u && i && (d = u.texture, p = e.bh(i.canonical.z, i.canonical.x, o.transform)), !d || !p) return;
            t1 || (p = e.ad.scale(e.ad.create(), p, [
                1,
                -1,
                1
            ]));
            const f = o.context, m = f.gl, g = "nearest" === a.paint.get("raster-resampling") ? m.NEAREST : m.LINEAR, v = o.colorModeForDrapableLayerRenderPass(n), x = s.defines;
            x.push("GLOBE_POLES");
            const y = new e.ae(m.LEQUAL, e.ae.ReadWrite, o.depthRangeFor3D), b = Float32Array.from(o.transform.expandedFarZProjMatrix), w = Float32Array.from(e.bf(e.bg(new e.aO(0, 0, 0))));
            o.terrain && o.terrain.prepareDrawTile(), f.activeTexture.set(m.TEXTURE0), d.bind(g, m.CLAMP_TO_EDGE), f.activeTexture.set(m.TEXTURE1), d.bind(g, m.CLAMP_TO_EDGE), d.useMipmap && f.extTextureFilterAnisotropic && o.transform.pitch > 20 && m.texParameterf(m.TEXTURE_2D, f.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, f.extTextureFilterAnisotropicMax);
            const [T, E, C, S] = i ? _.getPoleBuffers(i.canonical.z, !1) : _.getPoleBuffers(0, !0), I = a.paint.get("raster-elevation");
            let L;
            t1 ? (L = T, o.renderDefaultNorthPole = 0 !== I) : (L = E, o.renderDefaultSouthPole = 0 !== I);
            const P = Uo(s.mix), A = ((e, t1, i, o, r, a, n, s, l, c, h, _, u)=>oo(e, t1, i, new Float32Array(16), new Float32Array(9), [
                    0,
                    0
                ], o, [
                    0,
                    0
                ], [
                    0,
                    0,
                    0,
                    0
                ], 1, {
                    opacity: 1,
                    mix: 0
                }, a, [
                    0,
                    0
                ], s, 2, c, h, _, 1, 0, u))(b, w, p, e.a1(o.transform.zoom), 0, a, 0, I, 0, P, s.offset, s.range, n), R = o.getOrCreateProgram("raster", {
                defines: x
            });
            o.uploadCommonUniforms(f, R, null), R.draw(o, m.TRIANGLES, y, c, v, l, A, a.id, L, C, S);
        }
        function jo(e) {
            const t1 = e._nearZ, i = e.projection.farthestPixelDistance(e), o = i - t1, r = .2 * e.height, a = t1 + r;
            return [
                t1,
                i,
                (a - r - t1) / o,
                (a - t1) / o
            ];
        }
        function Vo(t1, i, o, r) {
            if (t1) return i instanceof Ri && t1 instanceof e.c3 ? i.getTextureDescriptor(t1, o, !0) : {
                texture: t1.texture,
                mix: Uo(r.mix),
                offset: r.offset,
                buffer: 0,
                tileSize: 1
            };
        }
        function Wo(t1, i, o) {
            if (!t1) return null;
            const r = i.getTextureDescriptor(t1, o, !0);
            if (!r) return null;
            let { texture: a, mix: n, offset: s, tileSize: l, buffer: c, format: h } = r;
            if (!a || !h) return null;
            let _ = !1;
            return "uint32" === h && (_ = !0, n[3] = 0, n = to(e.c4, n, [
                0,
                o.paint.get("raster-particle-max-speed")
            ]), s = io(e.c4, s, [
                0,
                o.paint.get("raster-particle-max-speed")
            ])), {
                texture: a,
                textureOffset: [
                    c / (l + 2 * c),
                    l / (l + 2 * c)
                ],
                tileSize: l,
                scalarData: _,
                scale: n,
                offset: s,
                defines: [
                    "RASTER_ARRAY",
                    {
                        uint8: "DATA_FORMAT_UINT8",
                        uint16: "DATA_FORMAT_UINT16",
                        uint32: "DATA_FORMAT_UINT32"
                    }[h]
                ]
            };
        }
        function Zo(e) {
            const t1 = e._nearZ, i = e.projection.farthestPixelDistance(e), o = i - t1, r = .2 * e.height, a = t1 + r;
            return [
                t1,
                i,
                (a - r - t1) / o,
                (a - t1) / o
            ];
        }
        const qo = new e.C(1, 0, 0, 1), Ho = new e.C(0, 1, 0, 1), $o = new e.C(0, 0, 1, 1), Xo = new e.C(1, 0, 1, 1), Yo = new e.C(0, 1, 1, 1);
        function Ko(t1, i, o, r, a, n, s) {
            const l = t1.context, c = t1.transform, h = l.gl, _ = "globe" === c.projection.name, u = _ ? [
                "PROJECTION_GLOBE_VIEW"
            ] : [];
            let d = e.ad.clone(o.projMatrix);
            if (_ && e.a1(c.zoom) > 0) {
                const t1 = e.c5(o.canonical, c), i = e.c6(t1);
                d = e.ad.multiply(new Float32Array(16), c.globeMatrix, i), e.ad.multiply(d, c.projMatrix, d);
            }
            const p = e.ad.create();
            p[12] += 2 * a / (e.e.devicePixelRatio * c.width), p[13] += 2 * n / (e.e.devicePixelRatio * c.height), e.ad.multiply(d, p, d);
            const f = t1.getOrCreateProgram("debug", {
                defines: u
            }), m = i.getTileByID(o.key);
            t1.terrain && t1.terrain.setupElevationDraw(m, f);
            const g = e.ae.disabled, v = e.ag.disabled, x = t1.colorModeForRenderPass(), y = "$debug";
            l.activeTexture.set(h.TEXTURE0), t1.emptyTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), _ ? m._makeGlobeTileDebugBuffers(t1.context, c) : m._makeDebugTileBoundsBuffers(t1.context, c.projection);
            const b = m._tileDebugBuffer || t1.debugBuffer, w = m._tileDebugIndexBuffer || t1.debugIndexBuffer, T = m._tileDebugSegments || t1.debugSegments;
            if (f.draw(t1, h.LINE_STRIP, g, v, x, e.af.disabled, Qi(d, r), y, b, w, T, null, null, null, [
                m._globeTileDebugBorderBuffer
            ]), s) {
                const e = m.latestRawTileData, i = Math.floor((e && e.byteLength || 0) / 1024);
                let r = o.canonical.toString();
                o.overscaledZ !== o.canonical.z && (r += ` => ${o.overscaledZ}`), r += ` ${m.state}`, r += ` ${i}kb`, function(e, t1) {
                    e.initDebugOverlayCanvas();
                    const i = e.debugOverlayCanvas, o = e.context.gl, r = e.debugOverlayCanvas.getContext("2d");
                    r.clearRect(0, 0, i.width, i.height), r.shadowColor = "white", r.shadowBlur = 2, r.lineWidth = 1.5, r.strokeStyle = "white", r.textBaseline = "top", r.font = "bold 36px Open Sans, sans-serif", r.fillText(t1, 5, 5), r.strokeText(t1, 5, 5), e.debugOverlayTexture.update(i), e.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);
                }(t1, r);
            }
            const E = i.getTile(o).tileSize, C = 512 / Math.min(E, 512) * (o.overscaledZ / c.zoom) * .5, S = m._tileDebugTextBuffer || t1.debugBuffer, I = m._tileDebugTextIndexBuffer || t1.quadTriangleIndexBuffer, L = m._tileDebugTextSegments || t1.debugSegments;
            f.draw(t1, h.TRIANGLES, g, v, e.a.alphaBlended, e.af.disabled, Qi(d, e.C.transparent, C), y, S, I, L, null, null, null, [
                m._globeTileDebugTextBuffer
            ]);
        }
        function Qo(e, t1, i, o) {
            er(e, 0, t1 + i / 2, e.transform.width, i, o);
        }
        function Jo(e, t1, i, o) {
            er(e, t1 - i / 2, 0, i, e.transform.height, o);
        }
        function er(t1, i, o, r, a, n) {
            const s = t1.context, l = s.gl;
            l.enable(l.SCISSOR_TEST), l.scissor(i * e.e.devicePixelRatio, o * e.e.devicePixelRatio, r * e.e.devicePixelRatio, a * e.e.devicePixelRatio), s.clear({
                color: n
            }), l.disable(l.SCISSOR_TEST);
        }
        const tr = e.c7([
            {
                name: "a_pos_3f",
                components: 3,
                type: "Float32"
            }
        ]), { members: ir } = tr;
        function or(e, t1, i, o) {
            e.emplaceBack(t1, i, o);
        }
        class rr {
            constructor(t1){
                this.vertexArray = new e.c8, this.indices = new e.bu, or(this.vertexArray, -1, -1, 1), or(this.vertexArray, 1, -1, 1), or(this.vertexArray, -1, 1, 1), or(this.vertexArray, 1, 1, 1), or(this.vertexArray, -1, -1, -1), or(this.vertexArray, 1, -1, -1), or(this.vertexArray, -1, 1, -1), or(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t1.createVertexBuffer(this.vertexArray, ir), this.indexBuffer = t1.createIndexBuffer(this.indices), this.segment = e.b.simpleSegment(0, 0, 36, 12);
            }
        }
        function ar(t1, i, o, r, a, n) {
            const s = t1.context.gl, l = i.paint.get("sky-atmosphere-color"), c = i.paint.get("sky-atmosphere-halo-color"), h = i.paint.get("sky-atmosphere-sun-intensity"), _ = ((e, t1, i, o, r)=>({
                    u_matrix_3f: e,
                    u_sun_direction: t1,
                    u_sun_intensity: i,
                    u_color_tint_r: [
                        o.r,
                        o.g,
                        o.b,
                        o.a
                    ],
                    u_color_tint_m: [
                        r.r,
                        r.g,
                        r.b,
                        r.a
                    ],
                    u_luminance: 5e-5
                }))(e.bC.fromMat4(e.bC.create(), r), a, h, l, c);
            s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + n, i.skyboxTexture, 0), o.draw(t1, s.TRIANGLES, e.ae.disabled, e.ag.disabled, e.a.unblended, e.af.frontCW, _, "skyboxCapture", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
        }
        const nr = e.c7([
            {
                type: "Float32",
                name: "a_pos",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            }
        ]);
        class sr {
            constructor(t1){
                const i = new e.c9;
                i.emplaceBack(-1, 1, 1, 0, 0), i.emplaceBack(1, 1, 1, 1, 0), i.emplaceBack(1, -1, 1, 1, 1), i.emplaceBack(-1, -1, 1, 0, 1);
                const o = new e.bu;
                o.emplaceBack(0, 1, 2), o.emplaceBack(2, 3, 0), this.vertexBuffer = t1.createVertexBuffer(i, nr.members), this.indexBuffer = t1.createIndexBuffer(o), this.segments = e.b.simpleSegment(0, 0, 4, 2);
            }
            destroy() {
                this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
            }
        }
        const lr = e.c7([
            {
                type: "Float32",
                name: "a_pos_3f",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            },
            {
                type: "Float32",
                name: "a_size_scale",
                components: 1
            },
            {
                type: "Float32",
                name: "a_fade_opacity",
                components: 1
            }
        ]);
        class cr {
            constructor(){
                this.starsCount = 16e3, this.sizeMultiplier = .15, this.sizeRange = 100, this.intensityRange = 200;
            }
        }
        class hr {
            constructor(t1){
                this.colorModeAlphaBlendedWriteRGB = new e.a([
                    e.ca,
                    e.cb,
                    e.ca,
                    e.cb
                ], e.C.transparent, [
                    !0,
                    !0,
                    !0,
                    !1
                ]), this.colorModeWriteAlpha = new e.a([
                    e.ca,
                    e.cc,
                    e.ca,
                    e.cc
                ], e.C.transparent, [
                    !1,
                    !1,
                    !1,
                    !0
                ]), this.params = new cr, this.updateNeeded = !0, t1.tp.registerParameter(this.params, [
                    "Stars"
                ], "starsCount", {
                    min: 100,
                    max: 16e3,
                    step: 1
                }, ()=>{
                    this.updateNeeded = !0;
                }), t1.tp.registerParameter(this.params, [
                    "Stars"
                ], "sizeMultiplier", {
                    min: .01,
                    max: 2,
                    step: .01
                }), t1.tp.registerParameter(this.params, [
                    "Stars"
                ], "sizeRange", {
                    min: 0,
                    max: 200,
                    step: 1
                }, ()=>{
                    this.updateNeeded = !0;
                }), t1.tp.registerParameter(this.params, [
                    "Stars"
                ], "intensityRange", {
                    min: 0,
                    max: 200,
                    step: 1
                }, ()=>{
                    this.updateNeeded = !0;
                });
            }
            update(t1) {
                const i = t1.context;
                if (!this.atmosphereBuffer || this.updateNeeded) {
                    this.updateNeeded = !1, this.atmosphereBuffer = new sr(i);
                    const t1 = this.params.sizeRange, o = this.params.intensityRange, r = function(t1) {
                        const i = e.cf(30), o = [];
                        for(let r = 0; r < t1; ++r){
                            const t1 = 2 * Math.PI * i(), r = Math.acos(1 - 2 * i()) - .5 * Math.PI;
                            o.push(e._.fromValues(Math.cos(r) * Math.cos(t1), Math.cos(r) * Math.sin(t1), Math.sin(r)));
                        }
                        return o;
                    }(this.params.starsCount), a = e.cf(300), n = new e.cd, s = new e.bu;
                    let l = 0;
                    for(let i = 0; i < r.length; ++i){
                        const c = e._.scale([], r[i], 200), h = Math.max(0, 1 + .01 * t1 * (1 * a() - .5)), _ = Math.max(0, 1 + .01 * o * (1 * a() - .5));
                        n.emplaceBack(c[0], c[1], c[2], -1, -1, h, _), n.emplaceBack(c[0], c[1], c[2], 1, -1, h, _), n.emplaceBack(c[0], c[1], c[2], 1, 1, h, _), n.emplaceBack(c[0], c[1], c[2], -1, 1, h, _), s.emplaceBack(l + 0, l + 1, l + 2), s.emplaceBack(l + 0, l + 2, l + 3), l += 4;
                    }
                    this.starsVx = i.createVertexBuffer(n, lr.members), this.starsIdx = i.createIndexBuffer(s), this.starsSegments = e.b.simpleSegment(0, 0, n.length, s.length);
                }
            }
            destroy() {
                this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
            }
            drawAtmosphereGlow(t1, i) {
                const o = t1.context, r = o.gl, a = t1.transform, n = new e.ae(r.LEQUAL, e.ae.ReadOnly, [
                    0,
                    1
                ]), s = e.a1(a.zoom), l = t1.style.getLut(i.scope), c = i.properties.get("color").toRenderColor(l).toArray01(), h = i.properties.get("high-color").toRenderColor(l).toArray01(), _ = i.properties.get("space-color").toRenderColor(l).toArray01PremultipliedAlpha(), u = 5e-4, d = e.ce(i.properties.get("horizon-blend"), 0, 1, u, .25), p = e.ba(t1, o, a) && d === u ? a.worldSize / (2 * Math.PI * 1.025) - 1 : a.globeRadius, f = t1.frameCounter / 1e3 % 1, m = e._.length(a.globeCenterInViewSpace), g = Math.sqrt(Math.pow(m, 2) - Math.pow(p, 2)), v = Math.acos(g / m), x = (i)=>{
                    const l = "globe" === a.projection.name ? [
                        "PROJECTION_GLOBE_VIEW",
                        "FOG"
                    ] : [
                        "FOG"
                    ];
                    i && l.push("ALPHA_PASS");
                    const u = t1.getOrCreateProgram("globeAtmosphere", {
                        defines: l
                    }), p = ((e, t1, i, o, r, a, n, s, l, c, h, _)=>({
                            u_frustum_tl: e,
                            u_frustum_tr: t1,
                            u_frustum_br: i,
                            u_frustum_bl: o,
                            u_horizon: r,
                            u_transition: a,
                            u_fadeout_range: n,
                            u_color: s,
                            u_high_color: l,
                            u_space_color: c,
                            u_temporal_offset: h,
                            u_horizon_angle: _
                        }))(a.frustumCorners.TL, a.frustumCorners.TR, a.frustumCorners.BR, a.frustumCorners.BL, a.frustumCorners.horizon, s, d, c, h, _, f, v);
                    t1.uploadCommonUniforms(o, u);
                    const m = this.atmosphereBuffer;
                    m && u.draw(t1, r.TRIANGLES, n, e.ag.disabled, i ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, e.af.backCW, p, i ? "atmosphere_glow_alpha" : "atmosphere_glow", m.vertexBuffer, m.indexBuffer, m.segments);
                };
                x(!1), x(!0);
            }
            drawStars(t1, i) {
                const o = e.at(i.properties.get("star-intensity"), 0, 1);
                if (0 === o) return;
                const r = t1.context, a = r.gl, n = t1.transform, s = t1.getOrCreateProgram("stars"), l = e.av.identity([]);
                e.av.rotateX(l, l, -n._pitch), e.av.rotateZ(l, l, -n.angle), e.av.rotateX(l, l, e.ab(n._center.lat)), e.av.rotateY(l, l, -e.ab(n._center.lng));
                const c = e.ad.fromQuat(new Float32Array(16), l), h = e.ad.multiply([], n.starsProjMatrix, c), _ = e.bC.fromMat4([], c), u = e.bC.invert([], _), d = [
                    0,
                    1,
                    0
                ];
                e._.transformMat3(d, d, u), e._.scale(d, d, this.params.sizeMultiplier);
                const p = [
                    1,
                    0,
                    0
                ];
                e._.transformMat3(p, p, u), e._.scale(p, p, this.params.sizeMultiplier);
                const f = (m = d, g = p, v = o, {
                    u_matrix: Float32Array.from(h),
                    u_up: m,
                    u_right: g,
                    u_intensity_multiplier: v
                });
                var m, g, v;
                t1.uploadCommonUniforms(r, s), this.starsVx && this.starsIdx && s.draw(t1, a.TRIANGLES, e.ae.disabled, e.ag.disabled, this.colorModeAlphaBlendedWriteRGB, e.af.disabled, f, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
            }
        }
        function _r(t1, i) {
            const o = [
                ...t1
            ], r = i.cameraWorldSizeForFog / i.worldSize, a = e.ad.identity([]);
            return e.ad.scale(a, a, [
                r,
                r,
                1
            ]), e.ad.multiply(o, a, o), e.ad.multiply(o, i.worldToFogMatrix, o), o;
        }
        function ur(t1, i, o, r, a) {
            const n = o.material, s = r.context, { baseColorTexture: l, metallicRoughnessTexture: c } = n.pbrMetallicRoughness, { normalTexture: h, occlusionTexture: _, emissionTexture: u } = n;
            function d(e, i, o) {
                if (e && (t1.push(i), s.activeTexture.set(s.gl.TEXTURE0 + o), e.gfxTexture)) {
                    const { minFilter: t1, magFilter: i, wrapS: o, wrapT: r } = e.sampler;
                    e.gfxTexture.bindExtraParam(t1, i, o, r);
                }
            }
            d(l, "HAS_TEXTURE_u_baseColorTexture", pi.BaseColor), d(c, "HAS_TEXTURE_u_metallicRoughnessTexture", pi.MetallicRoughness), d(h, "HAS_TEXTURE_u_normalTexture", pi.Normal), d(_, "HAS_TEXTURE_u_occlusionTexture", pi.Occlusion), d(u, "HAS_TEXTURE_u_emissionTexture", pi.Emission), a && (a.texture || (a.texture = new e.ch(r.context, a.image, [
                a.image.height,
                a.image.height,
                a.image.height
            ], s.gl.RGBA)), s.activeTexture.set(s.gl.TEXTURE0 + pi.LUT), a.texture && a.texture.bind(s.gl.LINEAR, s.gl.CLAMP_TO_EDGE), t1.push("APPLY_LUT_ON_GPU")), o.texcoordBuffer && (t1.push("HAS_ATTRIBUTE_a_uv_2f"), i.push(o.texcoordBuffer)), o.colorBuffer && (t1.push(12 === o.colorBuffer.itemSize ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), i.push(o.colorBuffer)), o.normalBuffer && (t1.push("HAS_ATTRIBUTE_a_normal_3f"), i.push(o.normalBuffer)), o.pbrBuffer && (t1.push("HAS_ATTRIBUTE_a_pbr"), t1.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), i.push(o.pbrBuffer)), "OPAQUE" !== n.alphaMode && "MASK" !== n.alphaMode || t1.push("UNPREMULT_TEXTURE_IN_SHADER"), n.defined || t1.push("DIFFUSE_SHADED"), t1.push("USE_STANDARD_DERIVATIVES");
        }
        function dr(t1, i, o, r, a, n) {
            const s = o.paint.get("model-opacity"), l = i.context, c = new e.ae(i.context.gl.LEQUAL, e.ae.ReadWrite, i.depthRangeFor3D), h = i.transform, _ = t1.mesh, u = _.material, d = u.pbrMetallicRoughness, p = i.style.fog;
            let f;
            f = "pixels" === i.transform.projection.zAxisUnit ? [
                ...t1.nodeModelMatrix
            ] : e.ad.multiply([], r.zScaleMatrix, t1.nodeModelMatrix), e.ad.multiply(f, r.negCameraPosMatrix, f);
            const m = e.ad.invert([], f);
            e.ad.transpose(m, m);
            const g = o.paint.get("model-emissive-strength").constantOr(0), v = go(new Float32Array(t1.worldViewProjection), new Float32Array(f), new Float32Array(m), null, i, s, d.baseColorFactor.toRenderColor(null), u.emissiveFactor, d.metallicFactor, d.roughnessFactor, u, g, o), x = {
                defines: []
            }, y = [];
            ur(x.defines, y, _, i, o.lut);
            const b = i.shadowRenderer;
            b && (b.useNormalOffset = !1);
            let w = null;
            if (p) {
                const e = _r(t1.nodeModelMatrix, i.transform);
                if (w = new Float32Array(e), "globe" !== h.projection.name) {
                    const t1 = _.aabb.min, i = _.aabb.max, [o, r] = p.getOpacityForBounds(e, t1[0], t1[1], i[0], i[1]);
                    x.overrideFog = o >= it || r >= it;
                }
            }
            const T = fi(i, o.paint.get("model-cutoff-fade-range"));
            T.shouldRenderCutoff && x.defines.push("RENDER_CUTOFF");
            const E = i.getOrCreateProgram("model", x);
            i.uploadCommonUniforms(l, E, null, w, T), "shadow" !== i.renderPass && b && b.setupShadowsFromMatrix(t1.nodeModelMatrix, E), E.draw(i, l.gl.TRIANGLES, c, a, n, _.material.doubleSided ? e.af.disabled : e.af.backCCW, v, o.id, _.vertexBuffer, _.indexBuffer, _.segments, o.paint, i.transform.zoom, void 0, y);
        }
        function pr(t1, i, o, r, a, n, s) {
            let l;
            l = "globe" === t1.projection.name ? e.ci(o, t1) : [
                ...o
            ], e.ad.multiply(l, l, i.matrix);
            const c = e.ad.multiply([], r, l);
            if (i.meshes) for (const t1 of i.meshes){
                if ("BLEND" !== t1.material.alphaMode) {
                    s.push({
                        mesh: t1,
                        depth: 0,
                        modelIndex: a,
                        worldViewProjection: c,
                        nodeModelMatrix: l
                    });
                    continue;
                }
                const i = e._.transformMat4([], t1.centroid, c);
                i[2] > 0 && n.push({
                    mesh: t1,
                    depth: i[2],
                    modelIndex: a,
                    worldViewProjection: c,
                    nodeModelMatrix: l
                });
            }
            if (i.children) for (const e of i.children)pr(t1, e, o, r, a, n, s);
        }
        function fr(t1, i, o, r) {
            const a = o.shadowRenderer;
            if (!a) return;
            const n = a.getShadowPassDepthMode(), s = a.getShadowPassColorMode(), l = a.calculateShadowPassMatrixFromMatrix(i), c = vo(l);
            o.getOrCreateProgram("modelDepth", {
                defines: o._shadowMapDebug ? [] : [
                    "DEPTH_TEXTURE"
                ]
            }).draw(o, o.context.gl.TRIANGLES, n, e.ag.disabled, s, e.af.backCCW, c, r.id, t1.vertexBuffer, t1.indexBuffer, t1.segments, r.paint, o.transform.zoom, void 0, void 0);
        }
        function mr(t1, i, o) {
            const r = i.updateZoomBasedPaintProperties(), a = function(t1, i, o) {
                let r, a, n, s = t1.terrain ? t1.terrain.exaggeration() : 0;
                if (t1.terrain && s > 0) {
                    const i = t1.terrain, a = i.findDEMTileFor(o);
                    a && a.dem ? r = e.ck.create(i, o, a) : s = 0;
                }
                if (0 === s && (i.terrainElevationMin = 0, i.terrainElevationMax = 0), s === i.validForExaggeration && (0 === s || r && r._demTile && r._demTile.tileID === i.validForDEMTile.id && r._dem._timestamp === i.validForDEMTile.timestamp)) return !1;
                for(const e in i.instancesPerModel){
                    const t1 = i.instancesPerModel[e];
                    for(let e = 0; e < t1.instancedDataArray.length; ++e){
                        const o = (r ? s * r.getElevationAt(0 | t1.instancedDataArray.float32[16 * e], 0 | t1.instancedDataArray.float32[16 * e + 1], !0, !0) : 0) + t1.instancesEvaluatedElevation[e];
                        t1.instancedDataArray.float32[16 * e + 6] = o, a = a ? Math.min(i.terrainElevationMin, o) : o, n = n ? Math.max(i.terrainElevationMax, o) : o;
                    }
                }
                return i.terrainElevationMin = a || 0, i.terrainElevationMax = n || 0, i.validForExaggeration = s, i.validForDEMTile = r && r._demTile ? {
                    id: r._demTile.tileID,
                    timestamp: r._dem._timestamp
                } : {
                    id: void 0,
                    timestamp: 0
                }, !0;
            }(t1, i, o);
            (r || a) && (i.uploaded = !1, i.upload(t1.context));
        }
        const gr = {
            shadowUniformsInitialized: !1,
            useSingleShadowCascade: !1,
            tileMatrix: new Float64Array(16),
            shadowTileMatrix: new Float32Array(16),
            aabb: new e.b6([
                0,
                0,
                0
            ], [
                e.a3,
                e.a3,
                0
            ])
        };
        function vr(t1, i) {
            const o = 1 << t1.canonical.z, r = i.getFreeCameraOptions().position, a = i.elevation, n = t1.canonical.x / o, s = (t1.canonical.x + 1) / o, l = t1.canonical.y / o, c = (t1.canonical.y + 1) / o;
            let h = i._centerAltitude;
            if (a) {
                const e = a.getMinMaxForTile(t1);
                e && e.max > h && (h = e.max);
            }
            const _ = e.at(r.x, n, s) - r.x, u = e.at(r.y, l, c) - r.y, d = e.ax(h, i.center.lat) - r.z;
            return i._zoomFromMercatorZ(Math.sqrt(_ * _ + u * u + d * d));
        }
        function xr(t1, i, o, r, a, n, s) {
            const l = t1.context, c = "shadow" === t1.renderPass, h = t1.shadowRenderer, _ = c && h ? h.getShadowPassDepthMode() : new e.ae(l.gl.LEQUAL, e.ae.ReadWrite, t1.depthRangeFor3D), u = t1.isTileAffectedByFog(n);
            if (o.meshes) for (const d of o.meshes){
                const p = [
                    "MODEL_POSITION_ON_GPU"
                ], f = [];
                let m, g, v;
                r.instancedDataArray.length > 20 && p.push("INSTANCED_ARRAYS");
                const x = fi(t1, i.paint.get("model-cutoff-fade-range"));
                if (x.shouldRenderCutoff && p.push("RENDER_CUTOFF"), c && h) m = t1.getOrCreateProgram("modelDepth", {
                    defines: p
                }), g = vo(s.shadowTileMatrix, s.shadowTileMatrix, Float32Array.from(o.matrix)), v = h.getShadowPassColorMode();
                else {
                    ur(p, f, d, t1, i.lut), m = t1.getOrCreateProgram("model", {
                        defines: p,
                        overrideFog: u
                    });
                    const r = d.material, c = r.pbrMetallicRoughness, _ = i.paint.get("model-opacity"), y = i.paint.get("model-emissive-strength").constantOr(0);
                    g = go(n.expandedProjMatrix, Float32Array.from(o.matrix), new Float32Array(16), null, t1, _, c.baseColorFactor.toRenderColor(null), r.emissiveFactor, c.metallicFactor, c.roughnessFactor, r, y, i, a), h && (s.shadowUniformsInitialized ? m.setShadowUniformValues(l, h.getShadowUniformValues()) : (h.setupShadows(n.toUnwrapped(), m, "model-tile", n.overscaledZ), s.shadowUniformsInitialized = !0)), v = x.shouldRenderCutoff || _ < 1 || "OPAQUE" !== r.alphaMode ? e.a.alphaBlended : e.a.unblended;
                }
                t1.uploadCommonUniforms(l, m, n.toUnwrapped(), null, x);
                const y = d.material.doubleSided ? e.af.disabled : e.af.backCCW;
                if (r.instancedDataArray.length > 20) f.push(r.instancedDataBuffer), m.draw(t1, l.gl.TRIANGLES, _, e.ag.disabled, v, y, g, i.id, d.vertexBuffer, d.indexBuffer, d.segments, i.paint, t1.transform.zoom, void 0, f, r.instancedDataArray.length);
                else {
                    const o = c ? "u_instance" : "u_normal_matrix";
                    for(let a = 0; a < r.instancedDataArray.length; ++a)g[o] = new Float32Array(r.instancedDataArray.arrayBuffer, 64 * a, 16), m.draw(t1, l.gl.TRIANGLES, _, e.ag.disabled, v, y, g, i.id, d.vertexBuffer, d.indexBuffer, d.segments, i.paint, t1.transform.zoom, void 0, f);
                }
            }
            if (o.children) for (const e of o.children)xr(t1, i, e, r, a, n, s);
        }
        const yr = [
            1,
            -1,
            1
        ];
        function br(t1, i, o, r) {
            if (!o.modelManager) return !0;
            const a = o.modelManager;
            if (!o.shadowRenderer) return !0;
            const n = o.shadowRenderer, s = i.aabb;
            let l = !0, c = t1.maxHeight;
            if (0 === c) {
                let e = 0;
                for(const i in t1.instancesPerModel){
                    const t1 = a.getModel(i, r);
                    t1 ? e = Math.max(e, Math.max(Math.max(t1.aabb.max[0], t1.aabb.max[1]), t1.aabb.max[2])) : l = !1;
                }
                c = t1.maxScale * e * 1.41 + t1.maxVerticalOffset, l && (t1.maxHeight = c);
            }
            s.max[2] = c, s.min[2] += t1.terrainElevationMin, s.max[2] += t1.terrainElevationMax, e._.transformMat4(s.min, s.min, i.tileMatrix), e._.transformMat4(s.max, s.max, i.tileMatrix);
            const h = s.intersects(n.getCurrentCascadeFrustum());
            return 0 === o.currentShadowCascade && (t1.isInsideFirstShadowMapFrustum = 2 === h), 0 === h;
        }
        function wr(t1, i) {
            const o = t1.uniformValues.u_cutoff_params[0], r = t1.uniformValues.u_cutoff_params[1], a = t1.uniformValues.u_cutoff_params[2], n = t1.uniformValues.u_cutoff_params[3];
            return r === o || n === a ? 1 : e.at(((i - o) / (r - o) - a) / (n - a), 0, 1);
        }
        function Tr(t1, i, o, r) {
            if (i.pitch < 20) return 1;
            const a = i.getWorldToCameraMatrix(), n = e.ad.multiply([], a, t1), s = [
                ...o.min,
                1
            ];
            let l = e.aA.transformMat4([], s, n), c = l, h = l;
            s[1] = o.max[1], l = e.aA.transformMat4([], s, n), c = l[1] < c[1] ? l : c, h = l[1] > h[1] ? l : h, s[0] = o.max[0], l = e.aA.transformMat4([], s, n), c = l[1] < c[1] ? l : c, h = l[1] > h[1] ? l : h, s[1] = o.min[1], l = e.aA.transformMat4([], s, n), c = l[1] < c[1] ? l : c, h = l[1] > h[1] ? l : h;
            const _ = e.at(r[0], 0, 1), u = 100 * i.pixelsPerMeter * e.at(r[1], 0, 1), d = e.at(r[2], 0, 1), p = e._.lerp([], c, h, _), f = Math.tan(.5 * i.fovX), m = -p[2] * f;
            if (0 === u) return p[1] < -Math.abs(m) ? d : 1;
            const g = (-Math.abs(m) - p[1]) / u, v = (e, t1, i)=>(1 - i) * e + i * t1, x = e.at(v(1, d, g), d, 1);
            return v(1, x, e.at((i.pitch - 20) / 20, 0, 1));
        }
        class Er {
        }
        class Cr {
            constructor(){
                this._storage = new Map;
            }
            getLinesFromTrianglesBuffer(t1, i, o) {
                {
                    const e = this._storage.get(i.id);
                    if (e) return e.lastUsedFrameIdx = t1, e.buf;
                }
                const r = o.gl, a = r.getBufferParameter(r.ELEMENT_ARRAY_BUFFER, r.BUFFER_SIZE), n = new ArrayBuffer(a), s = new Int16Array(n);
                r.getBufferSubData(r.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(n));
                const l = new e.cm;
                for(let e = 0; e < a / 2; e += 3){
                    const t1 = s[e], i = s[e + 1], o = s[e + 2];
                    l.emplaceBack(t1, i), l.emplaceBack(i, o), l.emplaceBack(o, t1);
                }
                const c = o.bindVertexArrayOES.current, h = new Er;
                return h.buf = new e.I(o, l), h.lastUsedFrameIdx = t1, this._storage.set(i.id, h), o.bindVertexArrayOES.set(c), h.buf;
            }
            update(e) {
                for (const [t1, i] of this._storage)e - i.lastUsedFrameIdx > 30 && (i.buf.destroy(), this._storage.delete(t1));
            }
            destroy() {
                for (const [e, t1] of this._storage)t1.buf.destroy(), this._storage.delete(e);
            }
        }
        const Sr = e.c7([
            {
                type: "Float32",
                name: "a_offset_xy",
                components: 2
            }
        ]);
        class Ir {
            constructor(t1){
                const i = new e.cn, o = new e.bu;
                i.emplaceBack(-1, -1), i.emplaceBack(1, -1), i.emplaceBack(1, 1), i.emplaceBack(-1, 1), o.emplaceBack(0, 1, 2), o.emplaceBack(0, 2, 3), this.segments = e.b.simpleSegment(0, 0, i.length, o.length), this.vx = t1.createVertexBuffer(i, Sr.members), this.idx = t1.createIndexBuffer(o);
            }
            destroy() {
                this.vx.destroy(), this.idx.destroy();
            }
        }
        const Lr = {
            symbol: function(t1, i, o, r, a) {
                if ("translucent" !== t1.renderPass) return;
                const n = e.ag.disabled, s = t1.colorModeForRenderPass();
                o.layout.get("text-variable-anchor") && function(t1, i, o, r, a, n, s) {
                    const l = i.transform, c = "map" === a, h = "map" === n;
                    for (const i of t1){
                        const t1 = r.getTile(i), a = t1.getBucket(o);
                        if (!a || !a.text || !a.text.segments.get().length) continue;
                        const n = e.aD(a.textSizeData, l.zoom), _ = To(i, a.getProjection(), l), u = l.calculatePixelsToTileUnitsMatrix(t1), d = Yt(_, t1.tileID.canonical, h, c, l, a.getProjection(), u), p = a.hasIconTextFit() && a.hasIconData();
                        if (n) {
                            const o = Math.pow(2, l.zoom - t1.tileID.overscaledZ);
                            Po(a, c, h, s, e.bO, l, d, i, o, n, p);
                        }
                    }
                }(r, t1, o, i, o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), a);
                const l = 0 !== o.paint.get("icon-opacity").constantOr(1), c = 0 !== o.paint.get("text-opacity").constantOr(1);
                void 0 !== o.layout.get("symbol-sort-key").constantOr(1) && (l || c) ? Ao(t1, i, o, r, n, s) : (l && Ao(t1, i, o, r, n, s, {
                    onlyIcons: !0
                }), c && Ao(t1, i, o, r, n, s, {
                    onlyText: !0
                }), function(t1, i, o, r) {
                    if (!t1.symbolParams.useOcclusionQueries) return;
                    const a = t1.context.gl, n = t1.transform, s = o.paint, l = s.get("icon-occlusion-opacity").constantOr(0), c = s.get("text-occlusion-opacity").constantOr(0);
                    if (!o.hasInitialOcclusionOpacityProperties || 1 === l && 1 === c) return;
                    const h = "globe" === n.projection.name;
                    for (const s of r){
                        const r = i.getTile(s), l = r.getBucket(o);
                        if (!l) continue;
                        if ("mercator" === l.projection.name && h) continue;
                        if (l.fullyClipped) continue;
                        if ("globe" === l.projection.name) {
                            e.w(`Occlusion not supported for globe mode. Layer: ${o.type}`);
                            continue;
                        }
                        const c = To(s, l.getProjection(), n), _ = e.ad.fromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, t1.symbolParams.depthOffset, 1), u = e.ad.multiply([], _, c), d = "none" !== t1.symbolParams.visualizeOcclusions ? 1 : t1.symbolParams.occlusionQueryFrameWindow;
                        for(let i = 0; i < l.symbolInstances.length; i++){
                            const o = l.symbolInstances.get(i), s = t1.style.placement.opacities[o.crossTileID];
                            if (s && s.isHidden()) continue;
                            if ((t1.frameCounter + i) % d != 0) continue;
                            const c = o.tileAnchorX, h = o.tileAnchorY, _ = o.zOffset;
                            let p;
                            if ("none" === t1.symbolParams.visualizeOcclusions) {
                                const e = l.queries.get(i);
                                if (e) {
                                    if (!e.isFree()) {
                                        if (!e.isResultAvailable()) continue;
                                        const t1 = e.consumeResult();
                                        o.occlusionState = 0 === t1 ? 0 : 1;
                                        continue;
                                    }
                                    p = e;
                                } else p = new ne(t1.context), l.queries.set(i, p);
                            }
                            const f = t1.getOrCreateProgram("occlusion"), m = t1.symbolParams.occluderSize, g = xo(u, [
                                c,
                                h,
                                _
                            ], [
                                n.width,
                                n.height
                            ], [
                                m,
                                m
                            ], "zPass" === t1.symbolParams.visualizeOcclusions ? [
                                1,
                                0,
                                0,
                                .8
                            ] : [
                                1,
                                .4,
                                .2,
                                .9
                            ]);
                            t1.terrain && t1.terrain.setupElevationDraw(r, f, {
                                useDepthForOcclusion: !1,
                                labelPlaneMatrixInv: void 0
                            }), "none" === t1.symbolParams.visualizeOcclusions && p && p.begin();
                            const v = new e.ae("zPass" === t1.symbolParams.visualizeOcclusions ? t1.context.gl.ALWAYS : t1.context.gl.LEQUAL, e.ae.ReadOnly, t1.depthRangeFor3D);
                            f.draw(t1, a.TRIANGLES, v, e.ag.disabled, "none" !== t1.symbolParams.visualizeOcclusions ? e.a.alphaBlendedNonPremultiplied : e.a.disabled, e.af.disabled, g, "occlusion", t1.occlusionBuffers.vx, t1.occlusionBuffers.idx, t1.occlusionBuffers.segments), "none" === t1.symbolParams.visualizeOcclusions && p && p.end();
                        }
                    }
                }(t1, i, o, r)), i.map.showCollisionBoxes && (Co(t1, i, o, r, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), !0), Co(t1, i, o, r, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), !1));
            },
            circle: function(t1, i, o, r) {
                if ("translucent" !== t1.renderPass) return;
                const a = o.paint.get("circle-opacity"), n = o.paint.get("circle-stroke-width"), s = o.paint.get("circle-stroke-opacity"), l = void 0 !== o.layout.get("circle-sort-key").constantOr(1), c = o.paint.get("circle-emissive-strength");
                if (0 === a.constantOr(1) && (0 === n.constantOr(1) || 0 === s.constantOr(1))) return;
                const h = t1.context, _ = h.gl, u = t1.transform, d = t1.depthModeForSublayer(0, e.ae.ReadOnly), p = e.ag.disabled, f = t1.colorModeForDrapableLayerRenderPass(c), m = "globe" === u.projection.name, g = [
                    e.aj(u.center.lng),
                    e.ak(u.center.lat)
                ], v = [];
                for(let a = 0; a < r.length; a++){
                    const n = r[a], s = i.getTile(n), c = s.getBucket(o);
                    if (!c || c.projection.name !== u.projection.name) continue;
                    const h = c.programConfigurations.get(o.id), _ = e.bR(o), d = t1.isTileAffectedByFog(n);
                    m && _.push("PROJECTION_GLOBE_VIEW"), _.push("TERRAIN_DEPTH_D24");
                    const p = t1.getOrCreateProgram("circle", {
                        config: h,
                        defines: _,
                        overrideFog: d
                    }), f = c.layoutVertexBuffer, x = c.globeExtVertexBuffer, y = c.indexBuffer, b = u.projection.createInversionMatrix(u, n.canonical), w = {
                        programConfiguration: h,
                        program: p,
                        layoutVertexBuffer: f,
                        globeExtVertexBuffer: x,
                        indexBuffer: y,
                        uniformValues: e.bS(t1, n, s, b, g, o),
                        tile: s
                    };
                    if (l) {
                        const t1 = c.segments.get();
                        for (const i of t1)v.push({
                            segments: new e.b([
                                i
                            ]),
                            sortKey: i.sortKey,
                            state: w
                        });
                    } else v.push({
                        segments: c.segments,
                        sortKey: 0,
                        state: w
                    });
                }
                l && v.sort((e, t1)=>e.sortKey - t1.sortKey);
                const x = {
                    useDepthForOcclusion: u.depthOcclusionForSymbolsAndCircles
                };
                for (const i of v){
                    const { programConfiguration: r, program: a, layoutVertexBuffer: n, globeExtVertexBuffer: s, indexBuffer: l, uniformValues: c, tile: m } = i.state, g = i.segments;
                    t1.terrain && t1.terrain.setupElevationDraw(m, a, x), t1.uploadCommonUniforms(h, a, m.tileID.toUnwrapped()), a.draw(t1, _.TRIANGLES, d, p, f, e.af.disabled, c, o.id, n, l, g, o.paint, u.zoom, r, [
                        s
                    ]);
                }
            },
            heatmap: function(t1, i, o, r) {
                if (0 !== o.paint.get("heatmap-opacity")) {
                    if ("offscreen" === t1.renderPass) {
                        const a = t1.context, n = a.gl, s = e.ag.disabled, l = new e.a([
                            n.ONE,
                            n.ONE,
                            n.ONE,
                            n.ONE
                        ], e.C.transparent, [
                            !0,
                            !0,
                            !0,
                            !0
                        ]);
                        !function(e, t1, i, o) {
                            const r = e.gl, a = t1.width * o, n = t1.height * o;
                            e.activeTexture.set(r.TEXTURE1), e.viewport.set([
                                0,
                                0,
                                a,
                                n
                            ]);
                            let s = i.heatmapFbo;
                            if (!s || s && (s.width !== a || s.height !== n)) {
                                s && s.destroy();
                                const t1 = r.createTexture();
                                r.bindTexture(r.TEXTURE_2D, t1), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), s = i.heatmapFbo = e.createFramebuffer(a, n, !0, null), function(e, t1, i, o, r, a) {
                                    const n = e.gl;
                                    n.texImage2D(n.TEXTURE_2D, 0, e.extRenderToTextureHalfFloat ? n.RGBA16F : n.RGBA, r, a, 0, n.RGBA, e.extRenderToTextureHalfFloat ? n.HALF_FLOAT : n.UNSIGNED_BYTE, null), o.colorAttachment.set(i);
                                }(e, 0, t1, s, a, n);
                            } else r.bindTexture(r.TEXTURE_2D, s.colorAttachment.get()), e.bindFramebuffer.set(s.framebuffer);
                        }(a, t1, o, "globe" === t1.transform.projection.name ? .5 : .25), a.clear({
                            color: e.C.transparent
                        });
                        const c = t1.transform, h = "globe" === c.projection.name, _ = h ? [
                            "PROJECTION_GLOBE_VIEW"
                        ] : [], u = h ? e.af.frontCCW : e.af.disabled, d = [
                            e.aj(c.center.lng),
                            e.ak(c.center.lat)
                        ];
                        for(let p = 0; p < r.length; p++){
                            const f = r[p];
                            if (i.hasRenderableParent(f)) continue;
                            const m = i.getTile(f), g = m.getBucket(o);
                            if (!g || g.projection.name !== c.projection.name) continue;
                            const v = t1.isTileAffectedByFog(f), x = g.programConfigurations.get(o.id), y = t1.getOrCreateProgram("heatmap", {
                                config: x,
                                defines: _,
                                overrideFog: v
                            }), { zoom: b } = t1.transform;
                            t1.terrain && t1.terrain.setupElevationDraw(m, y), t1.uploadCommonUniforms(a, y, f.toUnwrapped());
                            const w = c.projection.createInversionMatrix(c, f.canonical);
                            y.draw(t1, n.TRIANGLES, e.ae.disabled, s, l, u, eo(t1, f, m, w, d, b, o.paint.get("heatmap-intensity")), o.id, g.layoutVertexBuffer, g.indexBuffer, g.segments, o.paint, t1.transform.zoom, x, h ? [
                                g.globeExtVertexBuffer
                            ] : null);
                        }
                        a.viewport.set([
                            0,
                            0,
                            t1.width,
                            t1.height
                        ]);
                    } else "translucent" === t1.renderPass && (t1.context.setColorMode(t1.colorModeForRenderPass()), function(t1, i) {
                        const o = t1.context, r = o.gl, a = i.heatmapFbo;
                        if (!a) return;
                        o.activeTexture.set(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, a.colorAttachment.get()), o.activeTexture.set(r.TEXTURE1);
                        let n = i.colorRampTexture;
                        n || (n = i.colorRampTexture = new e.T(o, i.colorRamp, r.RGBA)), n.bind(r.LINEAR, r.CLAMP_TO_EDGE), t1.getOrCreateProgram("heatmapTexture").draw(t1, r.TRIANGLES, e.ae.disabled, e.ag.disabled, t1.colorModeForRenderPass(), e.af.disabled, ((e, t1, i, o)=>({
                                u_image: 0,
                                u_color_ramp: 1,
                                u_opacity: t1.paint.get("heatmap-opacity")
                            }))(0, i), i.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments, i.paint, t1.transform.zoom);
                    }(t1, o));
                }
            },
            line: function(t1, i, o, r) {
                if ("translucent" !== t1.renderPass) return;
                const a = o.paint.get("line-opacity"), n = o.paint.get("line-width");
                if (0 === a.constantOr(1) || 0 === n.constantOr(1)) return;
                const s = o.paint.get("line-emissive-strength"), l = o.paint.get("line-occlusion-opacity"), c = t1.context, h = c.gl, _ = o.layout.get("line-z-offset"), u = !_.isConstant() || !!_.constantOr(0), d = u ? new e.ae(t1.depthOcclusion ? h.GREATER : h.LEQUAL, e.ae.ReadOnly, t1.depthRangeFor3D) : t1.depthModeForSublayer(0, e.ae.ReadOnly), p = t1.colorModeForDrapableLayerRenderPass(s), f = t1.terrain && t1.terrain.renderingToTexture, m = f ? 1 : e.e.devicePixelRatio, g = o.paint.get("line-dasharray"), v = g.constantOr(1), x = o.layout.get("line-cap"), y = g.constantOr(null), b = x.constantOr(null), w = o.paint.get("line-pattern"), T = w.constantOr(1), E = w.constantOr(null), C = o.paint.get("line-opacity").constantOr(1);
                let S = !T && 1 !== C || t1.depthOcclusion && l > 0 && l < 1;
                const I = o.paint.get("line-gradient"), L = T ? "linePattern" : "line", P = e.bT(o);
                let A;
                if (f && t1.terrain && t1.terrain.clipOrMaskOverlapStencilType() && (S = !1), 0 !== l && t1.depthOcclusion) {
                    const t1 = o.paint._values["line-opacity"];
                    t1 && t1.value && "constant" === t1.value.kind ? A = t1.value : e.w(`Occlusion opacity for layer ${o.id} is supported only when line-opacity isn't data-driven.`);
                }
                if (u && (t1.forceTerrainMode = !0), !u && 0 !== l && t1.terrain && !f) return void e.w(`Occlusion opacity for layer ${o.id} is supported on terrain only if the layer has non-zero line-z-offset.`);
                const R = S && u ? t1.stencilModeFor3D() : e.ag.disabled;
                for (const a of r){
                    const r = i.getTile(a);
                    if (T && !r.patternsLoaded()) continue;
                    const n = r.getBucket(o);
                    if (!n) continue;
                    t1.prepareDrawTile();
                    const s = n.programConfigurations.get(o.id), _ = t1.isTileAffectedByFog(a), g = t1.getOrCreateProgram(L, {
                        config: s,
                        defines: u ? [
                            ...P,
                            "ELEVATED"
                        ] : P,
                        overrideFog: _
                    });
                    if (E && r.imageAtlas) {
                        const e = r.imageAtlas.patternPositions[E.toString()];
                        e && s.setConstantPatternPositions(e);
                    }
                    if (!T && y && b && r.lineAtlas) {
                        const e = r.lineAtlas.getDash(y, b);
                        e && s.setConstantPatternPositions(e);
                    }
                    let [x, w] = o.paint.get("line-trim-offset");
                    if ("round" === b || "square" === b) {
                        const e = 1;
                        x !== w && (0 === x && (x -= e), 1 === w && (w += e));
                    }
                    const D = f ? a.projMatrix : null, M = T ? e.bU(t1, r, o, D, m, [
                        x,
                        w
                    ]) : e.bV(t1, r, o, D, n.lineClipsArray.length, m, [
                        x,
                        w
                    ]);
                    if (I) {
                        const r = n.gradients[o.id];
                        let s = r.texture;
                        if (o.gradientVersion !== r.version) {
                            let l = 256;
                            if (o.stepInterpolant) {
                                const o = i.getSource().maxzoom, r = a.canonical.z === o ? Math.ceil(1 << t1.transform.maxZoom - a.canonical.z) : 1;
                                l = e.at(e.bW(n.maxLineLength / e.a3 * 1024 * r), 256, c.maxTextureSize);
                            }
                            r.gradient = e.bX({
                                expression: o.gradientExpression(),
                                evaluationKey: "lineProgress",
                                resolution: l,
                                image: r.gradient || void 0,
                                clips: n.lineClipsArray
                            }), r.texture ? r.texture.update(r.gradient) : r.texture = new e.T(c, r.gradient, h.RGBA), r.version = o.gradientVersion, s = r.texture;
                        }
                        c.activeTexture.set(h.TEXTURE1), s.bind(o.stepInterpolant ? h.NEAREST : h.LINEAR, h.CLAMP_TO_EDGE);
                    }
                    v && (c.activeTexture.set(h.TEXTURE0), r.lineAtlasTexture && r.lineAtlasTexture.bind(h.LINEAR, h.REPEAT), s.updatePaintBuffers()), T && (c.activeTexture.set(h.TEXTURE0), r.imageAtlasTexture && r.imageAtlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), s.updatePaintBuffers()), u && t1.terrain.setupElevationDraw(r, g), t1.uploadCommonUniforms(c, g, a.toUnwrapped());
                    const z = (i)=>{
                        null != A && (A.value = C * l), g.draw(t1, h.TRIANGLES, d, i, p, e.af.disabled, M, o.id, n.layoutVertexBuffer, n.indexBuffer, n.segments, o.paint, t1.transform.zoom, s, [
                            n.layoutVertexBuffer2,
                            n.patternVertexBuffer,
                            n.zOffsetVertexBuffer
                        ]), null != A && (A.value = C);
                    };
                    if (S && !u) {
                        const i = t1.stencilModeForClipping(a).ref;
                        0 === i && f && c.clear({
                            stencil: 0
                        });
                        const o = {
                            func: h.EQUAL,
                            mask: 255
                        };
                        M.u_alpha_discard_threshold = .8, z(new e.ag(o, i, 255, h.KEEP, h.KEEP, h.INVERT)), M.u_alpha_discard_threshold = 0, z(new e.ag(o, i, 255, h.KEEP, h.KEEP, h.KEEP));
                    } else S && u && (M.u_alpha_discard_threshold = .001), z(u ? R : t1.stencilModeForClipping(a));
                }
                S && (t1.resetStencilClippingMasks(), f && c.clear({
                    stencil: 0
                })), 0 === l || t1.depthOcclusion || f || t1.layersWithOcclusionOpacity.push(t1.currentLayer), u && (t1.forceTerrainMode = !1);
            },
            fill: function(t1, i, o, r) {
                const a = o.paint.get("fill-color"), n = o.paint.get("fill-opacity");
                if (0 === n.constantOr(1)) return;
                const s = o.paint.get("fill-emissive-strength"), l = t1.colorModeForDrapableLayerRenderPass(s), c = o.paint.get("fill-pattern"), h = t1.opaquePassEnabledForLayer() && !c.constantOr(1) && 1 === a.constantOr(e.C.transparent).a && 1 === n.constantOr(0) ? "opaque" : "translucent";
                if (t1.renderPass === h) {
                    const a = t1.depthModeForSublayer(1, "opaque" === t1.renderPass ? e.ae.ReadWrite : e.ae.ReadOnly);
                    Do(t1, i, o, r, a, l, !1);
                }
                if ("translucent" === t1.renderPass && o.paint.get("fill-antialias")) {
                    const a = t1.depthModeForSublayer(o.getPaintProperty("fill-outline-color") ? 2 : 0, e.ae.ReadOnly);
                    Do(t1, i, o, r, a, l, !0);
                }
            },
            "fill-extrusion": function(t1, i, o, r) {
                const a = o.paint.get("fill-extrusion-opacity"), n = t1.context, s = n.gl, l = t1.terrain, c = l && l.renderingToTexture;
                if (0 === a) return;
                const h = t1.conflationActive && t1.style.isLayerClipped(o, i.getSource()), _ = t1.style.order.indexOf(o.fqid);
                if (h && function(e, t1, i, o, r) {
                    for (const a of o){
                        const o = t1.getTile(a).getBucket(i);
                        o && (o.updateReplacement(a, e.replacementSource, r), o.uploadCentroid(e.context));
                    }
                }(t1, i, o, r, _), l || h) for (const e of r){
                    const r = i.getTile(e).getBucket(o);
                    r && Oo(t1.context, i, e, r, o, l, h);
                }
                if ("shadow" === t1.renderPass && t1.shadowRenderer) {
                    const n = t1.shadowRenderer;
                    if (l && a < .65 && o._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof e.Z) return;
                    const s = n.getShadowPassDepthMode(), c = n.getShadowPassColorMode();
                    Mo(t1, i, o, r, s, e.ag.disabled, c, h);
                } else if ("translucent" === t1.renderPass) {
                    const _ = !o.paint.get("fill-extrusion-pattern").constantOr(1), u = o.paint.get("fill-extrusion-color").constantOr(e.C.white);
                    if (!c && 0 !== u.a) {
                        const n = new e.ae(t1.context.gl.LEQUAL, e.ae.ReadWrite, t1.depthRangeFor3D);
                        1 === a && _ ? Mo(t1, i, o, r, n, e.ag.disabled, e.a.unblended, h) : (Mo(t1, i, o, r, n, e.ag.disabled, e.a.disabled, h), Mo(t1, i, o, r, n, t1.stencilModeFor3D(), t1.colorModeForRenderPass(), h), t1.resetStencilClippingMasks());
                    }
                    if (t1.style.enable3dLights() && _ && (!l && "globe" !== t1.transform.projection.name || c)) {
                        const a = o.paint.get("fill-extrusion-opacity"), _ = o.paint.get("fill-extrusion-ambient-occlusion-intensity"), u = o.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), d = o.paint.get("fill-extrusion-flood-light-intensity"), p = o.paint.get("fill-extrusion-flood-light-color").toRenderColor(o.lut).toArray01().slice(0, 3), f = _ > 0 && u > 0, m = d > 0, g = (e, t1, i)=>(1 - i) * e + i * t1, v = (n)=>{
                            const l = t1.depthModeForSublayer(1, e.ae.ReadOnly, s.LEQUAL, !0), c = o.paint.get(n ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), f = g(.1, 3, c), m = t1._showOverdrawInspector;
                            if (!m) {
                                const c = new e.ag({
                                    func: s.ALWAYS,
                                    mask: 255
                                }, 255, 255, s.KEEP, s.KEEP, s.REPLACE), m = new e.a([
                                    s.ONE,
                                    s.ONE,
                                    s.ONE,
                                    s.ONE
                                ], e.C.transparent, [
                                    !1,
                                    !1,
                                    !1,
                                    !0
                                ], s.MIN);
                                zo(t1, i, o, r, l, c, m, e.af.disabled, n, "sdf", a, _, u, d, p, f, h, !1);
                            }
                            {
                                const c = m ? e.ag.disabled : new e.ag({
                                    func: s.EQUAL,
                                    mask: 255
                                }, 255, 255, s.KEEP, s.DECR, s.DECR), g = m ? t1.colorModeForRenderPass() : new e.a([
                                    s.ONE_MINUS_DST_ALPHA,
                                    s.DST_ALPHA,
                                    s.ONE,
                                    s.ONE
                                ], e.C.transparent, [
                                    !0,
                                    !0,
                                    !0,
                                    !0
                                ]);
                                zo(t1, i, o, r, l, c, g, e.af.disabled, n, "color", a, _, u, d, p, f, h, !1);
                            }
                        };
                        if (c) {
                            const c = (n, l, c)=>{
                                const f = t1.depthModeForSublayer(1, e.ae.ReadOnly, s.LEQUAL, !1), m = o.paint.get(n ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), v = g(.1, 3, m);
                                {
                                    const c = new e.a([
                                        s.ONE,
                                        s.ONE,
                                        s.ONE,
                                        s.ONE
                                    ], e.C.transparent, [
                                        !1,
                                        !1,
                                        !1,
                                        !0
                                    ]);
                                    zo(t1, i, o, r, f, e.ag.disabled, c, e.af.disabled, n, "clear", a, _, u, d, p, v, h, l);
                                }
                                {
                                    const c = new e.ag({
                                        func: s.ALWAYS,
                                        mask: 255
                                    }, 255, 255, s.KEEP, s.KEEP, s.REPLACE), m = new e.a([
                                        s.ONE,
                                        s.ONE,
                                        s.ONE,
                                        s.ONE
                                    ], e.C.transparent, [
                                        !1,
                                        !1,
                                        !1,
                                        !0
                                    ], s.MIN);
                                    zo(t1, i, o, r, f, c, m, e.af.disabled, n, "sdf", a, _, u, d, p, v, h, l);
                                }
                                {
                                    const c = n ? s.ZERO : s.ONE_MINUS_DST_ALPHA, m = new e.ag({
                                        func: s.EQUAL,
                                        mask: 255
                                    }, 255, 255, s.KEEP, s.DECR, s.DECR), g = new e.a([
                                        c,
                                        s.DST_ALPHA,
                                        s.ONE_MINUS_DST_ALPHA,
                                        s.ZERO
                                    ], e.C.transparent, [
                                        !0,
                                        !0,
                                        !0,
                                        !0
                                    ]);
                                    zo(t1, i, o, r, f, m, g, e.af.disabled, n, "color", a, _, u, d, p, v, h, l);
                                }
                                {
                                    const m = new e.a([
                                        s.ONE,
                                        s.ONE,
                                        s.ONE,
                                        n ? s.ZERO : s.ONE
                                    ], e.C.transparent, [
                                        !1,
                                        !1,
                                        !1,
                                        !0
                                    ], n ? s.FUNC_ADD : s.MAX);
                                    zo(t1, i, o, r, f, e.ag.disabled, m, e.af.disabled, n, "clear", a, _, u, d, p, v, h, l, c);
                                }
                            };
                            if (f || m) {
                                let i;
                                if (t1.prepareDrawTile(), l) {
                                    const t1 = l.drapeBufferSize[0], o = l.drapeBufferSize[1];
                                    i = l.framebufferCopyTexture, i && (!i || i.size[0] === t1 && i.size[1] === o) || (i && i.destroy(), i = l.framebufferCopyTexture = new e.T(n, new e.i({
                                        width: t1,
                                        height: o
                                    }), s.RGBA)), i.bind(s.LINEAR, s.CLAMP_TO_EDGE), s.copyTexImage2D(s.TEXTURE_2D, 0, s.RGBA, 0, 0, t1, o, 0);
                                }
                                f && c(!0, !1, i), m && c(!1, !0, i);
                            }
                        } else f && v(!0), m && v(!1);
                    }
                }
            },
            hillshade: function(t1, i, o, r) {
                if ("offscreen" !== t1.renderPass && "translucent" !== t1.renderPass) return;
                if (t1.style.disableElevatedTerrain) return;
                const a = t1.context, n = t1.terrain && t1.terrain.renderingToTexture, [s, l] = "translucent" !== t1.renderPass || n ? [
                    {},
                    r
                ] : t1.stencilConfigForOverlap(r);
                for (const r of l){
                    const a = i.getTile(r);
                    if (a.needsHillshadePrepare && "offscreen" === t1.renderPass) Ot(t1, a, o);
                    else if ("translucent" === t1.renderPass) {
                        const i = t1.depthModeForSublayer(0, e.ae.ReadOnly), l = o.paint.get("hillshade-emissive-strength"), c = t1.colorModeForDrapableLayerRenderPass(l), h = n && t1.terrain ? t1.terrain.stencilModeForRTTOverlap(r) : s[r.overscaledZ];
                        Mt(t1, r, a, o, i, h, c);
                    }
                }
                a.viewport.set([
                    0,
                    0,
                    t1.width,
                    t1.height
                ]), t1.resetStencilClippingMasks();
            },
            raster: function(t1, i, o, r, a, n) {
                if ("translucent" !== t1.renderPass) return;
                if (0 === o.paint.get("raster-opacity")) return;
                const s = "globe" === t1.transform.projection.name, l = 0 !== o.paint.get("raster-elevation"), c = l && s;
                if (t1.renderElevatedRasterBackface && !c) return;
                const h = t1.context, _ = h.gl, u = i.getSource(), d = function(t1, i, o, r) {
                    const a = i.paint.get("raster-color"), n = "raster-array" === t1.type, s = [], l = i.paint.get("raster-resampling"), c = i.paint.get("raster-color-mix");
                    let h = i.paint.get("raster-color-range");
                    const _ = [
                        c[0],
                        c[1],
                        c[2],
                        0
                    ], u = c[3];
                    let d = "nearest" === l ? r.NEAREST : r.LINEAR;
                    if (n && (s.push("RASTER_ARRAY"), a || s.push("RASTER_COLOR"), "linear" === l && s.push("RASTER_ARRAY_LINEAR"), d = r.NEAREST, !h && t1.rasterLayers)) {
                        const e = t1.rasterLayers.find(({ id: e })=>e === i.sourceLayer);
                        e && e.fields && e.fields.range && (h = e.fields.range);
                    }
                    if (h = h || [
                        0,
                        1
                    ], a) {
                        s.push("RASTER_COLOR"), o.activeTexture.set(r.TEXTURE2), i.updateColorRamp(h);
                        let t1 = i.colorRampTexture;
                        t1 || (t1 = i.colorRampTexture = new e.T(o, i.colorRamp, r.RGBA)), t1.bind(r.LINEAR, r.CLAMP_TO_EDGE);
                    }
                    return {
                        mix: _,
                        range: h,
                        offset: u,
                        defines: s,
                        resampling: d
                    };
                }(u, o, h, _);
                if (u instanceof e.bm && !r.length && !s) return;
                const p = o.paint.get("raster-emissive-strength"), f = t1.colorModeForDrapableLayerRenderPass(p), m = t1.terrain && t1.terrain.renderingToTexture, g = !t1.options.moving, v = "nearest" === o.paint.get("raster-resampling") ? _.NEAREST : _.LINEAR;
                if (u instanceof e.bm && !r.length && (u.onNorthPole || u.onSouthPole)) {
                    const r = l ? t1.stencilModeFor3D() : e.ag.disabled;
                    return void Go(!!u.onNorthPole, null, t1, i, o, p, d, e.af.disabled, r);
                }
                if (!r.length) return;
                const [x, y] = u instanceof e.bm || m ? [
                    {},
                    r
                ] : t1.stencilConfigForOverlap(r), b = y[y.length - 1].overscaledZ;
                c && d.defines.push("PROJECTION_GLOBE_VIEW"), l && d.defines.push("RENDER_CUTOFF");
                const w = (r, a, y)=>{
                    for (const w of r){
                        const r = w.toUnwrapped(), T = i.getTile(w);
                        if (m && (!T || !T.hasData())) continue;
                        h.activeTexture.set(_.TEXTURE0);
                        const E = Vo(T, u, o, d);
                        if (!E || !E.texture) continue;
                        const { texture: C, mix: S, offset: I, tileSize: L, buffer: P } = E;
                        let A, R;
                        m ? (A = e.ae.disabled, R = w.projMatrix) : l ? (A = new e.ae(_.LEQUAL, e.ae.ReadWrite, t1.depthRangeFor3D), R = s ? Float32Array.from(t1.transform.expandedFarZProjMatrix) : t1.transform.calculateProjMatrix(r, g)) : (A = t1.depthModeForSublayer(w.overscaledZ - b, 1 === o.paint.get("raster-opacity") ? e.ae.ReadWrite : e.ae.ReadOnly, _.LESS), R = t1.transform.calculateProjMatrix(r, g));
                        const D = t1.terrain && m ? t1.terrain.stencilModeForRTTOverlap(w) : x[w.overscaledZ], M = n ? 0 : o.paint.get("raster-fade-duration");
                        T.registerFadeDuration(M);
                        const z = i.findLoadedParent(w, 0), O = Ai(T, z, i, t1.transform, M);
                        let F, B;
                        t1.terrain && t1.terrain.prepareDrawTile(), h.activeTexture.set(_.TEXTURE0), C.bind(v, _.CLAMP_TO_EDGE), h.activeTexture.set(_.TEXTURE1), z ? (z.texture && z.texture.bind(v, _.CLAMP_TO_EDGE), F = Math.pow(2, z.tileID.overscaledZ - T.tileID.overscaledZ), B = [
                            T.tileID.canonical.x * F % 1,
                            T.tileID.canonical.y * F % 1
                        ]) : C.bind(v, _.CLAMP_TO_EDGE), C.useMipmap && h.extTextureFilterAnisotropic && t1.transform.pitch > 20 && _.texParameterf(_.TEXTURE_2D, h.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, h.extTextureFilterAnisotropicMax);
                        const k = t1.transform;
                        let N;
                        const U = l ? jo(k) : [
                            0,
                            0,
                            0,
                            0
                        ];
                        let G, j, V, W, Z, q = 0;
                        if (c && u instanceof e.bm && u.coordinates.length > 3) G = Float32Array.from(e.bf(e.bg(new e.aO(0, 0, 0)))), j = Float32Array.from(k.globeMatrix), V = Float32Array.from(e.bb(k)), W = [
                            e.aj(k.center.lng),
                            e.ak(k.center.lat)
                        ], N = u.elevatedGlobePerspectiveTransform, Z = u.elevatedGlobeGridMatrix || new Float32Array(9);
                        else if (c) {
                            const t1 = e.bc(w.canonical);
                            q = e.bd(t1.getCenter().lat), G = Float32Array.from(e.bf(e.bg(w.canonical))), j = Float32Array.from(k.globeMatrix), V = Float32Array.from(e.bb(k)), W = [
                                e.aj(k.center.lng),
                                e.ak(k.center.lat)
                            ], N = [
                                0,
                                0
                            ], Z = Float32Array.from(e.be(w.canonical, t1, q, k.worldSize / k._pixelsPerMercatorPixel));
                        } else N = u instanceof e.bm ? u.perspectiveTransform : [
                            0,
                            0
                        ], G = new Float32Array(16), j = new Float32Array(9), V = new Float32Array(16), W = [
                            0,
                            0
                        ], Z = new Float32Array(9);
                        const H = oo(R, G, j, V, Z, B || [
                            0,
                            0
                        ], e.a1(t1.transform.zoom), W, U, F || 1, O, o, N, l ? o.paint.get("raster-elevation") : 0, 2, S, I, d.range, L, P, p), $ = t1.isTileAffectedByFog(w), X = t1.getOrCreateProgram("raster", {
                            defines: d.defines,
                            overrideFog: $
                        });
                        if (t1.uploadCommonUniforms(h, X, r), u instanceof e.bm) {
                            const i = u.elevatedGlobeVertexBuffer, r = u.elevatedGlobeIndexBuffer;
                            if (m || !s) u.boundsBuffer && u.boundsSegments && X.draw(t1, _.TRIANGLES, A, e.ag.disabled, f, e.af.disabled, H, o.id, u.boundsBuffer, t1.quadTriangleIndexBuffer, u.boundsSegments);
                            else if (i && r) {
                                const n = k.zoom <= e.b1 ? u.elevatedGlobeSegments : u.getSegmentsForLongitude(k.center.lng);
                                n && X.draw(t1, _.TRIANGLES, A, e.ag.disabled, f, a, H, o.id, i, r, n);
                            }
                        } else if (c) {
                            A = new e.ae(_.LEQUAL, e.ae.ReadOnly, t1.depthRangeFor3D);
                            const i = t1.globeSharedBuffers;
                            if (i) {
                                const [e, r, n] = i.getGridBuffers(q, !1);
                                X.draw(t1, _.TRIANGLES, A, y || D, t1.colorModeForRenderPass(), a, H, o.id, e, r, n);
                            }
                        } else {
                            const { tileBoundsBuffer: i, tileBoundsIndexBuffer: r, tileBoundsSegments: a } = t1.getTileBoundsBuffers(T);
                            X.draw(t1, _.TRIANGLES, A, D, f, e.af.disabled, H, o.id, i, r, a);
                        }
                    }
                    if (!(u instanceof e.bm) && c) for (const n of r){
                        const r = n.canonical.y === (1 << n.canonical.z) - 1;
                        0 === n.canonical.y && Go(!0, n, t1, i, o, p, d, a, y || e.ag.disabled), r && Go(!1, n, t1, i, o, p, d, a === e.af.frontCW ? e.af.backCW : e.af.frontCW, y || e.ag.disabled);
                    }
                };
                c ? w(y, t1.renderElevatedRasterBackface ? e.af.backCW : e.af.frontCW, t1.stencilModeFor3D()) : w(y, e.af.disabled, void 0), t1.resetStencilClippingMasks();
            },
            "raster-particle": function(t1, i, o, r, a, n) {
                "offscreen" === t1.renderPass && function(t1, i, o, r) {
                    if (!r.length) return;
                    const a = t1.context, n = a.gl, s = i.getSource();
                    if (!(s instanceof Ri)) return;
                    const l = Math.ceil(Math.sqrt(o.paint.get("raster-particle-count")));
                    let c = o.particlePositionRGBAImage;
                    if (!c || c.width !== l) {
                        const t1 = function(e) {
                            const t1 = e * e, i = new Uint8Array(4 * t1), o = function(e) {
                                return e |= 0, e = Math.imul(2747636419 ^ e, 2654435769), e = Math.imul(e ^ e >>> 16, 2654435769), ((e = Math.imul(e ^ e >>> 16, 2654435769)) >>> 0) / 4294967296;
                            }, r = 1 / 1.1;
                            for(let e = 0; e < t1; e++){
                                const t1 = r * (o(2 * e + 0) + ao), a = r * (o(2 * e + 1) + ao), n = 255 * t1 % 1, s = 255 * a % 1, l = n, c = a - s / 255, h = s;
                                i[4 * e + 0] = 255 * (t1 - n / 255), i[4 * e + 1] = 255 * l, i[4 * e + 2] = 255 * c, i[4 * e + 3] = 255 * h;
                            }
                            return i;
                        }(l);
                        c = o.particlePositionRGBAImage = new e.i({
                            width: l,
                            height: l
                        }, t1);
                    }
                    let h = o.particleFramebuffer;
                    h ? h.width !== l && (h.destroy(), h = o.particleFramebuffer = a.createFramebuffer(l, l, !0, null)) : h = o.particleFramebuffer = a.createFramebuffer(l, l, !0, null);
                    const _ = [];
                    for (const t1 of r){
                        const r = i.getTile(t1);
                        if (!(r instanceof e.c3)) continue;
                        const n = Wo(r, s, o);
                        if (!n) continue;
                        const h = [
                            r.tileSize,
                            r.tileSize
                        ];
                        let u = o.tileFramebuffer;
                        u || (u = o.tileFramebuffer = a.createFramebuffer(h[0], h[1], !0, null));
                        let d = r.rasterParticleState;
                        d || (d = r.rasterParticleState = new le(a, t1, h, c));
                        const p = d.update(o.lastInvalidatedAt);
                        d.particleTextureDimension !== l && d.updateParticleTexture(t1, c);
                        const f = d.targetColorTexture;
                        d.targetColorTexture = d.backgroundColorTexture, d.backgroundColorTexture = f;
                        const m = d.particleTexture0;
                        d.particleTexture0 = d.particleTexture1, d.particleTexture1 = m, _.push([
                            t1,
                            n,
                            d,
                            p
                        ]);
                    }
                    if (0 === _.length) return;
                    const u = e.e.now(), d = o.previousDrawTimestamp ? .001 * (u - o.previousDrawTimestamp) : .0167;
                    if (o.previousDrawTimestamp = u, o.hasColorMap()) {
                        a.activeTexture.set(n.TEXTURE0 + 2);
                        let t1 = o.colorRampTexture;
                        t1 || (t1 = o.colorRampTexture = new e.T(a, o.colorRamp, n.RGBA)), t1.bind(n.LINEAR, n.CLAMP_TO_EDGE);
                    }
                    a.bindFramebuffer.set(o.tileFramebuffer.framebuffer), function(t1, i, o) {
                        const r = t1.context, a = r.gl, n = i.tileFramebuffer;
                        r.activeTexture.set(a.TEXTURE0);
                        const s = {
                            u_texture: 0,
                            u_opacity: 1.05 * (c = i.paint.get("raster-particle-fade-opacity-factor")) / (c + .05)
                        }, l = t1.getOrCreateProgram("rasterParticleTexture", {
                            defines: [],
                            overrideFog: !1
                        });
                        var c;
                        for (const c of o){
                            const [, , o, h] = c;
                            n.colorAttachment.set(o.targetColorTexture.texture), r.viewport.set([
                                0,
                                0,
                                n.width,
                                n.height
                            ]), r.clear({
                                color: e.C.transparent
                            }), h && (o.backgroundColorTexture.bind(a.NEAREST, a.CLAMP_TO_EDGE), l.draw(t1, a.TRIANGLES, e.ae.disabled, e.ag.disabled, e.a.alphaBlended, e.af.disabled, s, i.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments));
                        }
                    }(t1, o, _), function(t1, i, o, r) {
                        const a = t1.context, n = a.gl, s = o.tileFramebuffer, l = "globe" === t1.transform.projection.name, c = o.paint.get("raster-particle-max-speed");
                        for (const h of r){
                            const [r, _, u] = h;
                            a.activeTexture.set(n.TEXTURE0 + 0), _.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), s.colorAttachment.set(u.targetColorTexture.texture);
                            const d = t1.getOrCreateProgram("rasterParticleDraw", {
                                defines: _.defines,
                                overrideFog: !1
                            });
                            a.activeTexture.set(n.TEXTURE0 + 1);
                            const p = _.scalarData ? [] : [
                                0,
                                1,
                                2,
                                3
                            ].map((t1)=>e.bZ[t1](r));
                            p.push(r);
                            const f = r.canonical.x, m = r.canonical.y;
                            for (const a of p){
                                const s = i.getTile(l ? a.wrapped() : a);
                                if (!s) continue;
                                const h = s.rasterParticleState;
                                if (!h) continue;
                                const u = a.canonical.x + (1 << a.canonical.z) * (a.wrap - r.wrap), p = a.canonical.y;
                                h.particleTexture0.bind(n.NEAREST, n.CLAMP_TO_EDGE);
                                const g = so(1, h.particleTexture0.size[0], [
                                    u - f,
                                    p - m
                                ], 0, _.texture.size, 2, c, _.textureOffset, _.scale, _.offset);
                                d.draw(t1, n.POINTS, e.ae.disabled, e.ag.disabled, e.a.alphaBlended, e.af.disabled, g, o.id, h.particleIndexBuffer, void 0, h.particleSegment);
                            }
                        }
                    }(t1, i, o, _), a.bindFramebuffer.set(o.particleFramebuffer.framebuffer), function(t1, i, o, r) {
                        const a = t1.context, n = a.gl, s = i.paint.get("raster-particle-max-speed"), l = r * i.paint.get("raster-particle-speed-factor") * .15, c = function(e) {
                            return Math.pow(e, 6);
                        }(.01 + 1 * i.paint.get("raster-particle-reset-rate-factor")), h = i.particleFramebuffer;
                        a.viewport.set([
                            0,
                            0,
                            h.width,
                            h.height
                        ]);
                        for (const r of o){
                            const [, o, _] = r;
                            a.activeTexture.set(n.TEXTURE0 + 0), o.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), a.activeTexture.set(n.TEXTURE0 + 1);
                            const u = _.particleTexture0;
                            u.bind(n.NEAREST, n.CLAMP_TO_EDGE);
                            const d = lo(1, u.size[0], 0, o.texture.size, s, l, c, o.textureOffset, o.scale, o.offset);
                            h.colorAttachment.set(_.particleTexture1.texture), a.clear({
                                color: e.C.transparent
                            }), t1.getOrCreateProgram("rasterParticleUpdate", {
                                defines: o.defines
                            }).draw(t1, n.TRIANGLES, e.ae.disabled, e.ag.disabled, e.a.unblended, e.af.disabled, d, i.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments);
                        }
                    }(t1, o, _, d);
                }(t1, i, o, r), "translucent" === t1.renderPass && (function(t1, i, o, r, a) {
                    const n = t1.context, s = n.gl, l = !t1.options.moving, c = "globe" === t1.transform.projection.name;
                    if (!r.length) return;
                    const [h, _] = t1.stencilConfigForOverlap(r), u = [];
                    c && u.push("PROJECTION_GLOBE_VIEW");
                    const d = t1.stencilModeFor3D();
                    for (const r of _){
                        const a = r.toUnwrapped(), _ = i.getTile(r);
                        if (!_.rasterParticleState) continue;
                        const p = _.rasterParticleState, f = 100;
                        _.registerFadeDuration(f);
                        const m = i.findLoadedParent(r, 0), g = Ai(_, m, i, t1.transform, f);
                        let v, x;
                        t1.terrain && t1.terrain.prepareDrawTile(), n.activeTexture.set(s.TEXTURE0), p.targetColorTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE), n.activeTexture.set(s.TEXTURE1), m && m.rasterParticleState ? (m.rasterParticleState.targetColorTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE), v = Math.pow(2, m.tileID.overscaledZ - _.tileID.overscaledZ), x = [
                            _.tileID.canonical.x * v % 1,
                            _.tileID.canonical.y * v % 1
                        ]) : p.targetColorTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE);
                        const y = c ? Float32Array.from(t1.transform.expandedFarZProjMatrix) : t1.transform.calculateProjMatrix(a, l), b = t1.transform, w = Zo(b), T = e.bc(r.canonical), E = e.bd(T.getCenter().lat);
                        let C, S, I, L, P;
                        c ? (C = Float32Array.from(e.bf(e.bg(r.canonical))), S = Float32Array.from(b.globeMatrix), I = Float32Array.from(e.bb(b)), L = [
                            e.aj(b.center.lng),
                            e.ak(b.center.lat)
                        ], P = Float32Array.from(e.be(r.canonical, T, E, b.worldSize / b._pixelsPerMercatorPixel))) : (C = new Float32Array(16), S = new Float32Array(9), I = new Float32Array(16), L = [
                            0,
                            0
                        ], P = new Float32Array(9));
                        const A = no(y, C, S, I, P, x || [
                            0,
                            0
                        ], e.a1(t1.transform.zoom), L, w, v || 1, g, 250), R = t1.isTileAffectedByFog(r), D = t1.getOrCreateProgram("rasterParticle", {
                            defines: u,
                            overrideFog: R
                        });
                        if (t1.uploadCommonUniforms(n, D, a), c) {
                            const i = new e.ae(s.LEQUAL, e.ae.ReadWrite, t1.depthRangeFor3D), r = 0, a = t1.globeSharedBuffers;
                            if (a) {
                                const [n, l, c] = a.getGridBuffers(E, 0 !== r);
                                D.draw(t1, s.TRIANGLES, i, d, e.a.alphaBlended, e.af.backCCW, A, o.id, n, l, c);
                            }
                        } else {
                            const i = t1.depthModeForSublayer(0, e.ae.ReadOnly), a = h[r.overscaledZ], { tileBoundsBuffer: n, tileBoundsIndexBuffer: l, tileBoundsSegments: c } = t1.getTileBoundsBuffers(_);
                            D.draw(t1, s.TRIANGLES, i, a, e.a.alphaBlended, e.af.disabled, A, o.id, n, l, c);
                        }
                    }
                    t1.resetStencilClippingMasks();
                }(t1, i, o, r), t1.style.map.triggerRepaint());
            },
            background: function(t1, i, o, r) {
                const a = o.paint.get("background-color"), n = o.paint.get("background-opacity"), s = o.paint.get("background-emissive-strength");
                if (0 === n) return;
                const l = t1.context, c = l.gl, h = t1.transform, _ = h.tileSize, u = o.paint.get("background-pattern");
                let d;
                if (void 0 !== u) {
                    if (null === u) return;
                    if (d = t1.imageManager.getPattern(u.toString(), o.scope, t1.style.getLut(o.scope)), !d) return;
                }
                const p = !u && 1 === a.a && 1 === n && t1.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (t1.renderPass !== p) return;
                const f = e.ag.disabled, m = t1.depthModeForSublayer(0, "opaque" === p ? e.ae.ReadWrite : e.ae.ReadOnly), g = t1.colorModeForDrapableLayerRenderPass(s), v = u ? "backgroundPattern" : "background";
                let x, y = r;
                y || (x = t1.getBackgroundTiles(), y = Object.values(x).map((e)=>e.tileID)), u && (l.activeTexture.set(c.TEXTURE0), t1.imageManager.bind(t1.context, o.scope));
                for (const p of y){
                    const y = t1.isTileAffectedByFog(p), b = t1.getOrCreateProgram(v, {
                        overrideFog: y
                    }), w = p.toUnwrapped(), T = r ? p.projMatrix : t1.transform.calculateProjMatrix(w);
                    t1.prepareDrawTile();
                    const E = i ? i.getTile(p) : x ? x[p.key] : new e.by(p, _, h.zoom, t1), C = u ? fo(T, s, n, t1, 0, o.scope, d, {
                        tileID: p,
                        tileSize: _
                    }) : po(T, s, n, a.toRenderColor(o.lut));
                    t1.uploadCommonUniforms(l, b, w);
                    const { tileBoundsBuffer: S, tileBoundsIndexBuffer: I, tileBoundsSegments: L } = t1.getTileBoundsBuffers(E);
                    b.draw(t1, c.TRIANGLES, m, f, g, e.af.disabled, C, o.id, S, I, L);
                }
            },
            sky: function(t1, i, o) {
                const r = t1._atmosphere ? e.a1(t1.transform.zoom) : 1, a = o.paint.get("sky-opacity") * r;
                if (0 === a) return;
                const n = t1.context, s = o.paint.get("sky-type"), l = new e.ae(n.gl.LEQUAL, e.ae.ReadOnly, [
                    0,
                    1
                ]), c = t1.frameCounter / 1e3 % 1;
                "atmosphere" === s ? "offscreen" === t1.renderPass ? o.needsSkyboxCapture(t1) && (function(t1, i, o, r) {
                    const a = t1.context, n = a.gl;
                    let s = i.skyboxFbo;
                    if (!s) {
                        s = i.skyboxFbo = a.createFramebuffer(32, 32, !0, null), i.skyboxGeometry = new rr(a), i.skyboxTexture = a.gl.createTexture(), n.bindTexture(n.TEXTURE_CUBE_MAP, i.skyboxTexture), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_MAG_FILTER, n.LINEAR);
                        for(let e = 0; e < 6; ++e)n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, n.RGBA, 32, 32, 0, n.RGBA, n.UNSIGNED_BYTE, null);
                    }
                    a.bindFramebuffer.set(s.framebuffer), a.viewport.set([
                        0,
                        0,
                        32,
                        32
                    ]);
                    const l = i.getCenter(t1, !0), c = t1.getOrCreateProgram("skyboxCapture"), h = new Float64Array(16);
                    e.ad.identity(h), e.ad.rotateY(h, h, .5 * -Math.PI), ar(t1, i, c, h, l, 0), e.ad.identity(h), e.ad.rotateY(h, h, .5 * Math.PI), ar(t1, i, c, h, l, 1), e.ad.identity(h), e.ad.rotateX(h, h, .5 * -Math.PI), ar(t1, i, c, h, l, 2), e.ad.identity(h), e.ad.rotateX(h, h, .5 * Math.PI), ar(t1, i, c, h, l, 3), e.ad.identity(h), ar(t1, i, c, h, l, 4), e.ad.identity(h), e.ad.rotateY(h, h, Math.PI), ar(t1, i, c, h, l, 5), a.viewport.set([
                        0,
                        0,
                        t1.width,
                        t1.height
                    ]);
                }(t1, o), o.markSkyboxValid(t1)) : "sky" === t1.renderPass && function(t1, i, o, r, a) {
                    const n = t1.context, s = n.gl, l = t1.transform, c = t1.getOrCreateProgram("skybox");
                    n.activeTexture.set(s.TEXTURE0), s.bindTexture(s.TEXTURE_CUBE_MAP, i.skyboxTexture);
                    const h = ((e, t1, i, o, r)=>({
                            u_matrix: e,
                            u_sun_direction: t1,
                            u_cubemap: 0,
                            u_opacity: o,
                            u_temporal_offset: r
                        }))(l.skyboxMatrix, i.getCenter(t1, !1), 0, r, a);
                    t1.uploadCommonUniforms(n, c), c.draw(t1, s.TRIANGLES, o, e.ag.disabled, t1.colorModeForRenderPass(), e.af.backCW, h, "skybox", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
                }(t1, o, l, a, c) : "gradient" === s && "sky" === t1.renderPass && function(t1, i, o, r, a) {
                    const n = t1.context, s = n.gl, l = t1.transform, c = t1.getOrCreateProgram("skyboxGradient");
                    i.skyboxGeometry || (i.skyboxGeometry = new rr(n)), n.activeTexture.set(s.TEXTURE0);
                    let h = i.colorRampTexture;
                    h || (h = i.colorRampTexture = new e.T(n, i.colorRamp, s.RGBA)), h.bind(s.LINEAR, s.CLAMP_TO_EDGE);
                    const _ = ((t1, i, o, r, a)=>({
                            u_matrix: t1,
                            u_color_ramp: 0,
                            u_center_direction: i,
                            u_radius: e.ab(o),
                            u_opacity: r,
                            u_temporal_offset: a
                        }))(l.skyboxMatrix, i.getCenter(t1, !1), i.paint.get("sky-gradient-radius"), r, a);
                    t1.uploadCommonUniforms(n, c), c.draw(t1, s.TRIANGLES, o, e.ag.disabled, t1.colorModeForRenderPass(), e.af.backCW, _, "skyboxGradient", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
                }(t1, o, l, a, c);
            },
            debug: function(t1, i, o, r, a, n) {
                for(let s = 0; s < o.length; s++)if (a) {
                    const a = 1, l = .8, c = new e.C(r.r * l, r.g * l, r.b * l, 1);
                    Ko(t1, i, o[s], r, -a, -a, n), Ko(t1, i, o[s], r, -a, a, n), Ko(t1, i, o[s], r, a, a, n), Ko(t1, i, o[s], r, a, -a, n), Ko(t1, i, o[s], c, 0, 0, n);
                } else Ko(t1, i, o[s], r, 0, 0, n);
            },
            custom: function(t1, i, o, r) {
                const a = t1.context, n = o.implementation;
                if (!t1.transform.projection.unsupportedLayers || !t1.transform.projection.unsupportedLayers.includes("custom") || t1.terrain && (t1.terrain.renderingToTexture || "offscreen" === t1.renderPass) && o.isDraped(i)) {
                    if ("offscreen" === t1.renderPass) {
                        const i = n.prerender;
                        if (i) {
                            if (t1.setCustomLayerDefaults(), a.setColorMode(t1.colorModeForRenderPass()), "globe" === t1.transform.projection.name) {
                                const o = t1.transform.pointMerc;
                                i.call(n, a.gl, t1.transform.customLayerMatrix(), t1.transform.getProjection(), t1.transform.globeToMercatorMatrix(), e.a1(t1.transform.zoom), [
                                    o.x,
                                    o.y
                                ], t1.transform.pixelsPerMeterRatio);
                            } else i.call(n, a.gl, t1.transform.customLayerMatrix());
                            a.setDirty(), t1.setBaseState();
                        }
                    } else if ("translucent" === t1.renderPass) {
                        if (t1.terrain && t1.terrain.renderingToTexture) {
                            const i = n.renderToTile;
                            if (i) {
                                const o = r[0].canonical, s = new e.Y(o.x + r[0].wrap * (1 << o.z), o.y, o.z);
                                a.setDepthMode(e.ae.disabled), a.setStencilMode(e.ag.disabled), a.setColorMode(t1.colorModeForRenderPass()), t1.setCustomLayerDefaults(), i.call(n, a.gl, s), a.setDirty(), t1.setBaseState();
                            }
                            return;
                        }
                        t1.setCustomLayerDefaults(), a.setColorMode(t1.colorModeForRenderPass()), a.setStencilMode(e.ag.disabled);
                        const i = "3d" === n.renderingMode ? new e.ae(t1.context.gl.LEQUAL, e.ae.ReadWrite, t1.depthRangeFor3D) : t1.depthModeForSublayer(0, e.ae.ReadOnly);
                        if (a.setDepthMode(i), "globe" === t1.transform.projection.name) {
                            const i = t1.transform.pointMerc;
                            n.render(a.gl, t1.transform.customLayerMatrix(), t1.transform.getProjection(), t1.transform.globeToMercatorMatrix(), e.a1(t1.transform.zoom), [
                                i.x,
                                i.y
                            ], t1.transform.pixelsPerMeterRatio);
                        } else n.render(a.gl, t1.transform.customLayerMatrix());
                        a.setDirty(), t1.setBaseState(), a.bindFramebuffer.set(null);
                    }
                } else e.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
            },
            model: function(t1, i, o, r) {
                if ("opaque" === t1.renderPass) return;
                const a = o.paint.get("model-opacity");
                if (0 === a) return;
                const n = o.paint.get("model-cast-shadows");
                if ("shadow" === t1.renderPass) {
                    if (!n) return;
                    if (t1.terrain && a < .65 && o._transitionablePaint._values["model-opacity"].value.expression instanceof e.Z) return;
                }
                const s = t1.shadowRenderer, l = o.paint.get("model-receive-shadows");
                s && (s.useNormalOffset = !0, l || (s.enabled = !1));
                const c = ()=>{
                    s && (s.useNormalOffset = !0, l || (s.enabled = !0));
                }, h = i.getSource();
                if ("light-beam" === t1.renderPass && "batched-model" !== h.type) return;
                if ("vector" === h.type || "geojson" === h.type) return function(t1, i, o, r, a) {
                    const n = t1.transform;
                    if ("mercator" !== n.projection.name) return void e.w(`Drawing 3D models for ${n.projection.name} projection is not yet implemented`);
                    const s = n.getFreeCameraOptions().position;
                    if (!t1.modelManager) return;
                    const l = t1.modelManager;
                    o.modelManager = l;
                    const c = t1.shadowRenderer;
                    if (!o._unevaluatedLayout._values.hasOwnProperty("model-id")) return;
                    const h = o._unevaluatedLayout._values["model-id"], _ = {
                        ...o.layout.get("model-id").parameters
                    }, u = t1.style.order.indexOf(o.fqid);
                    for (const d of r){
                        const r = i.getTile(d).getBucket(o);
                        if (!r || r.projection.name !== n.projection.name) continue;
                        const p = r.getModelUris();
                        p && !r.modelsRequested && (l.addModelsFromBucket(p, a), r.modelsRequested = !0);
                        const f = vr(d, n);
                        _.zoom = f;
                        const m = h.possiblyEvaluate(_);
                        if (mr(t1, r, d), gr.shadowUniformsInitialized = !1, gr.useSingleShadowCascade = !!c && 0 === c.getMaxCascadeForTile(d.toUnwrapped()), "shadow" === t1.renderPass && c) {
                            if (1 === t1.currentShadowCascade && r.isInsideFirstShadowMapFrustum) continue;
                            const i = n.calculatePosMatrix(d.toUnwrapped(), n.worldSize);
                            if (gr.tileMatrix.set(i), gr.shadowTileMatrix = Float32Array.from(c.calculateShadowPassMatrixFromMatrix(i)), gr.aabb.min.fill(0), gr.aabb.max[0] = gr.aabb.max[1] = e.a3, gr.aabb.max[2] = 0, br(r, gr, t1, o.scope)) continue;
                        }
                        const g = 1 << d.canonical.z, v = [
                            ((s.x - d.wrap) * g - d.canonical.x) * e.a3,
                            (s.y * g - d.canonical.y) * e.a3,
                            s.z * g * e.a3
                        ];
                        t1.conflationActive && Object.keys(r.instancesPerModel).length > 0 && t1.style.isLayerClipped(o, i.getSource()) && r.updateReplacement(d, t1.replacementSource, u) && (r.uploaded = !1, r.upload(t1.context));
                        for(let e in r.instancesPerModel){
                            const i = r.instancesPerModel[e];
                            i.features.length > 0 && (e = m.evaluate(i.features[0].feature, {}));
                            const n = l.getModel(e, a);
                            if (n && n.uploaded) for (const e of n.nodes)xr(t1, o, e, i, v, d, gr);
                        }
                    }
                }(t1, i, o, r, "vector" === h.type ? o.scope : ""), void c();
                if (!h.loaded()) return;
                if ("batched-model" === h.type) return function(t1, i, o, r) {
                    o.resetLayerRenderingStats(t1);
                    const a = t1.context, n = t1.transform, s = t1.style.fog, l = t1.shadowRenderer;
                    if ("mercator" !== n.projection.name) return void e.w(`Drawing 3D landmark models for ${n.projection.name} projection is not yet implemented`);
                    const c = t1.transform.getFreeCameraOptions().position, h = e._.scale([], [
                        c.x,
                        c.y,
                        c.z
                    ], t1.transform.worldSize);
                    e._.negate(h, h);
                    const _ = e.ad.identity([]), u = e.cg(n.center.lat, n.zoom), d = e.ad.fromScaling([], [
                        1,
                        1,
                        1 / u
                    ]);
                    e.ad.translate(_, _, h);
                    const p = o.paint.get("model-opacity"), f = new e.ae(a.gl.LEQUAL, e.ae.ReadWrite, t1.depthRangeFor3D), m = new e.ae(a.gl.LEQUAL, e.ae.ReadOnly, t1.depthRangeFor3D), g = new e.b6([
                        1 / 0,
                        1 / 0,
                        1 / 0
                    ], [
                        -1 / 0,
                        -1 / 0,
                        -1 / 0
                    ]), v = "shadow" === t1.renderPass, x = v && l ? l.getCurrentCascadeFrustum() : n.getFrustum(n.scaleZoom(n.worldSize)), y = o.paint.get("model-front-cutoff"), b = y[2] < 1, w = fi(t1, o.paint.get("model-cutoff-fade-range")), T = o.getLayerRenderingStats();
                    (function(e, t1, i, o) {
                        const r = e.terrain ? e.terrain.exaggeration() : 0, a = e.transform.zoom;
                        for (const n of o){
                            const o = t1.getTile(n).getBucket(i);
                            o && (e.conflationActive && o.updateReplacement(n, e.replacementSource), o.evaluateScale(e, i), e.terrain && r > 0 && o.elevationUpdate(e.terrain, r, n, i.source), o.needsReEvaluation(e, a, i) && o.evaluate(i));
                        }
                    })(t1, i, o, r), function() {
                        let c, h, u;
                        b ? (c = r.length - 1, h = -1, u = -1) : (c = 0, h = r.length, u = 1);
                        for(let E = c; E !== h; E += u){
                            const c = r[E], h = i.getTile(c).getBucket(o);
                            if (!h || !h.uploaded) continue;
                            let u = !1;
                            l && (u = 0 === l.getMaxCascadeForTile(c.toUnwrapped()));
                            const C = n.calculatePosMatrix(c.toUnwrapped(), n.worldSize), S = h.modelTraits, I = [];
                            for (const i of h.getNodesInfo()){
                                if (i.hiddenByReplacement) continue;
                                if (!i.node.meshes) continue;
                                const o = i.node;
                                let r = 0;
                                t1.terrain && o.elevation && (r = o.elevation * t1.terrain.exaggeration());
                                const a = i.evaluatedScale;
                                if (a[0] <= 1 && a[1] <= 1 && a[2] <= 1 && 0 === (()=>{
                                    const t1 = i.aabb;
                                    return g.min = [
                                        ...t1.min
                                    ], g.max = [
                                        ...t1.max
                                    ], g.min[2] += r, g.max[2] += r, e._.transformMat4(g.min, g.min, C), e._.transformMat4(g.max, g.max, C), g;
                                })().intersects(x)) continue;
                                const s = [
                                    ...C
                                ], l = o.anchor ? o.anchor[0] : 0, c = o.anchor ? o.anchor[1] : 0;
                                e.ad.translate(s, s, [
                                    l * (a[0] - 1),
                                    c * (a[1] - 1),
                                    r
                                ]), e._.exactEquals(a, e.cj) || e.ad.scale(s, s, a);
                                const h = e.ad.multiply([], s, o.matrix), _ = e.ad.multiply([], n.expandedFarZProjMatrix, h), u = e.ad.multiply([], n.expandedFarZProjMatrix, s), d = e.aA.transformMat4([], [
                                    l,
                                    c,
                                    r,
                                    1
                                ], _)[2];
                                o.hidden = !1;
                                let f = p;
                                v || (b && (f *= Tr(s, n, i.aabb, y)), f *= wr(w, d)), 0 !== f ? I.push({
                                    nodeInfo: i,
                                    depth: d,
                                    opacity: f,
                                    wvpForNode: _,
                                    wvpForTile: u,
                                    nodeModelMatrix: h,
                                    tileModelMatrix: s
                                }) : o.hidden = !0;
                            }
                            v || I.sort((e, t1)=>!b || 1 === e.opacity && 1 === t1.opacity ? e.depth < t1.depth ? -1 : 1 : 1 === e.opacity ? -1 : 1 === t1.opacity ? 1 : e.depth > t1.depth ? -1 : 1);
                            for (const i of I){
                                const r = i.nodeInfo, c = r.node;
                                let h = e.ad.multiply([], d, i.tileModelMatrix);
                                e.ad.multiply(h, _, h);
                                const p = e.ad.invert([], h);
                                e.ad.transpose(p, p), e.ad.scale(p, p, yr), h = e.ad.multiply(h, h, c.matrix);
                                const g = "light-beam" === t1.renderPass, x = S & e.cl.HasMapboxMeshFeatures, y = x ? 0 : r.evaluatedRMEA[0][2];
                                for(let _ = 0; _ < c.meshes.length; ++_){
                                    const d = c.meshes[_], b = _ === c.lightMeshIndex;
                                    let w = i.wvpForNode;
                                    if (b) {
                                        if (!g && !t1.terrain && t1.shadowRenderer) {
                                            t1.currentLayer < t1.firstLightBeamLayer && (t1.firstLightBeamLayer = t1.currentLayer);
                                            continue;
                                        }
                                        w = i.wvpForTile;
                                    } else if (g) continue;
                                    const E = {
                                        defines: []
                                    }, C = [];
                                    if (ur(E.defines, C, d, t1, o.lut), x || E.defines.push("DIFFUSE_SHADED"), u && E.defines.push("SHADOWS_SINGLE_CASCADE"), T && (v ? T.numRenderedVerticesInShadowPass += d.vertexArray.length : T.numRenderedVerticesInTransparentPass += d.vertexArray.length), v) {
                                        fr(d, i.nodeModelMatrix, t1, o);
                                        continue;
                                    }
                                    let S = null;
                                    if (s) {
                                        const e = _r(i.nodeModelMatrix, t1.transform);
                                        if (S = new Float32Array(e), "globe" !== n.projection.name) {
                                            const t1 = d.aabb.min, i = d.aabb.max, [o, r] = s.getOpacityForBounds(e, t1[0], t1[1], i[0], i[1]);
                                            E.overrideFog = o >= it || r >= it;
                                        }
                                    }
                                    const I = d.material;
                                    let L;
                                    I.occlusionTexture && I.occlusionTexture.offsetScale && (L = I.occlusionTexture.offsetScale, E.defines.push("OCCLUSION_TEXTURE_TRANSFORM")), !v && l && (l.useNormalOffset = !!d.normalBuffer);
                                    const P = t1.getOrCreateProgram("model", E);
                                    !v && l && l.setupShadowsFromMatrix(i.tileModelMatrix, P, l.useNormalOffset), t1.uploadCommonUniforms(a, P, null, S);
                                    const A = I.pbrMetallicRoughness;
                                    A.metallicFactor = .9, A.roughnessFactor = .5;
                                    const R = go(new Float32Array(w), new Float32Array(h), new Float32Array(p), new Float32Array(c.matrix), t1, i.opacity, A.baseColorFactor.toRenderColor(null), I.emissiveFactor, A.metallicFactor, A.roughnessFactor, I, y, o, [
                                        0,
                                        0,
                                        0
                                    ], L);
                                    !b && (r.hasTranslucentParts || i.opacity < 1) && P.draw(t1, a.gl.TRIANGLES, f, e.ag.disabled, e.a.disabled, e.af.backCCW, R, o.id, d.vertexBuffer, d.indexBuffer, d.segments, o.paint, t1.transform.zoom, void 0, C), P.draw(t1, a.gl.TRIANGLES, b ? m : f, e.ag.disabled, b || i.opacity < 1 || r.hasTranslucentParts ? e.a.alphaBlended : e.a.unblended, e.af.backCCW, R, o.id, d.vertexBuffer, d.indexBuffer, d.segments, o.paint, t1.transform.zoom, void 0, C);
                                }
                            }
                        }
                    }();
                }(t1, i, o, r), void c();
                if ("model" !== h.type) return;
                const _ = h.getModels(), u = [], d = t1.transform.getFreeCameraOptions().position, p = e._.scale([], [
                    d.x,
                    d.y,
                    d.z
                ], t1.transform.worldSize);
                e._.negate(p, p);
                const f = [], m = [];
                let g = 0;
                for (const i of _){
                    const r = o.paint.get("model-rotation").constantOr(null), a = o.paint.get("model-scale").constantOr(null), n = o.paint.get("model-translation").constantOr(null);
                    i.computeModelMatrix(t1, r, a, n, !0, !0, !1);
                    const s = e.ad.identity([]), l = e.cg(i.position.lat, t1.transform.zoom), c = e.ad.fromScaling([], [
                        1,
                        1,
                        1 / l
                    ]);
                    e.ad.translate(s, s, p), u.push({
                        zScaleMatrix: c,
                        negCameraPosMatrix: s
                    });
                    for (const e of i.nodes)pr(t1.transform, e, i.matrix, t1.transform.expandedFarZProjMatrix, g, f, m);
                    g++;
                }
                if (f.sort((e, t1)=>t1.depth - e.depth), "shadow" !== t1.renderPass) {
                    if (1 === a) for (const i of m)dr(i, t1, o, u[i.modelIndex], e.ag.disabled, t1.colorModeForRenderPass());
                    else {
                        for (const i of m)dr(i, t1, o, u[i.modelIndex], e.ag.disabled, e.a.disabled);
                        for (const e of m)dr(e, t1, o, u[e.modelIndex], t1.stencilModeFor3D(), t1.colorModeForRenderPass());
                        t1.resetStencilClippingMasks();
                    }
                    for (const i of f)dr(i, t1, o, u[i.modelIndex], e.ag.disabled, t1.colorModeForRenderPass());
                    c();
                } else {
                    for (const e of m)fr(e.mesh, e.nodeModelMatrix, t1, o);
                    for (const e of f)fr(e.mesh, e.nodeModelMatrix, t1, o);
                    c();
                }
            }
        }, Pr = {
            model: function(e, t1, i) {
                const o = t1.getSource();
                if (!o.loaded()) return;
                if ("vector" === o.type || "geojson" === o.type) return void (i.modelManager && i.modelManager.upload(i, "vector" === o.type ? e.scope : ""));
                if ("batched-model" === o.type) return;
                if ("model" !== o.type) return;
                const r = o.getModels();
                for (const e of r)e.upload(i.context);
            },
            raster: function(e, t1, i) {
                const o = t1.getSource();
                if (!(o instanceof Ri && o.loaded())) return;
                const r = e.sourceLayer || o.rasterLayerIds && o.rasterLayerIds[0];
                if (!r) return;
                const a = e.paint.get("raster-array-band") || o.getInitialBand(r);
                if (null == a) return;
                const n = t1.getIds().map((e)=>t1.getTileByID(e));
                for (const e of n)e.updateNeeded(r, a) && o.prepareTile(e, r, a);
            },
            "raster-particle": function(e, t1, i) {
                const o = t1.getSource();
                if (!(o instanceof Ri && o.loaded())) return;
                const r = e.sourceLayer || o.rasterLayerIds && o.rasterLayerIds[0];
                if (!r) return;
                const a = e.paint.get("raster-particle-array-band") || o.getInitialBand(r);
                if (null == a) return;
                const n = t1.getIds().map((e)=>t1.getTileByID(e));
                for (const e of n)e.updateNeeded(r, a) && o.prepareTile(e, r, a);
            }
        };
        class Ar {
            constructor(t1, i, o, r){
                this.context = new ae(t1, i), this.occlusionBuffers = new Ir(this.context), this.transform = o, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = r, this._timeStamp = e.e.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = {
                    showTerrainProxyTiles: !1,
                    fpsWindow: 30,
                    continousRedraw: !1,
                    enabledLayers: {}
                };
                const a = [
                    "fill",
                    "line",
                    "symbol",
                    "circle",
                    "heatmap",
                    "fill-extrusion",
                    "raster",
                    "raster-particle",
                    "hillshade",
                    "model",
                    "background",
                    "sky"
                ];
                for (const e of a)this._debugParams.enabledLayers[e] = !0;
                r.registerParameter(this._debugParams, [
                    "Terrain"
                ], "showTerrainProxyTiles", {}, ()=>{
                    this.style.map.triggerRepaint();
                }), r.registerParameter(this._debugParams, [
                    "FPS"
                ], "fpsWindow", {
                    min: 1,
                    max: 100,
                    step: 1
                }), r.registerBinding(this._debugParams, [
                    "FPS"
                ], "continousRedraw", {
                    readonly: !0,
                    label: "continuous redraw"
                }), r.registerBinding(this, [
                    "FPS"
                ], "_averageFPS", {
                    readonly: !0,
                    label: "value"
                }), r.registerBinding(this, [
                    "FPS"
                ], "_averageFPS", {
                    readonly: !0,
                    label: "graph",
                    view: "graph",
                    min: 0,
                    max: 200
                });
                for (const e of a)r.registerParameter(this._debugParams.enabledLayers, [
                    "Debug",
                    "Layers"
                ], e);
                this.symbolParams = new se(r), this.setup(), this.numSublayers = e.bv.maxUnderzooming + e.bv.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = !1, this.replacementSource = new e.co, this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = !1, this._cachedTileFogOpacities = {}, this._shadowRenderer = new xi(this), this._wireframeDebugCache = new Cr, this.renderDefaultNorthPole = !0, this.renderDefaultSouthPole = !0, this.layersWithOcclusionOpacity = [];
            }
            updateTerrain(e, t1) {
                const i = !!e && !!e.terrain && this.transform.projection.supportsTerrain;
                if (!(i || this._terrain && this._terrain.enabled)) return;
                this._terrain || (this._terrain = new Bi(this, e));
                const o = this._terrain;
                this.transform.elevation = i ? o : null, o.update(e, this.transform, t1), this.transform.elevation && !o.enabled && (this.transform.elevation = null);
            }
            _updateFog(e) {
                const t1 = e.fog;
                if (!t1 || "globe" === this.transform.projection.name || t1.getOpacity(this.transform.pitch) < 1 || t1.properties.get("horizon-blend") < .03) return void (this.transform.fogCullDistSq = null);
                const [i, o] = t1.getFovAdjustedRange(this.transform._fov);
                if (i > o) return void (this.transform.fogCullDistSq = null);
                const r = i + .78 * (o - i);
                this.transform.fogCullDistSq = r * r;
            }
            get terrain() {
                return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null;
            }
            get forceTerrainMode() {
                return this._forceTerrainMode;
            }
            set forceTerrainMode(e) {
                e && !this._terrain && (this._terrain = new Bi(this, this.style)), this._forceTerrainMode = e;
            }
            get shadowRenderer() {
                return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
            }
            get wireframeDebugCache() {
                return this._wireframeDebugCache;
            }
            resize(t1, i) {
                if (this.width = t1 * e.e.devicePixelRatio, this.height = i * e.e.devicePixelRatio, this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.style) for (const e of this.style.order)this.style._mergedLayers[e].resize();
            }
            setup() {
                const t1 = this.context, i = new e.bt;
                i.emplaceBack(0, 0), i.emplaceBack(e.a3, 0), i.emplaceBack(0, e.a3), i.emplaceBack(e.a3, e.a3), this.tileExtentBuffer = t1.createVertexBuffer(i, e.br.members), this.tileExtentSegments = e.b.simpleSegment(0, 0, 4, 2);
                const o = new e.bt;
                o.emplaceBack(0, 0), o.emplaceBack(e.a3, 0), o.emplaceBack(0, e.a3), o.emplaceBack(e.a3, e.a3), this.debugBuffer = t1.createVertexBuffer(o, e.br.members), this.debugSegments = e.b.simpleSegment(0, 0, 4, 5);
                const r = new e.bt;
                r.emplaceBack(-1, -1), r.emplaceBack(1, -1), r.emplaceBack(-1, 1), r.emplaceBack(1, 1), this.viewportBuffer = t1.createVertexBuffer(r, e.br.members), this.viewportSegments = e.b.simpleSegment(0, 0, 4, 2);
                const a = new e.cp;
                a.emplaceBack(0, 0, 0, 0), a.emplaceBack(e.a3, 0, e.a3, 0), a.emplaceBack(0, e.a3, 0, e.a3), a.emplaceBack(e.a3, e.a3, e.a3, e.a3), this.mercatorBoundsBuffer = t1.createVertexBuffer(a, e.cq.members), this.mercatorBoundsSegments = e.b.simpleSegment(0, 0, 4, 2);
                const n = new e.bu;
                n.emplaceBack(0, 1, 2), n.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t1.createIndexBuffer(n);
                const s = new e.cr;
                for (const e of [
                    0,
                    1,
                    3,
                    2,
                    0
                ])s.emplaceBack(e);
                this.debugIndexBuffer = t1.createIndexBuffer(s), this.emptyTexture = new e.T(t1, new e.i({
                    width: 1,
                    height: 1
                }, Uint8Array.of(0, 0, 0, 0)), t1.gl.RGBA), this.identityMat = e.ad.create();
                const l = this.context.gl;
                this.stencilClearMode = new e.ag({
                    func: l.ALWAYS,
                    mask: 0
                }, 0, 255, l.ZERO, l.ZERO, l.ZERO), this.loadTimeStamps.push(performance.now());
            }
            getMercatorTileBoundsBuffers() {
                return {
                    tileBoundsBuffer: this.mercatorBoundsBuffer,
                    tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                    tileBoundsSegments: this.mercatorBoundsSegments
                };
            }
            getTileBoundsBuffers(e) {
                return e._makeTileBoundsBuffers(this.context, this.transform.projection), e._tileBoundsBuffer ? {
                    tileBoundsBuffer: e._tileBoundsBuffer,
                    tileBoundsIndexBuffer: e._tileBoundsIndexBuffer,
                    tileBoundsSegments: e._tileBoundsSegments
                } : this.getMercatorTileBoundsBuffers();
            }
            clearStencil() {
                const t1 = this.context.gl;
                this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, t1.TRIANGLES, e.ae.disabled, this.stencilClearMode, e.a.disabled, e.af.disabled, Pi(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            resetStencilClippingMasks() {
                this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
            }
            _renderTileClippingMasks(t1, i, o) {
                if (!i || this.currentStencilSource === i.id || !t1.isTileClipped() || !o || 0 === o.length) return;
                if (this._tileClippingMaskIDs && !this.terrain) {
                    let e = !1;
                    for (const t1 of o)if (void 0 === this._tileClippingMaskIDs[t1.key]) {
                        e = !0;
                        break;
                    }
                    if (!e) return;
                }
                this.currentStencilSource = i.id;
                const r = this.context, a = r.gl;
                this.nextStencilID + o.length > 256 && this.clearStencil(), r.setColorMode(e.a.disabled), r.setDepthMode(e.ae.disabled);
                const n = this.getOrCreateProgram("clippingMask");
                this._tileClippingMaskIDs = {};
                for (const t1 of o){
                    const o = i.getTile(t1), r = this._tileClippingMaskIDs[t1.key] = this.nextStencilID++, { tileBoundsBuffer: s, tileBoundsIndexBuffer: l, tileBoundsSegments: c } = this.getTileBoundsBuffers(o);
                    n.draw(this, a.TRIANGLES, e.ae.disabled, new e.ag({
                        func: a.ALWAYS,
                        mask: 0
                    }, r, 255, a.KEEP, a.KEEP, a.REPLACE), e.a.disabled, e.af.disabled, Pi(t1.projMatrix), "$clipping", s, l, c);
                }
            }
            stencilModeFor3D() {
                this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
                const t1 = this.nextStencilID++, i = this.context.gl;
                return new e.ag({
                    func: i.NOTEQUAL,
                    mask: 255
                }, t1, 255, i.KEEP, i.KEEP, i.REPLACE);
            }
            stencilModeForClipping(t1) {
                if (this.terrain) return this.terrain.stencilModeForRTTOverlap(t1);
                const i = this.context.gl;
                return new e.ag({
                    func: i.EQUAL,
                    mask: 255
                }, this._tileClippingMaskIDs[t1.key], 0, i.KEEP, i.KEEP, i.REPLACE);
            }
            stencilConfigForOverlap(t1) {
                const i = this.context.gl, o = t1.sort((e, t1)=>t1.overscaledZ - e.overscaledZ), r = o[o.length - 1].overscaledZ, a = o[0].overscaledZ - r + 1;
                if (a > 1) {
                    this.currentStencilSource = void 0, this.nextStencilID + a > 256 && this.clearStencil();
                    const t1 = {};
                    for(let o = 0; o < a; o++)t1[o + r] = new e.ag({
                        func: i.GEQUAL,
                        mask: 255
                    }, o + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);
                    return this.nextStencilID += a, [
                        t1,
                        o
                    ];
                }
                return [
                    {
                        [r]: e.ag.disabled
                    },
                    o
                ];
            }
            colorModeForRenderPass() {
                const t1 = this.context.gl;
                if (this._showOverdrawInspector) {
                    const i = 1 / 8;
                    return new e.a([
                        t1.CONSTANT_COLOR,
                        t1.ONE,
                        t1.CONSTANT_COLOR,
                        t1.ONE
                    ], new e.C(i, i, i, 0), [
                        !0,
                        !0,
                        !0,
                        !0
                    ]);
                }
                return "opaque" === this.renderPass ? e.a.unblended : e.a.alphaBlended;
            }
            colorModeForDrapableLayerRenderPass(t1) {
                const i = this.context.gl;
                return (()=>this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && "translucent" === this.renderPass ? new e.a([
                    i.ONE,
                    i.ONE_MINUS_SRC_ALPHA,
                    i.CONSTANT_ALPHA,
                    i.ONE_MINUS_SRC_ALPHA
                ], new e.C(0, 0, 0, void 0 === t1 ? 0 : t1), [
                    !0,
                    !0,
                    !0,
                    !0
                ]) : this.colorModeForRenderPass();
            }
            depthModeForSublayer(t1, i, o, r = !1) {
                if (this.depthOcclusion) return new e.ae(this.context.gl.GREATER, e.ae.ReadOnly, this.depthRangeFor3D);
                if (!this.opaquePassEnabledForLayer() && !r) return e.ae.disabled;
                const a = 1 - ((1 + this.currentLayer) * this.numSublayers + t1) * this.depthEpsilon;
                return new e.ae(o || this.context.gl.LEQUAL, i, [
                    a,
                    a
                ]);
            }
            opaquePassEnabledForLayer() {
                return this.currentLayer < this.opaquePassCutoff;
            }
            blitDepth() {
                const t1 = this.context.gl, i = Math.ceil(this.width), o = Math.ceil(this.height), r = this.context.bindFramebuffer.get(), a = t1.getParameter(t1.TEXTURE_BINDING_2D);
                this.terrainDepthFBO && this.terrainDepthFBO.width === i && this.terrainDepthFBO.height === o || (this.terrainDepthFBO && (this.terrainDepthFBO.destroy(), this.terrainDepthFBO = void 0, this.terrainDepthTexture = void 0), 0 !== i && 0 !== o && (this.terrainDepthFBO = new re(this.context, i, o, !1, "texture"), this.terrainDepthTexture = new e.T(this.context, {
                    width: i,
                    height: o,
                    data: null
                }, t1.DEPTH_STENCIL), this.terrainDepthFBO.depthAttachment.set(this.terrainDepthTexture.texture))), this.context.bindFramebuffer.set(r), t1.bindTexture(t1.TEXTURE_2D, a), this.terrainDepthFBO && (t1.bindFramebuffer(t1.READ_FRAMEBUFFER, null), t1.bindFramebuffer(t1.DRAW_FRAMEBUFFER, this.terrainDepthFBO.framebuffer), t1.blitFramebuffer(0, 0, i, o, 0, 0, i, o, t1.DEPTH_BUFFER_BIT, t1.NEAREST), t1.bindFramebuffer(t1.FRAMEBUFFER, this.context.bindFramebuffer.current));
            }
            updateAverageFPS() {
                this._fpsHistory.push(0 === this._dt ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((e, t1)=>e + t1 / this._fpsHistory.length, 0));
            }
            render(t1, i) {
                const o = e.e.now();
                this._dt = o - this._timeStamp, this._timeStamp = o, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t1.map.repaint, this.style = t1, this.options = i;
                const r = this.style._mergedLayers, a = this.style.order.filter((e)=>{
                    const t1 = r[e];
                    return !(t1.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[t1.type];
                }), n = a.map((e)=>r[e]), s = this.style._mergedSourceCaches;
                this.imageManager = t1.imageManager, this.modelManager = t1.modelManager, this.symbolFadeChange = t1.placement.symbolFadeChange(e.e.now()), this.imageManager.beginFrame();
                let l = 0, c = !1;
                for(const e in s){
                    const t1 = s[e];
                    t1.used && (t1.prepare(this.context), t1.getSource().usedInConflation && ++l);
                }
                let h = !1;
                for (const e of n)e.isHidden(this.transform.zoom) || ("clip" === e.type && (h = !0), this.prepareLayer(e));
                const _ = {}, u = {}, d = {}, p = {}, f = {};
                for(const e in s){
                    const t1 = s[e];
                    _[e] = t1.getVisibleCoordinates(), u[e] = _[e].slice().reverse(), d[e] = t1.getVisibleCoordinates(!0).reverse(), p[e] = t1.getShadowCasterCoordinates(), f[e] = t1.sortCoordinatesByDistance(_[e]);
                }
                const m = (e)=>{
                    const t1 = this.style.getLayerSourceCache(e);
                    return t1 && t1.used ? t1.getSource() : null;
                };
                if (l || h) {
                    const t1 = [], i = [];
                    let o = 0;
                    for (const e of n)this.isSourceForClippingOrConflation(e, m(e)) && (t1.push(e), i.push(o)), o++;
                    if (t1 && (h || t1.length > 1)) {
                        const o = [];
                        for(let r = 0; r < t1.length; r++){
                            const a = t1[r], n = i[r], s = this.style.getLayerSourceCache(a);
                            if (!s || !s.used || !s.getSource().usedInConflation && "clip" !== a.type) continue;
                            let l = 1 / 0, c = e.cu.None;
                            if ("clip" === a.type) {
                                l = n;
                                for (const t1 of a.layout.get("clip-layer-types"))c |= "model" === t1 ? e.cu.Model : "symbol" === t1 ? e.cu.Symbol : e.cu.FillExtrusion;
                            }
                            o.push({
                                layer: a.fqid,
                                cache: s,
                                order: l,
                                clipMask: c
                            });
                        }
                        this.replacementSource.setSources(o), c = !0;
                    }
                }
                c || this.replacementSource.clear(), this.conflationActive = c, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];
                for(let e = 0; e < n.length; e++){
                    const t1 = n[e], i = t1.cutoffRange();
                    if (this.longestCutoffRange = Math.max(i, this.longestCutoffRange), i > 0) {
                        const e = m(t1);
                        e && (this.minCutoffZoom = Math.max(e.minzoom, this.minCutoffZoom)), t1.minzoom && (this.minCutoffZoom = Math.max(t1.minzoom, this.minCutoffZoom));
                    }
                    t1.is3D() && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = e), this._lastOcclusionLayer = e);
                }
                const g = this.style && this.style.fog;
                g ? (this._fogVisible = 0 !== g.getOpacity(this.transform.pitch), this._fogVisible && "globe" !== this.transform.projection.name && (this._fogVisible = g.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = !1, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(d), this.opaquePassCutoff = 0);
                const v = this._shadowRenderer;
                if (v) {
                    v.updateShadowParameters(this.transform, this.style.directionalLight);
                    for(const e in s)for (const t1 of _[e]){
                        let e = {
                            min: 0,
                            max: 0
                        };
                        this.terrain && (e = this.terrain.getMinMaxForTile(t1) || e), v.addShadowReceiver(t1.toUnwrapped(), e.min, e.max);
                    }
                }
                if ("globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.cs(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new hr(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), !e.ct(this.context.gl)) return;
                this.renderPass = "offscreen";
                for (const e of n){
                    const i = t1.getLayerSourceCache(e);
                    if (!e.hasOffscreenPass() || e.isHidden(this.transform.zoom)) continue;
                    const o = i ? u[i.id] : void 0;
                    ("custom" === e.type || "raster" === e.type || "raster-particle" === e.type || e.isSky() || o && o.length) && this.renderLayer(this, i, e, o);
                }
                this.depthRangeFor3D = [
                    0,
                    1 - (n.length + 2) * this.numSublayers * this.depthEpsilon
                ], this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, p)), this.context.bindFramebuffer.set(null), this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]);
                const x = "globe" === this.transform.projection.name || this.transform.isHorizonVisible(), y = (()=>{
                    if (i.showOverdrawInspector) return e.C.black;
                    const t1 = this.style.fog;
                    if (t1 && this.transform.projection.supportsFog) {
                        const i = this.style.getLut(t1.scope);
                        if (!x) {
                            const o = t1.properties.get("color").toRenderColor(i).toArray01();
                            return new e.C(...o);
                        }
                        if (x) {
                            const o = t1.properties.get("space-color").toRenderColor(i).toArray01();
                            return new e.C(...o);
                        }
                    }
                    return e.C.transparent;
                })();
                if (this.context.clear({
                    color: y,
                    depth: 1
                }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && x && this._atmosphere.drawStars(this, this.style.fog), !this.terrain) for(this.currentLayer = a.length - 1; this.currentLayer >= 0; this.currentLayer--){
                    const e = n[this.currentLayer], i = t1.getLayerSourceCache(e);
                    if (e.isSky()) continue;
                    const o = i ? (e.is3D() ? f : u)[i.id] : void 0;
                    this._renderTileClippingMasks(e, i, o), this.renderLayer(this, i, e, o);
                }
                if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && x && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || e.a1(this.transform.zoom) > 0) && ("globe" === this.transform.projection.name || this.transform.isHorizonVisible())) for(this.currentLayer = 0; this.currentLayer < a.length; this.currentLayer++){
                    const e = n[this.currentLayer], i = t1.getLayerSourceCache(e);
                    e.isSky() && this.renderLayer(this, i, e, i ? u[i.id] : void 0);
                }
                function b(e, t1) {
                    let i;
                    return t1 && (i = ("symbol" === e.type ? d : e.is3D() ? f : u)[t1.id]), i;
                }
                if (this.renderPass = "translucent", "globe" === this.transform.projection.name) {
                    for(this.renderElevatedRasterBackface = !0, this.currentLayer = 0; this.currentLayer < a.length;){
                        const e = n[this.currentLayer];
                        if ("raster" === e.type) {
                            const i = t1.getLayerSourceCache(e);
                            this.renderLayer(this, i, e, b(e, i));
                        }
                        ++this.currentLayer;
                    }
                    this.renderElevatedRasterBackface = !1;
                }
                this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
                let w = 0;
                v && (w = v.getShadowCastingLayerCount());
                let T = !1;
                for(; this.currentLayer < a.length;){
                    const e = n[this.currentLayer], i = t1.getLayerSourceCache(e);
                    if (e.isSky()) ++this.currentLayer;
                    else if (this.terrain && this.style.isLayerDraped(e)) {
                        if (e.isHidden(this.transform.zoom)) {
                            ++this.currentLayer;
                            continue;
                        }
                        this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);
                    } else {
                        if (T || !this.terrain || !this.style.hasSymbolLayers() && !this.style.hasCircleLayers() || this.transform.isOrthographic || (T = !0, this.blitDepth()), e.is3D() || this.terrain || this._renderTileClippingMasks(e, i, i ? _[i.id] : void 0), this.renderLayer(this, i, e, b(e, i)), !this.terrain && v && w > 0 && e.hasShadowPass() && 0 == --w && (v.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {
                            const e = this.currentLayer;
                            for(this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= e; this.currentLayer++){
                                const e = n[this.currentLayer];
                                if (!e.hasLightBeamPass()) continue;
                                const i = t1.getLayerSourceCache(e);
                                this.renderLayer(this, i, e, i ? u[i.id] : void 0);
                            }
                            this.currentLayer = e, this.renderPass = "translucent";
                        }
                        if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
                            const e = this.currentLayer;
                            this.depthOcclusion = !0;
                            for (const e of this.layersWithOcclusionOpacity){
                                this.currentLayer = e;
                                const i = n[this.currentLayer], o = t1.getLayerSourceCache(i), r = o ? u[o.id] : void 0;
                                i.is3D() || this.terrain || this._renderTileClippingMasks(i, o, o ? _[o.id] : void 0), this.renderLayer(this, o, i, r);
                            }
                            this.depthOcclusion = !1, this.currentLayer = e, this.renderPass = "translucent", this.layersWithOcclusionOpacity = [];
                        }
                        ++this.currentLayer;
                    }
                }
                if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                    let i = null;
                    n.forEach((e)=>{
                        const o = t1.getLayerSourceCache(e);
                        o && !e.isHidden(this.transform.zoom) && o.getVisibleCoordinates().length && (!i || i.getSource().maxzoom < o.getSource().maxzoom) && (i = o);
                    }), i && this.options.showTileBoundaries && Lr.debug(this, i, i.getVisibleCoordinates(), e.C.red, !1, this.options.showParseStatus);
                }
                this.terrain && this._debugParams.showTerrainProxyTiles && Lr.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new e.C(1, .8, .1, 1), !0, this.options.showParseStatus), this.options.showPadding && function(e) {
                    const t1 = e.transform.padding;
                    Qo(e, e.transform.height - (t1.top || 0), 3, qo), Qo(e, t1.bottom || 0, 3, Ho), Jo(e, t1.left || 0, 3, $o), Jo(e, e.transform.width - (t1.right || 0), 3, Xo);
                    const i = e.transform.centerPoint;
                    !function(e, t1, i, o) {
                        er(e, t1 - 1, i - 10, 2, 20, o), er(e, t1 - 10, i - 1, 20, 2, o);
                    }(e, i.x, e.transform.height - i.y, Yo);
                }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), c || (this.conflationActive = !1);
            }
            prepareLayer(e) {
                this.gpuTimingStart(e);
                const { unsupportedLayers: t1 } = this.transform.projection, i = !t1 || !t1.includes(e.type);
                if (Pr[e.type] && (i || this.terrain && "custom" === e.type)) {
                    const t1 = this.style.getLayerSourceCache(e);
                    Pr[e.type](e, t1, this);
                }
                this.gpuTimingEnd();
            }
            renderLayer(e, t1, i, o) {
                i.isHidden(this.transform.zoom) || ("background" === i.type || "sky" === i.type || "custom" === i.type || "model" === i.type || "raster" === i.type || "raster-particle" === i.type || o && o.length) && (this.id = i.id, this.gpuTimingStart(i), e.transform.projection.unsupportedLayers && e.transform.projection.unsupportedLayers.includes(i.type) && (!e.terrain || "custom" !== i.type) || "clip" === i.type || Lr[i.type](e, t1, i, o, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
            }
            gpuTimingStart(e) {
                if (!this.options.gpuTiming) return;
                const t1 = this.context.extTimerQuery, i = this.context.gl;
                let o = this.gpuTimers[e.id];
                o || (o = this.gpuTimers[e.id] = {
                    calls: 0,
                    cpuTime: 0,
                    query: i.createQuery()
                }), o.calls++, i.beginQuery(t1.TIME_ELAPSED_EXT, o.query);
            }
            gpuTimingDeferredRenderStart() {
                if (this.options.gpuTimingDeferredRender) {
                    const e = this.context.extTimerQuery, t1 = this.context.gl, i = t1.createQuery();
                    this.deferredRenderGpuTimeQueries.push(i), t1.beginQuery(e.TIME_ELAPSED_EXT, i);
                }
            }
            gpuTimingDeferredRenderEnd() {
                this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
            }
            gpuTimingEnd() {
                this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
            }
            collectGpuTimers() {
                const e = this.gpuTimers;
                return this.gpuTimers = {}, e;
            }
            collectDeferredRenderGpuQueries() {
                const e = this.deferredRenderGpuTimeQueries;
                return this.deferredRenderGpuTimeQueries = [], e;
            }
            queryGpuTimers(e) {
                const t1 = {};
                for(const i in e){
                    const o = e[i], r = this.context.extTimerQuery, a = r.getQueryParameter(o.query, this.context.gl.QUERY_RESULT) / 1e6;
                    r.deleteQueryEXT(o.query), t1[i] = a;
                }
                return t1;
            }
            queryGpuTimeDeferredRender(e) {
                if (!this.options.gpuTimingDeferredRender) return 0;
                const t1 = this.context.extTimerQuery, i = this.context.gl;
                let o = 0;
                for (const r of e)o += t1.getQueryParameter(r, i.QUERY_RESULT) / 1e6, t1.deleteQueryEXT(r);
                return o;
            }
            translatePosMatrix(t1, i, o, r, a) {
                if (!o[0] && !o[1]) return t1;
                const n = a ? "map" === r ? this.transform.angle : 0 : "viewport" === r ? -this.transform.angle : 0;
                if (n) {
                    const e = Math.sin(n), t1 = Math.cos(n);
                    o = [
                        o[0] * t1 - o[1] * e,
                        o[0] * e + o[1] * t1
                    ];
                }
                const s = [
                    a ? o[0] : e.bB(i, o[0], this.transform.zoom),
                    a ? o[1] : e.bB(i, o[1], this.transform.zoom),
                    0
                ], l = new Float32Array(16);
                return e.ad.translate(l, t1, s), l;
            }
            saveTileTexture(e) {
                const t1 = e.size[0], i = this._tileTextures[t1];
                i ? i.push(e) : this._tileTextures[t1] = [
                    e
                ];
            }
            getTileTexture(e) {
                const t1 = this._tileTextures[e];
                return t1 && t1.length > 0 ? t1.pop() : null;
            }
            terrainRenderModeElevated() {
                return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode;
            }
            linearFloatFilteringSupported() {
                return null != this.context.extTextureFloatLinear;
            }
            currentGlobalDefines(e, t1, i) {
                const o = void 0 === i ? this.terrain && this.terrain.renderingToTexture : i, r = [];
                return this.style && this.style.enable3dLights() && ("globeRaster" === e || "terrainRaster" === e ? (r.push("LIGHTING_3D_MODE"), r.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : o || r.push("LIGHTING_3D_MODE")), "shadow" === this.renderPass ? this._shadowMapDebug || r.push("DEPTH_TEXTURE") : this.shadowRenderer && (this.shadowRenderer.useNormalOffset ? r.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET") : r.push("RENDER_SHADOWS", "DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (r.push("TERRAIN"), this.linearFloatFilteringSupported() && r.push("TERRAIN_DEM_FLOAT_FORMAT")), "globe" === this.transform.projection.name && r.push("GLOBE"), !this._fogVisible || o || void 0 !== t1 && !t1 || r.push("FOG", "FOG_DITHERING"), o && r.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && r.push("OVERDRAW_INSPECTOR"), r;
            }
            getOrCreateProgram(e, t1) {
                this.cache = this.cache || {};
                const i = t1 && t1.defines || [], o = t1 && t1.config, r = this.currentGlobalDefines(e, t1 && t1.overrideFog, t1 && t1.overrideRtt).concat(i), a = Gi.cacheKey(Lt[e], e, r, o);
                return this.cache[a] || (this.cache[a] = new Gi(this.context, e, Lt[e], o, yo[e], r)), this.cache[a];
            }
            setCustomLayerDefaults() {
                this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
                const e = this.context.gl;
                this.context.cullFace.set(!1), this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.context.blendEquation.set(e.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
                null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
            }
            destroy() {
                this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.terrainDepthFBO && (this.terrainDepthFBO.destroy(), this.terrainDepthFBO = void 0, this.terrainDepthTexture = void 0);
            }
            prepareDrawTile() {
                this.terrain && this.terrain.prepareDrawTile();
            }
            uploadCommonLightUniforms(t1, i) {
                if (this.style.enable3dLights()) {
                    const o = this.style.directionalLight, r = this.style.ambientLight;
                    if (o && r) {
                        const a = ((t1, i, o)=>{
                            const r = t1.properties.get("direction"), a = t1.properties.get("color").toRenderColor(o.getLut(t1.scope)).toArray01(), n = t1.properties.get("intensity"), s = i.properties.get("color").toRenderColor(o.getLut(i.scope)).toArray01(), l = i.properties.get("intensity"), c = [
                                r.x,
                                r.y,
                                r.z
                            ], h = e.bA(s, l), _ = e.bA(a, n);
                            return {
                                u_lighting_ambient_color: h,
                                u_lighting_directional_dir: c,
                                u_lighting_directional_color: _,
                                u_ground_radiance: ki(c, _, h)
                            };
                        })(o, r, this.style);
                        i.setLightsUniformValues(t1, a);
                    }
                }
            }
            uploadCommonUniforms(t1, i, o, r, a) {
                if (this.uploadCommonLightUniforms(t1, i), this.terrain && this.terrain.renderingToTexture) return;
                const n = this.style.fog;
                if (n) {
                    const a = n.getOpacity(this.transform.pitch), s = ((t1, i, o, r, a, n, s, l, c, h, _, u)=>{
                        const d = t1.transform, p = i.properties.get("color").toRenderColor(t1.style.getLut(i.scope)).toArray01();
                        p[3] = r;
                        const f = t1.frameCounter / 1e3 % 1, [m, g] = i.properties.get("vertical-range");
                        return {
                            u_fog_matrix: o ? d.calculateFogTileMatrix(o) : u || t1.identityMat,
                            u_fog_range: i.getFovAdjustedRange(d._fov),
                            u_fog_color: p,
                            u_fog_horizon_blend: i.properties.get("horizon-blend"),
                            u_fog_vertical_limit: [
                                Math.min(m, g),
                                g
                            ],
                            u_fog_temporal_offset: f,
                            u_frustum_tl: a,
                            u_frustum_tr: n,
                            u_frustum_br: s,
                            u_frustum_bl: l,
                            u_globe_pos: c,
                            u_globe_radius: h,
                            u_viewport: _,
                            u_globe_transition: e.a1(d.zoom),
                            u_is_globe: +("globe" === d.projection.name)
                        };
                    })(this, n, o, a, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [
                        this.transform.width * e.e.devicePixelRatio,
                        this.transform.height * e.e.devicePixelRatio
                    ], r);
                    i.setFogUniformValues(t1, s);
                }
                a && i.setCutoffUniformValues(t1, a.uniformValues);
            }
            setTileLoadedFlag(e) {
                this.tileLoaded = e;
            }
            saveCanvasCopy() {
                const e = this.canvasCopy();
                e && (this.frameCopies.push(e), this.tileLoaded = !1);
            }
            canvasCopy() {
                const e = this.context.gl, t1 = e.createTexture();
                return e.bindTexture(e.TEXTURE_2D, t1), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, 0, 0, e.drawingBufferWidth, e.drawingBufferHeight, 0), t1;
            }
            getCanvasCopiesAndTimestamps() {
                return {
                    canvasCopies: this.frameCopies,
                    timeStamps: this.loadTimeStamps
                };
            }
            averageElevationNeedsEasing() {
                if (!this.transform._elevation) return !1;
                const e = this.style && this.style.fog;
                return !!e && 0 !== e.getOpacity(this.transform.pitch);
            }
            getBackgroundTiles() {
                const t1 = this._backgroundTiles, i = this._backgroundTiles = {}, o = this.transform.coveringTiles({
                    tileSize: 512
                });
                for (const r of o)i[r.key] = t1[r.key] || new e.by(r, 512, this.transform.tileZoom, this);
                return i;
            }
            clearBackgroundTiles() {
                this._backgroundTiles = {};
            }
            isSourceForClippingOrConflation(e, t1) {
                return !(!e.is3D() || e.minzoom && e.minzoom > this.transform.zoom || (this.style._clipLayerIndices.length || "building" !== e.sourceLayer) && "clip" !== e.type && (!t1 || "batched-model" !== t1.type));
            }
            isTileAffectedByFog(e) {
                if (!this.style || !this.style.fog) return !1;
                if ("globe" === this.transform.projection.name) return !0;
                let t1 = this._cachedTileFogOpacities[e.key];
                return t1 || (this._cachedTileFogOpacities[e.key] = t1 = this.style.fog.getOpacityForTile(e)), t1[0] >= it || t1[1] >= it;
            }
        }
        class Rr {
            constructor(e, t1, i, o){
                this.screenBounds = e, this.cameraPoint = t1, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o);
            }
            static createFromScreenPoints(t1, i) {
                let o, r;
                if (t1 instanceof e.P || "number" == typeof t1[0]) {
                    const a = e.P.convert(t1);
                    o = [
                        a
                    ], r = i.isPointAboveHorizon(a);
                } else {
                    const a = e.P.convert(t1[0]), n = e.P.convert(t1[1]);
                    o = [
                        a,
                        n
                    ], r = e.cv(a, n).every((e)=>i.isPointAboveHorizon(e));
                }
                return new Rr(o, i.getCameraPoint(), r, i);
            }
            isPointQuery() {
                return 1 === this.screenBounds.length;
            }
            bufferedScreenGeometry(t1) {
                return e.cv(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t1);
            }
            bufferedCameraGeometry(t1) {
                const i = this.screenBounds[0], o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], r = e.cv(i, o, 0, !1);
                return this.cameraPoint.y > o.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < o.x ? r.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o.x ? r[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (r[3] = this.cameraPoint)), e.cw(r, t1);
            }
            bufferedCameraGeometryGlobe(t1) {
                const i = this.screenBounds[0], o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], r = e.cv(i, o, t1), a = this.cameraPoint.clone();
                switch(3 * ((a.y > i.y) + (a.y > o.y)) + ((a.x > i.x) + (a.x > o.x))){
                    case 0:
                        r[0] = a, r[4] = a.clone();
                        break;
                    case 1:
                        r.splice(1, 0, a);
                        break;
                    case 2:
                        r[1] = a;
                        break;
                    case 3:
                        r.splice(4, 0, a);
                        break;
                    case 5:
                        r.splice(2, 0, a);
                        break;
                    case 6:
                        r[3] = a;
                        break;
                    case 7:
                        r.splice(3, 0, a);
                        break;
                    case 8:
                        r[2] = a;
                }
                return r;
            }
            containsTile(t1, i, o, r = 0) {
                const a = t1.queryPadding / i._pixelsPerMercatorPixel + 1, n = o ? this._bufferedCameraMercator(a, i) : this._bufferedScreenMercator(a, i);
                let s = t1.tileID.wrap + (n.unwrapped ? r : 0);
                const l = n.polygon.map((i)=>e.cx(t1.tileTransform, i, s));
                if (!e.cy(l, 0, 0, e.a3, e.a3)) return;
                s = t1.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r : 0);
                const c = this.screenGeometryMercator.polygon.map((i)=>e.cz(t1.tileTransform, i, s)), h = c.map((t1)=>new e.P(t1[0], t1[1])), _ = i.getFreeCameraOptions().position || new e.Y(0, 0, 0), u = e.cz(t1.tileTransform, _, s), d = c.map((t1)=>{
                    const i = e._.sub(t1, t1, u);
                    return e._.normalize(i, i), new e.aT(u, i);
                }), p = e.bB(t1, 1, i.zoom) * i._pixelsPerMercatorPixel;
                var f;
                return {
                    queryGeometry: this,
                    tilespaceGeometry: h,
                    tilespaceRays: d,
                    bufferedTilespaceGeometry: l,
                    bufferedTilespaceBounds: (f = e.cA(l), f.min.x = e.at(f.min.x, 0, e.a3), f.min.y = e.at(f.min.y, 0, e.a3), f.max.x = e.at(f.max.x, 0, e.a3), f.max.y = e.at(f.max.y, 0, e.a3), f),
                    tile: t1,
                    tileID: t1.tileID,
                    pixelToTileUnitsFactor: p
                };
            }
            _bufferedScreenMercator(e, t1) {
                const i = zr(e);
                if (this._screenRaycastCache[i]) return this._screenRaycastCache[i];
                {
                    let o;
                    return o = "globe" === t1.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e), t1) : {
                        polygon: this.bufferedScreenGeometry(e).map((e)=>t1.pointCoordinate3D(e)),
                        unwrapped: !0
                    }, this._screenRaycastCache[i] = o, o;
                }
            }
            _bufferedCameraMercator(e, t1) {
                const i = zr(e);
                if (this._cameraRaycastCache[i]) return this._cameraRaycastCache[i];
                {
                    let o;
                    return o = "globe" === t1.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e), t1) : {
                        polygon: this.bufferedCameraGeometry(e).map((e)=>t1.pointCoordinate3D(e)),
                        unwrapped: !0
                    }, this._cameraRaycastCache[i] = o, o;
                }
            }
            _projectAndResample(t1, i) {
                const o = function(t1, i) {
                    const o = e.ad.multiply([], i.pixelMatrix, i.globeMatrix), r = [
                        0,
                        -e.cD,
                        0,
                        1
                    ], a = [
                        0,
                        e.cD,
                        0,
                        1
                    ], n = [
                        0,
                        0,
                        0,
                        1
                    ];
                    e.aA.transformMat4(r, r, o), e.aA.transformMat4(a, a, o), e.aA.transformMat4(n, n, o);
                    const s = new e.P(r[0] / r[3], r[1] / r[3]), l = new e.P(a[0] / a[3], a[1] / a[3]), c = e.cB(t1, s) && r[3] < n[3], h = e.cB(t1, l) && a[3] < n[3];
                    if (!c && !h) return null;
                    const _ = function(e, t1, i) {
                        for(let o = 1; o < e.length; o++){
                            const r = Mr(t1.pointCoordinate3D(e[o - 1]).x), a = Mr(t1.pointCoordinate3D(e[o]).x);
                            if (i < 0) {
                                if (r < a) return {
                                    idx: o,
                                    t: -r / (a - 1 - r)
                                };
                            } else if (a < r) return {
                                idx: o,
                                t: (1 - r) / (a + 1 - r)
                            };
                        }
                        return null;
                    }(t1, i, c ? -1 : 1);
                    if (!_) return null;
                    const { idx: u, t: d } = _;
                    let p = u > 1 ? Dr(t1.slice(0, u), i) : [], f = u < t1.length ? Dr(t1.slice(u), i) : [];
                    p = p.map((t1)=>new e.P(Mr(t1.x), t1.y)), f = f.map((t1)=>new e.P(Mr(t1.x), t1.y));
                    const m = [
                        ...p
                    ];
                    0 === m.length && m.push(f[f.length - 1]);
                    const g = e.a2(m[m.length - 1].y, (0 === f.length ? p[0] : f[0]).y, d);
                    let v;
                    return v = c ? [
                        new e.P(0, g),
                        new e.P(0, 0),
                        new e.P(1, 0),
                        new e.P(1, g)
                    ] : [
                        new e.P(1, g),
                        new e.P(1, 1),
                        new e.P(0, 1),
                        new e.P(0, g)
                    ], m.push(...v), 0 === f.length ? m.push(p[0]) : m.push(...f), {
                        polygon: m.map((t1)=>new e.Y(t1.x, t1.y)),
                        unwrapped: !1
                    };
                }(t1, i);
                if (o) return o;
                const r = function(t1, i) {
                    let o = !1, r = -1 / 0, a = 0;
                    for(let e = 0; e < t1.length - 1; e++)t1[e].x > r && (r = t1[e].x, a = e);
                    for(let e = 0; e < t1.length - 1; e++){
                        const i = (a + e) % (t1.length - 1), r = t1[i], n = t1[i + 1];
                        Math.abs(r.x - n.x) > .5 && (r.x < n.x ? (r.x += 1, 0 === i && (t1[t1.length - 1].x += 1)) : (n.x += 1, i + 1 === t1.length - 1 && (t1[0].x += 1)), o = !0);
                    }
                    const n = e.aj(i.center.lng);
                    return o && n < Math.abs(n - 1) && t1.forEach((e)=>{
                        e.x -= 1;
                    }), {
                        polygon: t1,
                        unwrapped: o
                    };
                }(Dr(t1, i).map((t1)=>new e.P(Mr(t1.x), t1.y)), i);
                return {
                    polygon: r.polygon.map((t1)=>new e.Y(t1.x, t1.y)),
                    unwrapped: r.unwrapped
                };
            }
        }
        function Dr(t1, i) {
            return e.cC(t1, (e)=>{
                const t1 = i.pointCoordinate3D(e);
                e.x = t1.x, e.y = t1.y;
            }, 1 / 256);
        }
        function Mr(e) {
            return e < 0 ? 1 + e % 1 : e % 1;
        }
        function zr(e) {
            return 100 * e | 0;
        }
        function Or(t1, i) {
            const o = e.ad.identity([]);
            return e.ad.scale(o, o, [
                .5 * t1.width,
                .5 * -t1.height,
                1
            ]), e.ad.translate(o, o, [
                1,
                -1,
                0
            ]), e.ad.multiply(o, o, t1.calculateProjMatrix(i.toUnwrapped())), Float32Array.from(o);
        }
        function Fr(e, t1, i, o, r, a, n, s = !1) {
            const l = e.tilesIn(o, n, s);
            l.sort(kr);
            const c = [];
            for (const o of l)c.push({
                wrappedTileID: o.tile.tileID.wrapped().key,
                queryResults: o.tile.queryRenderedFeatures(t1, i, e._state, o, r, a, Or(e.transform, o.tile.tileID), s)
            });
            const h = function(e) {
                const t1 = {}, i = {};
                for (const o of e){
                    const e = o.queryResults, r = o.wrappedTileID, a = i[r] = i[r] || {};
                    for(const i in e){
                        const o = e[i], r = a[i] = a[i] || {}, n = t1[i] = t1[i] || [];
                        for (const e of o)r[e.featureIndex] || (r[e.featureIndex] = !0, n.push(e));
                    }
                }
                return t1;
            }(c);
            for(const t1 in h)h[t1].forEach((t1)=>{
                const i = t1.feature, o = i.layer;
                o && "background" !== o.type && "sky" !== o.type && "slot" !== o.type && (i.source = o.source, o["source-layer"] && (i.sourceLayer = o["source-layer"]), i.state = void 0 !== i.id ? e.getFeatureState(o["source-layer"], i.id) : {});
            });
            return h;
        }
        function Br(e, t1) {
            const i = e.getRenderableIds().map((t1)=>e.getTileByID(t1)), o = [], r = {};
            for(let e = 0; e < i.length; e++){
                const a = i[e], n = a.tileID.canonical.key;
                r[n] || (r[n] = !0, a.querySourceFeatures(o, t1));
            }
            return o;
        }
        function kr(e, t1) {
            const i = e.tileID, o = t1.tileID;
            return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;
        }
        class Nr {
            constructor(e){
                this.style = e, this.layersGotHidden = !1, this.layers = [];
            }
            processLayersChanged() {
                this.layers = [];
                const e = !1, t1 = !1;
                for(const i in this.style._mergedLayers){
                    const o = this.style._mergedLayers[i];
                    if ("fill-extrusion" === o.type) this.layers.push({
                        layer: o,
                        visible: e,
                        visibilityChanged: t1
                    });
                    else if ("model" === o.type) {
                        const i = this.style.getLayerSource(o);
                        i && "batched-model" === i.type && this.layers.push({
                            layer: o,
                            visible: e,
                            visibilityChanged: t1
                        });
                    }
                }
            }
            onNewFrame(e) {
                this.layersGotHidden = !1;
                for (const t1 of this.layers){
                    const i = t1.layer;
                    let o = !1;
                    "fill-extrusion" === i.type ? o = !i.isHidden(e) && i.paint.get("fill-extrusion-opacity") > 0 : "model" === i.type && (o = !i.isHidden(e) && i.paint.get("model-opacity") > 0), this.layersGotHidden = this.layersGotHidden || !o && t1.visible, t1.visible = o;
                }
            }
            updateZOffset(e, t1) {
                this.currentBuildingBuckets = [];
                for (const e of this.layers){
                    const i = e.layer, o = this.style.getLayerSourceCache(i);
                    let r = 1;
                    "fill-extrusion" === i.type && (r = e.visible ? i.paint.get("fill-extrusion-vertical-scale") : 0);
                    let a = o ? o.getTile(t1) : null;
                    if (!a && o && t1.canonical.z > o.getSource().minzoom) {
                        let e = t1.scaledTo(Math.min(o.getSource().maxzoom, t1.overscaledZ - 1));
                        for(; e.overscaledZ >= o.getSource().minzoom && (a = o.getTile(e), !a && 0 !== e.overscaledZ);)e = e.scaledTo(e.overscaledZ - 1);
                    }
                    this.currentBuildingBuckets.push({
                        bucket: a ? a.getBucket(i) : null,
                        tileID: a ? a.tileID : t1,
                        verticalScale: r
                    });
                }
                e.hasAnyZOffset = !1;
                let i = !1;
                for(let o = 0; o < e.symbolInstances.length; o++){
                    const r = e.symbolInstances.get(o), a = r.zOffset, n = this._getHeightAtTileOffset(t1, r.tileAnchorX, r.tileAnchorY);
                    r.zOffset = n !== Number.NEGATIVE_INFINITY ? n : a, i || a === r.zOffset || (i = !0), e.hasAnyZOffset || 0 === r.zOffset || (e.hasAnyZOffset = !0);
                }
                i && (e.zOffsetBuffersNeedUpload = !0, e.zOffsetSortDirty = !0);
            }
            _mapCoordToOverlappingTile(t1, i, o, r) {
                let a = i, n = o;
                if (t1.canonical.z !== r.canonical.z) {
                    const s = r.canonical, l = 1 / (1 << t1.canonical.z - s.z);
                    a = (i + t1.canonical.x * e.a3) * l - s.x * e.a3 | 0, n = (o + t1.canonical.y * e.a3) * l - s.y * e.a3 | 0;
                }
                return {
                    tileX: a,
                    tileY: n
                };
            }
            _getHeightAtTileOffset(e, t1, i) {
                let o, r;
                for(let a = 0; a < this.layers.length; ++a){
                    if ("fill-extrusion" !== this.layers[a].layer.type) continue;
                    const { bucket: n, tileID: s, verticalScale: l } = this.currentBuildingBuckets[a];
                    if (!n) continue;
                    const { tileX: c, tileY: h } = this._mapCoordToOverlappingTile(e, t1, i, s), _ = n.getHeightAtTileCoord(c, h);
                    _ && void 0 !== _.height && (_.hidden ? o = _.height : r = Math.max(_.height * l, r || 0));
                }
                if (void 0 !== r) return r;
                for(let r = 0; r < this.layers.length; ++r){
                    const a = this.layers[r];
                    if ("model" !== a.layer.type || !a.visible) continue;
                    const { bucket: n, tileID: s } = this.currentBuildingBuckets[r];
                    if (!n) continue;
                    const { tileX: l, tileY: c } = this._mapCoordToOverlappingTile(e, t1, i, s), h = n.getHeightAtTileCoord(l, c);
                    if (h && !h.hidden) return void 0 === h.height && void 0 !== o ? Math.min(h.maxHeight, o) * h.verticalScale : h.height ? h.height * h.verticalScale : Number.NEGATIVE_INFINITY;
                }
                return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
            }
        }
        function Ur(t1, i) {
            const o = {};
            for(const e in t1)"ref" !== e && (o[e] = t1[e]);
            return e.cE.forEach((e)=>{
                e in i && (o[e] = i[e]);
            }), o;
        }
        function Gr(e) {
            e = e.slice();
            const t1 = Object.create(null);
            for(let i = 0; i < e.length; i++)t1[e[i].id] = e[i];
            for(let i = 0; i < e.length; i++)"ref" in e[i] && (e[i] = Ur(e[i], t1[e[i].ref]));
            return e;
        }
        const jr = {
            setStyle: "setStyle",
            addLayer: "addLayer",
            removeLayer: "removeLayer",
            setPaintProperty: "setPaintProperty",
            setLayoutProperty: "setLayoutProperty",
            setSlot: "setSlot",
            setFilter: "setFilter",
            addSource: "addSource",
            removeSource: "removeSource",
            setGeoJSONSourceData: "setGeoJSONSourceData",
            setLayerZoomRange: "setLayerZoomRange",
            setLayerProperty: "setLayerProperty",
            setCenter: "setCenter",
            setZoom: "setZoom",
            setBearing: "setBearing",
            setPitch: "setPitch",
            setSprite: "setSprite",
            setGlyphs: "setGlyphs",
            setTransition: "setTransition",
            setLight: "setLight",
            setTerrain: "setTerrain",
            setFog: "setFog",
            setCamera: "setCamera",
            setLights: "setLights",
            setProjection: "setProjection",
            addImport: "addImport",
            removeImport: "removeImport",
            updateImport: "updateImport"
        };
        function Vr(e, t1, i) {
            i.push({
                command: jr.addSource,
                args: [
                    e,
                    t1[e]
                ]
            });
        }
        function Wr(e, t1, i) {
            t1.push({
                command: jr.removeSource,
                args: [
                    e
                ]
            }), i[e] = !0;
        }
        function Zr(e, t1, i, o) {
            Wr(e, i, o), Vr(e, t1, i);
        }
        function qr(e, i, o) {
            let r;
            for(r in e[o])if (e[o].hasOwnProperty(r) && "data" !== r && !t1(e[o][r], i[o][r])) return !1;
            for(r in i[o])if (i[o].hasOwnProperty(r) && "data" !== r && !t1(e[o][r], i[o][r])) return !1;
            return !0;
        }
        function Hr(e, i, o, r, a, n) {
            let s;
            for(s in i = i || {}, e = e || {})e.hasOwnProperty(s) && (t1(e[s], i[s]) || o.push({
                command: n,
                args: [
                    r,
                    s,
                    i[s],
                    a
                ]
            }));
            for(s in i)i.hasOwnProperty(s) && !e.hasOwnProperty(s) && (t1(e[s], i[s]) || o.push({
                command: n,
                args: [
                    r,
                    s,
                    i[s],
                    a
                ]
            }));
        }
        function $r(e) {
            return e.id;
        }
        function Xr(e, t1) {
            return e[t1.id] = t1, e;
        }
        class Yr {
            constructor(e, t1){
                this.reset(e, t1);
            }
            reset(e, t1) {
                this.points = e || [], this._distances = [
                    0
                ];
                for(let e = 1; e < this.points.length; e++)this._distances[e] = this._distances[e - 1] + this.points[e].dist(this.points[e - 1]);
                this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t1 || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(t1) {
                if (1 === this.points.length) return this.points[0];
                t1 = e.at(t1, 0, 1);
                let i = 1, o = this._distances[i];
                const r = t1 * this.paddedLength + this.padding;
                for(; o < r && i < this._distances.length;)o = this._distances[++i];
                const a = i - 1, n = this._distances[a], s = o - n, l = s > 0 ? (r - n) / s : 0;
                return this.points[a].mult(1 - l).add(this.points[i].mult(l));
            }
        }
        class Kr {
            constructor(e, t1, i){
                const o = this.boxCells = [], r = this.circleCells = [];
                this.xCellCount = Math.ceil(e / i), this.yCellCount = Math.ceil(t1 / i);
                for(let e = 0; e < this.xCellCount * this.yCellCount; e++)o.push([]), r.push([]);
                this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t1, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t1, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
                return this.boxKeys.length + this.circleKeys.length;
            }
            insert(e, t1, i, o, r) {
                this._forEachCell(t1, i, o, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t1), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(r);
            }
            insertCircle(e, t1, i, o) {
                this._forEachCell(t1 - o, i - o, t1 + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t1), this.circles.push(i), this.circles.push(o);
            }
            _insertBoxCell(e, t1, i, o, r, a) {
                this.boxCells[r].push(a);
            }
            _insertCircleCell(e, t1, i, o, r, a) {
                this.circleCells[r].push(a);
            }
            _query(e, t1, i, o, r, a) {
                if (i < 0 || e > this.width || o < 0 || t1 > this.height) return !r && [];
                const n = [];
                if (e <= 0 && t1 <= 0 && this.width <= i && this.height <= o) {
                    if (r) return !0;
                    for(let e = 0; e < this.boxKeys.length; e++)n.push({
                        key: this.boxKeys[e],
                        x1: this.bboxes[4 * e],
                        y1: this.bboxes[4 * e + 1],
                        x2: this.bboxes[4 * e + 2],
                        y2: this.bboxes[4 * e + 3]
                    });
                    for(let e = 0; e < this.circleKeys.length; e++){
                        const t1 = this.circles[3 * e], i = this.circles[3 * e + 1], o = this.circles[3 * e + 2];
                        n.push({
                            key: this.circleKeys[e],
                            x1: t1 - o,
                            y1: i - o,
                            x2: t1 + o,
                            y2: i + o
                        });
                    }
                    return a ? n.filter(a) : n;
                }
                return this._forEachCell(e, t1, i, o, this._queryCell, n, {
                    hitTest: r,
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, a), r ? n.length > 0 : n;
            }
            _queryCircle(e, t1, i, o, r) {
                const a = e - i, n = e + i, s = t1 - i, l = t1 + i;
                if (n < 0 || a > this.width || l < 0 || s > this.height) return !o && [];
                const c = [];
                return this._forEachCell(a, s, n, l, this._queryCellCircle, c, {
                    hitTest: o,
                    circle: {
                        x: e,
                        y: t1,
                        radius: i
                    },
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, r), o ? c.length > 0 : c;
            }
            query(e, t1, i, o, r) {
                return this._query(e, t1, i, o, !1, r);
            }
            hitTest(e, t1, i, o, r) {
                return this._query(e, t1, i, o, !0, r);
            }
            hitTestCircle(e, t1, i, o) {
                return this._queryCircle(e, t1, i, !0, o);
            }
            _queryCell(e, t1, i, o, r, a, n, s) {
                const l = n.seenUids, c = this.boxCells[r];
                if (null !== c) {
                    const r = this.bboxes;
                    for (const h of c)if (!l.box[h]) {
                        l.box[h] = !0;
                        const c = 4 * h;
                        if (e <= r[c + 2] && t1 <= r[c + 3] && i >= r[c + 0] && o >= r[c + 1] && (!s || s(this.boxKeys[h]))) {
                            if (n.hitTest) return a.push(!0), !0;
                            a.push({
                                key: this.boxKeys[h],
                                x1: r[c],
                                y1: r[c + 1],
                                x2: r[c + 2],
                                y2: r[c + 3]
                            });
                        }
                    }
                }
                const h = this.circleCells[r];
                if (null !== h) {
                    const r = this.circles;
                    for (const c of h)if (!l.circle[c]) {
                        l.circle[c] = !0;
                        const h = 3 * c;
                        if (this._circleAndRectCollide(r[h], r[h + 1], r[h + 2], e, t1, i, o) && (!s || s(this.circleKeys[c]))) {
                            if (n.hitTest) return a.push(!0), !0;
                            {
                                const e = r[h], t1 = r[h + 1], i = r[h + 2];
                                a.push({
                                    key: this.circleKeys[c],
                                    x1: e - i,
                                    y1: t1 - i,
                                    x2: e + i,
                                    y2: t1 + i
                                });
                            }
                        }
                    }
                }
            }
            _queryCellCircle(e, t1, i, o, r, a, n, s) {
                const l = n.circle, c = n.seenUids, h = this.boxCells[r];
                if (null !== h) {
                    const e = this.bboxes;
                    for (const t1 of h)if (!c.box[t1]) {
                        c.box[t1] = !0;
                        const i = 4 * t1;
                        if (this._circleAndRectCollide(l.x, l.y, l.radius, e[i + 0], e[i + 1], e[i + 2], e[i + 3]) && (!s || s(this.boxKeys[t1]))) return a.push(!0), !0;
                    }
                }
                const _ = this.circleCells[r];
                if (null !== _) {
                    const e = this.circles;
                    for (const t1 of _)if (!c.circle[t1]) {
                        c.circle[t1] = !0;
                        const i = 3 * t1;
                        if (this._circlesCollide(e[i], e[i + 1], e[i + 2], l.x, l.y, l.radius) && (!s || s(this.circleKeys[t1]))) return a.push(!0), !0;
                    }
                }
            }
            _forEachCell(e, t1, i, o, r, a, n, s) {
                const l = this._convertToXCellCoord(e), c = this._convertToYCellCoord(t1), h = this._convertToXCellCoord(i), _ = this._convertToYCellCoord(o);
                for(let u = l; u <= h; u++)for(let l = c; l <= _; l++)if (r.call(this, e, t1, i, o, this.xCellCount * l + u, a, n, s)) return;
            }
            _convertToXCellCoord(e) {
                return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
            }
            _convertToYCellCoord(e) {
                return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
            }
            _circlesCollide(e, t1, i, o, r, a) {
                const n = o - e, s = r - t1, l = i + a;
                return l * l > n * n + s * s;
            }
            _circleAndRectCollide(e, t1, i, o, r, a, n) {
                const s = (a - o) / 2, l = Math.abs(e - (o + s));
                if (l > s + i) return !1;
                const c = (n - r) / 2, h = Math.abs(t1 - (r + c));
                if (h > c + i) return !1;
                if (l <= s || h <= c) return !0;
                const _ = l - s, u = h - c;
                return _ * _ + u * u <= i * i;
            }
        }
        const Qr = 100;
        class Jr {
            constructor(e, t1, i = new Kr(e.width + 200, e.height + 200, 25), o = new Kr(e.width + 200, e.height + 200, 25)){
                this.transform = e, this.grid = i, this.ignoredGrid = o, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Qr, this.screenBottomBoundary = e.height + Qr, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.fogState = t1;
            }
            placeCollisionBox(e, t1, i, o, r, a, n, s) {
                let l = i.projectedAnchorX, c = i.projectedAnchorY, h = i.projectedAnchorZ;
                const _ = i.elevation, u = i.tileID, d = e.getProjection();
                if (_ && u) {
                    const [e, t1, o] = d.upVector(u.canonical, i.tileAnchorX, i.tileAnchorY), r = d.upVectorScale(u.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                    l += e * _ * r, c += t1 * _ * r, h += o * _ * r;
                }
                const p = this.projectAndGetPerspectiveRatio(n, l, c, h, i.tileID, "globe" === d.name || !!_ || this.transform.pitch > 0, d), f = a * p.perspectiveRatio, m = (i.x1 * t1 + o.x - i.padding) * f + p.point.x, g = (i.y1 * t1 + o.y - i.padding) * f + p.point.y, v = (i.x2 * t1 + o.x + i.padding) * f + p.point.x, x = (i.y2 * t1 + o.y + i.padding) * f + p.point.y, y = p.perspectiveRatio <= .55 || p.occluded;
                return !this.isInsideGrid(m, g, v, x) || !r && this.grid.hitTest(m, g, v, x, s) || y ? {
                    box: [],
                    offscreen: !1,
                    occluded: p.occluded
                } : {
                    box: [
                        m,
                        g,
                        v,
                        x
                    ],
                    offscreen: this.isOffscreen(m, g, v, x),
                    occluded: !1
                };
            }
            placeCollisionCircles(t1, i, o, r, a, n, s, l, c, h, _, u, d, p, f) {
                const m = [], g = this.transform.elevation, v = t1.getProjection(), x = g ? g.getAtTileOffsetFunc(f, this.transform.center.lat, this.transform.worldSize, v) : null, y = new e.P(o.tileAnchorX, o.tileAnchorY);
                let { x: b, y: w, z: T } = v.projectTilePoint(y.x, y.y, f.canonical);
                if (x) {
                    const [e, t1, i] = x(y);
                    b += e, w += t1, T += i;
                }
                const E = "globe" === v.name, C = this.projectAndGetPerspectiveRatio(s, b, w, T, f, E || !!g || this.transform.pitch > 0, v), { perspectiveRatio: S } = C, I = (_ ? n / S : n * S) / e.bN, L = Jt(b, w, T, l), P = C.signedDistanceFromCamera > 0 ? oi(I, a, o.lineOffsetX * I, o.lineOffsetY * I, !1, L, y, o, r, l, {}, g && !_ ? x : null, _ && !!g, v, f, _) : null;
                let A = !1, R = !1, D = !0;
                if (P && !C.occluded) {
                    const t1 = .5 * d * S + p, o = new e.P(-100, -100), r = new e.P(this.screenRightBoundary, this.screenBottomBoundary), a = new Yr, { first: n, last: s } = P, l = n.path.length;
                    let _ = [];
                    for(let e = l - 1; e >= 1; e--)_.push(n.path[e]);
                    for(let e = 1; e < s.path.length; e++)_.push(s.path[e]);
                    const f = 2.5 * t1;
                    c && (_ = _.map(([e, t1, i], o)=>(x && !E && (i = x(o < l - 1 ? n.tilePath[l - 1 - o] : s.tilePath[o - l + 2])[2]), Jt(e, t1, i, c))), _.some((e)=>e[3] <= 0) && (_ = []));
                    let g = [];
                    if (_.length > 0) {
                        let t1 = 1 / 0, i = -1 / 0, a = 1 / 0, n = -1 / 0;
                        for (const e of _)t1 = Math.min(t1, e[0]), a = Math.min(a, e[1]), i = Math.max(i, e[0]), n = Math.max(n, e[1]);
                        i >= o.x && t1 <= r.x && n >= o.y && a <= r.y && (g = [
                            _.map((t1)=>new e.P(t1[0], t1[1]))
                        ], (t1 < o.x || i > r.x || a < o.y || n > r.y) && (g = e.cF(g, o.x, o.y, r.x, r.y)));
                    }
                    for (const e of g){
                        a.reset(e, .25 * t1);
                        let o = 0;
                        o = a.length <= .5 * t1 ? 1 : Math.ceil(a.paddedLength / f) + 1;
                        for(let e = 0; e < o; e++){
                            const r = e / Math.max(o - 1, 1), n = a.lerp(r), s = n.x + Qr, l = n.y + Qr;
                            m.push(s, l, t1, 0);
                            const c = s - t1, _ = l - t1, d = s + t1, p = l + t1;
                            if (D = D && this.isOffscreen(c, _, d, p), R = R || this.isInsideGrid(c, _, d, p), !i && this.grid.hitTestCircle(s, l, t1, u) && (A = !0, !h)) return {
                                circles: [],
                                offscreen: !1,
                                collisionDetected: A,
                                occluded: !1
                            };
                        }
                    }
                }
                return {
                    circles: !h && A || !R ? [] : m,
                    offscreen: D,
                    collisionDetected: A,
                    occluded: C.occluded
                };
            }
            queryRenderedSymbols(t1) {
                if (0 === t1.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
                const i = [];
                let o = 1 / 0, r = 1 / 0, a = -1 / 0, n = -1 / 0;
                for (const s of t1){
                    const t1 = new e.P(s.x + Qr, s.y + Qr);
                    o = Math.min(o, t1.x), r = Math.min(r, t1.y), a = Math.max(a, t1.x), n = Math.max(n, t1.y), i.push(t1);
                }
                const s = this.grid.query(o, r, a, n).concat(this.ignoredGrid.query(o, r, a, n)), l = {}, c = {};
                for (const t1 of s){
                    const o = t1.key;
                    if (void 0 === l[o.bucketInstanceId] && (l[o.bucketInstanceId] = {}), l[o.bucketInstanceId][o.featureIndex]) continue;
                    const r = [
                        new e.P(t1.x1, t1.y1),
                        new e.P(t1.x2, t1.y1),
                        new e.P(t1.x2, t1.y2),
                        new e.P(t1.x1, t1.y2)
                    ];
                    e.cG(i, r) && (l[o.bucketInstanceId][o.featureIndex] = !0, void 0 === c[o.bucketInstanceId] && (c[o.bucketInstanceId] = []), c[o.bucketInstanceId].push(o.featureIndex));
                }
                return c;
            }
            insertCollisionBox(e, t1, i, o, r) {
                (t1 ? this.ignoredGrid : this.grid).insert({
                    bucketInstanceId: i,
                    featureIndex: o,
                    collisionGroupID: r
                }, e[0], e[1], e[2], e[3]);
            }
            insertCollisionCircles(e, t1, i, o, r) {
                const a = t1 ? this.ignoredGrid : this.grid, n = {
                    bucketInstanceId: i,
                    featureIndex: o,
                    collisionGroupID: r
                };
                for(let t1 = 0; t1 < e.length; t1 += 4)a.insertCircle(n, e[t1], e[t1 + 1], e[t1 + 2]);
            }
            projectAndGetPerspectiveRatio(t1, i, o, r, a, n, s) {
                const l = [
                    i,
                    o,
                    r,
                    1
                ];
                let c = !1;
                if (r || this.transform.pitch > 0) {
                    if (e.aA.transformMat4(l, l, t1), this.fogState && a && "globe" !== s.name) {
                        const t1 = function(t1, i, o, r, a, n) {
                            const s = n.calculateFogTileMatrix(a), l = [
                                i,
                                o,
                                r
                            ];
                            return e._.transformMat4(l, l, s), ot(t1, e._.length(l), n.pitch, n._fov);
                        }(this.fogState, i, o, r, a.toUnwrapped(), this.transform);
                        c = t1 > .9;
                    }
                } else hi(l, l, t1);
                const h = l[3];
                return {
                    point: new e.P((l[0] / h + 1) / 2 * this.transform.width + Qr, (-l[1] / h + 1) / 2 * this.transform.height + Qr),
                    perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(s) / h * .5, 1.5),
                    signedDistanceFromCamera: h,
                    occluded: n && l[2] > h || c
                };
            }
            isOffscreen(e, t1, i, o) {
                return i < Qr || e >= this.screenRightBoundary || o < Qr || t1 > this.screenBottomBoundary;
            }
            isInsideGrid(e, t1, i, o) {
                return i >= 0 && e < this.gridRightBoundary && o >= 0 && t1 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
                const t1 = e.ad.identity([]);
                return e.ad.translate(t1, t1, [
                    -100,
                    -100,
                    0
                ]), t1;
            }
        }
        class ea {
            constructor(e, t1, i, o){
                this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t1 : -t1))) : o && i ? 1 : 0, this.placed = i;
            }
            isHidden() {
                return 0 === this.opacity && !this.placed;
            }
        }
        class ta {
            constructor(e, t1, i, o, r, a = !1){
                this.text = new ea(e ? e.text : null, t1, i, r), this.icon = new ea(e ? e.icon : null, t1, o, r), this.clipped = a;
            }
            isHidden() {
                return this.text.isHidden() && this.icon.isHidden();
            }
        }
        class ia {
            constructor(e, t1, i, o = !1){
                this.text = e, this.icon = t1, this.skipFade = i, this.clipped = o;
            }
        }
        class oa {
            constructor(){
                this.invProjMatrix = e.ad.create(), this.viewportMatrix = e.ad.create(), this.circles = [];
            }
        }
        class ra {
            constructor(e, t1, i, o, r){
                this.bucketInstanceId = e, this.featureIndex = t1, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = r;
            }
        }
        class aa {
            constructor(e){
                this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(e) {
                if (this.crossSourceCollisions) return {
                    ID: 0,
                    predicate: null
                };
                if (!this.collisionGroups[e]) {
                    const t1 = ++this.maxGroupID;
                    this.collisionGroups[e] = {
                        ID: t1,
                        predicate: (e)=>e.collisionGroupID === t1
                    };
                }
                return this.collisionGroups[e];
            }
        }
        function na(t1, i, o, r, a) {
            const { horizontalAlign: n, verticalAlign: s } = e.bQ(t1), l = -(n - .5) * i, c = -(s - .5) * o, h = e.bP(t1, r);
            return new e.P(l + h[0] * a, c + h[1] * a);
        }
        function sa(t1, i, o, r, a) {
            const n = new e.P(t1, i);
            return o && n._rotate(r ? a : -a), n;
        }
        class la {
            constructor(e, t1, i, o, r, a){
                this.transform = e.clone(), this.projection = e.projection.name, this.collisionIndex = new Jr(this.transform, r), this.buildingIndex = a, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t1, this.retainedQueryData = {}, this.collisionGroups = new aa(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};
            }
            getBucketParts(t1, i, o, r) {
                const a = o.getBucket(i), n = o.latestFeatureIndex;
                if (!a || !n || i.fqid !== a.layerIds[0]) return;
                const s = a.layers[0].layout, l = o.collisionBoxArray, c = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ), h = o.tileSize / e.a3, _ = o.tileID.toUnwrapped();
                this.transform.setProjection(a.projection);
                const u = (d = o.tileID, p = a.getProjection(), f = this.transform, p.name === this.projection ? f.calculateProjMatrix(d.toUnwrapped()) : bo(f, p, d));
                var d, p, f;
                const m = "map" === s.get("text-pitch-alignment"), g = "map" === s.get("text-rotation-alignment");
                i.compileFilter();
                const v = i.dynamicFilter(), x = i.dynamicFilterNeedsFeature(), y = this.transform.calculatePixelsToTileUnitsMatrix(o), b = Kt(u, o.tileID.canonical, m, g, this.transform, a.getProjection(), y);
                let w = null;
                if (m) {
                    const t1 = Qt(u, o.tileID.canonical, m, g, this.transform, a.getProjection(), y);
                    w = e.ad.multiply([], this.transform.labelPlaneMatrix, t1);
                }
                let T = null;
                v && o.latestFeatureIndex && (T = {
                    unwrappedTileID: _,
                    dynamicFilter: v,
                    dynamicFilterNeedsFeature: x,
                    featureIndex: o.latestFeatureIndex
                }), this.retainedQueryData[a.bucketInstanceId] = new ra(a.bucketInstanceId, n, a.sourceLayerIndex, a.index, o.tileID);
                const E = {
                    bucket: a,
                    layout: s,
                    posMatrix: u,
                    textLabelPlaneMatrix: b,
                    labelToScreenMatrix: w,
                    clippingData: T,
                    scale: c,
                    textPixelRatio: h,
                    holdingForFade: o.holdingForFade(),
                    collisionBoxArray: l,
                    partiallyEvaluatedTextSize: e.aD(a.textSizeData, this.transform.zoom),
                    partiallyEvaluatedIconSize: e.aD(a.iconSizeData, this.transform.zoom),
                    collisionGroup: this.collisionGroups.get(a.sourceID)
                };
                if (r) for (const e of a.sortKeyRanges){
                    const { sortKey: i, symbolInstanceStart: o, symbolInstanceEnd: r } = e;
                    t1.push({
                        sortKey: i,
                        symbolInstanceStart: o,
                        symbolInstanceEnd: r,
                        parameters: E
                    });
                }
                else t1.push({
                    symbolInstanceStart: 0,
                    symbolInstanceEnd: a.symbolInstances.length,
                    parameters: E
                });
            }
            attemptAnchorPlacement(e, t1, i, o, r, a, n, s, l, c, h, _, u, d, p, f, m, g) {
                const { textOffset0: v, textOffset1: x, crossTileID: y } = _, b = [
                    v,
                    x
                ], w = na(e, i, o, b, r), T = this.collisionIndex.placeCollisionBox(d, r, t1, sa(w.x, w.y, a, n, this.transform.angle), h, s, l, c.predicate);
                if (f) {
                    const e = d.getSymbolInstanceIconSize(g, this.transform.zoom, _.placedIconSymbolIndex);
                    if (0 === this.collisionIndex.placeCollisionBox(d, e, f, sa(w.x, w.y, a, n, this.transform.angle), h, s, l, c.predicate).box.length) return;
                }
                if (T.box.length > 0) {
                    let t1;
                    return this.prevPlacement && this.prevPlacement.variableOffsets[y] && this.prevPlacement.placements[y] && this.prevPlacement.placements[y].text && (t1 = this.prevPlacement.variableOffsets[y].anchor), this.variableOffsets[y] = {
                        textOffset: b,
                        width: i,
                        height: o,
                        anchor: e,
                        textScale: r,
                        prevAnchor: t1
                    }, this.markUsedJustification(d, e, _, p), d.allowVerticalPlacement && (this.markUsedOrientation(d, p, _), this.placedOrientations[y] = p), {
                        shift: w,
                        placedGlyphBoxes: T
                    };
                }
            }
            placeLayerBucketPart(t1, i, o, r) {
                const { bucket: a, layout: n, posMatrix: s, textLabelPlaneMatrix: l, labelToScreenMatrix: c, clippingData: h, textPixelRatio: _, holdingForFade: u, collisionBoxArray: d, partiallyEvaluatedTextSize: p, partiallyEvaluatedIconSize: f, collisionGroup: m } = t1.parameters, g = n.get("text-optional"), v = n.get("icon-optional"), x = n.get("text-allow-overlap"), y = n.get("icon-allow-overlap"), b = "map" === n.get("text-rotation-alignment"), w = "map" === n.get("text-pitch-alignment"), T = "viewport-y" === n.get("symbol-z-order"), E = n.get("symbol-z-elevate");
                this.transform.setProjection(a.projection);
                let C = x && (y || !a.hasIconData() || v), S = y && (x || !a.hasTextData() || g);
                !a.collisionArrays && d && a.deserializeCollisionBoxes(d), o && r && a.updateCollisionDebugBuffers(this.transform.zoom, d);
                const I = (t1, r, d)=>{
                    const { crossTileID: T, numVerticalGlyphVertices: E } = t1;
                    if (h) {
                        const o = {
                            zoom: this.transform.zoom,
                            pitch: this.transform.pitch
                        };
                        let r = null;
                        if (h.dynamicFilterNeedsFeature) {
                            const e = this.retainedQueryData[a.bucketInstanceId];
                            r = h.featureIndex.loadFeature({
                                featureIndex: t1.featureIndex,
                                bucketIndex: e.bucketIndex,
                                sourceLayerIndex: e.sourceLayerIndex,
                                layoutVertexArrayOffset: 0
                            });
                        }
                        if (!(0, h.dynamicFilter)(o, r, this.retainedQueryData[a.bucketInstanceId].tileID.canonical, new e.P(t1.tileAnchorX, t1.tileAnchorY), this.transform.calculateDistanceTileData(h.unwrappedTileID))) return this.placements[T] = new ia(!1, !1, !1, !0), void i.add(T);
                    }
                    if (i.has(T)) return;
                    if (u) return void (this.placements[T] = new ia(!1, !1, !1));
                    let I = !1, L = !1, P = !0, A = !1, R = !1, D = null, M = {
                        box: null,
                        offscreen: null,
                        occluded: null
                    }, z = {
                        box: null,
                        offscreen: null,
                        occluded: null
                    }, O = null, F = null, B = null, k = 0, N = 0, U = 0;
                    d.textFeatureIndex ? k = d.textFeatureIndex : t1.useRuntimeCollisionCircles && (k = t1.featureIndex), d.verticalTextFeatureIndex && (N = d.verticalTextFeatureIndex);
                    const G = (e)=>{
                        e.tileID = this.retainedQueryData[a.bucketInstanceId].tileID;
                        const i = this.transform.elevation;
                        e.elevation = t1.zOffset + (i ? i.getAtTileOffset(e.tileID, e.tileAnchorX, e.tileAnchorY) : 0);
                    }, j = d.textBox;
                    if (j) {
                        G(j);
                        const i = (i)=>{
                            let o = e.aE.horizontal;
                            if (a.allowVerticalPlacement && !i && this.prevPlacement) {
                                const e = this.prevPlacement.placedOrientations[T];
                                e && (this.placedOrientations[T] = e, o = e, this.markUsedOrientation(a, o, t1));
                            }
                            return o;
                        }, o = (t1, i)=>{
                            if (a.allowVerticalPlacement && E > 0 && d.verticalTextBox) {
                                for (const o of a.writingModes)if (o === e.aE.vertical ? (M = i(), z = M) : M = t1(), M && M.box && M.box.length) break;
                            } else M = t1();
                        };
                        if (n.get("text-variable-anchor")) {
                            let l = n.get("text-variable-anchor");
                            if (this.prevPlacement && this.prevPlacement.variableOffsets[T]) {
                                const e = this.prevPlacement.variableOffsets[T];
                                l.indexOf(e.anchor) > 0 && (l = l.filter((t1)=>t1 !== e.anchor), l.unshift(e.anchor));
                            }
                            const c = (e, i, o)=>{
                                const n = a.getSymbolInstanceTextSize(p, t1, this.transform.zoom, r), c = (e.x2 - e.x1) * n + 2 * e.padding, h = (e.y2 - e.y1) * n + 2 * e.padding, u = t1.hasIconTextFit && !y ? i : null;
                                u && G(u);
                                let d = {
                                    box: [],
                                    offscreen: !1,
                                    occluded: !1
                                };
                                const g = x ? 2 * l.length : l.length;
                                for(let i = 0; i < g; ++i){
                                    const g = this.attemptAnchorPlacement(l[i % l.length], e, c, h, n, b, w, _, s, m, i >= l.length, t1, r, a, o, u, p, f);
                                    if (g && (d = g.placedGlyphBoxes, d && d.box && d.box.length)) {
                                        I = !0, D = g.shift;
                                        break;
                                    }
                                }
                                return d;
                            };
                            o(()=>c(j, d.iconBox, e.aE.horizontal), ()=>{
                                const t1 = d.verticalTextBox;
                                return t1 && G(t1), a.allowVerticalPlacement && !(M && M.box && M.box.length) && E > 0 && t1 ? c(t1, d.verticalIconBox, e.aE.vertical) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                };
                            }), M && (I = M.box, P = M.offscreen, A = M.occluded);
                            const h = i(!(!M || !M.box));
                            if (!I && this.prevPlacement) {
                                const e = this.prevPlacement.variableOffsets[T];
                                e && (this.variableOffsets[T] = e, this.markUsedJustification(a, e.anchor, t1, h));
                            }
                        } else {
                            const n = (i, o)=>{
                                const n = a.getSymbolInstanceTextSize(p, t1, this.transform.zoom, r), l = this.collisionIndex.placeCollisionBox(a, n, i, new e.P(0, 0), x, _, s, m.predicate);
                                return l && l.box && l.box.length && (this.markUsedOrientation(a, o, t1), this.placedOrientations[T] = o), l;
                            };
                            o(()=>n(j, e.aE.horizontal), ()=>{
                                const t1 = d.verticalTextBox;
                                return a.allowVerticalPlacement && E > 0 && t1 ? (G(t1), n(t1, e.aE.vertical)) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                };
                            }), i(!!(M && M.box && M.box.length));
                        }
                    }
                    if (O = M, I = O && O.box && O.box.length > 0, P = O && O.offscreen, A = O && O.occluded, t1.useRuntimeCollisionCircles) {
                        const i = a.text.placedSymbolArray.get(t1.centerJustifiedTextSymbolIndex >= 0 ? t1.centerJustifiedTextSymbolIndex : t1.verticalPlacedTextSymbolIndex), r = e.aF(a.textSizeData, p, i), h = n.get("text-padding");
                        F = this.collisionIndex.placeCollisionCircles(a, x, i, a.lineVertexArray, a.glyphOffsetArray, r, s, l, c, o, w, m.predicate, t1.collisionCircleDiameter * r / e.bN, h, this.retainedQueryData[a.bucketInstanceId].tileID), I = x || F.circles.length > 0 && !F.collisionDetected, P = P && F.offscreen, A = F.occluded;
                    }
                    if (d.iconFeatureIndex && (U = d.iconFeatureIndex), d.iconBox) {
                        const i = (i)=>{
                            G(i);
                            const o = t1.hasIconTextFit && D ? sa(D.x, D.y, b, w, this.transform.angle) : new e.P(0, 0), r = a.getSymbolInstanceIconSize(f, this.transform.zoom, t1.placedIconSymbolIndex);
                            return this.collisionIndex.placeCollisionBox(a, r, i, o, y, _, s, m.predicate);
                        };
                        z && z.box && z.box.length && d.verticalIconBox ? (B = i(d.verticalIconBox), L = B.box.length > 0) : (B = i(d.iconBox), L = B.box.length > 0), P = P && B.offscreen, R = B.occluded;
                    }
                    const V = g || 0 === t1.numHorizontalGlyphVertices && 0 === E, W = v || 0 === t1.numIconVertices;
                    if (V || W ? W ? V || (L = L && I) : I = L && I : L = I = L && I, I && O && O.box && this.collisionIndex.insertCollisionBox(O.box, n.get("text-ignore-placement"), a.bucketInstanceId, z && z.box && N ? N : k, m.ID), L && B && this.collisionIndex.insertCollisionBox(B.box, n.get("icon-ignore-placement"), a.bucketInstanceId, U, m.ID), F && (I && this.collisionIndex.insertCollisionCircles(F.circles, n.get("text-ignore-placement"), a.bucketInstanceId, k, m.ID), o)) {
                        const e = a.bucketInstanceId;
                        let t1 = this.collisionCircleArrays[e];
                        void 0 === t1 && (t1 = this.collisionCircleArrays[e] = new oa);
                        for(let e = 0; e < F.circles.length; e += 4)t1.circles.push(F.circles[e + 0]), t1.circles.push(F.circles[e + 1]), t1.circles.push(F.circles[e + 2]), t1.circles.push(F.collisionDetected ? 1 : 0);
                    }
                    const Z = "globe" !== a.projection.name;
                    C = C && (Z || !A), S = S && (Z || !R), this.placements[T] = new ia(I || C, L || S, P || a.justReloaded), i.add(T);
                };
                if (E && this.buildingIndex && (this.buildingIndex.updateZOffset(a, this.retainedQueryData[a.bucketInstanceId].tileID), a.updateZOffset()), T) {
                    const t1 = a.getSortedSymbolIndexes(this.transform.angle);
                    for(let e = t1.length - 1; e >= 0; --e){
                        const i = t1[e];
                        I(a.symbolInstances.get(i), i, a.collisionArrays[i]);
                    }
                    a.hasAnyZOffset && e.w(`${a.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
                } else if (a.hasAnyZOffset) {
                    const e = a.getSortedIndexesByZOffset();
                    for(let t1 = 0; t1 < e.length; ++t1){
                        const i = e[t1];
                        I(a.symbolInstances.get(i), i, a.collisionArrays[i]);
                    }
                } else for(let e = t1.symbolInstanceStart; e < t1.symbolInstanceEnd; e++)I(a.symbolInstances.get(e), e, a.collisionArrays[e]);
                if (o && a.bucketInstanceId in this.collisionCircleArrays) {
                    const t1 = this.collisionCircleArrays[a.bucketInstanceId];
                    e.ad.invert(t1.invProjMatrix, s), t1.viewportMatrix = this.collisionIndex.getViewportMatrix();
                }
                a.justReloaded = !1;
            }
            markUsedJustification(t1, i, o, r) {
                const { leftJustifiedTextSymbolIndex: a, centerJustifiedTextSymbolIndex: n, rightJustifiedTextSymbolIndex: s, verticalPlacedTextSymbolIndex: l, crossTileID: c } = o, h = e.cJ(i), _ = r === e.aE.vertical ? l : "left" === h ? a : "center" === h ? n : "right" === h ? s : -1;
                a >= 0 && (t1.text.placedSymbolArray.get(a).crossTileID = _ >= 0 && a !== _ ? 0 : c), n >= 0 && (t1.text.placedSymbolArray.get(n).crossTileID = _ >= 0 && n !== _ ? 0 : c), s >= 0 && (t1.text.placedSymbolArray.get(s).crossTileID = _ >= 0 && s !== _ ? 0 : c), l >= 0 && (t1.text.placedSymbolArray.get(l).crossTileID = _ >= 0 && l !== _ ? 0 : c);
            }
            markUsedOrientation(t1, i, o) {
                const r = i === e.aE.horizontal || i === e.aE.horizontalOnly ? i : 0, a = i === e.aE.vertical ? i : 0, { leftJustifiedTextSymbolIndex: n, centerJustifiedTextSymbolIndex: s, rightJustifiedTextSymbolIndex: l, verticalPlacedTextSymbolIndex: c } = o, h = t1.text.placedSymbolArray;
                n >= 0 && (h.get(n).placedOrientation = r), s >= 0 && (h.get(s).placedOrientation = r), l >= 0 && (h.get(l).placedOrientation = r), c >= 0 && (h.get(c).placedOrientation = a);
            }
            commit(e) {
                this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
                const t1 = this.prevPlacement;
                let i = !1;
                this.prevZoomAdjustment = t1 ? t1.zoomAdjustment(this.transform.zoom) : 0;
                const o = t1 ? t1.symbolFadeChange(e) : 1, r = t1 ? t1.opacities : {}, a = t1 ? t1.variableOffsets : {}, n = t1 ? t1.placedOrientations : {};
                for(const e in this.placements){
                    const t1 = this.placements[e], a = r[e];
                    a ? (this.opacities[e] = new ta(a, o, t1.text, t1.icon, null, t1.clipped), i = i || t1.text !== a.text.placed || t1.icon !== a.icon.placed) : (this.opacities[e] = new ta(null, o, t1.text, t1.icon, t1.skipFade, t1.clipped), i = i || t1.text || t1.icon);
                }
                for(const e in r){
                    const t1 = r[e];
                    if (!this.opacities[e]) {
                        const r = new ta(t1, o, !1, !1);
                        r.isHidden() || (this.opacities[e] = r, i = i || t1.text.placed || t1.icon.placed);
                    }
                }
                for(const e in a)this.variableOffsets[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.variableOffsets[e] = a[e]);
                for(const e in n)this.placedOrientations[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.placedOrientations[e] = n[e]);
                i ? this.lastPlacementChangeTime = e : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t1 ? t1.lastPlacementChangeTime : e);
            }
            updateLayerOpacities(e, t1, i, o) {
                const r = new Set;
                for (const a of t1){
                    const t1 = a.getBucket(e);
                    t1 && a.latestFeatureIndex && e.fqid === t1.layerIds[0] && (this.updateBucketOpacities(t1, r, a.collisionBoxArray, i, o, a.tileID), t1.layers[0].layout.get("symbol-z-elevate") && this.buildingIndex && (this.buildingIndex.updateZOffset(t1, a.tileID), t1.updateZOffset()));
                }
            }
            updateBucketOpacities(t1, i, o, r, a, n) {
                t1.hasTextData() && t1.text.opacityVertexArray.clear(), t1.hasIconData() && t1.icon.opacityVertexArray.clear(), t1.hasIconCollisionBoxData() && t1.iconCollisionBox.collisionVertexArray.clear(), t1.hasTextCollisionBoxData() && t1.textCollisionBox.collisionVertexArray.clear();
                const s = t1.layers[0].layout, l = !!t1.layers[0].dynamicFilter(), c = new ta(null, 0, !1, !1, !0), h = s.get("text-allow-overlap"), _ = s.get("icon-allow-overlap"), u = s.get("text-variable-anchor"), d = "map" === s.get("text-rotation-alignment"), p = "map" === s.get("text-pitch-alignment"), f = new ta(null, 0, h && (_ || !t1.hasIconData() || s.get("icon-optional")), _ && (h || !t1.hasTextData() || s.get("text-optional")), !0);
                !t1.collisionArrays && o && (t1.hasIconCollisionBoxData() || t1.hasTextCollisionBoxData()) && t1.deserializeCollisionBoxes(o);
                const m = (e, t1, i)=>{
                    for(let o = 0; o < t1 / 4; o++)e.opacityVertexArray.emplaceBack(i);
                };
                let g = 0;
                a && t1.updateReplacement(n, a);
                for(let o = 0; o < t1.symbolInstances.length; o++){
                    const s = t1.symbolInstances.get(o), { numHorizontalGlyphVertices: h, numVerticalGlyphVertices: _, crossTileID: v, numIconVertices: x, tileAnchorX: y, tileAnchorY: b } = s, w = i.has(v);
                    let T = this.opacities[v];
                    w ? T = c : T || (T = f, this.opacities[v] = T), i.add(v);
                    const E = h > 0 || _ > 0, C = x > 0, S = this.placedOrientations[v], I = S === e.aE.vertical, L = S === e.aE.horizontal || S === e.aE.horizontalOnly;
                    !E && !C || T.isHidden() || g++;
                    let P = !1;
                    if ((E || C) && a) for (const i of t1.activeReplacements){
                        if (i.order < r || i.order === 1 / 0 || !(i.clipMask & e.cu.Symbol)) continue;
                        if (i.min.x > y || y > i.max.x || i.min.y > b || b > i.max.y) continue;
                        const t1 = e.cH(y, b, n.canonical, i.footprintTileId.canonical);
                        if (P = e.cI(t1, i), P) break;
                    }
                    if (E) {
                        const e = P ? va : ga(T.text);
                        m(t1.text, h, I ? va : e), m(t1.text, _, L ? va : e);
                        const i = T.text.isHidden(), { leftJustifiedTextSymbolIndex: o, centerJustifiedTextSymbolIndex: r, rightJustifiedTextSymbolIndex: a, verticalPlacedTextSymbolIndex: n } = s, l = t1.text.placedSymbolArray, c = i || I ? 1 : 0;
                        o >= 0 && (l.get(o).hidden = c), r >= 0 && (l.get(r).hidden = c), a >= 0 && (l.get(a).hidden = c), n >= 0 && (l.get(n).hidden = i || L ? 1 : 0);
                        const u = this.variableOffsets[v];
                        u && this.markUsedJustification(t1, u.anchor, s, S);
                        const d = this.placedOrientations[v];
                        d && (this.markUsedJustification(t1, "left", s, d), this.markUsedOrientation(t1, d, s));
                    }
                    if (C) {
                        const e = P ? va : ga(T.icon), { placedIconSymbolIndex: i, verticalPlacedIconSymbolIndex: o } = s, r = t1.icon.placedSymbolArray, a = T.icon.isHidden() ? 1 : 0;
                        i >= 0 && (m(t1.icon, x, I ? va : e), r.get(i).hidden = a), o >= 0 && (m(t1.icon, s.numVerticalIconVertices, L ? va : e), r.get(o).hidden = a);
                    }
                    if (t1.hasIconCollisionBoxData() || t1.hasTextCollisionBoxData()) {
                        const i = t1.collisionArrays[o];
                        if (i) {
                            let o = new e.P(0, 0), r = !0;
                            if (i.textBox || i.verticalTextBox) {
                                if (u) {
                                    const e = this.variableOffsets[v];
                                    e ? (o = na(e.anchor, e.width, e.height, e.textOffset, e.textScale), d && o._rotate(p ? this.transform.angle : -this.transform.angle)) : r = !1;
                                }
                                l && (r = !T.clipped), i.textBox && ca(t1.textCollisionBox.collisionVertexArray, T.text.placed, !r || I, o.x, o.y), i.verticalTextBox && ca(t1.textCollisionBox.collisionVertexArray, T.text.placed, !r || L, o.x, o.y);
                            }
                            const a = r && Boolean(!L && i.verticalIconBox);
                            i.iconBox && ca(t1.iconCollisionBox.collisionVertexArray, T.icon.placed, a, s.hasIconTextFit ? o.x : 0, s.hasIconTextFit ? o.y : 0), i.verticalIconBox && ca(t1.iconCollisionBox.collisionVertexArray, T.icon.placed, !a, s.hasIconTextFit ? o.x : 0, s.hasIconTextFit ? o.y : 0);
                        }
                    }
                }
                if (t1.fullyClipped = 0 === g, t1.sortFeatures(this.transform.angle), this.retainedQueryData[t1.bucketInstanceId] && (this.retainedQueryData[t1.bucketInstanceId].featureSortOrder = t1.featureSortOrder), t1.hasTextData() && t1.text.opacityVertexBuffer && t1.text.opacityVertexBuffer.updateData(t1.text.opacityVertexArray), t1.hasIconData() && t1.icon.opacityVertexBuffer && t1.icon.opacityVertexBuffer.updateData(t1.icon.opacityVertexArray), t1.hasIconCollisionBoxData() && t1.iconCollisionBox.collisionVertexBuffer && t1.iconCollisionBox.collisionVertexBuffer.updateData(t1.iconCollisionBox.collisionVertexArray), t1.hasTextCollisionBoxData() && t1.textCollisionBox.collisionVertexBuffer && t1.textCollisionBox.collisionVertexBuffer.updateData(t1.textCollisionBox.collisionVertexArray), t1.bucketInstanceId in this.collisionCircleArrays) {
                    const e = this.collisionCircleArrays[t1.bucketInstanceId];
                    t1.placementInvProjMatrix = e.invProjMatrix, t1.placementViewportMatrix = e.viewportMatrix, t1.collisionCircleArray = e.circles, delete this.collisionCircleArrays[t1.bucketInstanceId];
                }
            }
            symbolFadeChange(e) {
                return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(e) {
                return Math.max(0, (this.transform.zoom - e) / 1.5);
            }
            hasTransitions(e) {
                return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(e, t1) {
                const i = this.zoomAtLastRecencyCheck === t1 ? 1 - this.zoomAdjustment(t1) : 1;
                return this.zoomAtLastRecencyCheck = t1, this.commitTime + this.fadeDuration * i > e;
            }
            setStale() {
                this.stale = !0;
            }
        }
        function ca(e, t1, i, o, r) {
            e.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, o || 0, r || 0);
        }
        const ha = Math.pow(2, 25), _a = Math.pow(2, 24), ua = Math.pow(2, 17), da = Math.pow(2, 16), pa = Math.pow(2, 9), fa = Math.pow(2, 8), ma = Math.pow(2, 1);
        function ga(e) {
            if (0 === e.opacity && !e.placed) return 0;
            if (1 === e.opacity && e.placed) return 4294967295;
            const t1 = e.placed ? 1 : 0, i = Math.floor(127 * e.opacity);
            return i * ha + t1 * _a + i * ua + t1 * da + i * pa + t1 * fa + i * ma + t1;
        }
        const va = 0;
        class xa {
            constructor(e){
                this._sortAcrossTiles = "viewport-y" !== e.layout.get("symbol-z-order") && void 0 !== e.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = new Set, this._bucketParts = [];
            }
            continuePlacement(e, t1, i, o, r) {
                const a = this._bucketParts;
                for(; this._currentTileIndex < e.length;)if (t1.getBucketParts(a, o, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r()) return !0;
                for(this._sortAcrossTiles && (this._sortAcrossTiles = !1, a.sort((e, t1)=>e.sortKey - t1.sortKey)); this._currentPartIndex < a.length;){
                    const e = a[this._currentPartIndex];
                    if (t1.placeLayerBucketPart(e, this._seenCrossTileIDs, i, 0 === e.symbolInstanceStart), this._currentPartIndex++, r()) return !0;
                }
                return !1;
            }
        }
        class ya {
            constructor(e, t1, i, o, r, a, n, s, l){
                this.placement = new la(e, r, a, n, s, l), this._currentPlacementIndex = t1.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;
            }
            isDone() {
                return this._done;
            }
            continuePlacement(t1, i, o, r) {
                const a = e.e.now(), n = ()=>{
                    const t1 = e.e.now() - a;
                    return !this._forceFullPlacement && t1 > 2;
                };
                for(; this._currentPlacementIndex >= 0;){
                    const a = i[t1[this._currentPlacementIndex]], s = this.placement.collisionIndex.transform.zoom;
                    if ("symbol" === a.type && (!a.minzoom || a.minzoom <= s) && (!a.maxzoom || a.maxzoom > s)) {
                        const t1 = a, i = t1.layout.get("symbol-z-elevate"), s = this._inProgressLayer = this._inProgressLayer || new xa(t1), l = e.al(a.source, a.scope);
                        if (s.continuePlacement(i ? r[l] : o[l], this.placement, this._showCollisionBoxes, a, n)) return;
                        delete this._inProgressLayer;
                    }
                    this._currentPlacementIndex--;
                }
                this._done = !0;
            }
            commit(e) {
                return this.placement.commit(e), this.placement;
            }
        }
        const ba = 512 / e.a3 / 2;
        class wa {
            constructor(t1, i, o){
                this.tileID = t1, this.bucketInstanceId = o, this.index = new e.cK(i.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
                const r = t1.canonical.x * e.a3, a = t1.canonical.y * e.a3;
                for(let e = 0; e < i.length; e++){
                    const { key: t1, crossTileID: o, tileAnchorX: n, tileAnchorY: s } = i.get(e), l = Math.floor((r + n) * ba), c = Math.floor((a + s) * ba);
                    this.index.add(l, c), this.keys.push(t1), this.crossTileIDs.push(o);
                }
                this.index.finish();
            }
            findMatches(t1, i, o) {
                const r = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z), a = ba / Math.pow(2, i.canonical.z - this.tileID.canonical.z), n = i.canonical.x * e.a3, s = i.canonical.y * e.a3;
                for(let e = 0; e < t1.length; e++){
                    const i = t1.get(e);
                    if (i.crossTileID) continue;
                    const { key: l, tileAnchorX: c, tileAnchorY: h } = i, _ = Math.floor((n + c) * a), u = Math.floor((s + h) * a), d = this.index.range(_ - r, u - r, _ + r, u + r);
                    for (const e of d){
                        const t1 = this.crossTileIDs[e];
                        if (this.keys[e] === l && !o.has(t1)) {
                            o.add(t1), i.crossTileID = t1;
                            break;
                        }
                    }
                }
            }
        }
        class Ta {
            constructor(){
                this.maxCrossTileID = 0;
            }
            generate() {
                return ++this.maxCrossTileID;
            }
        }
        class Ea {
            constructor(){
                this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(e) {
                const t1 = Math.round((e - this.lng) / 360);
                if (0 !== t1) for(const e in this.indexes){
                    const i = this.indexes[e], o = {};
                    for(const e in i){
                        const r = i[e];
                        r.tileID = r.tileID.unwrapTo(r.tileID.wrap + t1), o[r.tileID.key] = r;
                    }
                    this.indexes[e] = o;
                }
                this.lng = e;
            }
            addBucket(e, t1, i) {
                if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
                    if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t1.bucketInstanceId) return !1;
                    this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
                }
                for(let e = 0; e < t1.symbolInstances.length; e++)t1.symbolInstances.get(e).crossTileID = 0;
                this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = new Set);
                const o = this.usedCrossTileIDs[e.overscaledZ];
                for(const i in this.indexes){
                    const r = this.indexes[i];
                    if (Number(i) > e.overscaledZ) for(const i in r){
                        const a = r[i];
                        a.tileID.isChildOf(e) && a.findMatches(t1.symbolInstances, e, o);
                    }
                    else {
                        const a = r[e.scaledTo(Number(i)).key];
                        a && a.findMatches(t1.symbolInstances, e, o);
                    }
                }
                for(let e = 0; e < t1.symbolInstances.length; e++){
                    const r = t1.symbolInstances.get(e);
                    r.crossTileID || (r.crossTileID = i.generate(), o.add(r.crossTileID));
                }
                return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new wa(e, t1.symbolInstances, t1.bucketInstanceId), !0;
            }
            removeBucketCrossTileIDs(e, t1) {
                for (const i of t1.crossTileIDs)this.usedCrossTileIDs[e].delete(i);
            }
            removeStaleBuckets(e) {
                let t1 = !1;
                for(const i in this.indexes){
                    const o = this.indexes[i];
                    for(const r in o)e[o[r].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[r]), delete o[r], t1 = !0);
                }
                return t1;
            }
        }
        class Ca {
            constructor(){
                this.layerIndexes = {}, this.crossTileIDs = new Ta, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(e, t1, i, o) {
                let r = this.layerIndexes[e.fqid];
                void 0 === r && (r = this.layerIndexes[e.fqid] = new Ea);
                let a = !1;
                const n = {};
                "globe" !== o.name && r.handleWrapJump(i);
                for (const i of t1){
                    const t1 = i.getBucket(e);
                    t1 && e.fqid === t1.layerIds[0] && (t1.bucketInstanceId || (t1.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(i.tileID, t1, this.crossTileIDs) && (a = !0), n[t1.bucketInstanceId] = !0);
                }
                return r.removeStaleBuckets(n) && (a = !0), a;
            }
            pruneUnusedLayers(e) {
                const t1 = {};
                e.forEach((e)=>{
                    t1[e] = !0;
                });
                for(const e in this.layerIndexes)t1[e] || delete this.layerIndexes[e];
            }
        }
        const Sa = new e.N({
            data: new e.O(e.L.colorTheme.data)
        }), Ia = (e, t1)=>Xe(e, t1 && t1.filter((e)=>"source.canvas" !== e.identifier)), La = e.ah(jr, [
            "addLayer",
            "removeLayer",
            "setLights",
            "setPaintProperty",
            "setLayoutProperty",
            "setSlot",
            "setFilter",
            "addSource",
            "removeSource",
            "setLayerZoomRange",
            "setLight",
            "setTransition",
            "setGeoJSONSourceData",
            "setTerrain",
            "setFog",
            "setProjection",
            "setCamera",
            "addImport",
            "removeImport",
            "updateImport"
        ]), Pa = e.ah(jr, [
            "setCenter",
            "setZoom",
            "setBearing",
            "setPitch"
        ]), Aa = {
            version: 8,
            layers: [],
            sources: {}
        }, Ra = {
            duration: 300,
            delay: 0
        };
        class Da extends e.E {
            constructor(t1, i = {}){
                super(), this.map = t1, this.scope = i.scope || "", this.globalId = null, this.fragments = [], this.importDepth = i.importDepth || 0, this.importsCache = i.importsCache || new Map, this.resolvedImports = i.resolvedImports || new Set, this.transition = e.W({}, Ra), this._buildingIndex = new Nr(this), this.crossTileSymbolIndex = new Ca, this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerIndices = [], this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this._changes = i.styleChanges || new v, this.dispatcher = i.dispatcher ? i.dispatcher : new e.bw(e.bx(), this), i.imageManager ? this.imageManager = i.imageManager : (this.imageManager = new _e, this.imageManager.setEventedParent(this)), this.imageManager.createScope(this.scope), this.glyphManager = i.glyphManager ? i.glyphManager : new e.cM(t1._requestManager, i.localFontFamily ? e.cN.all : i.localIdeographFontFamily ? e.cN.ideographs : e.cN.none, i.localFontFamily || i.localIdeographFontFamily), i.modelManager ? this.modelManager = i.modelManager : (this.modelManager = new ce(t1._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._precompileDone = !1, this._shouldPrecompile = !1, this._availableImages = [], this._order = [], this._markersNeedUpdate = !1, this._styleColorTheme = {
                    lut: null,
                    lutLoading: !1,
                    lutLoadingCorrelationID: 0,
                    colorTheme: null
                }, this._styleColorThemeForScope = {}, this.options = i.configOptions ? i.configOptions : new Map, this._configDependentLayers = i.configDependentLayers ? i.configDependentLayers : new Set, this._config = i.config, this._initialConfig = i.initialConfig, this.dispatcher.broadcast("setReferrer", e.cO());
                const o = this;
                this._rtlTextPluginCallback = Da.registerForPluginStateChange((t1)=>{
                    o.dispatcher.broadcast("syncRTLPluginState", {
                        pluginStatus: t1.pluginStatus,
                        pluginURL: t1.pluginURL
                    }, (t1, i)=>{
                        if (e.cP(t1), i && i.every((e)=>e)) for(const e in o._sourceCaches){
                            const t1 = o._sourceCaches[e], i = t1.getSource().type;
                            "vector" !== i && "geojson" !== i || t1.reload();
                        }
                    });
                }), this.on("data", (e)=>{
                    if ("source" !== e.dataType || "metadata" !== e.sourceDataType) return;
                    const t1 = this.getOwnSource(e.sourceId);
                    if (t1 && t1.vectorLayerIds) for(const e in this._layers){
                        const i = this._layers[e];
                        i.source === t1.id && this._validateLayer(i);
                    }
                });
            }
            load(e) {
                return e ? ("string" == typeof e ? this.loadURL(e) : this.loadJSON(e), this) : this;
            }
            _getGlobalId(t1) {
                if (!t1) return null;
                if ("string" == typeof t1) {
                    if (e.cQ(t1)) return t1;
                    const i = e.cR(t1);
                    if (!i.startsWith("http")) try {
                        return new URL(i, location.href).toString();
                    } catch (e) {
                        return i;
                    }
                    return i;
                }
                return `json://${e.cS(JSON.stringify(t1))}`;
            }
            _diffStyle(t1, i, o) {
                this.globalId = this._getGlobalId(t1);
                const r = (e, t1)=>{
                    try {
                        t1(null, this.setState(e, o));
                    } catch (e) {
                        t1(e, !1);
                    }
                };
                if ("string" == typeof t1) {
                    const o = this.map._requestManager.normalizeStyleURL(t1), a = this.map._requestManager.transformRequest(o, e.R.Style);
                    e.g(a, (t1, o)=>{
                        t1 ? this.fire(new e.d(t1)) : o && r(o, i);
                    });
                } else "object" == typeof t1 && r(t1, i);
            }
            loadURL(t1, i = {}) {
                this.fire(new e.f("dataloading", {
                    dataType: "style"
                }));
                const o = "boolean" == typeof i.validate ? i.validate : !e.cQ(t1);
                this.globalId = this._getGlobalId(t1), t1 = this.map._requestManager.normalizeStyleURL(t1, i.accessToken), this.resolvedImports.add(t1);
                const r = this.importsCache.get(t1);
                if (r) return this._load(r, o);
                const a = this.map._requestManager.transformRequest(t1, e.R.Style);
                this._request = e.g(a, (i, r)=>{
                    if (this._request = null, i) this.fire(new e.d(i));
                    else if (r) return this.importsCache.set(t1, r), this._load(r, o);
                });
            }
            loadJSON(t1, i = {}) {
                this.fire(new e.f("dataloading", {
                    dataType: "style"
                })), this.globalId = this._getGlobalId(t1), this._request = e.e.frame(()=>{
                    this._request = null, this._load(t1, !1 !== i.validate);
                });
            }
            loadEmpty() {
                this.fire(new e.f("dataloading", {
                    dataType: "style"
                })), this._load(Aa, !1);
            }
            _loadImports(t1, i, o) {
                if (this.importDepth >= 4) return e.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
                const r = [];
                for (const e of t1){
                    const t1 = this._createFragmentStyle(e), a = new Promise((e)=>{
                        t1.once("style.import.load", e), t1.once("error", e);
                    }).then(()=>this.mergeAll());
                    if (r.push(a), this.resolvedImports.has(e.url)) {
                        t1.loadEmpty();
                        continue;
                    }
                    const n = e.data || this.importsCache.get(e.url);
                    n ? (t1.loadJSON(n, {
                        validate: i
                    }), this._isInternalStyle(n) && (t1.globalId = null)) : e.url ? t1.loadURL(e.url, {
                        validate: i
                    }) : t1.loadEmpty();
                    const s = {
                        style: t1,
                        id: e.id,
                        config: e.config
                    };
                    if (o) {
                        const e = this.fragments.findIndex(({ id: e })=>e === o);
                        this.fragments = this.fragments.slice(0, e).concat(s).concat(this.fragments.slice(e));
                    } else this.fragments.push(s);
                }
                return Promise.allSettled(r);
            }
            getImportGlobalIds(e = this, t1 = new Set) {
                for (const i of e.fragments)i.style.globalId && t1.add(i.style.globalId), this.getImportGlobalIds(i.style, t1);
                return [
                    ...t1.values()
                ];
            }
            _createFragmentStyle(t1) {
                const i = this.scope ? e.al(t1.id, this.scope) : t1.id;
                let o;
                const r = this._initialConfig && this._initialConfig[i];
                (t1.config || r) && (o = e.W({}, t1.config, r));
                const a = new Da(this.map, {
                    scope: i,
                    styleChanges: this._changes,
                    importDepth: this.importDepth + 1,
                    importsCache: this.importsCache,
                    resolvedImports: new Set(this.resolvedImports),
                    dispatcher: this.dispatcher,
                    imageManager: this.imageManager,
                    glyphManager: this.glyphManager,
                    modelManager: this.modelManager,
                    config: o,
                    configOptions: this.options,
                    configDependentLayers: this._configDependentLayers
                });
                return a.setEventedParent(this.map, {
                    style: a
                }), a;
            }
            _reloadImports() {
                this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", {
                    layers: this._serializeLayers(this._order),
                    scope: this.scope,
                    options: this.options
                }), this._shouldPrecompile = this.isRootStyle();
            }
            _isInternalStyle(e) {
                return this.isRootStyle() && (e.fragment || !!e.schema && !1 !== e.fragment);
            }
            _load(t1, i) {
                const o = t1.schema;
                if (this._isInternalStyle(t1)) {
                    const o = e.W({}, Aa, {
                        imports: [
                            {
                                id: "basemap",
                                data: t1,
                                url: ""
                            }
                        ]
                    });
                    return void this._load(o, i);
                }
                if (this.updateConfig(this._config, o), i && Ia(this, Be(t1))) return;
                this._loaded = !0, this.stylesheet = e.cT(t1);
                const r = ()=>{
                    for(const e in t1.sources)this.addSource(e, t1.sources[e], {
                        validate: !1,
                        isInitialLoad: !0
                    });
                    t1.sprite ? this._loadSprite(t1.sprite) : (this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", {
                        scope: this.scope,
                        isLoaded: !0
                    })), this.glyphManager.setURL(t1.glyphs, this.scope);
                    const o = Gr(this.stylesheet.layers);
                    if (this._order = o.map((e)=>e.id), this.stylesheet.light && e.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights) {
                        if (1 === this.stylesheet.lights.length && "flat" === this.stylesheet.lights[0].type) {
                            const e = this.stylesheet.lights[0];
                            this.light = new Ke(e.properties, e.id);
                        } else this.setLights(this.stylesheet.lights);
                    }
                    this.light || (this.light = new Ke(this.stylesheet.light)), this._layers = {}, this._serializedLayers = {};
                    for (const t1 of o){
                        const i = e.cY(t1, this.scope, this._styleColorTheme.lut, this.options);
                        i.isConfigDependent && this._configDependentLayers.add(i.fqid), i.setEventedParent(this, {
                            layer: {
                                id: i.id
                            }
                        }), this._layers[i.id] = i, this._serializedLayers[i.id] = i.serialize();
                        const o = this.getOwnLayerSourceCache(i), r = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                        o && i.canCastShadows() && r && (o.castsShadows = !0);
                    }
                    this.stylesheet.models && this.modelManager.addModels(this.stylesheet.models, this.scope);
                    const r = this.stylesheet.terrain;
                    r && (this.checkCanvasFingerprintNoise(), this.terrainSetForDrapingOnly() || this._createTerrain(r, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new e.f("data", {
                        dataType: "style"
                    }));
                    const a = this.isRootStyle();
                    t1.imports ? this._loadImports(t1.imports, i).then(()=>{
                        this._reloadImports(), this.fire(new e.f(a ? "style.load" : "style.import.load"));
                    }) : (this._reloadImports(), this.fire(new e.f(a ? "style.load" : "style.import.load")));
                }, a = this.stylesheet["color-theme"];
                if (this._styleColorTheme.colorTheme = a, a) {
                    const t1 = this._evaluateColorThemeData(a);
                    this._loadColorTheme(t1).then(()=>{
                        r();
                    }).catch((t1)=>{
                        e.w(`Couldn't load color theme from the stylesheet: ${t1}`), r();
                    });
                } else this._styleColorTheme.lut = null, r();
            }
            isRootStyle() {
                return 0 === this.importDepth;
            }
            mergeAll() {
                let t1, i, o, r, a, n, s, l;
                const c = {};
                this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((e)=>{
                    if (e.stylesheet) {
                        if (null != e.light && (t1 = e.light), e.stylesheet.lights) for (const t1 of e.stylesheet.lights)"ambient" === t1.type && null != e.ambientLight && (i = e.ambientLight), "directional" === t1.type && null != e.directionalLight && (o = e.directionalLight);
                        r = this._prioritizeTerrain(r, e.terrain, e.stylesheet.terrain), e.stylesheet.fog && null != e.fog && (a = e.fog), null != e.stylesheet.camera && (l = e.stylesheet.camera), null != e.stylesheet.projection && (n = e.stylesheet.projection), null != e.stylesheet.transition && (s = e.stylesheet.transition), c[e.scope] = e._styleColorTheme;
                    }
                }), this.light = t1, this.ambientLight = i, this.directionalLight = o, this.fog = a, this._styleColorThemeForScope = c, null === r ? delete this.terrain : this.terrain = r, this.camera = l || {
                    "camera-projection": "perspective"
                }, this.projection = n || {
                    name: "mercator"
                }, this.transition = e.W({}, Ra, s), this.mergeSources(), this.mergeLayers();
            }
            forEachFragmentStyle(e) {
                const t1 = (i)=>{
                    for (const e of i.fragments)t1(e.style);
                    e(i);
                };
                t1(this);
            }
            _prioritizeTerrain(e, t1, i) {
                const o = e && 0 === e.drapeRenderMode;
                return null === i ? t1 && 0 === t1.drapeRenderMode ? t1 : o ? e : null : null != t1 && (!e || o || t1 && 1 === t1.drapeRenderMode) ? t1 : e;
            }
            mergeTerrain() {
                let e;
                this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((t1)=>{
                    e = this._prioritizeTerrain(e, t1.terrain, t1.stylesheet.terrain);
                }), null === e ? delete this.terrain : this.terrain = e;
            }
            mergeProjection() {
                let e;
                this.forEachFragmentStyle((t1)=>{
                    null != t1.stylesheet.projection && (e = t1.stylesheet.projection);
                }), this.projection = e || {
                    name: "mercator"
                };
            }
            mergeSources() {
                const t1 = {}, i = {}, o = {};
                this.forEachFragmentStyle((r)=>{
                    for(const i in r._sourceCaches){
                        const o = e.al(i, r.scope);
                        t1[o] = r._sourceCaches[i];
                    }
                    for(const t1 in r._otherSourceCaches){
                        const o = e.al(t1, r.scope);
                        i[o] = r._otherSourceCaches[t1];
                    }
                    for(const t1 in r._symbolSourceCaches){
                        const i = e.al(t1, r.scope);
                        o[i] = r._symbolSourceCaches[t1];
                    }
                }), this._mergedSourceCaches = t1, this._mergedOtherSourceCaches = i, this._mergedSymbolSourceCaches = o;
            }
            mergeLayers() {
                const t1 = {}, i = [], o = {};
                this._mergedSlots = [], this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this.forEachFragmentStyle((o)=>{
                    for (const r of o._order){
                        const a = o._layers[r];
                        if ("slot" === a.type) {
                            const i = e.cU(r);
                            if (t1[i]) continue;
                            t1[i] = [];
                        }
                        a.slot && t1[a.slot] ? t1[a.slot].push(a) : i.push(a);
                    }
                }), this._mergedOrder = [], this._clipLayerIndices = [];
                let r = 0;
                const a = (i = [])=>{
                    for (const n of i)if ("slot" === n.type) {
                        const i = e.cU(n.id);
                        t1[i] && a(t1[i]), this._mergedSlots.push(i);
                    } else {
                        const t1 = e.al(n.id, n.scope);
                        this._mergedOrder.push(t1), o[t1] = n, n.is3D() && (this._has3DLayers = !0), "circle" === n.type && (this._hasCircleLayers = !0), "symbol" === n.type && (this._hasSymbolLayers = !0), "clip" === n.type && this._clipLayerIndices.push(r), r++;
                    }
                };
                a(i), this._mergedLayers = o, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();
            }
            terrainSetForDrapingOnly() {
                return !!this.terrain && 0 === this.terrain.drapeRenderMode;
            }
            getCamera() {
                return this.stylesheet.camera;
            }
            setCamera(t1) {
                return this.stylesheet.camera = e.W({}, this.stylesheet.camera, t1), this.camera = this.stylesheet.camera, this;
            }
            _evaluateColorThemeData(t1) {
                return t1.data ? (function(t1, i, o) {
                    const r = e.W({}, i);
                    for (const t1 of Object.keys(e.L.colorTheme))void 0 === r[t1] && (r[t1] = e.L.colorTheme[t1].default);
                    const a = new e.U(Sa, t1, new Map(o));
                    return a.setTransitionOrValue(r, o), a.untransitioned().possiblyEvaluate(new e.X(0));
                })(this.scope, t1, this.options).get("data") : null;
            }
            _loadColorTheme(t1) {
                this._styleColorTheme.lutLoading = !0, this._styleColorTheme.lutLoadingCorrelationID += 1;
                const i = this._styleColorTheme.lutLoadingCorrelationID;
                return new Promise((o, r)=>{
                    const a = "data:image/png;base64,";
                    if (!t1 || 0 === t1.length) return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = !1, void o();
                    let n = t1;
                    n.startsWith(a) || (n = a + n);
                    const s = "mapbox-reserved-lut", l = new Image;
                    l.src = n, l.onerror = ()=>{
                        this._styleColorTheme.lutLoading = !1, r(new Error("Failed to load image data"));
                    }, l.onload = ()=>{
                        if (this._styleColorTheme.lutLoadingCorrelationID !== i) return void o();
                        this._styleColorTheme.lutLoading = !1;
                        const { width: a, height: n, data: c } = e.e.getImageData(l);
                        if (n > 32) return void r(new Error("The height of the image must be less than or equal to 32 pixels."));
                        if (a !== n * n) return void r(new Error("The width of the image must be equal to the height squared."));
                        this.getImage(s) && this.removeImage(s), this.addImage(s, {
                            data: new e.i({
                                width: a,
                                height: n
                            }, c),
                            pixelRatio: 1,
                            sdf: !1,
                            version: 0
                        });
                        const h = this.imageManager.getImage(s, this.scope);
                        h ? (this._styleColorTheme.lut = {
                            image: h.data,
                            data: t1
                        }, o()) : r(new Error("Missing LUT image."));
                    };
                });
            }
            getLut(e) {
                const t1 = this._styleColorThemeForScope[e];
                return t1 ? t1.lut : null;
            }
            setProjection(e) {
                e ? this.stylesheet.projection = e : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
            }
            applyProjectionUpdate() {
                this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));
            }
            _updateMapProjection() {
                this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
            }
            _loadSprite(t1) {
                this._spriteRequest = function(t1, i, o) {
                    let r, a, n;
                    const s = e.e.devicePixelRatio > 1 ? "@2x" : "";
                    let l = e.g(i.transformRequest(i.normalizeSpriteURL(t1, s, ".json"), e.R.SpriteJSON), (e, t1)=>{
                        l = null, n || (n = e, r = t1, h());
                    }), c = e.h(i.transformRequest(i.normalizeSpriteURL(t1, s, ".png"), e.R.SpriteImage), (e, t1)=>{
                        c = null, n || (n = e, a = t1, h());
                    });
                    function h() {
                        if (n) o(n);
                        else if (r && a) {
                            const t1 = e.e.getImageData(a), i = {};
                            for(const o in r){
                                const { width: a, height: n, x: s, y: l, sdf: c, pixelRatio: h, stretchX: _, stretchY: u, content: d } = r[o], p = new e.i({
                                    width: a,
                                    height: n
                                });
                                e.i.copy(t1, p, {
                                    x: s,
                                    y: l
                                }, {
                                    x: 0,
                                    y: 0
                                }, {
                                    width: a,
                                    height: n
                                }, null), i[o] = {
                                    data: p,
                                    pixelRatio: h,
                                    sdf: c,
                                    stretchX: _,
                                    stretchY: u,
                                    content: d
                                };
                            }
                            o(null, i);
                        }
                    }
                    return {
                        cancel () {
                            l && (l.cancel(), l = null), c && (c.cancel(), c = null);
                        }
                    };
                }(t1, this.map._requestManager, (t1, i)=>{
                    if (this._spriteRequest = null, t1) this.fire(new e.d(t1));
                    else if (i) for(const e in i)this.imageManager.addImage(e, this.scope, i[e]);
                    this.imageManager.setLoaded(!0, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", {
                        scope: this.scope,
                        images: this._availableImages
                    }), this.dispatcher.broadcast("spriteLoaded", {
                        scope: this.scope,
                        isLoaded: !0
                    }), this.fire(new e.f("data", {
                        dataType: "style"
                    }));
                });
            }
            _validateLayer(t1) {
                const i = this.getOwnSource(t1.source);
                if (!i) return;
                const o = t1.sourceLayer;
                o && ("geojson" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(o)) && this.fire(new e.d(new Error(`Source layer "${o}" does not exist on source "${i.id}" as specified by style layer "${t1.id}"`)));
            }
            loaded() {
                if (!this._loaded) return !1;
                if (Object.keys(this._changes.getUpdatedSourceCaches()).length) return !1;
                for(const e in this._sourceCaches)if (!this._sourceCaches[e].loaded()) return !1;
                if (!this.imageManager.isLoaded()) return !1;
                if (!this.modelManager.isLoaded()) return !1;
                if (this._styleColorTheme.lutLoading) return !1;
                for (const { style: e } of this.fragments)if (!e.loaded()) return !1;
                return !0;
            }
            _serializeImports() {
                if (this.stylesheet.imports) return this.stylesheet.imports.map((e, t1)=>{
                    const i = this.fragments[t1];
                    return i && i.style && (e.data = i.style.serialize()), e;
                });
            }
            _serializeSources() {
                const e = {};
                for(const t1 in this._sourceCaches){
                    const i = this._sourceCaches[t1].getSource();
                    e[i.id] || (e[i.id] = i.serialize());
                }
                return e;
            }
            _serializeLayers(e) {
                const t1 = [];
                for (const i of e){
                    const e = this._layers[i];
                    e && "custom" !== e.type && t1.push(e.serialize());
                }
                return t1;
            }
            hasLightTransitions() {
                return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
            }
            hasFogTransition() {
                return !!this.fog && this.fog.hasTransition();
            }
            hasTransitions() {
                if (this.hasLightTransitions()) return !0;
                if (this.hasFogTransition()) return !0;
                for(const e in this._sourceCaches)if (this._sourceCaches[e].hasTransition()) return !0;
                for(const e in this._layers)if (this._layers[e].hasTransition()) return !0;
                return !1;
            }
            get order() {
                return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
            }
            isLayerDraped(e) {
                return !!this.terrain && e.isDraped(this.getLayerSourceCache(e));
            }
            _checkLoaded() {
                if (!this._loaded) throw new Error("Style is not done loading");
            }
            _checkLayer(t1) {
                const i = this.getOwnLayer(t1);
                if (i) return i;
                this.fire(new e.d(new Error(`The layer '${t1}' does not exist in the map's style.`)));
            }
            _checkSource(t1) {
                const i = this.getOwnSource(t1);
                if (i) return i;
                this.fire(new e.d(new Error(`The source '${t1}' does not exist in the map's style.`)));
            }
            update(t1) {
                if (!this._loaded) return;
                this.ambientLight && this.ambientLight.recalculate(t1), this.directionalLight && this.directionalLight.recalculate(t1);
                const i = this.calculateLightsBrightness();
                t1.brightness = i || 0, i !== this._brightness && (this._brightness = i, this.dispatcher.broadcast("setBrightness", i));
                const o = this._changes.isDirty();
                let r = !1;
                if (this._changes.isDirty()) {
                    const e = this._changes.getLayerUpdatesByScope();
                    for(const t1 in e){
                        const { updatedIds: i, removedIds: o } = e[t1];
                        (i || o) && (this._updateWorkerLayers(t1, i, o), r = !0);
                    }
                    this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t1), this.light && this.light.updateTransitions(t1), this.ambientLight && this.ambientLight.updateTransitions(t1), this.directionalLight && this.directionalLight.updateTransitions(t1), this.fog && this.fog.updateTransitions(t1), this._changes.reset();
                }
                const a = {};
                for(const e in this._mergedSourceCaches){
                    const t1 = this._mergedSourceCaches[e];
                    a[e] = t1.used, t1.used = !1, t1.tileCoverLift = 0;
                }
                for (const e of this._mergedOrder){
                    const i = this._mergedLayers[e];
                    if (i.recalculate(t1, this._availableImages), !i.isHidden(t1.zoom)) {
                        const e = this.getLayerSourceCache(i);
                        e && (e.used = !0, e.tileCoverLift = Math.max(e.tileCoverLift, i.tileCoverLift()));
                    }
                    if (!this._precompileDone && this._shouldPrecompile) for(let e = i.minzoom || 0; e < (i.maxzoom || 25.5); e++){
                        const e = this.map.painter;
                        if (e) {
                            const o = i.getProgramIds();
                            if (!o) continue;
                            for (const r of o){
                                const o = i.getDefaultProgramParams(r, t1.zoom, this._styleColorTheme.lut);
                                o && (e.style = this, this.fog && (e._fogVisible = !0, o.overrideFog = !0, e.getOrCreateProgram(r, o)), e._fogVisible = !1, o.overrideFog = !1, e.getOrCreateProgram(r, o), (this.stylesheet.terrain || this.stylesheet.projection && "globe" === this.stylesheet.projection.name) && (o.overrideRtt = !0, e.getOrCreateProgram(r, o)));
                            }
                        }
                    }
                }
                this._shouldPrecompile && (this._precompileDone = !0), this.terrain && r && this.mergeLayers();
                for(const t1 in a){
                    const i = this._mergedSourceCaches[t1];
                    a[t1] !== i.used && i.getSource().fire(new e.f("data", {
                        sourceDataType: "visibility",
                        dataType: "source",
                        sourceId: i.getSource().id
                    }));
                }
                this.light && this.light.recalculate(t1), this.terrain && this.terrain.recalculate(t1), this.fog && this.fog.recalculate(t1), this.z = t1.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), o && this.fire(new e.f("data", {
                    dataType: "style"
                }));
            }
            _updateTilesForChangedImages() {
                const e = this._changes.getUpdatedImages();
                if (e.length) {
                    for(const t1 in this._sourceCaches)this._sourceCaches[t1].reloadTilesForDependencies([
                        "icons",
                        "patterns"
                    ], e);
                    this._changes.resetUpdatedImages();
                }
            }
            _updateWorkerLayers(e, t1, i) {
                const o = this.getFragmentStyle(e);
                o && this.dispatcher.broadcast("updateLayers", {
                    layers: t1 ? o._serializeLayers(t1) : [],
                    scope: e,
                    removedIds: i || [],
                    options: o.options
                });
            }
            setState(i, o) {
                if (this._checkLoaded(), Ia(this, Be(i))) return !1;
                (i = e.cT(i)).layers = Gr(i.layers);
                const r = (function(e, i) {
                    if (!e) return [
                        {
                            command: jr.setStyle,
                            args: [
                                i
                            ]
                        }
                    ];
                    let o = [];
                    try {
                        if (!t1(e.version, i.version)) return [
                            {
                                command: jr.setStyle,
                                args: [
                                    i
                                ]
                            }
                        ];
                        if (t1(e.center, i.center) || o.push({
                            command: jr.setCenter,
                            args: [
                                i.center
                            ]
                        }), t1(e.zoom, i.zoom) || o.push({
                            command: jr.setZoom,
                            args: [
                                i.zoom
                            ]
                        }), t1(e.bearing, i.bearing) || o.push({
                            command: jr.setBearing,
                            args: [
                                i.bearing
                            ]
                        }), t1(e.pitch, i.pitch) || o.push({
                            command: jr.setPitch,
                            args: [
                                i.pitch
                            ]
                        }), t1(e.sprite, i.sprite) || o.push({
                            command: jr.setSprite,
                            args: [
                                i.sprite
                            ]
                        }), t1(e.glyphs, i.glyphs) || o.push({
                            command: jr.setGlyphs,
                            args: [
                                i.glyphs
                            ]
                        }), t1(e.imports, i.imports) || function(e = [], i = [], o) {
                            i = i || [];
                            const r = (e = e || []).map($r), a = i.map($r), n = e.reduce(Xr, {}), s = i.reduce(Xr, {}), l = r.slice();
                            let c, h, _, u;
                            for(c = 0, h = 0; c < r.length; c++)_ = r[c], s.hasOwnProperty(_) ? h++ : (o.push({
                                command: jr.removeImport,
                                args: [
                                    _
                                ]
                            }), l.splice(l.indexOf(_, h), 1));
                            for(c = 0, h = 0; c < a.length; c++)_ = a[a.length - 1 - c], l[l.length - 1 - c] !== _ && (n.hasOwnProperty(_) ? (o.push({
                                command: jr.removeImport,
                                args: [
                                    _
                                ]
                            }), l.splice(l.lastIndexOf(_, l.length - h), 1)) : h++, u = l[l.length - c], o.push({
                                command: jr.addImport,
                                args: [
                                    s[_],
                                    u
                                ]
                            }), l.splice(l.length - c, 0, _));
                            for (const e of i){
                                const i = n[e.id];
                                i && !t1(i, e) && o.push({
                                    command: jr.updateImport,
                                    args: [
                                        e.id,
                                        e
                                    ]
                                });
                            }
                        }(e.imports, i.imports, o), t1(e.transition, i.transition) || o.push({
                            command: jr.setTransition,
                            args: [
                                i.transition
                            ]
                        }), t1(e.light, i.light) || o.push({
                            command: jr.setLight,
                            args: [
                                i.light
                            ]
                        }), t1(e.fog, i.fog) || o.push({
                            command: jr.setFog,
                            args: [
                                i.fog
                            ]
                        }), t1(e.projection, i.projection) || o.push({
                            command: jr.setProjection,
                            args: [
                                i.projection
                            ]
                        }), t1(e.lights, i.lights) || o.push({
                            command: jr.setLights,
                            args: [
                                i.lights
                            ]
                        }), t1(e.camera, i.camera) || o.push({
                            command: jr.setCamera,
                            args: [
                                i.camera
                            ]
                        }), !t1(e["color-theme"], i["color-theme"])) return [
                            {
                                command: jr.setStyle,
                                args: [
                                    i
                                ]
                            }
                        ];
                        const r = {}, a = [];
                        !function(e, i, o, r) {
                            let a;
                            for(a in i = i || {}, e = e || {})e.hasOwnProperty(a) && (i.hasOwnProperty(a) || Wr(a, o, r));
                            for(a in i){
                                if (!i.hasOwnProperty(a)) continue;
                                const n = i[a];
                                e.hasOwnProperty(a) ? t1(e[a], n) || ("geojson" === e[a].type && "geojson" === n.type && qr(e, i, a) ? o.push({
                                    command: jr.setGeoJSONSourceData,
                                    args: [
                                        a,
                                        n.data
                                    ]
                                }) : Zr(a, i, o, r)) : Vr(a, i, o);
                            }
                        }(e.sources, i.sources, a, r);
                        const n = [];
                        e.layers && e.layers.forEach((e)=>{
                            e.source && r[e.source] ? o.push({
                                command: jr.removeLayer,
                                args: [
                                    e.id
                                ]
                            }) : n.push(e);
                        });
                        let s = e.terrain;
                        s && r[s.source] && (o.push({
                            command: jr.setTerrain,
                            args: [
                                void 0
                            ]
                        }), s = void 0), o = o.concat(a), t1(s, i.terrain) || o.push({
                            command: jr.setTerrain,
                            args: [
                                i.terrain
                            ]
                        }), function(e, i, o) {
                            i = i || [];
                            const r = (e = e || []).map($r), a = i.map($r), n = e.reduce(Xr, {}), s = i.reduce(Xr, {}), l = r.slice(), c = Object.create(null);
                            let h, _, u, d, p, f, m;
                            for(h = 0, _ = 0; h < r.length; h++)u = r[h], s.hasOwnProperty(u) ? _++ : (o.push({
                                command: jr.removeLayer,
                                args: [
                                    u
                                ]
                            }), l.splice(l.indexOf(u, _), 1));
                            for(h = 0, _ = 0; h < a.length; h++)u = a[a.length - 1 - h], l[l.length - 1 - h] !== u && (n.hasOwnProperty(u) ? (o.push({
                                command: jr.removeLayer,
                                args: [
                                    u
                                ]
                            }), l.splice(l.lastIndexOf(u, l.length - _), 1)) : _++, f = l[l.length - h], o.push({
                                command: jr.addLayer,
                                args: [
                                    s[u],
                                    f
                                ]
                            }), l.splice(l.length - h, 0, u), c[u] = !0);
                            for(h = 0; h < a.length; h++)if (u = a[h], d = n[u], p = s[u], !c[u] && !t1(d, p)) {
                                if (t1(d.source, p.source) && t1(d["source-layer"], p["source-layer"]) && t1(d.type, p.type)) {
                                    for(m in Hr(d.layout, p.layout, o, u, null, jr.setLayoutProperty), Hr(d.paint, p.paint, o, u, null, jr.setPaintProperty), t1(d.slot, p.slot) || o.push({
                                        command: jr.setSlot,
                                        args: [
                                            u,
                                            p.slot
                                        ]
                                    }), t1(d.filter, p.filter) || o.push({
                                        command: jr.setFilter,
                                        args: [
                                            u,
                                            p.filter
                                        ]
                                    }), t1(d.minzoom, p.minzoom) && t1(d.maxzoom, p.maxzoom) || o.push({
                                        command: jr.setLayerZoomRange,
                                        args: [
                                            u,
                                            p.minzoom,
                                            p.maxzoom
                                        ]
                                    }), d)d.hasOwnProperty(m) && "layout" !== m && "paint" !== m && "filter" !== m && "metadata" !== m && "minzoom" !== m && "maxzoom" !== m && "slot" !== m && (0 === m.indexOf("paint.") ? Hr(d[m], p[m], o, u, m.slice(6), jr.setPaintProperty) : t1(d[m], p[m]) || o.push({
                                        command: jr.setLayerProperty,
                                        args: [
                                            u,
                                            m,
                                            p[m]
                                        ]
                                    }));
                                    for(m in p)p.hasOwnProperty(m) && !d.hasOwnProperty(m) && "layout" !== m && "paint" !== m && "filter" !== m && "metadata" !== m && "minzoom" !== m && "maxzoom" !== m && "slot" !== m && (0 === m.indexOf("paint.") ? Hr(d[m], p[m], o, u, m.slice(6), jr.setPaintProperty) : t1(d[m], p[m]) || o.push({
                                        command: jr.setLayerProperty,
                                        args: [
                                            u,
                                            m,
                                            p[m]
                                        ]
                                    }));
                                } else o.push({
                                    command: jr.removeLayer,
                                    args: [
                                        u
                                    ]
                                }), f = l[l.lastIndexOf(u) + 1], o.push({
                                    command: jr.addLayer,
                                    args: [
                                        p,
                                        f
                                    ]
                                });
                            }
                        }(n, i.layers, o);
                    } catch (e) {
                        console.warn("Unable to compute style diff:", e), o = [
                            {
                                command: jr.setStyle,
                                args: [
                                    i
                                ]
                            }
                        ];
                    }
                    return o;
                })(this.serialize(), i).filter((e)=>!(e.command in Pa));
                if (0 === r.length) return !1;
                const a = r.filter((e)=>!(e.command in La));
                if (a.length > 0) throw new Error(`Unimplemented: ${a.map((e)=>e.command).join(", ")}.`);
                const n = [];
                return r.forEach((e)=>{
                    n.push(this[e.command].apply(this, e.args));
                }), o && Promise.all(n).then(o), this.stylesheet = i, this.mergeAll(), this.dispatcher.broadcast("setLayers", {
                    layers: this._serializeLayers(this._order),
                    scope: this.scope,
                    options: this.options
                }), !0;
            }
            addImage(t1, i) {
                return this.getImage(t1) ? this.fire(new e.d(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t1, this.scope, i), this._afterImageUpdated(t1), this);
            }
            updateImage(e, t1) {
                this.imageManager.updateImage(e, this.scope, t1);
            }
            getImage(e) {
                return this.imageManager.getImage(e, this.scope);
            }
            removeImage(t1) {
                return this.getImage(t1) ? (this.imageManager.removeImage(t1, this.scope), this._afterImageUpdated(t1), this) : this.fire(new e.d(new Error("No image with this name exists.")));
            }
            _afterImageUpdated(t1) {
                this._availableImages = this.imageManager.listImages(this.scope), this._changes.updateImage(t1), this.dispatcher.broadcast("setImages", {
                    scope: this.scope,
                    images: this._availableImages
                }), this.fire(new e.f("data", {
                    dataType: "style"
                }));
            }
            listImages() {
                return this._checkLoaded(), this._availableImages.slice();
            }
            addModel(e, t1, i = {}) {
                return this._checkLoaded(), this._validate(He, `models.${e}`, t1, null, i) || (this.modelManager.addModel(e, t1, this.scope), this._changes.setDirty()), this;
            }
            hasModel(e) {
                return this.modelManager.hasModel(e, this.scope);
            }
            removeModel(t1) {
                return this.hasModel(t1) ? (this.modelManager.removeModel(t1, this.scope), this) : this.fire(new e.d(new Error("No model with this ID exists.")));
            }
            listModels() {
                return this._checkLoaded(), this.modelManager.listModels(this.scope);
            }
            addSource(t1, i, o = {}) {
                if (this._checkLoaded(), void 0 !== this.getOwnSource(t1)) throw new Error(`There is already a source with ID "${t1}".`);
                if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
                if ([
                    "vector",
                    "raster",
                    "geojson",
                    "video",
                    "image"
                ].indexOf(i.type) >= 0 && this._validate(ke, `sources.${t1}`, i, null, o)) return;
                this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
                const r = Mi(t1, i, this.dispatcher, this);
                r.scope = this.scope, r.setEventedParent(this, ()=>({
                        isSourceLoaded: this._isSourceCacheLoaded(r.id),
                        source: r.serialize(),
                        sourceId: r.id
                    }));
                const a = (t1)=>{
                    const i = (t1 ? "symbol:" : "other:") + r.id, o = e.al(i, this.scope), a = this._sourceCaches[i] = new e.bv(o, r, t1);
                    (t1 ? this._symbolSourceCaches : this._otherSourceCaches)[r.id] = a, a.onAdd(this.map);
                };
                a(!1), "vector" !== i.type && "geojson" !== i.type || a(!0), r.onAdd && r.onAdd(this.map), o.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
            }
            removeSource(t1) {
                this._checkLoaded();
                const i = this.getOwnSource(t1);
                if (!i) throw new Error("There is no source with this ID");
                for(const i in this._layers)if (this._layers[i].source === t1) return this.fire(new e.d(new Error(`Source "${t1}" cannot be removed while layer "${i}" is using it.`)));
                if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t1) return this.fire(new e.d(new Error(`Source "${t1}" cannot be removed while terrain is using it.`)));
                const o = this.getOwnSourceCaches(t1);
                for (const t1 of o){
                    const i = e.cU(t1.id);
                    delete this._sourceCaches[i], this._changes.discardSourceCacheUpdate(t1.id), t1.fire(new e.f("data", {
                        sourceDataType: "metadata",
                        dataType: "source",
                        sourceId: t1.getSource().id
                    })), t1.setEventedParent(null), t1.clearTiles();
                }
                return delete this._otherSourceCaches[t1], delete this._symbolSourceCaches[t1], this.mergeSources(), i.setEventedParent(null), i.onRemove && i.onRemove(this.map), this._changes.setDirty(), this;
            }
            setGeoJSONSourceData(e, t1) {
                this._checkLoaded(), this.getOwnSource(e).setData(t1), this._changes.setDirty();
            }
            getOwnSource(e) {
                const t1 = this.getOwnSourceCache(e);
                return t1 && t1.getSource();
            }
            getOwnSources() {
                const e = [];
                for(const t1 in this._otherSourceCaches){
                    const i = this.getOwnSourceCache(t1);
                    i && e.push(i.getSource());
                }
                return e;
            }
            areTilesLoaded() {
                const e = this._mergedSourceCaches;
                for(const t1 in e){
                    const i = e[t1]._tiles;
                    for(const e in i){
                        const t1 = i[e];
                        if ("loaded" !== t1.state && "errored" !== t1.state) return !1;
                    }
                }
                return !0;
            }
            setLights(t1) {
                if (this._checkLoaded(), !t1) return delete this.ambientLight, void delete this.directionalLight;
                const i = this._getTransitionParameters();
                for (const e of t1){
                    if (this._validate(Ue, "lights", e)) return;
                    switch(e.type){
                        case "ambient":
                            if (this.ambientLight) {
                                const t1 = this.ambientLight;
                                t1.set(e), t1.updateTransitions(i);
                            } else this.ambientLight = new ct(e, ht, this.scope, this.options);
                            break;
                        case "directional":
                            if (this.directionalLight) {
                                const t1 = this.directionalLight;
                                t1.set(e), t1.updateTransitions(i);
                            } else this.directionalLight = new ct(e, _t, this.scope, this.options);
                    }
                }
                const o = new e.X(this.z || 0, i);
                this.ambientLight && this.ambientLight.recalculate(o), this.directionalLight && this.directionalLight.recalculate(o), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
            }
            calculateLightsBrightness() {
                const t1 = this.directionalLight, i = this.ambientLight;
                if (!t1 || !i) return;
                const o = (e)=>.2126 * (e[0] <= .03928 ? e[0] / 12.92 : Math.pow((e[0] + .055) / 1.055, 2.4)) + .7152 * (e[1] <= .03928 ? e[1] / 12.92 : Math.pow((e[1] + .055) / 1.055, 2.4)) + .0722 * (e[2] <= .03928 ? e[2] / 12.92 : Math.pow((e[2] + .055) / 1.055, 2.4)), r = t1.properties.get("color").toRenderColor(null).toArray01(), a = t1.properties.get("intensity"), n = t1.properties.get("direction"), s = 1 - e.ac(n.x, n.y, n.z)[2] / 90, l = o(r) * a * s, c = i.properties.get("color").toRenderColor(null).toArray01(), h = i.properties.get("intensity");
                return (l + o(c) * h) / 2;
            }
            getBrightness() {
                return this._brightness;
            }
            getLights() {
                if (!this.enable3dLights()) return null;
                const e = [];
                return this.directionalLight && e.push(this.directionalLight.get()), this.ambientLight && e.push(this.ambientLight.get()), e;
            }
            enable3dLights() {
                return !!this.ambientLight && !!this.directionalLight;
            }
            getFragmentStyle(t1) {
                if (!t1) return this;
                if (e.cV(t1)) {
                    const i = e.cW(t1), o = this.fragments.find(({ id: e })=>e === i);
                    if (!o) throw new Error(`Style import not found: ${t1}`);
                    const r = e.cU(t1);
                    return o.style.getFragmentStyle(r);
                }
                {
                    const e = this.fragments.find(({ id: e })=>e === t1);
                    if (!e) throw new Error(`Style import not found: ${t1}`);
                    return e.style;
                }
            }
            getConfigProperty(t1, i) {
                const o = this.getFragmentStyle(t1);
                if (!o) return null;
                const r = e.al(i, o.scope), a = o.options.get(r), n = a ? a.value || a.default : null;
                return n ? n.serialize() : null;
            }
            setConfigProperty(t1, i, o) {
                const r = this.getFragmentStyle(t1);
                if (!r) return;
                const a = r.stylesheet.schema;
                if (!a || !a[i]) return;
                const n = e.y(o);
                if ("success" !== n.result) return void Ia(this, n.value);
                const s = n.value.expression, l = e.al(i, r.scope), c = r.options.get(l);
                if (!c) return;
                let h;
                const { minValue: _, maxValue: u, stepValue: d, type: p, values: f } = a[i], m = e.y(a[i].default);
                "success" === m.result && (h = m.value.expression), h ? (this.options.set(l, {
                    ...c,
                    value: s,
                    default: h,
                    minValue: _,
                    maxValue: u,
                    stepValue: d,
                    type: p,
                    values: f
                }), this.updateConfigDependencies()) : this.fire(new e.d(new Error(`No schema defined for the config option "${i}" in the "${t1}" fragment.`)));
            }
            getConfig(t1) {
                const i = this.getFragmentStyle(t1);
                if (!i) return null;
                const o = i.stylesheet.schema;
                if (!o) return null;
                const r = {};
                for(const t1 in o){
                    const o = e.al(t1, i.scope), a = i.options.get(o), n = a ? a.value || a.default : null;
                    r[t1] = n ? n.serialize() : null;
                }
                return r;
            }
            setConfig(e, t1) {
                const i = this.getFragmentStyle(e);
                i && (i.updateConfig(t1, i.stylesheet.schema), this.updateConfigDependencies());
            }
            getSchema(e) {
                const t1 = this.getFragmentStyle(e);
                return t1 ? t1.stylesheet.schema : null;
            }
            setSchema(e, t1) {
                const i = this.getFragmentStyle(e);
                i && (i.stylesheet.schema = t1, i.updateConfig(i._config, t1), this.updateConfigDependencies());
            }
            updateConfig(t1, i) {
                if (this._config = t1, t1 || i) {
                    if (i) for(const o in i){
                        let r, a;
                        const n = e.y(i[o].default);
                        if ("success" === n.result && (r = n.value.expression), t1 && void 0 !== t1[o]) {
                            const i = e.y(t1[o]);
                            "success" === i.result && (a = i.value.expression);
                        }
                        const { minValue: s, maxValue: l, stepValue: c, type: h, values: _ } = i[o];
                        if (r) {
                            const t1 = e.al(o, this.scope);
                            this.options.set(t1, {
                                default: r,
                                value: a,
                                minValue: s,
                                maxValue: l,
                                stepValue: c,
                                type: h,
                                values: _
                            });
                        } else this.fire(new e.d(new Error(`No schema defined for config option "${o}".`)));
                    }
                    else this.fire(new e.d(new Error("Attempting to set config for a style without schema.")));
                }
            }
            updateConfigDependencies() {
                for (const e of this._configDependentLayers){
                    const t1 = this.getLayer(e);
                    t1 && (t1.possiblyEvaluateVisibility(), this._updateLayer(t1));
                }
                this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.forEachFragmentStyle((e)=>{
                    if (e._styleColorTheme.colorTheme) {
                        const t1 = e._evaluateColorThemeData(e._styleColorTheme.colorTheme);
                        (!e._styleColorTheme.lut || e._styleColorTheme.lut && t1 !== e._styleColorTheme.lut.data) && e.setColorTheme(e._styleColorTheme.colorTheme);
                    }
                }), this._changes.setDirty();
            }
            addLayer(t1, i, o = {}) {
                this._checkLoaded();
                const r = t1.id;
                if (this._layers[r]) return void this.fire(new e.d(new Error(`Layer with id "${r}" already exists on this map`)));
                let a;
                if ("custom" === t1.type) {
                    if (Ia(this, e.cX(t1))) return;
                    a = e.cY(t1, this.scope, this._styleColorTheme.lut, this.options);
                } else {
                    if ("object" == typeof t1.source && (this.addSource(r, t1.source), t1 = e.cT(t1), t1 = e.W(t1, {
                        source: r
                    })), this._validate(Ve, `layers.${r}`, t1, {
                        arrayIndex: -1
                    }, o)) return;
                    a = e.cY(t1, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(a), a.setEventedParent(this, {
                        layer: {
                            id: r
                        }
                    }), this._serializedLayers[a.id] = a.serialize();
                }
                a.isConfigDependent && this._configDependentLayers.add(a.fqid);
                let n = this._order.length;
                if (i) {
                    const t1 = this._order.indexOf(i);
                    if (-1 === t1) return void this.fire(new e.d(new Error(`Layer with id "${i}" does not exist on this map.`)));
                    a.slot === this._layers[i].slot ? n = t1 : e.w(`Layer with id "${i}" has a different slot. Layers can only be rearranged within the same slot.`);
                }
                this._order.splice(n, 0, r), this._layerOrderChanged = !0, this._layers[r] = a;
                const s = this.getOwnLayerSourceCache(a), l = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                s && a.canCastShadows() && l && (s.castsShadows = !0);
                const c = this._changes.getRemovedLayer(a);
                if (c && a.source && s && "custom" !== a.type) {
                    this._changes.discardLayerRemoval(a);
                    const t1 = e.al(a.source, a.scope);
                    c.type !== a.type ? this._changes.updateSourceCache(t1, "clear") : (this._changes.updateSourceCache(t1, "reload"), s.pause());
                }
                this._updateLayer(a), a.onAdd && a.onAdd(this.map), a.scope = this.scope, this.mergeLayers();
            }
            moveLayer(t1, i) {
                this._checkLoaded();
                const o = this._checkLayer(t1);
                if (!o) return;
                if (t1 === i) return;
                const r = this._order.indexOf(t1);
                this._order.splice(r, 1);
                let a = this._order.length;
                if (i) {
                    const t1 = this._order.indexOf(i);
                    if (-1 === t1) return void this.fire(new e.d(new Error(`Layer with id "${i}" does not exist on this map.`)));
                    o.slot === this._layers[i].slot ? a = t1 : e.w(`Layer with id "${i}" has a different slot. Layers can only be rearranged within the same slot.`);
                }
                this._order.splice(a, 0, t1), this._changes.setDirty(), this._layerOrderChanged = !0, this.mergeLayers();
            }
            removeLayer(e) {
                this._checkLoaded();
                const t1 = this._checkLayer(e);
                if (!t1) return;
                t1.setEventedParent(null);
                const i = this._order.indexOf(e);
                this._order.splice(i, 1), delete this._layers[e], delete this._serializedLayers[e], this._changes.setDirty(), this._layerOrderChanged = !0, this._configDependentLayers.delete(t1.fqid), this._changes.removeLayer(t1);
                const o = this.getOwnLayerSourceCache(t1);
                if (o && o.castsShadows) {
                    let e = !1;
                    for(const i in this._layers)if (this._layers[i].source === t1.source && this._layers[i].canCastShadows()) {
                        e = !0;
                        break;
                    }
                    o.castsShadows = e;
                }
                t1.onRemove && t1.onRemove(this.map), this.mergeLayers();
            }
            getOwnLayer(e) {
                return this._layers[e];
            }
            hasLayer(e) {
                return e in this._mergedLayers;
            }
            hasLayerType(e) {
                for(const t1 in this._layers)if (this._layers[t1].type === e) return !0;
                return !1;
            }
            setLayerZoomRange(e, t1, i) {
                this._checkLoaded();
                const o = this._checkLayer(e);
                o && (o.minzoom === t1 && o.maxzoom === i || (null != t1 && (o.minzoom = t1), null != i && (o.maxzoom = i), this._updateLayer(o)));
            }
            getSlots() {
                return this._checkLoaded(), this._mergedSlots;
            }
            setSlot(e, t1) {
                this._checkLoaded();
                const i = this._checkLayer(e);
                i && i.slot !== t1 && (i.slot = t1, this._updateLayer(i));
            }
            setFilter(i, o, r = {}) {
                this._checkLoaded();
                const a = this._checkLayer(i);
                if (a && !t1(a.filter, o)) return null == o ? (a.filter = void 0, void this._updateLayer(a)) : void (this._validate(We, `layers.${a.id}.filter`, o, {
                    layerType: a.type
                }, r) || (a.filter = e.cT(o), this._updateLayer(a)));
            }
            getFilter(t1) {
                const i = this._checkLayer(t1);
                if (i) return e.cT(i.filter);
            }
            setLayoutProperty(i, o, r, a = {}) {
                this._checkLoaded();
                const n = this._checkLayer(i);
                if (n && !t1(n.getLayoutProperty(o), r)) {
                    if (null != r && (!a || !1 !== a.validate) && Ia(n, qe.call(Be, {
                        key: `layers.${i}.layout.${o}`,
                        layerType: n.type,
                        objectKey: o,
                        value: r,
                        styleSpec: e.L,
                        style: {
                            glyphs: !0,
                            sprite: !0
                        }
                    }))) return;
                    n.setLayoutProperty(o, r), n.isConfigDependent && this._configDependentLayers.add(n.fqid), this._updateLayer(n);
                }
            }
            getLayoutProperty(e, t1) {
                const i = this._checkLayer(e);
                if (i) return i.getLayoutProperty(t1);
            }
            setPaintProperty(i, o, r, a = {}) {
                this._checkLoaded();
                const n = this._checkLayer(i);
                if (!n) return;
                if (t1(n.getPaintProperty(o), r)) return;
                if (null != r && (!a || !1 !== a.validate) && Ia(n, Ze.call(Be, {
                    key: `layers.${i}.paint.${o}`,
                    layerType: n.type,
                    objectKey: o,
                    value: r,
                    styleSpec: e.L
                }))) return;
                const s = n.setPaintProperty(o, r);
                n.isConfigDependent && this._configDependentLayers.add(n.fqid), s && this._updateLayer(n), this._changes.updatePaintProperties(n);
            }
            getPaintProperty(e, t1) {
                const i = this._checkLayer(e);
                if (i) return i.getPaintProperty(t1);
            }
            setFeatureState(t1, i) {
                this._checkLoaded();
                const o = t1.source, r = t1.sourceLayer, a = this._checkSource(o);
                if (!a) return;
                const n = a.type;
                if ("geojson" === n && r) return void this.fire(new e.d(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
                if ("vector" === n && !r) return void this.fire(new e.d(new Error("The sourceLayer parameter must be provided for vector source types.")));
                void 0 === t1.id && this.fire(new e.d(new Error("The feature id parameter must be provided.")));
                const s = this.getOwnSourceCaches(o);
                for (const e of s)e.setFeatureState(r, t1.id, i);
            }
            removeFeatureState(t1, i) {
                this._checkLoaded();
                const o = t1.source, r = this._checkSource(o);
                if (!r) return;
                const a = r.type, n = "vector" === a ? t1.sourceLayer : void 0;
                if ("vector" === a && !n) return void this.fire(new e.d(new Error("The sourceLayer parameter must be provided for vector source types.")));
                if (i && "string" != typeof t1.id && "number" != typeof t1.id) return void this.fire(new e.d(new Error("A feature id is required to remove its specific state property.")));
                const s = this.getOwnSourceCaches(o);
                for (const e of s)e.removeFeatureState(n, t1.id, i);
            }
            getFeatureState(t1) {
                this._checkLoaded();
                const i = t1.source, o = t1.sourceLayer, r = this._checkSource(i);
                if (r) {
                    if ("vector" !== r.type || o) return void 0 === t1.id && this.fire(new e.d(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(i)[0].getFeatureState(o, t1.id);
                    this.fire(new e.d(new Error("The sourceLayer parameter must be provided for vector source types.")));
                }
            }
            setTransition(t1) {
                return this.stylesheet.transition = e.W({}, this.stylesheet.transition, t1), this.transition = this.stylesheet.transition, this;
            }
            getTransition() {
                return e.W({}, this.stylesheet.transition);
            }
            serialize() {
                this._checkLoaded();
                const t1 = this.getTerrain(), i = t1 && this.terrain && this.terrain.scope === this.scope ? t1 : this.stylesheet.terrain;
                return e.cZ({
                    version: this.stylesheet.version,
                    name: this.stylesheet.name,
                    metadata: this.stylesheet.metadata,
                    fragment: this.stylesheet.fragment,
                    imports: this._serializeImports(),
                    schema: this.stylesheet.schema,
                    camera: this.stylesheet.camera,
                    light: this.stylesheet.light,
                    lights: this.stylesheet.lights,
                    terrain: i,
                    fog: this.stylesheet.fog,
                    center: this.stylesheet.center,
                    "color-theme": this.stylesheet["color-theme"],
                    zoom: this.stylesheet.zoom,
                    bearing: this.stylesheet.bearing,
                    pitch: this.stylesheet.pitch,
                    sprite: this.stylesheet.sprite,
                    glyphs: this.stylesheet.glyphs,
                    transition: this.stylesheet.transition,
                    projection: this.stylesheet.projection,
                    sources: this._serializeSources(),
                    layers: this._serializeLayers(this._order)
                }, (e)=>void 0 !== e);
            }
            _updateLayer(t1) {
                this._changes.updateLayer(t1);
                const i = this.getLayerSourceCache(t1), o = e.al(t1.source, t1.scope), r = this._changes.getUpdatedSourceCaches();
                t1.source && !r[o] && i && "raster" !== i.getSource().type && (this._changes.updateSourceCache(o, "reload"), i.pause()), t1.invalidateCompiledFilter();
            }
            _flattenAndSortRenderedFeatures(e) {
                const t1 = (e)=>"fill-extrusion" === this._mergedLayers[e].type || "model" === this._mergedLayers[e].type, i = this.order, o = {}, r = [];
                for(let a = i.length - 1; a >= 0; a--){
                    const n = i[a];
                    if (t1(n)) {
                        o[n] = a;
                        for (const t1 of e){
                            const e = t1[n];
                            if (e) for (const t1 of e)r.push(t1);
                        }
                    }
                }
                r.sort((e, t1)=>t1.intersectionZ - e.intersectionZ);
                const a = [];
                for(let n = i.length - 1; n >= 0; n--){
                    const s = i[n];
                    if (t1(s)) for(let e = r.length - 1; e >= 0; e--){
                        const t1 = r[e].feature;
                        if (t1.layer && o[t1.layer.id] < n) break;
                        a.push(t1), r.pop();
                    }
                    else for (const t1 of e){
                        const e = t1[s];
                        if (e) for (const t1 of e)a.push(t1.feature);
                    }
                }
                return a;
            }
            queryRenderedFeatures(t1, i, o) {
                i && i.filter && this._validate(We, "queryRenderedFeatures.filter", i.filter, null, i), i.scope = this.scope, i.availableImages = this._availableImages, i.serializedLayers = this._serializedLayers;
                const r = {};
                if (i && i.layers) {
                    if (!Array.isArray(i.layers)) return this.fire(new e.d(new Error("parameters.layers must be an Array."))), [];
                    for (const t1 of i.layers){
                        const i = this._mergedLayers[t1];
                        if (!i) return this.fire(new e.d(new Error(`The layer '${t1}' does not exist in the map's style and cannot be queried for features.`))), [];
                        r[i.source] = !0;
                    }
                }
                const a = [], n = i.serializedLayers || {}, s = i && i.layers ? i.layers.some((e)=>{
                    const t1 = this.getLayer(e);
                    return t1 && t1.is3D();
                }) : this.has3DLayers(), l = Rr.createFromScreenPoints(t1, o);
                for(const e in this._mergedSourceCaches){
                    const t1 = this._mergedSourceCaches[e].getSource();
                    if (!t1 || t1.scope !== i.scope) continue;
                    const c = this._mergedSourceCaches[e].getSource().id;
                    i.layers && !r[c] || a.push(Fr(this._mergedSourceCaches[e], this._mergedLayers, n, l, i, o, s, !!this.map._showQueryGeometry));
                }
                return this.placement && a.push(function(e, t1, i, o, r, a, n) {
                    const s = {}, l = a.queryRenderedSymbols(o), c = [];
                    for (const e of Object.keys(l).map(Number))c.push(n[e]);
                    c.sort(kr);
                    for (const i of c){
                        const o = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], t1, i.bucketIndex, i.sourceLayerIndex, r.filter, r.layers, r.availableImages, e);
                        for(const e in o){
                            const t1 = s[e] = s[e] || [], r = o[e];
                            r.sort((e, t1)=>{
                                const o = i.featureSortOrder;
                                if (o) {
                                    const i = o.indexOf(e.featureIndex);
                                    return o.indexOf(t1.featureIndex) - i;
                                }
                                return t1.featureIndex - e.featureIndex;
                            });
                            for (const e of r)t1.push(e);
                        }
                    }
                    for(const t1 in s)s[t1].forEach((o)=>{
                        const r = o.feature, a = i(e[t1]);
                        if (!a) return;
                        const n = a.getFeatureState(r.layer["source-layer"], r.id);
                        r.source = r.layer.source, r.layer["source-layer"] && (r.sourceLayer = r.layer["source-layer"]), r.state = n;
                    });
                    return s;
                }(this._mergedLayers, n, this.getLayerSourceCache.bind(this), l.screenGeometry, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(a);
            }
            querySourceFeatures(e, t1) {
                t1 && t1.filter && this._validate(We, "querySourceFeatures.filter", t1.filter, null, t1);
                const i = this.getOwnSourceCaches(e);
                let o = [];
                for (const e of i)o = o.concat(Br(e, t1));
                return o;
            }
            addSourceType(e, t1, i) {
                return Da.getSourceType(e) ? i(new Error(`A source type called "${e}" already exists.`)) : (Da.setSourceType(e, t1), t1.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
                    name: e,
                    url: t1.workerSourceURL
                }, i) : i(null, null));
            }
            getFlatLight() {
                return this.light.getLight();
            }
            setFlatLight(e, i, o = {}) {
                this._checkLoaded();
                const r = this.light.getLight();
                let a = !1;
                for(const i in e)if (!t1(e[i], r[i])) {
                    a = !0;
                    break;
                }
                if (!a) return;
                const n = this._getTransitionParameters();
                this.light.setLight(e, i, o), this.light.updateTransitions(n);
            }
            getTerrain() {
                return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
            }
            setTerrainForDraping() {
                this.setTerrain({
                    source: "",
                    exaggeration: 0
                }, 0);
            }
            checkCanvasFingerprintNoise() {
                void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = e.e.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && e.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."));
            }
            setTerrain(i, o = 1) {
                if (this._checkLoaded(), !i) return this.terrainSetForDrapingOnly() && 0 !== o || delete this.terrain, null === i ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
                this.checkCanvasFingerprintNoise();
                let r = i;
                const a = null == i.source;
                if (1 === o) {
                    if (this.disableElevatedTerrain) return;
                    if ("object" == typeof r.source) {
                        const t1 = "terrain-dem-src";
                        this.addSource(t1, r.source), r = e.cT(r), r = e.W(r, {
                            source: t1
                        });
                    }
                    const t1 = e.W({}, r), i = {};
                    if (this.terrain && a) {
                        t1.source = this.terrain.get().source;
                        const e = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
                        e && (i.style = e.serialize());
                    }
                    if (this._validate(Ge, "terrain", t1, i)) return;
                }
                if (!this.terrain || this.terrain.scope !== this.scope && !a || this.terrain && o !== this.terrain.drapeRenderMode) {
                    if (!r) return;
                    this._createTerrain(r, o), this.fire(new e.f("data", {
                        dataType: "style"
                    }));
                } else {
                    const o = this.terrain, a = o.get();
                    for (const t1 of Object.keys(e.L.terrain))!r.hasOwnProperty(t1) && e.L.terrain[t1].default && (r[t1] = e.L.terrain[t1].default);
                    for(const r in i)if (!t1(i[r], a[r])) {
                        o.set(i, this.options), this.stylesheet.terrain = i;
                        const t1 = this._getTransitionParameters({
                            duration: 0
                        });
                        o.updateTransitions(t1), this.fire(new e.f("data", {
                            dataType: "style"
                        }));
                        break;
                    }
                }
                this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = !0;
            }
            _createFog(e) {
                const t1 = this.fog = new lt(e, this.map.transform, this.scope, this.options);
                this.stylesheet.fog = t1.get();
                const i = this._getTransitionParameters({
                    duration: 0
                });
                t1.updateTransitions(i);
            }
            _updateMarkersOpacity() {
                0 !== this.map._markers.length && this.map._requestDomTask(()=>{
                    for (const e of this.map._markers)e._evaluateOpacity();
                });
            }
            getFog() {
                return this.fog ? this.fog.get() : null;
            }
            setFog(e) {
                if (this._checkLoaded(), !e) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
                if (this.fog) {
                    const i = this.fog;
                    if (!t1(i.get(), e)) {
                        i.set(e, this.options), this.stylesheet.fog = i.get();
                        const t1 = this._getTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(t1);
                    }
                } else this._createFog(e);
                this._markersNeedUpdate = !0;
            }
            setColorTheme(t1) {
                this._checkLoaded();
                const i = ()=>{
                    for(const e in this._layers)this._layers[e].lut = this._styleColorTheme.lut;
                    for(const e in this._sourceCaches)this._sourceCaches[e].clearTiles();
                };
                if (this._styleColorTheme.colorTheme = t1, !t1) return this._styleColorTheme.lut = null, void i();
                const o = this._evaluateColorThemeData(t1);
                this._loadColorTheme(o).then(()=>{
                    this.fire(new e.f("colorthemeset")), i();
                }).catch((t1)=>{
                    e.w(`Couldn't set color theme: ${t1}`);
                });
            }
            _getTransitionParameters(t1) {
                return {
                    now: e.e.now(),
                    transition: e.W(this.transition, t1)
                };
            }
            updateDrapeFirstLayers() {
                if (!this.terrain) return;
                const e = [], t1 = [];
                for(const i in this._mergedLayers)this.isLayerDraped(this._mergedLayers[i]) ? e.push(i) : t1.push(i);
                this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e), this._drapedFirstOrder.push(...t1);
            }
            _createTerrain(e, t1) {
                const i = this.terrain = new Je(e, t1, this.scope, this.options);
                1 === t1 && (this.stylesheet.terrain = e), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
                const o = this._getTransitionParameters({
                    duration: 0
                });
                i.updateTransitions(o);
            }
            _force3DLayerUpdate() {
                for(const e in this._layers){
                    const t1 = this._layers[e];
                    "fill-extrusion" === t1.type && this._updateLayer(t1);
                }
            }
            _forceSymbolLayerUpdate() {
                for(const e in this._layers){
                    const t1 = this._layers[e];
                    "symbol" === t1.type && this._updateLayer(t1);
                }
            }
            _validate(t1, i, o, r, a = {}) {
                if (a && !1 === a.validate) return !1;
                const n = e.W({}, this.serialize());
                return Ia(this, t1.call(Be, e.W({
                    key: i,
                    style: n,
                    value: o,
                    styleSpec: e.L
                }, r)));
            }
            _remove() {
                this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.c_.off("pluginStateChange", this._rtlTextPluginCallback);
                for(const e in this._mergedLayers)this._mergedLayers[e].setEventedParent(null);
                for(const e in this._mergedSourceCaches)this._mergedSourceCaches[e].clearTiles(), this._mergedSourceCaches[e].setEventedParent(null);
                this.setEventedParent(null), delete this.fog, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.dispatcher.remove());
            }
            clearSource(e) {
                const t1 = this.getSourceCaches(e);
                for (const e of t1)e.clearTiles();
            }
            clearSources() {
                for(const e in this._mergedSourceCaches)this._mergedSourceCaches[e].clearTiles();
            }
            reloadSource(e) {
                const t1 = this.getSourceCaches(e);
                for (const e of t1)e.resume(), e.reload();
            }
            reloadSources() {
                for (const e of this.getSources())e.reload && e.reload();
            }
            updateSources(e) {
                let t1;
                this.directionalLight && (t1 = bi(this.directionalLight));
                for(const i in this._mergedSourceCaches)this._mergedSourceCaches[i].update(e, void 0, void 0, t1);
            }
            _generateCollisionBoxes() {
                for(const e in this._sourceCaches){
                    const t1 = this._sourceCaches[e];
                    t1.resume(), t1.reload();
                }
            }
            _updatePlacement(t1, i, o, r, a, n, s = !1) {
                let l = !1, c = !1;
                const h = {}, _ = {};
                for (const t1 of this._mergedOrder){
                    const o = this._mergedLayers[t1];
                    if ("symbol" !== o.type) continue;
                    const r = e.al(o.source, o.scope);
                    let a = h[r];
                    if (!a) {
                        const e = this.getLayerSourceCache(o);
                        if (!e) continue;
                        const t1 = e.getRenderableIds(!0).map((t1)=>e.getTileByID(t1));
                        _[r] = t1.slice(), a = h[r] = t1.sort((e, t1)=>t1.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t1.tileID) ? -1 : 1));
                    }
                    const n = this.crossTileSymbolIndex.addLayer(o, a, i.center.lng, i.projection);
                    l = l || n;
                }
                if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), s = s || this._layerOrderChanged || 0 === r, this._layerOrderChanged && this.fire(new e.f("neworder")), (s || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.e.now(), i.zoom)) && (this.pauseablePlacement = new ya(i, this._mergedOrder, s, o, r, a, this.placement, this.fog && i.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, h, _), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.e.now()), c = !0), l && this.pauseablePlacement.placement.setStale()), c || l) {
                    this._buildingIndex.onNewFrame(i.zoom);
                    for(let t1 = 0; t1 < this._mergedOrder.length; t1++){
                        const i = this._mergedLayers[this._mergedOrder[t1]];
                        if ("symbol" !== i.type) continue;
                        const o = this.isLayerClipped(i) && this._clipLayerIndices.some((e)=>t1 < e);
                        this.placement.updateLayerOpacities(i, h[e.al(i.source, i.scope)], t1, o ? n : null);
                    }
                }
                let u = !1;
                for (const i of this._mergedOrder){
                    const o = this._mergedLayers[i];
                    if ("symbol" !== o.type) continue;
                    const r = h[e.al(o.source, o.scope)];
                    for (const e of r){
                        const i = e.getBucket(o);
                        i && e.latestFeatureIndex && o.fqid === i.layerIds[0] && (u = i.updateOcclusionOpacities(t1.context, t1.symbolParams, t1._dt) || u);
                    }
                }
                return {
                    needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.e.now()) || u,
                    occlusionQueryBasedOpacityChanged: u
                };
            }
            _releaseSymbolFadeTiles() {
                for(const e in this._sourceCaches)this._sourceCaches[e].releaseSymbolFadeTiles();
            }
            addImport(t1, i) {
                this._checkLoaded();
                const o = this.stylesheet.imports = this.stylesheet.imports || [];
                if (-1 !== o.findIndex(({ id: e })=>e === t1.id)) return void this.fire(new e.d(new Error(`Import with id '${t1.id}' already exists in the map's style.`)));
                if (!i) return o.push(t1), this._loadImports([
                    t1
                ], !0);
                const r = o.findIndex(({ id: e })=>e === i);
                return -1 === r && this.fire(new e.d(new Error(`Import with id "${i}" does not exist on this map.`))), this.stylesheet.imports = o.slice(0, r).concat(t1).concat(o.slice(r)), this._loadImports([
                    t1
                ], !0, i);
            }
            updateImport(e, i) {
                this._checkLoaded();
                const o = this.stylesheet.imports || [], r = this.getImportIndex(e);
                return -1 === r ? this : "string" == typeof i ? (this.setImportUrl(e, i), this) : (i.url && i.url !== o[r].url && this.setImportUrl(e, i.url), t1(i.config, o[r].config) || this.setImportConfig(e, i.config), t1(i.data, o[r].data) || this.setImportData(e, i.data), this);
            }
            moveImport(e, t1) {
                this._checkLoaded();
                let i = this.stylesheet.imports || [];
                const o = this.getImportIndex(e);
                if (-1 === o) return this;
                const r = this.getImportIndex(t1);
                if (-1 === r) return this;
                const a = i[o], n = this.fragments[o];
                return i = i.filter(({ id: t1 })=>t1 !== e), this.fragments = this.fragments.filter(({ id: t1 })=>t1 !== e), this.stylesheet.imports = i.slice(0, r).concat(a).concat(i.slice(r)), this.fragments = this.fragments.slice(0, r).concat(n).concat(this.fragments.slice(r)), this.mergeLayers(), this;
            }
            setImportUrl(e, t1) {
                this._checkLoaded();
                const i = this.stylesheet.imports || [], o = this.getImportIndex(e);
                if (-1 === o) return this;
                i[o].url = t1;
                const r = this.fragments[o];
                return r.style = this._createFragmentStyle(i[o]), r.style.on("style.import.load", ()=>this.mergeAll()), r.style.loadURL(t1), this;
            }
            setImportData(e, t1) {
                this._checkLoaded();
                const i = this.getImportIndex(e), o = this.stylesheet.imports || [];
                return -1 === i ? this : t1 ? (this.fragments[i].style.setState(t1), this._reloadImports(), this) : (delete o[i].data, this.setImportUrl(e, o[i].url));
            }
            setImportConfig(e, t1) {
                this._checkLoaded();
                const i = this.getImportIndex(e), o = this.stylesheet.imports || [];
                if (-1 === i) return this;
                t1 ? o[i].config = t1 : delete o[i].config;
                const r = this.fragments[i], a = r.style.stylesheet && r.style.stylesheet.schema;
                return r.config = t1, r.style.updateConfig(t1, a), this.updateConfigDependencies(), this;
            }
            removeImport(e) {
                this._checkLoaded();
                const t1 = this.stylesheet.imports || [], i = this.getImportIndex(e);
                -1 !== i && (t1.splice(i, 1), this.fragments[i].style._remove(), this.fragments.splice(i, 1), this._reloadImports());
            }
            getImportIndex(t1) {
                const i = (this.stylesheet.imports || []).findIndex((e)=>e.id === t1);
                return -1 === i && this.fire(new e.d(new Error(`Import '${t1}' does not exist in the map's style and cannot be updated.`))), i;
            }
            getLayer(e) {
                return this._mergedLayers[e];
            }
            getSources() {
                const e = [];
                for(const t1 in this._mergedOtherSourceCaches){
                    const i = this._mergedOtherSourceCaches[t1];
                    i && e.push(i.getSource());
                }
                return e;
            }
            getSource(e, t1) {
                const i = this.getSourceCache(e, t1);
                return i && i.getSource();
            }
            getLayerSource(e) {
                const t1 = this.getLayerSourceCache(e);
                return t1 && t1.getSource();
            }
            getSourceCache(t1, i) {
                const o = e.al(t1, i);
                return this._mergedOtherSourceCaches[o];
            }
            getLayerSourceCache(t1) {
                const i = e.al(t1.source, t1.scope);
                return "symbol" === t1.type ? this._mergedSymbolSourceCaches[i] : this._mergedOtherSourceCaches[i];
            }
            getSourceCaches(e) {
                if (null == e) return Object.values(this._mergedSourceCaches);
                const t1 = [];
                return this._mergedOtherSourceCaches[e] && t1.push(this._mergedOtherSourceCaches[e]), this._mergedSymbolSourceCaches[e] && t1.push(this._mergedSymbolSourceCaches[e]), t1;
            }
            updateSourceCaches() {
                const e = this._changes.getUpdatedSourceCaches();
                for(const t1 in e){
                    const i = e[t1];
                    "reload" === i ? this.reloadSource(t1) : "clear" === i && this.clearSource(t1);
                }
            }
            updateLayers(e) {
                const t1 = this._changes.getUpdatedPaintProperties();
                for (const i of t1){
                    const t1 = this.getLayer(i);
                    t1 && t1.updateTransitions(e);
                }
            }
            getImages(e, t1, i) {
                this.imageManager.getImages(t1.icons, t1.scope, i), this._updateTilesForChangedImages();
                const o = (e)=>{
                    e && e.setDependencies(t1.tileID.key, t1.type, t1.icons);
                };
                o(this._otherSourceCaches[t1.source]), o(this._symbolSourceCaches[t1.source]);
            }
            getGlyphs(e, t1, i) {
                this.glyphManager.getGlyphs(t1.stacks, t1.scope, i);
            }
            getResource(t1, i, o) {
                return e.c$(i, o);
            }
            getOwnSourceCache(e) {
                return this._otherSourceCaches[e];
            }
            getOwnLayerSourceCache(e) {
                return "symbol" === e.type ? this._symbolSourceCaches[e.source] : this._otherSourceCaches[e.source];
            }
            getOwnSourceCaches(e) {
                const t1 = [];
                return this._otherSourceCaches[e] && t1.push(this._otherSourceCaches[e]), this._symbolSourceCaches[e] && t1.push(this._symbolSourceCaches[e]), t1;
            }
            _isSourceCacheLoaded(t1) {
                const i = this.getOwnSourceCaches(t1);
                return 0 === i.length ? (this.fire(new e.d(new Error(`There is no source with ID '${t1}'`))), !1) : i.every((e)=>e.loaded());
            }
            has3DLayers() {
                return this._has3DLayers;
            }
            hasSymbolLayers() {
                return this._hasSymbolLayers;
            }
            hasCircleLayers() {
                return this._hasCircleLayers;
            }
            isLayerClipped(t1, i) {
                if (0 === this._clipLayerIndices.length && "fill-extrusion" !== t1.type) return !1;
                const o = "fill-extrusion" === t1.type && "building" === t1.sourceLayer;
                let r = 0;
                if (t1.is3D()) {
                    if (o || i && "batched-model" === i.type) return !0;
                    "model" === t1.type && (r = e.cu.Model);
                } else "symbol" === t1.type && (r = e.cu.Symbol);
                for (const t1 of this._clipLayerIndices){
                    const i = this._mergedLayers[this._mergedOrder[t1]];
                    if (!i) continue;
                    const o = [];
                    for (const t1 of i.layout.get("clip-layer-types"))o.push("model" === t1 ? e.cu.Model : "symbol" === t1 ? e.cu.Symbol : e.cu.FillExtrusion);
                    for (const e of o)if (r & e) return !0;
                }
                return !1;
            }
            _clearWorkerCaches() {
                this.dispatcher.broadcast("clearCaches");
            }
            destroy() {
                this._clearWorkerCaches(), this.fragments.forEach((e)=>{
                    e.style._remove();
                }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
            }
        }
        function Ma(e, t1) {
            let i = !1, o = null;
            const r = ()=>{
                o = null, i && (e(), o = setTimeout(r, t1), i = !1);
            };
            return ()=>(i = !0, o || r(), o);
        }
        Da.getSourceType = function(e) {
            return Di[e];
        }, Da.setSourceType = function(e, t1) {
            Di[e] = t1;
        }, Da.registerForPluginStateChange = e.cL;
        class za {
            constructor(t1){
                this._hashName = t1 && encodeURIComponent(t1), e.bp([
                    "_getCurrentHash",
                    "_onHashChange",
                    "_updateHash"
                ], this), this._updateHash = Ma(this._updateHashUnthrottled.bind(this), 300);
            }
            addTo(e) {
                return this._map = e, window.addEventListener("hashchange", this._onHashChange, !1), e.on("moveend", this._updateHash), this;
            }
            remove() {
                return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
            }
            getHashString() {
                const e = this._map;
                if (!e) return "";
                const t1 = Oa(e);
                if (this._hashName) {
                    const e = this._hashName;
                    let i = !1;
                    const o = location.hash.slice(1).split("&").map((o)=>{
                        const r = o.split("=")[0];
                        return r === e ? (i = !0, `${r}=${t1}`) : o;
                    }).filter((e)=>e);
                    return i || o.push(`${e}=${t1}`), `#${o.join("&")}`;
                }
                return `#${t1}`;
            }
            _getCurrentHash() {
                const e = location.hash.replace("#", "");
                if (this._hashName) {
                    let t1;
                    return e.split("&").map((e)=>e.split("=")).forEach((e)=>{
                        e[0] === this._hashName && (t1 = e);
                    }), (t1 && t1[1] || "").split("/");
                }
                return e.split("/");
            }
            _onHashChange() {
                const e = this._map;
                if (!e) return !1;
                const t1 = this._getCurrentHash();
                if (t1.length >= 3 && !t1.some((e)=>isNaN(e))) {
                    const i = e.dragRotate.isEnabled() && e.touchZoomRotate.isEnabled() ? +(t1[3] || 0) : e.getBearing();
                    return e.jumpTo({
                        center: [
                            +t1[2],
                            +t1[1]
                        ],
                        zoom: +t1[0],
                        bearing: i,
                        pitch: +(t1[4] || 0)
                    }), !0;
                }
                return !1;
            }
            _updateHashUnthrottled() {
                history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
            }
        }
        function Oa(e, t1) {
            const i = e.getCenter(), o = Math.round(100 * e.getZoom()) / 100, r = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), a = Math.pow(10, r), n = Math.round(i.lng * a) / a, s = Math.round(i.lat * a) / a, l = e.getBearing(), c = e.getPitch();
            let h = t1 ? `/${n}/${s}/${o}` : `${o}/${s}/${n}`;
            return (l || c) && (h += "/" + Math.round(10 * l) / 10), c && (h += `/${Math.round(c)}`), h;
        }
        const Fa = {
            linearity: .3,
            easing: e.d0(0, 0, .3, 1)
        }, Ba = e.W({
            deceleration: 2500,
            maxSpeed: 1400
        }, Fa), ka = e.W({
            deceleration: 20,
            maxSpeed: 1400
        }, Fa), Na = e.W({
            deceleration: 1e3,
            maxSpeed: 360
        }, Fa), Ua = e.W({
            deceleration: 1e3,
            maxSpeed: 90
        }, Fa);
        class Ga {
            constructor(e){
                this._map = e, this.clear();
            }
            clear() {
                this._inertiaBuffer = [];
            }
            record(t1) {
                this._drainInertiaBuffer(), this._inertiaBuffer.push({
                    time: e.e.now(),
                    settings: t1
                });
            }
            _drainInertiaBuffer() {
                const t1 = this._inertiaBuffer, i = e.e.now();
                for(; t1.length > 0 && i - t1[0].time > 160;)t1.shift();
            }
            _onMoveEnd(t1) {
                if (this._map._prefersReducedMotion()) return;
                if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
                const i = {
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    pan: new e.P(0, 0),
                    pinchAround: void 0,
                    around: void 0
                };
                for (const { settings: e } of this._inertiaBuffer)i.zoom += e.zoomDelta || 0, i.bearing += e.bearingDelta || 0, i.pitch += e.pitchDelta || 0, e.panDelta && i.pan._add(e.panDelta), e.around && (i.around = e.around), e.pinchAround && (i.pinchAround = e.pinchAround);
                const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r = {};
                if (i.pan.mag()) {
                    const a = Va(i.pan.mag(), o, e.W({}, Ba, t1 || {}));
                    r.offset = i.pan.mult(a.amount / i.pan.mag()), r.center = this._map.transform.center, ja(r, a);
                }
                if (i.zoom) {
                    const e = Va(i.zoom, o, ka);
                    r.zoom = this._map.transform.zoom + e.amount, ja(r, e);
                }
                if (i.bearing) {
                    const t1 = Va(i.bearing, o, Na);
                    r.bearing = this._map.transform.bearing + e.at(t1.amount, -179, 179), ja(r, t1);
                }
                if (i.pitch) {
                    const e = Va(i.pitch, o, Ua);
                    r.pitch = this._map.transform.pitch + e.amount, ja(r, e);
                }
                if (r.zoom || r.bearing) {
                    const e = void 0 === i.pinchAround ? i.around : i.pinchAround;
                    r.around = e ? this._map.unproject(e) : this._map.getCenter();
                }
                return this.clear(), r.noMoveStart = !0, r;
            }
        }
        function ja(e, t1) {
            (!e.duration || e.duration < t1.duration) && (e.duration = t1.duration, e.easing = t1.easing);
        }
        function Va(t1, i, o) {
            const { maxSpeed: r, linearity: a, deceleration: n } = o, s = e.at(t1 * a / (i / 1e3), -r, r), l = Math.abs(s) / (n * a);
            return {
                easing: o.easing,
                duration: 1e3 * l,
                amount: s * (l / 2)
            };
        }
        class Wa extends e.f {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(t1, i, o, r = {}){
                const a = p(i.getCanvasContainer(), o), n = i.unproject(a);
                super(t1, e.W({
                    point: a,
                    lngLat: n,
                    originalEvent: o
                }, r)), this._defaultPrevented = !1, this.target = i;
            }
        }
        class Za extends e.f {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(t1, i, o){
                const r = "touchend" === t1 ? o.changedTouches : o.touches, a = f(i.getCanvasContainer(), r), n = a.map((e)=>i.unproject(e)), s = a.reduce((e, t1, i, o)=>e.add(t1.div(o.length)), new e.P(0, 0));
                super(t1, {
                    points: a,
                    point: s,
                    lngLats: n,
                    lngLat: i.unproject(s),
                    originalEvent: o
                }), this._defaultPrevented = !1;
            }
        }
        class qa extends e.f {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(e, t1){
                super("wheel", {
                    originalEvent: t1
                }), this._defaultPrevented = !1;
            }
        }
        class Ha {
            constructor(e, t1){
                this._map = e, this._clickTolerance = t1.clickTolerance;
            }
            reset() {
                this._mousedownPos = void 0;
            }
            wheel(e) {
                return this._firePreventable(new qa(this._map, e));
            }
            mousedown(e, t1) {
                return this._mousedownPos = t1, this._firePreventable(new Wa(e.type, this._map, e));
            }
            mouseup(e) {
                this._map.fire(new Wa(e.type, this._map, e));
            }
            preclick(t1) {
                const i = e.W({}, t1);
                i.type = "preclick", this._map.fire(new Wa(i.type, this._map, i));
            }
            click(e, t1) {
                this._mousedownPos && this._mousedownPos.dist(t1) >= this._clickTolerance || (this.preclick(e), this._map.fire(new Wa(e.type, this._map, e)));
            }
            dblclick(e) {
                return this._firePreventable(new Wa(e.type, this._map, e));
            }
            mouseover(e) {
                this._map.fire(new Wa(e.type, this._map, e));
            }
            mouseout(e) {
                this._map.fire(new Wa(e.type, this._map, e));
            }
            touchstart(e) {
                return this._firePreventable(new Za(e.type, this._map, e));
            }
            touchmove(e) {
                this._map.fire(new Za(e.type, this._map, e));
            }
            touchend(e) {
                this._map.fire(new Za(e.type, this._map, e));
            }
            touchcancel(e) {
                this._map.fire(new Za(e.type, this._map, e));
            }
            _firePreventable(e) {
                if (this._map.fire(e), e.defaultPrevented) return {};
            }
            isEnabled() {
                return !0;
            }
            isActive() {
                return !1;
            }
            enable() {}
            disable() {}
        }
        class $a {
            constructor(e){
                this._map = e;
            }
            reset() {
                this._delayContextMenu = !1, this._contextMenuEvent = void 0;
            }
            mousemove(e) {
                this._map.fire(new Wa(e.type, this._map, e));
            }
            mousedown() {
                this._delayContextMenu = !0;
            }
            mouseup() {
                this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Wa("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(e) {
                this._delayContextMenu ? this._contextMenuEvent = e : this._map.fire(new Wa(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
            }
            isEnabled() {
                return !0;
            }
            isActive() {
                return !1;
            }
            enable() {}
            disable() {}
        }
        class Xa {
            constructor(e, t1){
                this._map = e, this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t1.clickTolerance || 1;
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return !!this._active;
            }
            enable() {
                this.isEnabled() || (this._enabled = !0);
            }
            disable() {
                this.isEnabled() && (this._enabled = !1);
            }
            mousedown(e, t1) {
                this.isEnabled() && e.shiftKey && 0 === e.button && (h(), this._startPos = this._lastPos = t1, this._active = !0);
            }
            mousemoveWindow(e, t1) {
                if (!this._active) return;
                const i = t1, o = this._startPos, r = this._lastPos;
                if (!o || !r || r.equals(i) || !this._box && i.dist(o) < this._clickTolerance) return;
                this._lastPos = i, this._box || (this._box = a("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e));
                const n = Math.min(o.x, i.x), s = Math.max(o.x, i.x), l = Math.min(o.y, i.y), c = Math.max(o.y, i.y);
                this._map._requestDomTask(()=>{
                    this._box && (this._box.style.transform = `translate(${n}px,${l}px)`, this._box.style.width = s - n + "px", this._box.style.height = c - l + "px");
                });
            }
            mouseupWindow(t1, i) {
                if (!this._active) return;
                const o = this._startPos, r = i;
                if (o && 0 === t1.button) {
                    if (this.reset(), d(), o.x !== r.x || o.y !== r.y) return this._map.fire(new e.f("boxzoomend", {
                        originalEvent: t1
                    })), {
                        cameraAnimation: (e)=>e.fitScreenCoordinates(o, r, this._map.getBearing(), {
                                linear: !1
                            })
                    };
                    this._fireEvent("boxzoomcancel", t1);
                }
            }
            keydown(e) {
                this._active && 27 === e.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e));
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), _(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(t1, i) {
                return this._map.fire(new e.f(t1, {
                    originalEvent: i
                }));
            }
        }
        function Ya(e, t1) {
            const i = {};
            for(let o = 0; o < e.length; o++)i[e[o].identifier] = t1[o];
            return i;
        }
        class Ka {
            constructor(e){
                this.reset(), this.numTouches = e.numTouches;
            }
            reset() {
                this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;
            }
            touchstart(t1, i, o) {
                (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t1.timeStamp), o.length === this.numTouches && (this.centroid = function(t1) {
                    const i = new e.P(0, 0);
                    for (const e of t1)i._add(e);
                    return i.div(t1.length);
                }(i), this.touches = Ya(o, i)));
            }
            touchmove(e, t1, i) {
                if (this.aborted || !this.centroid) return;
                const o = Ya(i, t1);
                for(const e in this.touches){
                    const t1 = o[e];
                    (!t1 || t1.dist(this.touches[e]) > 30) && (this.aborted = !0);
                }
            }
            touchend(e, t1, i) {
                if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {
                    const e = !this.aborted && this.centroid;
                    if (this.reset(), e) return e;
                }
            }
        }
        class Qa {
            constructor(e){
                this.singleTap = new Ka(e), this.numTaps = e.numTaps, this.reset();
            }
            reset() {
                this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
            }
            touchstart(e, t1, i) {
                this.singleTap.touchstart(e, t1, i);
            }
            touchmove(e, t1, i) {
                this.singleTap.touchmove(e, t1, i);
            }
            touchend(e, t1, i) {
                const o = this.singleTap.touchend(e, t1, i);
                if (o) {
                    const t1 = e.timeStamp - this.lastTime < 500, i = !this.lastTap || this.lastTap.dist(o) < 30;
                    if (t1 && i || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;
                }
            }
        }
        class Ja {
            constructor(){
                this._zoomIn = new Qa({
                    numTouches: 1,
                    numTaps: 2
                }), this._zoomOut = new Qa({
                    numTouches: 2,
                    numTaps: 1
                }), this.reset();
            }
            reset() {
                this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(e, t1, i) {
                this._zoomIn.touchstart(e, t1, i), this._zoomOut.touchstart(e, t1, i);
            }
            touchmove(e, t1, i) {
                this._zoomIn.touchmove(e, t1, i), this._zoomOut.touchmove(e, t1, i);
            }
            touchend(e, t1, i) {
                const o = this._zoomIn.touchend(e, t1, i), r = this._zoomOut.touchend(e, t1, i);
                return o ? (this._active = !0, e.preventDefault(), setTimeout(()=>this.reset(), 0), {
                    cameraAnimation: (t1)=>t1.easeTo({
                            duration: 300,
                            zoom: t1.getZoom() + 1,
                            around: t1.unproject(o)
                        }, {
                            originalEvent: e
                        })
                }) : r ? (this._active = !0, e.preventDefault(), setTimeout(()=>this.reset(), 0), {
                    cameraAnimation: (t1)=>t1.easeTo({
                            duration: 300,
                            zoom: t1.getZoom() - 1,
                            around: t1.unproject(r)
                        }, {
                            originalEvent: e
                        })
                }) : void 0;
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        const en = {
            0: 1,
            2: 2
        };
        class tn {
            constructor(e){
                this.reset(), this._clickTolerance = e.clickTolerance || 1;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;
            }
            _correctButton(e, t1) {
                return !1;
            }
            _move(e, t1) {
                return {};
            }
            mousedown(e, t1) {
                if (this._lastPoint) return;
                const i = m(e);
                this._correctButton(e, i) && (this._lastPoint = t1, this._eventButton = i);
            }
            mousemoveWindow(e, t1) {
                const i = this._lastPoint;
                if (i) {
                    if (e.preventDefault(), null != this._eventButton && function(e, t1) {
                        const i = en[t1];
                        return void 0 === e.buttons || (e.buttons & i) !== i;
                    }(e, this._eventButton)) this.reset();
                    else if (this._moved || !(t1.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t1, this._move(i, t1);
                }
            }
            mouseupWindow(e) {
                this._lastPoint && m(e) === this._eventButton && (this._moved && d(), this.reset());
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class on extends tn {
            mousedown(e, t1) {
                super.mousedown(e, t1), this._lastPoint && (this._active = !0);
            }
            _correctButton(e, t1) {
                return 0 === t1 && !e.ctrlKey;
            }
            _move(e, t1) {
                return {
                    around: t1,
                    panDelta: t1.sub(e)
                };
            }
        }
        class rn extends tn {
            _correctButton(e, t1) {
                return 0 === t1 && e.ctrlKey || 2 === t1;
            }
            _move(e, t1) {
                const i = .8 * (t1.x - e.x);
                if (i) return this._active = !0, {
                    bearingDelta: i
                };
            }
            contextmenu(e) {
                e.preventDefault();
            }
        }
        class an extends tn {
            _correctButton(e, t1) {
                return 0 === t1 && e.ctrlKey || 2 === t1;
            }
            _move(e, t1) {
                const i = -0.5 * (t1.y - e.y);
                if (i) return this._active = !0, {
                    pitchDelta: i
                };
            }
            contextmenu(e) {
                e.preventDefault();
            }
        }
        class nn {
            constructor(t1, i){
                this._map = t1, this._el = t1.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i.clickTolerance || 1, this.reset(), e.bp([
                    "_addTouchPanBlocker",
                    "_showTouchPanBlockerAlert"
                ], this);
            }
            reset() {
                this._active = !1, this._touches = {}, this._sum = new e.P(0, 0);
            }
            touchstart(e, t1, i) {
                return this._calculateTransform(e, t1, i);
            }
            touchmove(t1, i, o) {
                if (this._active && !(o.length < this._minTouches)) {
                    if (this._map._cooperativeGestures && !this._map.isMoving()) {
                        if (1 === o.length && !e.d1()) return void this._showTouchPanBlockerAlert();
                        "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                    }
                    return t1.cancelable && t1.preventDefault(), this._calculateTransform(t1, i, o);
                }
            }
            touchend(e, t1, i) {
                this._calculateTransform(e, t1, i), this._active && i.length < this._minTouches && this.reset();
            }
            touchcancel() {
                this.reset();
            }
            _calculateTransform(t1, i, o) {
                o.length > 0 && (this._active = !0);
                const r = Ya(o, i), a = new e.P(0, 0), n = new e.P(0, 0);
                let s = 0;
                for(const e in r){
                    const t1 = r[e], i = this._touches[e];
                    i && (a._add(t1), n._add(t1.sub(i)), s++, r[e] = t1);
                }
                if (this._touches = r, s < this._minTouches || !n.mag()) return;
                const l = n.div(s);
                return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {
                    around: a.div(s),
                    panDelta: l
                };
            }
            enable() {
                this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
            }
            disable() {
                this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return !!this._active;
            }
            _addTouchPanBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = a("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
            }
            _showTouchPanBlockerAlert() {
                this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(()=>{
                    this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
                }, 500);
            }
        }
        class sn {
            constructor(){
                this.reset();
            }
            reset() {
                this._active = !1, this._firstTwoTouches = void 0;
            }
            _start(e) {}
            _move(e, t1, i) {
                return {};
            }
            touchstart(e, t1, i) {
                this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [
                    i[0].identifier,
                    i[1].identifier
                ], this._start([
                    t1[0],
                    t1[1]
                ]));
            }
            touchmove(e, t1, i) {
                const o = this._firstTwoTouches;
                if (!o) return;
                e.preventDefault();
                const [r, a] = o, n = ln(i, t1, r), s = ln(i, t1, a);
                if (!n || !s) return;
                const l = this._aroundCenter ? null : n.add(s).div(2);
                return this._move([
                    n,
                    s
                ], l, e);
            }
            touchend(e, t1, i) {
                if (!this._firstTwoTouches) return;
                const [o, r] = this._firstTwoTouches, a = ln(i, t1, o), n = ln(i, t1, r);
                a && n || (this._active && d(), this.reset());
            }
            touchcancel() {
                this.reset();
            }
            enable(e) {
                this._enabled = !0, this._aroundCenter = !!e && "center" === e.around;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        function ln(e, t1, i) {
            for(let o = 0; o < e.length; o++)if (e[o].identifier === i) return t1[o];
        }
        function cn(e, t1) {
            return Math.log(e / t1) / Math.LN2;
        }
        class hn extends sn {
            reset() {
                super.reset(), this._distance = 0, this._startDistance = 0;
            }
            _start(e) {
                this._startDistance = this._distance = e[0].dist(e[1]);
            }
            _move(e, t1) {
                const i = this._distance;
                if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(cn(this._distance, this._startDistance)) < .1)) return this._active = !0, {
                    zoomDelta: cn(this._distance, i),
                    pinchAround: t1
                };
            }
        }
        function _n(e, t1) {
            return 180 * e.angleWith(t1) / Math.PI;
        }
        class un extends sn {
            reset() {
                super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
            }
            _start(e) {
                this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
            }
            _move(e, t1) {
                const i = this._vector;
                if (this._vector = e[0].sub(e[1]), i && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, {
                    bearingDelta: _n(this._vector, i),
                    pinchAround: t1
                };
            }
            _isBelowThreshold(e) {
                this._minDiameter = Math.min(this._minDiameter, e.mag());
                const t1 = 25 / (Math.PI * this._minDiameter) * 360, i = this._startVector;
                if (!i) return !1;
                const o = _n(e, i);
                return Math.abs(o) < t1;
            }
        }
        function dn(e) {
            return Math.abs(e.y) > Math.abs(e.x);
        }
        class pn extends sn {
            constructor(e){
                super(), this._map = e;
            }
            reset() {
                super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
            }
            _start(e) {
                this._lastPoints = e, dn(e[0].sub(e[1])) && (this._valid = !1);
            }
            _move(t1, i, o) {
                const r = this._lastPoints;
                if (!r) return;
                const a = t1[0].sub(r[0]), n = t1[1].sub(r[1]);
                return this._map._cooperativeGestures && !e.d1() && o.touches.length < 3 || (this._valid = this.gestureBeginsVertically(a, n, o.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t1, this._active = !0, {
                    pitchDelta: (a.y + n.y) / 2 * -0.5
                });
            }
            gestureBeginsVertically(e, t1, i) {
                if (void 0 !== this._valid) return this._valid;
                const o = e.mag() >= 2, r = t1.mag() >= 2;
                if (!o && !r) return;
                if (!o || !r) return null == this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;
                const a = e.y > 0 == t1.y > 0;
                return dn(e) && dn(t1) && a;
            }
        }
        const fn = {
            panStep: 100,
            bearingStep: 15,
            pitchStep: 10
        };
        class mn {
            constructor(){
                const e = fn;
                this._panStep = e.panStep, this._bearingStep = e.bearingStep, this._pitchStep = e.pitchStep, this._rotationDisabled = !1;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            keydown(e) {
                if (e.altKey || e.ctrlKey || e.metaKey) return;
                let t1 = 0, i = 0, o = 0, r = 0, a = 0;
                switch(e.keyCode){
                    case 61:
                    case 107:
                    case 171:
                    case 187:
                        t1 = 1;
                        break;
                    case 189:
                    case 109:
                    case 173:
                        t1 = -1;
                        break;
                    case 37:
                        e.shiftKey ? i = -1 : (e.preventDefault(), r = -1);
                        break;
                    case 39:
                        e.shiftKey ? i = 1 : (e.preventDefault(), r = 1);
                        break;
                    case 38:
                        e.shiftKey ? o = 1 : (e.preventDefault(), a = -1);
                        break;
                    case 40:
                        e.shiftKey ? o = -1 : (e.preventDefault(), a = 1);
                        break;
                    default:
                        return;
                }
                return this._rotationDisabled && (i = 0, o = 0), {
                    cameraAnimation: (n)=>{
                        const s = n.getZoom();
                        n.easeTo({
                            duration: 300,
                            easeId: "keyboardHandler",
                            easing: gn,
                            zoom: t1 ? Math.round(s) + t1 * (e.shiftKey ? 2 : 1) : s,
                            bearing: n.getBearing() + i * this._bearingStep,
                            pitch: n.getPitch() + o * this._pitchStep,
                            offset: [
                                -r * this._panStep,
                                -a * this._panStep
                            ],
                            center: n.getCenter()
                        }, {
                            originalEvent: e
                        });
                    }
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
            disableRotation() {
                this._rotationDisabled = !0;
            }
            enableRotation() {
                this._rotationDisabled = !1;
            }
        }
        function gn(e) {
            return e * (2 - e);
        }
        const vn = 4.000244140625, xn = 1 / 450;
        class yn {
            constructor(t1, i){
                this._map = t1, this._el = t1.getCanvasContainer(), this._handler = i, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = xn, e.bp([
                    "_onTimeout",
                    "_addScrollZoomBlocker",
                    "_showBlockerAlert"
                ], this);
            }
            setZoomRate(e) {
                this._defaultZoomRate = e;
            }
            setWheelZoomRate(e) {
                this._wheelZoomRate = e;
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return this._active || void 0 !== this._finishTimeout;
            }
            isZooming() {
                return !!this._zooming;
            }
            enable(e) {
                this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && "center" === e.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
            }
            disable() {
                this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
            }
            wheel(t1) {
                if (!this.isEnabled()) return;
                if (this._map._cooperativeGestures) {
                    if (!(t1.ctrlKey || t1.metaKey || this.isZooming() || e.d1())) return void this._showBlockerAlert();
                    "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                }
                let i = t1.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t1.deltaY : t1.deltaY;
                const o = e.e.now(), r = o - (this._lastWheelEventTime || 0);
                this._lastWheelEventTime = o, 0 !== i && i % vn == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : r > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, t1)) : this._type || (this._type = Math.abs(r * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), t1.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = t1, this._delta -= i, this._active || this._start(t1)), t1.preventDefault();
            }
            _onTimeout(e) {
                this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e);
            }
            _start(e) {
                if (!this._delta) return;
                this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
                const t1 = p(this._el, e);
                this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t1, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
            }
            renderFrame() {
                if (!this._frameId) return;
                if (this._frameId = null, !this.isActive()) return;
                const t1 = this._map.transform;
                "wheel" === this._type && t1.projection.wrap && (t1._center.lng >= 180 || t1._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
                const i = ()=>t1._terrainEnabled() && this._aroundCoord ? t1.computeZoomRelativeTo(this._aroundCoord) : t1.zoom;
                if (0 !== this._delta) {
                    const e = "wheel" === this._type && Math.abs(this._delta) > vn ? this._wheelZoomRate : this._defaultZoomRate;
                    let o = 2 / (1 + Math.exp(-Math.abs(this._delta * e)));
                    this._delta < 0 && 0 !== o && (o = 1 / o);
                    const r = i(), a = Math.pow(2, r), n = "number" == typeof this._targetZoom ? t1.zoomScale(this._targetZoom) : a;
                    this._targetZoom = Math.min(t1.maxZoom, Math.max(t1.minZoom, t1.scaleZoom(n * o))), "wheel" === this._type && (this._startZoom = r, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
                }
                const o = "number" == typeof this._targetZoom ? this._targetZoom : i(), r = this._startZoom, a = this._easing;
                let n, s = !1;
                if ("wheel" === this._type && r && a) {
                    const t1 = Math.min((e.e.now() - this._lastWheelEventTime) / 200, 1), i = a(t1);
                    n = e.a2(r, o, i), t1 < 1 ? this._frameId || (this._frameId = !0) : s = !0;
                } else n = o, s = !0;
                this._active = !0, s && (this._active = !1, this._finishTimeout = setTimeout(()=>{
                    this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
                }, 200));
                let l = n - i();
                return l * this._lastDelta < 0 && (l = 0), {
                    noInertia: !0,
                    needsRenderFrame: !s,
                    zoomDelta: l,
                    around: this._aroundPoint,
                    aroundCoord: this._aroundCoord,
                    originalEvent: this._lastWheelEvent
                };
            }
            _smoothOutEasing(t1) {
                let i = e.d2;
                if (this._prevEase) {
                    const t1 = this._prevEase, o = (e.e.now() - t1.start) / t1.duration, r = t1.easing(o + .01) - t1.easing(o), a = .27 / Math.sqrt(r * r + 1e-4) * .01, n = Math.sqrt(.0729 - a * a);
                    i = e.d0(a, n, .25, 1);
                }
                return this._prevEase = {
                    start: e.e.now(),
                    duration: t1,
                    easing: i
                }, i;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            _addScrollZoomBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = a("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
            }
            _showBlockerAlert() {
                this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(()=>{
                    this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
                }, 200);
            }
        }
        class bn {
            constructor(e, t1){
                this._clickZoom = e, this._tapZoom = t1;
            }
            enable() {
                this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
                this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
                return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
                return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
        }
        class wn {
            constructor(){
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            blur() {
                this.reset();
            }
            dblclick(e, t1) {
                return e.preventDefault(), {
                    cameraAnimation: (i)=>{
                        i.easeTo({
                            duration: 300,
                            zoom: i.getZoom() + (e.shiftKey ? -1 : 1),
                            around: i.unproject(t1)
                        }, {
                            originalEvent: e
                        });
                    }
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class Tn {
            constructor(){
                this._tap = new Qa({
                    numTouches: 1,
                    numTaps: 1
                }), this.reset();
            }
            reset() {
                this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
            }
            touchstart(e, t1, i) {
                this._swipePoint || (this._tapTime && e.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = t1[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(e, t1, i));
            }
            touchmove(e, t1, i) {
                if (this._tapTime) {
                    if (this._swipePoint) {
                        if (i[0].identifier !== this._swipeTouch) return;
                        const o = t1[0], r = o.y - this._swipePoint.y;
                        return this._swipePoint = o, e.preventDefault(), this._active = !0, {
                            zoomDelta: r / 128
                        };
                    }
                } else this._tap.touchmove(e, t1, i);
            }
            touchend(e, t1, i) {
                this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(e, t1, i) && (this._tapTime = e.timeStamp);
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class En {
            constructor(e, t1, i){
                this._el = e, this._mousePan = t1, this._touchPan = i;
            }
            enable(e) {
                this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
            }
            disable() {
                this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
            }
            isEnabled() {
                return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
                return this._mousePan.isActive() || this._touchPan.isActive();
            }
        }
        class Cn {
            constructor(e, t1, i){
                this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t1, this._mousePitch = i;
            }
            enable() {
                this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
                this._mouseRotate.disable(), this._mousePitch.disable();
            }
            isEnabled() {
                return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }
            isActive() {
                return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
        }
        class Sn {
            constructor(e, t1, i, o){
                this._el = e, this._touchZoom = t1, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;
            }
            enable(e) {
                this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
            }
            disable() {
                this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
            }
            isEnabled() {
                return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
                return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
                this._rotationDisabled = !0, this._touchRotate.disable();
            }
            enableRotation() {
                this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
        }
        const In = (e)=>e.zoom || e.drag || e.pitch || e.rotate;
        class Ln extends e.f {
        }
        class Pn {
            constructor(){
                this.constants = [
                    1,
                    1,
                    .01
                ], this.radius = 0;
            }
            setup(t1, i) {
                const o = e._.sub([], i, t1);
                this.radius = e._.length(o[2] < 0 ? e._.div([], o, this.constants) : [
                    o[0],
                    o[1],
                    0
                ]);
            }
            projectRay(t1) {
                e._.div(t1, t1, this.constants), e._.normalize(t1, t1), e._.mul(t1, t1, this.constants);
                const i = e._.scale([], t1, this.radius);
                if (i[2] > 0) {
                    const t1 = e._.scale([], [
                        0,
                        0,
                        1
                    ], e._.dot(i, [
                        0,
                        0,
                        1
                    ])), o = e._.scale([], e._.normalize([], [
                        i[0],
                        i[1],
                        0
                    ]), this.radius), r = e._.add([], i, e._.scale([], e._.sub([], e._.add([], o, t1), i), 2));
                    i[0] = r[0], i[1] = r[1];
                }
                return i;
            }
        }
        function An(e) {
            return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta;
        }
        class Rn {
            constructor(t1, i){
                this._map = t1, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ga(t1), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Pn, this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i), e.bp([
                    "handleEvent",
                    "handleWindowEvent"
                ], this);
                const o = this._el;
                this._listeners = [
                    [
                        o,
                        "touchstart",
                        {
                            passive: !0
                        }
                    ],
                    [
                        o,
                        "touchmove",
                        {
                            passive: !1
                        }
                    ],
                    [
                        o,
                        "touchend",
                        void 0
                    ],
                    [
                        o,
                        "touchcancel",
                        void 0
                    ],
                    [
                        o,
                        "mousedown",
                        void 0
                    ],
                    [
                        o,
                        "mousemove",
                        void 0
                    ],
                    [
                        o,
                        "mouseup",
                        void 0
                    ],
                    [
                        document,
                        "mousemove",
                        {
                            capture: !0
                        }
                    ],
                    [
                        document,
                        "mouseup",
                        void 0
                    ],
                    [
                        o,
                        "mouseover",
                        void 0
                    ],
                    [
                        o,
                        "mouseout",
                        void 0
                    ],
                    [
                        o,
                        "dblclick",
                        void 0
                    ],
                    [
                        o,
                        "click",
                        void 0
                    ],
                    [
                        o,
                        "keydown",
                        {
                            capture: !1
                        }
                    ],
                    [
                        o,
                        "keyup",
                        void 0
                    ],
                    [
                        o,
                        "wheel",
                        {
                            passive: !1
                        }
                    ],
                    [
                        o,
                        "contextmenu",
                        void 0
                    ],
                    [
                        window,
                        "blur",
                        void 0
                    ]
                ];
                for (const [e, t1, i] of this._listeners){
                    const o = e === document ? this.handleWindowEvent : this.handleEvent;
                    e.addEventListener(t1, o, i);
                }
            }
            destroy() {
                for (const [e, t1, i] of this._listeners){
                    const o = e === document ? this.handleWindowEvent : this.handleEvent;
                    e.removeEventListener(t1, o, i);
                }
            }
            _addDefaultHandlers(e) {
                const t1 = this._map, i = t1.getCanvasContainer();
                this._add("mapEvent", new Ha(t1, e));
                const o = t1.boxZoom = new Xa(t1, e);
                this._add("boxZoom", o);
                const r = new Ja, a = new wn;
                t1.doubleClickZoom = new bn(a, r), this._add("tapZoom", r), this._add("clickZoom", a);
                const n = new Tn;
                this._add("tapDragZoom", n);
                const s = t1.touchPitch = new pn(t1);
                this._add("touchPitch", s);
                const l = new rn(e), c = new an(e);
                t1.dragRotate = new Cn(e, l, c), this._add("mouseRotate", l, [
                    "mousePitch"
                ]), this._add("mousePitch", c, [
                    "mouseRotate"
                ]);
                const h = new on(e), _ = new nn(t1, e);
                t1.dragPan = new En(i, h, _), this._add("mousePan", h), this._add("touchPan", _, [
                    "touchZoom",
                    "touchRotate"
                ]);
                const u = new un, d = new hn;
                t1.touchZoomRotate = new Sn(i, d, u, n), this._add("touchRotate", u, [
                    "touchPan",
                    "touchZoom"
                ]), this._add("touchZoom", d, [
                    "touchPan",
                    "touchRotate"
                ]), this._add("blockableMapEvent", new $a(t1));
                const p = t1.scrollZoom = new yn(t1, this);
                this._add("scrollZoom", p, [
                    "mousePan"
                ]);
                const f = t1.keyboard = new mn;
                this._add("keyboard", f);
                for (const i of [
                    "boxZoom",
                    "doubleClickZoom",
                    "tapDragZoom",
                    "touchPitch",
                    "dragRotate",
                    "dragPan",
                    "touchZoomRotate",
                    "scrollZoom",
                    "keyboard"
                ])e.interactive && e[i] && t1[i].enable(e[i]);
            }
            _add(e, t1, i) {
                this._handlers.push({
                    handlerName: e,
                    handler: t1,
                    allowed: i
                }), this._handlersById[e] = t1;
            }
            stop(e) {
                if (!this._updatingCamera) {
                    for (const { handler: e } of this._handlers)e.reset();
                    this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [], this._originalZoom = void 0;
                }
            }
            isActive() {
                for (const { handler: e } of this._handlers)if (e.isActive()) return !0;
                return !1;
            }
            isZooming() {
                return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
                return !!this._eventsInProgress.rotate;
            }
            isMoving() {
                return !!In(this._eventsInProgress) || this.isZooming();
            }
            _isDragging() {
                return !!this._eventsInProgress.drag;
            }
            _blockedByActive(e, t1, i) {
                for(const o in e)if (o !== i && (!t1 || t1.indexOf(o) < 0)) return !0;
                return !1;
            }
            handleWindowEvent(e) {
                this.handleEvent(e, `${e.type}Window`);
            }
            _getMapTouches(e) {
                const t1 = [];
                for (const i of e)this._el.contains(i.target) && t1.push(i);
                return t1;
            }
            handleEvent(e, t1) {
                this._updatingCamera = !0;
                const i = "renderFrame" === e.type, o = i ? void 0 : e, r = {
                    needsRenderFrame: !1
                }, a = {}, n = {}, s = e.touches ? this._getMapTouches(e.touches) : void 0, l = s ? f(this._el, s) : i ? void 0 : p(this._el, e);
                for (const { handlerName: i, handler: c, allowed: h } of this._handlers){
                    if (!c.isEnabled()) continue;
                    let _;
                    this._blockedByActive(n, h, i) ? c.reset() : c[t1 || e.type] && (_ = c[t1 || e.type](e, l, s), this.mergeHandlerResult(r, a, _, i, o), _ && _.needsRenderFrame && this._triggerRenderFrame()), (_ || c.isActive()) && (n[i] = c);
                }
                const c = {};
                for(const e in this._previousActiveHandlers)n[e] || (c[e] = o);
                this._previousActiveHandlers = n, (Object.keys(c).length || An(r)) && (this._changes.push([
                    r,
                    a,
                    c
                ]), this._triggerRenderFrame()), (Object.keys(n).length || An(r)) && this._map._stop(!0), this._updatingCamera = !1;
                const { cameraAnimation: h } = r;
                h && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], h(this._map));
            }
            mergeHandlerResult(t1, i, o, r, a) {
                if (!o) return;
                e.W(t1, o);
                const n = {
                    handlerName: r,
                    originalEvent: o.originalEvent || a
                };
                void 0 !== o.zoomDelta && (i.zoom = n), void 0 !== o.panDelta && (i.drag = n), void 0 !== o.pitchDelta && (i.pitch = n), void 0 !== o.bearingDelta && (i.rotate = n);
            }
            _applyChanges() {
                const t1 = {}, i = {}, o = {};
                for (const [r, a, n] of this._changes)r.panDelta && (t1.panDelta = (t1.panDelta || new e.P(0, 0))._add(r.panDelta)), r.zoomDelta && (t1.zoomDelta = (t1.zoomDelta || 0) + r.zoomDelta), r.bearingDelta && (t1.bearingDelta = (t1.bearingDelta || 0) + r.bearingDelta), r.pitchDelta && (t1.pitchDelta = (t1.pitchDelta || 0) + r.pitchDelta), void 0 !== r.around && (t1.around = r.around), void 0 !== r.aroundCoord && (t1.aroundCoord = r.aroundCoord), void 0 !== r.pinchAround && (t1.pinchAround = r.pinchAround), r.noInertia && (t1.noInertia = r.noInertia), e.W(i, a), e.W(o, n);
                this._updateMapTransform(t1, i, o), this._changes = [];
            }
            _updateMapTransform(t1, i, o) {
                const r = this._map, a = r.transform, n = (e)=>[
                        e.x,
                        e.y,
                        e.z
                    ];
                if (((e)=>{
                    const t1 = this._eventsInProgress.drag;
                    return t1 && !this._handlersById[t1.handlerName].isActive();
                })() && !An(t1)) {
                    const e = a.zoom;
                    a.cameraElevationReference = "sea", null != this._originalZoom && a._orthographicProjectionAtLowPitch && "globe" !== a.projection.name && 0 === a.pitch ? (a.cameraElevationReference = "ground", a.zoom = this._originalZoom) : (a.recenterOnTerrain(), a.cameraElevationReference = "ground"), e !== a.zoom && this._map._update(!0);
                }
                if (a._isCameraConstrained && r._stop(!0), !An(t1)) return void this._fireEvents(i, o, !0);
                let { panDelta: s, zoomDelta: l, bearingDelta: c, pitchDelta: h, around: _, aroundCoord: u, pinchAround: d } = t1;
                a._isCameraConstrained && (l > 0 && (l = 0), a._isCameraConstrained = !1), void 0 !== d && (_ = d), (l || ((e)=>i[e] && !this._eventsInProgress[e])("drag")) && _ && (this._dragOrigin = n(a.pointCoordinate3D(_)), this._originalZoom = a.zoom, this._trackingEllipsoid.setup(a._camera.position, this._dragOrigin)), a.cameraElevationReference = "sea", r._stop(!0), _ = _ || r.transform.centerPoint, c && (a.bearing += c), h && (a.pitch += h), a._updateCameraState();
                const p = [
                    0,
                    0,
                    0
                ];
                if (s) {
                    if ("mercator" === a.projection.name) {
                        const e = this._trackingEllipsoid.projectRay(a.screenPointToMercatorRay(_).dir), t1 = this._trackingEllipsoid.projectRay(a.screenPointToMercatorRay(_.sub(s)).dir);
                        p[0] = t1[0] - e[0], p[1] = t1[1] - e[1];
                    } else {
                        const t1 = a.pointCoordinate(_);
                        if ("globe" === a.projection.name) {
                            s = s.rotate(-a.angle);
                            const i = a._pixelsPerMercatorPixel / a.worldSize;
                            p[0] = -s.x * e.d3(e.ay(t1.y)) * i, p[1] = -s.y * e.d3(a.center.lat) * i;
                        } else {
                            const e = a.pointCoordinate(_.sub(s));
                            t1 && e && (p[0] = e.x - t1.x, p[1] = e.y - t1.y);
                        }
                    }
                }
                const f = a.zoom, m = [
                    0,
                    0,
                    0
                ];
                if (l) {
                    const t1 = n(u || a.pointCoordinate3D(_)), i = {
                        dir: e._.normalize([], e._.sub([], t1, a._camera.position))
                    };
                    if (i.dir[2] < 0) {
                        const o = a.zoomDeltaToMovement(t1, l);
                        e._.scale(m, i.dir, o);
                    }
                }
                const g = e._.add(p, p, m);
                a._translateCameraConstrained(g), l && Math.abs(a.zoom - f) > 1e-4 && a.recenterOnTerrain(), a.cameraElevationReference = "ground", this._map._update(), t1.noInertia || this._inertia.record(t1), this._fireEvents(i, o, !0);
            }
            _fireEvents(t1, i, o) {
                const r = In(this._eventsInProgress), a = In(t1), n = {};
                for(const e in t1){
                    const { originalEvent: i } = t1[e];
                    this._eventsInProgress[e] || (n[`${e}start`] = i), this._eventsInProgress[e] = t1[e];
                }
                !r && a && this._fireEvent("movestart", a.originalEvent);
                for(const e in n)this._fireEvent(e, n[e]);
                a && this._fireEvent("move", a.originalEvent);
                for(const e in t1){
                    const { originalEvent: i } = t1[e];
                    this._fireEvent(e, i);
                }
                const s = {};
                let l;
                for(const e in this._eventsInProgress){
                    const { handlerName: t1, originalEvent: o } = this._eventsInProgress[e];
                    this._handlersById[t1].isActive() || (delete this._eventsInProgress[e], l = i[t1] || o, s[`${e}end`] = l);
                }
                for(const e in s)this._fireEvent(e, s[e]);
                const c = In(this._eventsInProgress);
                if (o && (r || a) && !c) {
                    this._updatingCamera = !0;
                    const t1 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i = (e)=>0 !== e && -this._bearingSnap < e && e < this._bearingSnap;
                    t1 ? (i(t1.bearing || this._map.getBearing()) && (t1.bearing = 0), this._map.easeTo(t1, {
                        originalEvent: l
                    })) : (this._map.fire(new e.f("moveend", {
                        originalEvent: l
                    })), i(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
                }
            }
            _fireEvent(t1, i) {
                this._map.fire(new e.f(t1, i ? {
                    originalEvent: i
                } : {}));
            }
            _requestFrame() {
                return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e)=>{
                    this._frameId = void 0, this.handleEvent(new Ln("renderFrame", {
                        timeStamp: e
                    })), this._applyChanges();
                });
            }
            _triggerRenderFrame() {
                void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
        }
        const Dn = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class Mn extends e.E {
            constructor(t1, i){
                super(), this._moving = !1, this._zooming = !1, this.transform = t1, this._bearingSnap = i.bearingSnap, this._respectPrefersReducedMotion = !1 !== i.respectPrefersReducedMotion, e.bp([
                    "_renderFrameCallback"
                ], this);
            }
            getCenter() {
                return new e.aI(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(e, t1) {
                return this.jumpTo({
                    center: e
                }, t1);
            }
            panBy(t1, i, o) {
                return t1 = e.P.convert(t1).mult(-1), this.panTo(this.transform.center, e.W({
                    offset: t1
                }, i), o);
            }
            panTo(t1, i, o) {
                return this.easeTo(e.W({
                    center: t1
                }, i), o);
            }
            getZoom() {
                return this.transform.zoom;
            }
            setZoom(e, t1) {
                return this.jumpTo({
                    zoom: e
                }, t1), this;
            }
            zoomTo(t1, i, o) {
                return this.easeTo(e.W({
                    zoom: t1
                }, i), o);
            }
            zoomIn(e, t1) {
                return this.zoomTo(this.getZoom() + 1, e, t1), this;
            }
            zoomOut(e, t1) {
                return this.zoomTo(this.getZoom() - 1, e, t1), this;
            }
            getBearing() {
                return this.transform.bearing;
            }
            setBearing(e, t1) {
                return this.jumpTo({
                    bearing: e
                }, t1), this;
            }
            getPadding() {
                return this.transform.padding;
            }
            setPadding(e, t1) {
                return this.jumpTo({
                    padding: e
                }, t1), this;
            }
            rotateTo(t1, i, o) {
                return this.easeTo(e.W({
                    bearing: t1
                }, i), o);
            }
            resetNorth(t1, i) {
                return this.rotateTo(0, e.W({
                    duration: 1e3
                }, t1), i), this;
            }
            resetNorthPitch(t1, i) {
                return this.easeTo(e.W({
                    bearing: 0,
                    pitch: 0,
                    duration: 1e3
                }, t1), i), this;
            }
            snapToNorth(e, t1) {
                return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t1) : this;
            }
            getPitch() {
                return this.transform.pitch;
            }
            setPitch(e, t1) {
                return this.jumpTo({
                    pitch: e
                }, t1), this;
            }
            cameraForBounds(t1, i) {
                t1 = e.ai.convert(t1);
                const o = i && i.bearing || 0, r = i && i.pitch || 0, a = t1.getNorthWest(), n = t1.getSouthEast();
                return this._cameraForBounds(this.transform, a, n, o, r, i);
            }
            _extendPadding(t1) {
                const i = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                };
                return null == t1 ? e.W({}, i, this.transform.padding) : "number" == typeof t1 ? {
                    top: t1,
                    bottom: t1,
                    right: t1,
                    left: t1
                } : e.W({}, i, t1);
            }
            _extendCameraOptions(t1) {
                return (t1 = e.W({
                    offset: [
                        0,
                        0
                    ],
                    maxZoom: this.transform.maxZoom
                }, t1)).padding = this._extendPadding(t1.padding), t1;
            }
            _minimumAABBFrustumDistance(e, t1) {
                const i = t1.max[0] - t1.min[0], o = t1.max[1] - t1.min[1];
                return i / o > e.aspect ? i / (2 * Math.tan(.5 * e.fovX) * e.aspect) : o / (2 * Math.tan(.5 * e.fovY) * e.aspect);
            }
            _cameraForBoundsOnGlobe(t1, i, o, r, a, n) {
                const s = t1.clone(), l = this._extendCameraOptions(n);
                s.bearing = r, s.pitch = a;
                const c = e.aI.convert(i), h = e.aI.convert(o), _ = .5 * (c.lat + h.lat), u = .5 * (c.lng + h.lng), d = e.d4(_, u), p = e._.normalize([], d), f = e._.normalize([], e._.cross([], p, [
                    0,
                    1,
                    0
                ])), m = e._.cross([], f, p), g = [
                    f[0],
                    f[1],
                    f[2],
                    0,
                    m[0],
                    m[1],
                    m[2],
                    0,
                    p[0],
                    p[1],
                    p[2],
                    0,
                    0,
                    0,
                    0,
                    1
                ], v = [
                    d,
                    e.d4(c.lat, c.lng),
                    e.d4(h.lat, c.lng),
                    e.d4(h.lat, h.lng),
                    e.d4(c.lat, h.lng),
                    e.d4(_, c.lng),
                    e.d4(_, h.lng),
                    e.d4(c.lat, u),
                    e.d4(h.lat, u)
                ];
                let x = e.b6.fromPoints(v.map((t1)=>[
                        e._.dot(f, t1),
                        e._.dot(m, t1),
                        e._.dot(p, t1)
                    ]));
                const y = e._.transformMat4([], x.center, g);
                0 === e._.squaredLength(y) && e._.set(y, 0, 0, 1), e._.normalize(y, y), e._.scale(y, y, e.cD), s.center = e.d5(y);
                const b = s.getWorldToCameraMatrix(), w = e.ad.invert(new Float64Array(16), b);
                x = e.b6.applyTransform(x, e.ad.multiply([], b, g));
                const T = this._extendAABB(x, s, l, r);
                if (!T) return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                x = T, e._.transformMat4(y, y, b);
                const E = .5 * (x.max[2] - x.min[2]), C = this._minimumAABBFrustumDistance(s, x), S = e._.scale([], [
                    0,
                    0,
                    1
                ], E), I = e._.add(S, y, S), L = C + (0 === s.pitch ? 0 : e._.distance(y, I)), P = s.globeCenterInViewSpace, A = e._.sub([], y, [
                    P[0],
                    P[1],
                    P[2]
                ]);
                e._.normalize(A, A), e._.scale(A, A, L);
                const R = e._.add([], y, A);
                e._.transformMat4(R, R, w);
                const D = e.d7 / e.cD, M = e._.length(R), z = e.ax(Math.max(M * D - e.d7, Number.EPSILON), 0), O = Math.min(s.zoomFromMercatorZAdjusted(z), l.maxZoom);
                return O > .5 * (e.b1 + e.aU) ? (s.setProjection({
                    name: "mercator"
                }), s.zoom = O, this._cameraForBounds(s, i, o, r, a, n)) : {
                    center: s.center,
                    zoom: O,
                    bearing: r,
                    pitch: a
                };
            }
            _extendAABB(t1, i, o, r) {
                const a = .5 * ((o.padding.left || 0) + (o.padding.right || 0)), n = .5 * ((o.padding.top || 0) + (o.padding.bottom || 0)), s = n, l = a, c = a, h = n, _ = i.width - (l + c), u = i.height - (s + h), d = e._.sub([], t1.max, t1.min), p = Math.min(_ / d[0], u / d[1]), f = Math.min(i.scaleZoom(i.scale * p), o.maxZoom);
                if (isNaN(f)) return null;
                const m = i.scale / i.zoomScale(f), g = new e.b6([
                    t1.min[0] - l * m,
                    t1.min[1] - h * m,
                    t1.min[2]
                ], [
                    t1.max[0] + c * m,
                    t1.max[1] + s * m,
                    t1.max[2]
                ]), v = ("number" == typeof o.offset.x && "number" == typeof o.offset.y ? new e.P(o.offset.x, o.offset.y) : e.P.convert(o.offset)).rotate(-e.ab(r));
                return g.center[0] -= v.x * m, g.center[1] += v.y * m, g;
            }
            queryTerrainElevation(t1, i) {
                const o = this.transform.elevation;
                return o ? (i = e.W({}, {
                    exaggerated: !0
                }, i), o.getAtPoint(e.Y.fromLngLat(t1), null, i.exaggerated)) : null;
            }
            _cameraForBounds(t1, i, o, r, a, n) {
                if ("globe" === t1.projection.name) return this._cameraForBoundsOnGlobe(t1, i, o, r, a, n);
                const s = t1.clone(), l = this._extendCameraOptions(n);
                s.bearing = r, s.pitch = a;
                const c = e.aI.convert(i), h = e.aI.convert(o), _ = new e.aI(c.lng, h.lat), u = new e.aI(h.lng, c.lat), d = s.project(c), p = s.project(h), f = this.queryTerrainElevation(c), m = this.queryTerrainElevation(h), g = this.queryTerrainElevation(_), v = this.queryTerrainElevation(u), x = [
                    [
                        d.x,
                        d.y,
                        Math.min(f || 0, m || 0, g || 0, v || 0)
                    ],
                    [
                        p.x,
                        p.y,
                        Math.max(f || 0, m || 0, g || 0, v || 0)
                    ]
                ];
                let y = e.b6.fromPoints(x);
                const b = s.getWorldToCameraMatrix(), w = e.ad.invert(new Float64Array(16), b);
                y = e.b6.applyTransform(y, b);
                const T = this._extendAABB(y, s, l, r);
                if (!T) return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                y = T;
                const E = .5 * e._.sub([], y.max, y.min)[2], C = this._minimumAABBFrustumDistance(s, y), S = [
                    0,
                    0,
                    1,
                    0
                ];
                e.aA.transformMat4(S, S, b), e.aA.normalize(S, S);
                const I = e._.scale([], S, C + E), L = e._.add([], y.center, I);
                e._.transformMat4(y.center, y.center, w), e._.transformMat4(L, L, w);
                const P = [
                    y.center[0],
                    y.center[1],
                    L[2] * s.pixelsPerMeter
                ];
                e._.scale(P, P, 1 / s.worldSize);
                const A = e.d6(P[0]), R = e.ay(P[1]), D = Math.min(s._zoomFromMercatorZ(P[2]), l.maxZoom), M = new e.aI(A, R);
                return s.mercatorFromTransition && D < .5 * (e.b1 + e.aU) ? (s.setProjection({
                    name: "globe"
                }), s.zoom = D, this._cameraForBounds(s, i, o, r, a, n)) : {
                    center: M,
                    zoom: D,
                    bearing: r,
                    pitch: a
                };
            }
            fitBounds(e, t1, i) {
                const o = this.cameraForBounds(e, t1);
                return this._fitInternal(o, t1, i);
            }
            fitScreenCoordinates(t1, i, o, r, a) {
                const n = e.P.convert(t1), s = e.P.convert(i), l = new e.P(Math.min(n.x, s.x), Math.min(n.y, s.y)), c = new e.P(Math.max(n.x, s.x), Math.max(n.y, s.y));
                if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(n, s)) return this;
                const h = this.transform.pointLocation3D(l), _ = this.transform.pointLocation3D(c), u = this.transform.pointLocation3D(new e.P(l.x, c.y)), d = this.transform.pointLocation3D(new e.P(c.x, l.y)), p = [
                    Math.min(h.lng, _.lng, u.lng, d.lng),
                    Math.min(h.lat, _.lat, u.lat, d.lat)
                ], f = [
                    Math.max(h.lng, _.lng, u.lng, d.lng),
                    Math.max(h.lat, _.lat, u.lat, d.lat)
                ], m = r && r.pitch ? r.pitch : this.getPitch(), g = this._cameraForBounds(this.transform, p, f, o, m, r);
                return this._fitInternal(g, r, a);
            }
            _fitInternal(t1, i, o) {
                return t1 ? (i = e.W(t1, i)).linear ? this.easeTo(i, o) : this.flyTo(i, o) : this;
            }
            jumpTo(t1, i) {
                this.stop();
                const o = t1.preloadOnly ? this.transform.clone() : this.transform;
                let r = !1, a = !1, n = !1;
                if ("zoom" in t1 && o.zoom !== +t1.zoom && (r = !0, o.zoom = +t1.zoom), void 0 !== t1.center && (o.center = e.aI.convert(t1.center)), "bearing" in t1 && o.bearing !== +t1.bearing && (a = !0, o.bearing = +t1.bearing), "pitch" in t1 && o.pitch !== +t1.pitch && (n = !0, o.pitch = +t1.pitch), null != t1.padding) {
                    const e = "number" == typeof t1.padding ? this._extendPadding(t1.padding) : t1.padding;
                    o.isPaddingEqual(e) || (o.padding = e);
                }
                return t1.preloadOnly ? (this._preloadTiles(o), this) : (this.fire(new e.f("movestart", i)).fire(new e.f("move", i)), r && this.fire(new e.f("zoomstart", i)).fire(new e.f("zoom", i)).fire(new e.f("zoomend", i)), a && this.fire(new e.f("rotatestart", i)).fire(new e.f("rotate", i)).fire(new e.f("rotateend", i)), n && this.fire(new e.f("pitchstart", i)).fire(new e.f("pitch", i)).fire(new e.f("pitchend", i)), this.fire(new e.f("moveend", i)));
            }
            getFreeCameraOptions() {
                return this.transform.projection.supportsFreeCamera || e.w(Dn), this.transform.getFreeCameraOptions();
            }
            setFreeCameraOptions(t1, i) {
                const o = this.transform;
                if (!o.projection.supportsFreeCamera) return e.w(Dn), this;
                this.stop();
                const r = o.zoom, a = o.pitch, n = o.bearing;
                o.setFreeCameraOptions(t1);
                const s = r !== o.zoom, l = a !== o.pitch, c = n !== o.bearing;
                return this.fire(new e.f("movestart", i)).fire(new e.f("move", i)), s && this.fire(new e.f("zoomstart", i)).fire(new e.f("zoom", i)).fire(new e.f("zoomend", i)), c && this.fire(new e.f("rotatestart", i)).fire(new e.f("rotate", i)).fire(new e.f("rotateend", i)), l && this.fire(new e.f("pitchstart", i)).fire(new e.f("pitch", i)).fire(new e.f("pitchend", i)), this.fire(new e.f("moveend", i)), this;
            }
            easeTo(t1, i) {
                this._stop(!1, t1.easeId), (!1 === (t1 = e.W({
                    offset: [
                        0,
                        0
                    ],
                    duration: 500,
                    easing: e.d2
                }, t1)).animate || this._prefersReducedMotion(t1)) && (t1.duration = 0);
                const o = this.transform, r = this.getZoom(), a = this.getBearing(), n = this.getPitch(), s = this.getPadding(), l = "zoom" in t1 ? +t1.zoom : r, c = "bearing" in t1 ? this._normalizeBearing(t1.bearing, a) : a, h = "pitch" in t1 ? +t1.pitch : n, _ = this._extendPadding(t1.padding), u = e.P.convert(t1.offset);
                let d, p, f;
                if ("globe" === o.projection.name) {
                    const i = e.Y.fromLngLat(o.center), r = u.rotate(-o.angle);
                    i.x += r.x / o.worldSize, i.y += r.y / o.worldSize;
                    const a = i.toLngLat(), n = e.aI.convert(t1.center || a);
                    this._normalizeCenter(n), d = o.centerPoint.add(r), p = new e.P(i.x, i.y).mult(o.worldSize), f = new e.P(e.aj(n.lng), e.ak(n.lat)).mult(o.worldSize).sub(p);
                } else {
                    d = o.centerPoint.add(u);
                    const i = o.pointLocation(d), r = e.aI.convert(t1.center || i);
                    this._normalizeCenter(r), p = o.project(i), f = o.project(r).sub(p);
                }
                const m = o.zoomScale(l - r);
                let g, v;
                t1.around && (g = e.aI.convert(t1.around), v = o.locationPoint(g));
                const x = this._zooming || l !== r, y = this._rotating || a !== c, b = this._pitching || h !== n, w = !o.isPaddingEqual(_), T = (o)=>(T)=>{
                        if (x && (o.zoom = e.a2(r, l, T)), y && (o.bearing = e.a2(a, c, T)), b && (o.pitch = e.a2(n, h, T)), w && (o.interpolatePadding(s, _, T), d = o.centerPoint.add(u)), g) o.setLocationAtPoint(g, v);
                        else {
                            const e = o.zoomScale(o.zoom - r), t1 = l > r ? Math.min(2, m) : Math.max(.5, m), i = Math.pow(t1, 1 - T), a = o.unproject(p.add(f.mult(T * i)).mult(e));
                            o.setLocationAtPoint(o.renderWorldCopies ? a.wrap() : a, d);
                        }
                        return t1.preloadOnly || this._fireMoveEvents(i), o;
                    };
                if (t1.preloadOnly) {
                    const e = this._emulate(T, t1.duration, o);
                    return this._preloadTiles(e), this;
                }
                const E = {
                    moving: this._moving,
                    zooming: this._zooming,
                    rotating: this._rotating,
                    pitching: this._pitching
                };
                return this._zooming = x, this._rotating = y, this._pitching = b, this._padding = w, this._easeId = t1.easeId, this._prepareEase(i, t1.noMoveStart, E), this._ease(T(o), (e)=>{
                    "sea" === o.cameraElevationReference && o.recenterOnTerrain(), this._afterEase(i, e);
                }, t1), this;
            }
            _prepareEase(t1, i, o = {}) {
                this._moving = !0, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && "globe" !== this.transform.projection.name && (this.transform.cameraElevationReference = "ground"), i || o.moving || this.fire(new e.f("movestart", t1)), this._zooming && !o.zooming && this.fire(new e.f("zoomstart", t1)), this._rotating && !o.rotating && this.fire(new e.f("rotatestart", t1)), this._pitching && !o.pitching && this.fire(new e.f("pitchstart", t1));
            }
            _fireMoveEvents(t1) {
                this.fire(new e.f("move", t1)), this._zooming && this.fire(new e.f("zoom", t1)), this._rotating && this.fire(new e.f("rotate", t1)), this._pitching && this.fire(new e.f("pitch", t1));
            }
            _afterEase(t1, i) {
                if (this._easeId && i && this._easeId === i) return;
                this._easeId = void 0, this.transform.cameraElevationReference = "ground";
                const o = this._zooming, r = this._rotating, a = this._pitching;
                this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new e.f("zoomend", t1)), r && this.fire(new e.f("rotateend", t1)), a && this.fire(new e.f("pitchend", t1)), this.fire(new e.f("moveend", t1));
            }
            flyTo(t1, i) {
                if (this._prefersReducedMotion(t1)) {
                    const o = e.ah(t1, [
                        "center",
                        "zoom",
                        "bearing",
                        "pitch",
                        "around",
                        "padding"
                    ]);
                    return this.jumpTo(o, i);
                }
                this.stop(), t1 = e.W({
                    offset: [
                        0,
                        0
                    ],
                    speed: 1.2,
                    curve: 1.42,
                    easing: e.d2
                }, t1);
                const o = this.transform, r = this.getZoom(), a = this.getBearing(), n = this.getPitch(), s = this.getPadding(), l = "zoom" in t1 ? e.at(+t1.zoom, o.minZoom, o.maxZoom) : r, c = "bearing" in t1 ? this._normalizeBearing(t1.bearing, a) : a, h = "pitch" in t1 ? +t1.pitch : n, _ = this._extendPadding(t1.padding), u = o.zoomScale(l - r), d = e.P.convert(t1.offset);
                let p = o.centerPoint.add(d);
                const f = o.pointLocation(p), m = e.aI.convert(t1.center || f);
                this._normalizeCenter(m);
                const g = o.project(f), v = o.project(m).sub(g);
                let x = t1.curve;
                const y = Math.max(o.width, o.height), b = y / u, w = v.mag();
                if ("minZoom" in t1) {
                    const i = e.at(Math.min(t1.minZoom, r, l), o.minZoom, o.maxZoom), a = y / o.zoomScale(i - r);
                    x = Math.sqrt(a / w * 2);
                }
                const T = x * x;
                function E(e) {
                    const t1 = (b * b - y * y + (e ? -1 : 1) * T * T * w * w) / (2 * (e ? b : y) * T * w);
                    return Math.log(Math.sqrt(t1 * t1 + 1) - t1);
                }
                function C(e) {
                    return (Math.exp(e) - Math.exp(-e)) / 2;
                }
                function S(e) {
                    return (Math.exp(e) + Math.exp(-e)) / 2;
                }
                const I = E(0);
                let L = function(e) {
                    return S(I) / S(I + x * e);
                }, P = function(e) {
                    var t1;
                    return y * ((S(I) * (C(t1 = I + x * e) / S(t1)) - C(I)) / T) / w;
                }, A = (E(1) - I) / x;
                if (Math.abs(w) < 1e-6 || !isFinite(A)) {
                    if (Math.abs(y - b) < 1e-6) return this.easeTo(t1, i);
                    const e = b < y ? -1 : 1;
                    A = Math.abs(Math.log(b / y)) / x, P = function() {
                        return 0;
                    }, L = function(t1) {
                        return Math.exp(e * x * t1);
                    };
                }
                t1.duration = "duration" in t1 ? +t1.duration : 1e3 * A / ("screenSpeed" in t1 ? +t1.screenSpeed / x : +t1.speed), t1.maxDuration && t1.duration > t1.maxDuration && (t1.duration = 0);
                const R = a !== c, D = h !== n, M = !o.isPaddingEqual(_), z = (o)=>(u)=>{
                        const f = u * A, x = 1 / L(f);
                        o.zoom = 1 === u ? l : r + o.scaleZoom(x), R && (o.bearing = e.a2(a, c, u)), D && (o.pitch = e.a2(n, h, u)), M && (o.interpolatePadding(s, _, u), p = o.centerPoint.add(d));
                        const y = 1 === u ? m : o.unproject(g.add(v.mult(P(f))).mult(x));
                        return o.setLocationAtPoint(o.renderWorldCopies ? y.wrap() : y, p), o._updateCameraOnTerrain(), t1.preloadOnly || this._fireMoveEvents(i), o;
                    };
                if (t1.preloadOnly) {
                    const e = this._emulate(z, t1.duration, o);
                    return this._preloadTiles(e), this;
                }
                return this._zooming = !0, this._rotating = R, this._pitching = D, this._padding = M, this._prepareEase(i, !1), this._ease(z(o), ()=>this._afterEase(i), t1), this;
            }
            isEasing() {
                return !!this._easeFrameId;
            }
            stop() {
                return this._stop();
            }
            _requestRenderFrame(e) {}
            _cancelRenderFrame(e) {}
            _stop(e, t1) {
                if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
                    const e = this._onEaseEnd;
                    this._onEaseEnd = void 0, e.call(this, t1);
                }
                if (!e) {
                    const e = this.handlers;
                    e && e.stop(!1);
                }
                return this;
            }
            _ease(t1, i, o) {
                !1 === o.animate || 0 === o.duration ? (t1(1), i()) : (this._easeStart = e.e.now(), this._easeOptions = o, this._onEaseFrame = t1, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _renderFrameCallback() {
                const t1 = Math.min((e.e.now() - this._easeStart) / this._easeOptions.duration, 1), i = this._onEaseFrame;
                i && i(this._easeOptions.easing(t1)), t1 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }
            _normalizeBearing(t1, i) {
                t1 = e.au(t1, -180, 180);
                const o = Math.abs(t1 - i);
                return Math.abs(t1 - 360 - i) < o && (t1 -= 360), Math.abs(t1 + 360 - i) < o && (t1 += 360), t1;
            }
            _normalizeCenter(e) {
                const t1 = this.transform;
                if (t1.maxBounds) return;
                if ("globe" !== t1.projection.name && !t1.renderWorldCopies) return;
                const i = e.lng - t1.center.lng;
                e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
            }
            _prefersReducedMotion(t1) {
                return this._respectPrefersReducedMotion && e.e.prefersReducedMotion && !(t1 && t1.essential);
            }
            _emulate(e, t1, i) {
                const o = Math.ceil(15 * t1 / 1e3), r = [], a = e(i.clone());
                for(let e = 0; e <= o; e++){
                    const t1 = a(e / o);
                    r.push(t1.clone());
                }
                return r;
            }
            _preloadTiles(e, t1) {}
        }
        class zn {
            constructor(t1 = {}){
                this.options = t1, e.bp([
                    "_toggleAttribution",
                    "_updateEditLink",
                    "_updateData",
                    "_updateCompact"
                ], this);
            }
            getDefaultPosition() {
                return "bottom-right";
            }
            onAdd(e) {
                const t1 = this.options && this.options.compact;
                return this._map = e, this._container = a("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = a("button", "mapboxgl-ctrl-attrib-button", this._container), a("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = a("div", "mapboxgl-ctrl-attrib-inner", this._container), t1 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t1 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
            }
            onRemove() {
                this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
            }
            _setElementTitle(e, t1) {
                const i = this._map._getUIString(`AttributionControl.${t1}`);
                e.removeAttribute("title"), e.firstElementChild && e.firstElementChild.setAttribute("title", i);
            }
            _toggleAttribution() {
                this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
            }
            _updateEditLink() {
                let t1 = this._editLink;
                t1 || (t1 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
                const i = [
                    {
                        key: "owner",
                        value: this.styleOwner
                    },
                    {
                        key: "id",
                        value: this.styleId
                    },
                    {
                        key: "access_token",
                        value: this._map._requestManager._customAccessToken || e.d8.ACCESS_TOKEN
                    }
                ];
                if (t1) {
                    const o = i.reduce((e, t1, o)=>(t1.value && (e += `${t1.key}=${t1.value}${o < i.length - 1 ? "&" : ""}`), e), "?");
                    t1.href = `${e.d8.FEEDBACK_URL}/${o}#${Oa(this._map, !0)}`, t1.rel = "noopener nofollow", this._setElementTitle(t1, "MapFeedback");
                }
            }
            _updateData(e) {
                !e || "metadata" !== e.sourceDataType && "visibility" !== e.sourceDataType && "style" !== e.dataType || (this._updateAttributions(), this._updateEditLink());
            }
            _updateAttributions() {
                if (!this._map.style) return;
                let e = [];
                if (this._map.style.stylesheet) {
                    const e = this._map.style.stylesheet;
                    this.styleOwner = e.owner, this.styleId = e.id;
                }
                const t1 = this._map.style._mergedSourceCaches;
                for(const i in t1){
                    const o = t1[i];
                    if (o.used) {
                        const t1 = o.getSource();
                        t1.attribution && e.indexOf(t1.attribution) < 0 && e.push(t1.attribution);
                    }
                }
                e.sort((e, t1)=>e.length - t1.length), e = e.filter((t1, i)=>{
                    for(let o = i + 1; o < e.length; o++)if (e[o].indexOf(t1) >= 0) return !1;
                    return !0;
                }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = [
                    ...this.options.customAttribution,
                    ...e
                ] : e.unshift(this.options.customAttribution));
                const i = e.join(" | ");
                i !== this._attribHTML && (this._attribHTML = i, e.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
            }
            _updateCompact() {
                this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
            }
        }
        class On {
            constructor(){
                e.bp([
                    "_updateLogo",
                    "_updateCompact"
                ], this);
            }
            onAdd(e) {
                this._map = e, this._container = a("div", "mapboxgl-ctrl");
                const t1 = a("a", "mapboxgl-ctrl-logo");
                return t1.target = "_blank", t1.rel = "noopener nofollow", t1.href = "https://www.mapbox.com/", t1.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t1.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t1), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
                this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
            }
            getDefaultPosition() {
                return "bottom-left";
            }
            _updateLogo(e) {
                e && "metadata" !== e.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
            }
            _logoRequired() {
                if (!this._map.style) return !0;
                const e = this._map.style._sourceCaches;
                if (0 === Object.entries(e).length) return !0;
                for(const t1 in e){
                    const i = e[t1].getSource();
                    if (i.hasOwnProperty("mapbox_logo") && !i.mapbox_logo) return !1;
                }
                return !0;
            }
            _updateCompact() {
                const e = this._container.children;
                if (e.length) {
                    const t1 = e[0];
                    this._map.getCanvasContainer().offsetWidth < 250 ? t1.classList.add("mapboxgl-compact") : t1.classList.remove("mapboxgl-compact");
                }
            }
        }
        class Fn {
            constructor(){
                this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
            }
            add(e) {
                const t1 = ++this._id;
                return this._queue.push({
                    callback: e,
                    id: t1,
                    cancelled: !1
                }), t1;
            }
            remove(e) {
                const t1 = this._currentlyRunning, i = t1 ? this._queue.concat(t1) : this._queue;
                for (const t1 of i)if (t1.id === e) return void (t1.cancelled = !0);
            }
            run(e = 0) {
                const t1 = this._currentlyRunning = this._queue;
                this._queue = [];
                for (const i of t1)if (!i.cancelled && (i.callback(e), this._cleared)) break;
                this._cleared = !1, this._currentlyRunning = !1;
            }
            clear() {
                this._currentlyRunning && (this._cleared = !0), this._queue = [];
            }
        }
        function Bn(t1, i, o) {
            if (t1 = new e.aI(t1.lng, t1.lat), i) {
                const r = new e.aI(t1.lng - 360, t1.lat), a = new e.aI(t1.lng + 360, t1.lat), n = 360 * Math.ceil(Math.abs(t1.lng - o.center.lng) / 360), s = o.locationPoint(t1).distSqr(i), l = i.x < 0 || i.y < 0 || i.x > o.width || i.y > o.height;
                o.locationPoint(r).distSqr(i) < s && (l || Math.abs(r.lng - o.center.lng) < n) ? t1 = r : o.locationPoint(a).distSqr(i) < s && (l || Math.abs(a.lng - o.center.lng) < n) && (t1 = a);
            }
            for(; Math.abs(t1.lng - o.center.lng) > 180;){
                const e = o.locationPoint(t1);
                if (e.x >= 0 && e.y >= 0 && e.x <= o.width && e.y <= o.height) break;
                t1.lng > o.center.lng ? t1.lng -= 360 : t1.lng += 360;
            }
            return t1;
        }
        const kn = {
            center: "translate(-50%,-50%)",
            top: "translate(-50%,0)",
            "top-left": "translate(0,0)",
            "top-right": "translate(-100%,0)",
            bottom: "translate(-50%,-100%)",
            "bottom-left": "translate(0,-100%)",
            "bottom-right": "translate(-100%,-100%)",
            left: "translate(0,-50%)",
            right: "translate(-100%,-50%)"
        };
        class Nn extends e.E {
            constructor(t1, i){
                if (super(), (t1 instanceof HTMLElement || i) && (t1 = e.W({
                    element: t1
                }, i)), e.bp([
                    "_update",
                    "_onMove",
                    "_onUp",
                    "_addDragHandler",
                    "_onMapClick",
                    "_onKeyPress",
                    "_clearFadeTimer"
                ], this), this._anchor = t1 && t1.anchor || "center", this._color = t1 && t1.color || "#3FB1CE", this._scale = t1 && t1.scale || 1, this._draggable = t1 && t1.draggable || !1, this._clickTolerance = t1 && t1.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = t1 && t1.rotation || 0, this._rotationAlignment = t1 && t1.rotationAlignment || "auto", this._pitchAlignment = t1 && t1.pitchAlignment && t1.pitchAlignment || "auto", this._updateMoving = ()=>this._update(!0), this._occludedOpacity = t1 && t1.occludedOpacity || .2, t1 && t1.element) this._element = t1.element, this._offset = e.P.convert(t1 && t1.offset || [
                    0,
                    0
                ]);
                else {
                    this._defaultMarker = !0, this._element = a("div");
                    const i = 41, o = 27, r = n("svg", {
                        display: "block",
                        height: i * this._scale + "px",
                        width: o * this._scale + "px",
                        viewBox: `0 0 ${o} ${i}`
                    }, this._element), s = n("radialGradient", {
                        id: "shadowGradient"
                    }, n("defs", {}, r));
                    n("stop", {
                        offset: "10%",
                        "stop-opacity": .4
                    }, s), n("stop", {
                        offset: "100%",
                        "stop-opacity": .05
                    }, s), n("ellipse", {
                        cx: 13.5,
                        cy: 34.8,
                        rx: 10.5,
                        ry: 5.25,
                        fill: "url(#shadowGradient)"
                    }, r), n("path", {
                        fill: this._color,
                        d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
                    }, r), n("path", {
                        opacity: .25,
                        d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
                    }, r), n("circle", {
                        fill: "white",
                        cx: 13.5,
                        cy: 13.5,
                        r: 5.5
                    }, r), this._offset = e.P.convert(t1 && t1.offset || [
                        0,
                        -14
                    ]);
                }
                this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e)=>{
                    e.preventDefault();
                }), this._element.addEventListener("mousedown", (e)=>{
                    e.preventDefault();
                });
                const o = this._element.classList;
                for(const e in kn)o.remove(`mapboxgl-marker-anchor-${e}`);
                o.add(`mapboxgl-marker-anchor-${this._anchor}`);
                const r = t1 && t1.className ? t1.className.trim().split(/\s+/) : [];
                o.add(...r), this._popup = null;
            }
            addTo(e) {
                return e === this._map || (this.remove(), this._map = e, e.getCanvasContainer().appendChild(this._element), e.on("move", this._updateMoving), e.on("moveend", this._update), e.on("remove", this._clearFadeTimer), e._addMarker(this), this.setDraggable(this._draggable), this._update(), e.on("click", this._onMapClick)), this;
            }
            remove() {
                const e = this._map;
                return e && (e.off("click", this._onMapClick), e.off("move", this._updateMoving), e.off("moveend", this._update), e.off("mousedown", this._addDragHandler), e.off("touchstart", this._addDragHandler), e.off("mouseup", this._onUp), e.off("touchend", this._onUp), e.off("mousemove", this._onMove), e.off("touchmove", this._onMove), e.off("remove", this._clearFadeTimer), e._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
                return this._lngLat;
            }
            setLngLat(t1) {
                return this._lngLat = e.aI.convert(t1), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
            }
            getElement() {
                return this._element;
            }
            setPopup(e) {
                if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
                    if (!("offset" in e.options)) {
                        const t1 = 38.1, i = 13.5, o = Math.sqrt(Math.pow(i, 2) / 2);
                        e.options.offset = this._defaultMarker ? {
                            top: [
                                0,
                                0
                            ],
                            "top-left": [
                                0,
                                0
                            ],
                            "top-right": [
                                0,
                                0
                            ],
                            bottom: [
                                0,
                                -t1
                            ],
                            "bottom-left": [
                                o,
                                -1 * (t1 - i + o)
                            ],
                            "bottom-right": [
                                -o,
                                -1 * (t1 - i + o)
                            ],
                            left: [
                                i,
                                -1 * (t1 - i)
                            ],
                            right: [
                                -i,
                                -1 * (t1 - i)
                            ]
                        } : this._offset;
                    }
                    this._popup = e, e._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
                }
                return this;
            }
            _onKeyPress(e) {
                const t1 = e.code, i = e.charCode || e.keyCode;
                "Space" !== t1 && "Enter" !== t1 && 32 !== i && 13 !== i || this.togglePopup();
            }
            _onMapClick(e) {
                const t1 = e.originalEvent.target, i = this._element;
                this._popup && (t1 === i || i.contains(t1)) && this.togglePopup();
            }
            getPopup() {
                return this._popup;
            }
            togglePopup() {
                const e = this._popup;
                return e ? (e.isOpen() ? (e.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
            }
            _behindTerrain() {
                const e = this._map, t1 = this._pos;
                if (!e || !t1) return !1;
                const i = e.unproject(t1), o = e.getFreeCameraOptions();
                if (!o.position) return !1;
                const r = o.position.toLngLat();
                return r.distanceTo(i) < .9 * r.distanceTo(this._lngLat);
            }
            _evaluateOpacity() {
                const t1 = this._map;
                if (!t1) return;
                const i = this._pos;
                if (!i || i.x < 0 || i.x > t1.transform.width || i.y < 0 || i.y > t1.transform.height) return void this._clearFadeTimer();
                const o = t1.unproject(i);
                let r;
                t1._showingGlobe() && e.d9(t1.transform, this._lngLat) ? r = 0 : (r = 1 - t1._queryFogOpacity(o), t1.transform._terrainEnabled() && t1.getTerrain() && this._behindTerrain() && (r *= this._occludedOpacity)), this._element.style.opacity = `${r}`, this._element.style.pointerEvents = r > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r), this._fadeTimer = null;
            }
            _clearFadeTimer() {
                this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
            }
            _updateDOM() {
                const e = this._pos;
                if (!e || !this._map) return;
                const t1 = this._offset.mult(this._scale);
                this._element.style.transform = `\n            translate(${e.x}px,${e.y}px)\n            ${kn[this._anchor]}\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${t1.x}px,${t1.y}px)\n        `;
            }
            _calculateXYTransform() {
                const t1 = this._pos, i = this._map, o = this.getPitchAlignment();
                if (!i || !t1 || "map" !== o) return "";
                if (!i._showingGlobe()) {
                    const e = i.getPitch();
                    return e ? `rotateX(${e}deg)` : "";
                }
                const r = e.b0(e.da(i.transform, this._lngLat)), a = t1.sub(e.db(i.transform)), n = Math.abs(a.x) + Math.abs(a.y);
                if (0 === n) return "";
                const s = r / n;
                return `rotateX(${-a.y * s}deg) rotateY(${a.x * s}deg)`;
            }
            _calculateZTransform() {
                const t1 = this._pos, i = this._map;
                if (!i || !t1) return "";
                let o = 0;
                const r = this.getRotationAlignment();
                if ("map" === r) {
                    if (i._showingGlobe()) {
                        const t1 = i.project(new e.aI(this._lngLat.lng, this._lngLat.lat + .001)), r = i.project(new e.aI(this._lngLat.lng, this._lngLat.lat - .001)).sub(t1);
                        o = e.b0(Math.atan2(r.y, r.x)) - 90;
                    } else o = -i.getBearing();
                } else if ("horizon" === r) {
                    const r = e.$(4, 6, i.getZoom()), a = e.db(i.transform);
                    a.y += r * i.transform.height;
                    const n = t1.sub(a), s = e.b0(Math.atan2(n.y, n.x));
                    o = (s > 90 ? s - 270 : s + 90) * (1 - r);
                }
                return o += this._rotation, o ? `rotateZ(${o}deg)` : "";
            }
            _update(e) {
                cancelAnimationFrame(this._updateFrameId);
                const t1 = this._map;
                t1 && (t1.transform.renderWorldCopies && (this._lngLat = Bn(this._lngLat, this._pos, t1.transform)), this._pos = t1.project(this._lngLat), !0 === e ? this._updateFrameId = requestAnimationFrame(()=>{
                    this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
                }) : this._pos = this._pos.round(), t1._requestDomTask(()=>{
                    this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (t1._showingGlobe() || t1.getTerrain() || t1.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
                }));
            }
            getOffset() {
                return this._offset;
            }
            setOffset(t1) {
                return this._offset = e.P.convert(t1), this._update(), this;
            }
            addClassName(e) {
                return this._element.classList.add(e), this;
            }
            removeClassName(e) {
                return this._element.classList.remove(e), this;
            }
            toggleClassName(e) {
                return this._element.classList.toggle(e);
            }
            _onMove(t1) {
                const i = this._map;
                if (!i) return;
                const o = this._pointerdownPos, r = this._positionDelta;
                if (o && r) {
                    if (!this._isDragging) {
                        const e = this._clickTolerance || i._clickTolerance;
                        if (t1.point.dist(o) < e) return;
                        this._isDragging = !0;
                    }
                    this._pos = t1.point.sub(r), this._lngLat = i.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.f("dragstart"))), this.fire(new e.f("drag"));
                }
            }
            _onUp() {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;
                const t1 = this._map;
                t1 && (t1.off("mousemove", this._onMove), t1.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e.f("dragend")), this._state = "inactive";
            }
            _addDragHandler(e) {
                const t1 = this._map, i = this._pos;
                t1 && i && this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(i), this._pointerdownPos = e.point, this._state = "pending", t1.on("mousemove", this._onMove), t1.on("touchmove", this._onMove), t1.once("mouseup", this._onUp), t1.once("touchend", this._onUp));
            }
            setDraggable(e) {
                this._draggable = !!e;
                const t1 = this._map;
                return t1 && (e ? (t1.on("mousedown", this._addDragHandler), t1.on("touchstart", this._addDragHandler)) : (t1.off("mousedown", this._addDragHandler), t1.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
                return this._draggable;
            }
            setRotation(e) {
                return this._rotation = e || 0, this._update(), this;
            }
            getRotation() {
                return this._rotation;
            }
            setRotationAlignment(e) {
                return this._rotationAlignment = e || "auto", this._update(), this;
            }
            getRotationAlignment() {
                return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
            }
            setPitchAlignment(e) {
                return this._pitchAlignment = e || "auto", this._update(), this;
            }
            getPitchAlignment() {
                return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
            }
            setOccludedOpacity(e) {
                return this._occludedOpacity = e || .2, this._update(), this;
            }
            getOccludedOpacity() {
                return this._occludedOpacity;
            }
        }
        const Un = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px"
        }, Gn = [
            "a[href]",
            "[tabindex]:not([tabindex='-1'])",
            "[contenteditable]:not([contenteditable='false'])",
            "button:not([disabled])",
            "input:not([disabled])",
            "select:not([disabled])",
            "textarea:not([disabled])"
        ].join(", ");
        function jn(t1 = new e.P(0, 0), i = "bottom") {
            if ("number" == typeof t1) {
                const o = Math.round(Math.sqrt(.5 * Math.pow(t1, 2)));
                switch(i){
                    case "top":
                        return new e.P(0, t1);
                    case "top-left":
                        return new e.P(o, o);
                    case "top-right":
                        return new e.P(-o, o);
                    case "bottom":
                        return new e.P(0, -t1);
                    case "bottom-left":
                        return new e.P(o, -o);
                    case "bottom-right":
                        return new e.P(-o, -o);
                    case "left":
                        return new e.P(t1, 0);
                    case "right":
                        return new e.P(-t1, 0);
                }
                return new e.P(0, 0);
            }
            return t1 instanceof e.P || Array.isArray(t1) ? e.P.convert(t1) : e.P.convert(t1[i] || [
                0,
                0
            ]);
        }
        class Vn {
            constructor(e){
                this.jumpTo(e);
            }
            getValue(t1) {
                if (t1 <= this._startTime) return this._start;
                if (t1 >= this._endTime) return this._end;
                const i = e.b9((t1 - this._startTime) / (this._endTime - this._startTime));
                return this._start * (1 - i) + this._end * i;
            }
            isEasing(e) {
                return e >= this._startTime && e <= this._endTime;
            }
            jumpTo(e) {
                this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e, this._end = e;
            }
            easeTo(e, t1, i) {
                this._start = this.getValue(t1), this._end = e, this._startTime = t1, this._endTime = t1 + i;
            }
        }
        const Wn = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "Mapbox logo",
            "Map.Title": "Map",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
            "ScrollZoomBlocker.CmdMessage": "Use \u2318 + scroll to zoom the map",
            "TouchPanBlocker.Message": "Use two fingers to move the map"
        };
        class Zn {
            registerParameter() {}
            registerButton() {}
            registerBinding() {}
            refreshUI() {}
        }
        const qn = {
            center: [
                0,
                0
            ],
            zoom: 0,
            bearing: 0,
            pitch: 0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 85,
            interactive: !0,
            scrollZoom: !0,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            performanceMetricsCollection: !0,
            bearingSnap: 7,
            clickTolerance: 3,
            pitchWithRotate: !0,
            hash: !1,
            attributionControl: !0,
            antialias: !1,
            failIfMajorPerformanceCaveat: !1,
            preserveDrawingBuffer: !1,
            trackResize: !0,
            renderWorldCopies: !0,
            refreshExpiredTiles: !0,
            minTileCacheSize: null,
            maxTileCacheSize: null,
            localIdeographFontFamily: "sans-serif",
            localFontFamily: null,
            transformRequest: null,
            accessToken: null,
            fadeDuration: 300,
            respectPrefersReducedMotion: !0,
            crossSourceCollisions: !0,
            collectResourceTiming: !1,
            testMode: !1
        }, Hn = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1
        };
        class $n {
            constructor(t1, i, o = !1){
                this._clickTolerance = 10, this.element = i, this.mouseRotate = new rn({
                    clickTolerance: t1.dragRotate._mouseRotate._clickTolerance
                }), this.map = t1, o && (this.mousePitch = new an({
                    clickTolerance: t1.dragRotate._mousePitch._clickTolerance
                })), e.bp([
                    "mousedown",
                    "mousemove",
                    "mouseup",
                    "touchstart",
                    "touchmove",
                    "touchend",
                    "reset"
                ], this), i.addEventListener("mousedown", this.mousedown), i.addEventListener("touchstart", this.touchstart, {
                    passive: !1
                }), i.addEventListener("touchmove", this.touchmove), i.addEventListener("touchend", this.touchend), i.addEventListener("touchcancel", this.reset);
            }
            down(e, t1) {
                this.mouseRotate.mousedown(e, t1), this.mousePitch && this.mousePitch.mousedown(e, t1), h();
            }
            move(e, t1) {
                const i = this.map, o = this.mouseRotate.mousemoveWindow(e, t1), r = o && o.bearingDelta;
                if (r && i.setBearing(i.getBearing() + r), this.mousePitch) {
                    const o = this.mousePitch.mousemoveWindow(e, t1), r = o && o.pitchDelta;
                    r && i.setPitch(i.getPitch() + r);
                }
            }
            off() {
                const e = this.element;
                e.removeEventListener("mousedown", this.mousedown), e.removeEventListener("touchstart", this.touchstart, {
                    passive: !1
                }), e.removeEventListener("touchmove", this.touchmove), e.removeEventListener("touchend", this.touchend), e.removeEventListener("touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
                _(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
            }
            mousedown(t1) {
                this.down(e.W({}, t1, {
                    ctrlKey: !0,
                    preventDefault: ()=>t1.preventDefault()
                }), p(this.element, t1)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
            }
            mousemove(e) {
                this.move(e, p(this.element, e));
            }
            mouseup(e) {
                this.mouseRotate.mouseupWindow(e), this.mousePitch && this.mousePitch.mouseupWindow(e), this.offTemp();
            }
            touchstart(e) {
                1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = f(this.element, e.targetTouches)[0], this.down({
                    type: "mousedown",
                    button: 0,
                    ctrlKey: !0,
                    preventDefault: ()=>e.preventDefault()
                }, this._startPos));
            }
            touchmove(e) {
                1 !== e.targetTouches.length ? this.reset() : (this._lastPos = f(this.element, e.targetTouches)[0], this.move({
                    preventDefault: ()=>e.preventDefault()
                }, this._lastPos));
            }
            touchend(e) {
                0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
            }
            reset() {
                this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }
        }
        const Xn = {
            positionOptions: {
                enableHighAccuracy: !1,
                maximumAge: 0,
                timeout: 6e3
            },
            fitBoundsOptions: {
                maxZoom: 15
            },
            trackUserLocation: !1,
            showAccuracyCircle: !0,
            showUserLocation: !0,
            showUserHeading: !1
        }, Yn = {
            maxWidth: 100,
            unit: "metric"
        }, Kn = {
            kilometer: "km",
            meter: "m",
            mile: "mi",
            foot: "ft",
            "nautical-mile": "nm"
        }, Qn = {
            version: e.dt,
            supported: i,
            setRTLTextPlugin: e.dv,
            getRTLTextPluginStatus: e.dw,
            Map: class extends Mn {
                constructor(t1){
                    e.dc.mark(e.dd.create);
                    const i = t1;
                    if (null != (t1 = e.W({}, qn, t1)).minZoom && null != t1.maxZoom && t1.minZoom > t1.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
                    if (null != t1.minPitch && null != t1.maxPitch && t1.minPitch > t1.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
                    if (null != t1.minPitch && t1.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (null != t1.maxPitch && t1.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (t1.antialias && e.de(window) && (t1.antialias = !1, e.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new di(t1.minZoom, t1.maxZoom, t1.minPitch, t1.maxPitch, t1.renderWorldCopies), t1), this._repaint = !!t1.repaint, this._interactive = t1.interactive, this._minTileCacheSize = t1.minTileCacheSize, this._maxTileCacheSize = t1.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t1.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t1.preserveDrawingBuffer, this._antialias = t1.antialias, this._trackResize = t1.trackResize, this._bearingSnap = t1.bearingSnap, this._refreshExpiredTiles = t1.refreshExpiredTiles, this._fadeDuration = t1.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t1.crossSourceCollisions, this._collectResourceTiming = t1.collectResourceTiming, this._language = this._parseLanguage(t1.language), this._worldview = t1.worldview, this._renderTaskQueue = new Fn, this._domRenderTaskQueue = new Fn, this._controls = [], this._markers = [], this._popups = [], this._mapId = e.df(), this._locale = e.W({}, Wn, t1.locale), this._clickTolerance = t1.clickTolerance, this._cooperativeGestures = t1.cooperativeGestures, this._performanceMetricsCollection = t1.performanceMetricsCollection, this._tessellationStep = t1.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = !0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new Vn(0), this._interactionRange = [
                        1 / 0,
                        -1 / 0
                    ], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._frameId = 0, this._lastDirtyFrameId = 0, this._requestManager = new e.dg(t1.transformRequest, t1.accessToken, t1.testMode), this._silenceAuthErrors = !!t1.testMode, this._contextCreateOptions = t1.contextCreateOptions ? {
                        ...t1.contextCreateOptions
                    } : {}, "string" == typeof t1.container) {
                        const e = document.getElementById(t1.container);
                        if (!e) throw new Error(`Container '${t1.container.toString()}' not found.`);
                        this._container = e;
                    } else {
                        if (!(t1.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                        this._container = t1.container;
                    }
                    if (this._container.childNodes.length > 0 && e.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t1.maxBounds && this.setMaxBounds(t1.maxBounds), e.bp([
                        "_onWindowOnline",
                        "_onWindowResize",
                        "_onVisibilityChange",
                        "_onMapScroll",
                        "_contextLost",
                        "_contextRestored"
                    ], this), this._setupContainer(), this._tp || (this._tp = new Zn), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showOverdrawInspector"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showTileBoundaries"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showParseStatus"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "repaint"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showTileAABBs"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showPadding"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showCollisionBoxes", {
                        noSave: !0
                    }), this._tp.registerParameter(this.transform, [
                        "Debug"
                    ], "freezeTileCoverage", {
                        noSave: !0
                    }, ()=>{
                        this._update();
                    }), this._tp.registerParameter(this, [
                        "Debug",
                        "Wireframe"
                    ], "showTerrainWireframe"), this._tp.registerParameter(this, [
                        "Debug",
                        "Wireframe"
                    ], "showLayers2DWireframe"), this._tp.registerParameter(this, [
                        "Debug",
                        "Wireframe"
                    ], "showLayers3DWireframe"), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");
                    if (this.on("move", ()=>this._update(!1)), this.on("moveend", ()=>this._update(!1)), this.on("zoom", ()=>this._update(!0)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, !1), window.addEventListener("resize", this._onWindowResize, !1), window.addEventListener("orientationchange", this._onWindowResize, !1), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.addEventListener("visibilitychange", this._onVisibilityChange, !1), this.handlers = new Rn(this, t1), this._localFontFamily = t1.localFontFamily, this._localIdeographFontFamily = t1.localIdeographFontFamily, (t1.style || !t1.testMode) && this.setStyle(t1.style || e.d8.DEFAULT_STYLE, {
                        config: t1.config,
                        localFontFamily: this._localFontFamily,
                        localIdeographFontFamily: this._localIdeographFontFamily
                    }), t1.projection && this.setProjection(t1.projection), t1.hash && (this._hash = new za("string" == typeof t1.hash && t1.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
                        null == i.center && null == i.zoom || (this.transform._unmodified = !1), this.jumpTo({
                            center: t1.center,
                            zoom: t1.zoom,
                            bearing: t1.bearing,
                            pitch: t1.pitch
                        });
                        const o = t1.bounds;
                        o && (this.resize(), this.fitBounds(o, e.W({}, t1.fitBoundsOptions, {
                            duration: 0
                        })));
                    }
                    this.resize(), t1.attributionControl && this.addControl(new zn({
                        customAttribution: t1.customAttribution
                    })), this._logoControl = new On, this.addControl(this._logoControl, t1.logoPosition), this.on("style.load", ()=>{
                        this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent();
                    }), this.on("data", (t1)=>{
                        this._update("style" === t1.dataType), this.fire(new e.f(`${t1.dataType}data`, t1));
                    }), this.on("dataloading", (t1)=>{
                        this.fire(new e.f(`${t1.dataType}dataloading`, t1));
                    });
                }
                _getMapId() {
                    return this._mapId;
                }
                addControl(t1, i) {
                    if (void 0 === i && (i = t1.getDefaultPosition ? t1.getDefaultPosition() : "top-right"), !t1 || !t1.onAdd) return this.fire(new e.d(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const o = t1.onAdd(this);
                    this._controls.push(t1);
                    const r = this._controlPositions[i];
                    return -1 !== i.indexOf("bottom") ? r.insertBefore(o, r.firstChild) : r.appendChild(o), this;
                }
                removeControl(t1) {
                    if (!t1 || !t1.onRemove) return this.fire(new e.d(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const i = this._controls.indexOf(t1);
                    return i > -1 && this._controls.splice(i, 1), t1.onRemove(this), this;
                }
                hasControl(e) {
                    return this._controls.indexOf(e) > -1;
                }
                getContainer() {
                    return this._container;
                }
                getCanvasContainer() {
                    return this._canvasContainer;
                }
                getCanvas() {
                    return this._canvas;
                }
                resize(t1) {
                    if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
                    this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
                    const i = !this._moving;
                    return i && this.fire(new e.f("movestart", t1)).fire(new e.f("move", t1)), this.fire(new e.f("resize", t1)), i && this.fire(new e.f("moveend", t1)), this;
                }
                getBounds() {
                    return this.transform.getBounds();
                }
                getMaxBounds() {
                    return this.transform.getMaxBounds() || null;
                }
                setMaxBounds(t1) {
                    return this.transform.setMaxBounds(e.ai.convert(t1)), this._update();
                }
                setMinZoom(t1) {
                    if ((t1 = t1 ?? -2) >= -2 && t1 <= this.transform.maxZoom) return this.transform.minZoom = t1, this._update(), this.getZoom() < t1 ? this.setZoom(t1) : this.fire(new e.f("zoomstart")).fire(new e.f("zoom")).fire(new e.f("zoomend")), this;
                    throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
                }
                getMinZoom() {
                    return this.transform.minZoom;
                }
                setMaxZoom(t1) {
                    if ((t1 = t1 ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = t1, this._update(), this.getZoom() > t1 ? this.setZoom(t1) : this.fire(new e.f("zoomstart")).fire(new e.f("zoom")).fire(new e.f("zoomend")), this;
                    throw new Error("maxZoom must be greater than the current minZoom");
                }
                getMaxZoom() {
                    return this.transform.maxZoom;
                }
                setMinPitch(t1) {
                    if ((t1 = t1 ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (t1 >= 0 && t1 <= this.transform.maxPitch) return this.transform.minPitch = t1, this._update(), this.getPitch() < t1 ? this.setPitch(t1) : this.fire(new e.f("pitchstart")).fire(new e.f("pitch")).fire(new e.f("pitchend")), this;
                    throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
                }
                getMinPitch() {
                    return this.transform.minPitch;
                }
                setMaxPitch(t1) {
                    if ((t1 = t1 ?? 85) > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (t1 >= this.transform.minPitch) return this.transform.maxPitch = t1, this._update(), this.getPitch() > t1 ? this.setPitch(t1) : this.fire(new e.f("pitchstart")).fire(new e.f("pitch")).fire(new e.f("pitchend")), this;
                    throw new Error("maxPitch must be greater than or equal to minPitch");
                }
                getMaxPitch() {
                    return this.transform.maxPitch;
                }
                getRenderWorldCopies() {
                    return this.transform.renderWorldCopies;
                }
                setRenderWorldCopies(e) {
                    return this.transform.renderWorldCopies = e, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();
                }
                getLanguage() {
                    return this._language;
                }
                _parseLanguage(e) {
                    return "auto" === e ? navigator.language : Array.isArray(e) ? 0 === e.length ? void 0 : e.map((e)=>"auto" === e ? navigator.language : e) : e;
                }
                setLanguage(e) {
                    const t1 = this._parseLanguage(e);
                    if (!this.style || t1 === this._language) return this;
                    this._language = t1, this.style.reloadSources();
                    for (const e of this._controls)e._setLanguage && e._setLanguage(this._language);
                    return this;
                }
                getWorldview() {
                    return this._worldview;
                }
                setWorldview(e) {
                    return this.style && e !== this._worldview ? (this._worldview = e, this.style.reloadSources(), this) : this;
                }
                getProjection() {
                    return this.transform.mercatorFromTransition ? {
                        name: "globe",
                        center: [
                            0,
                            0
                        ]
                    } : this.transform.getProjection();
                }
                _showingGlobe() {
                    return "globe" === this.transform.projection.name;
                }
                setProjection(e) {
                    return this._lazyInitEmptyStyle(), e ? "string" == typeof e && (e = {
                        name: e
                    }) : e = null, this._useExplicitProjection = !!e, this._prioritizeAndUpdateProjection(e, this.style.projection);
                }
                _updateProjectionTransition() {
                    if ("globe" !== this.getProjection().name) return;
                    const t1 = this.transform, i = t1.projection.name;
                    let o;
                    "globe" === i && t1.zoom >= e.aU ? (t1.setMercatorFromTransition(), o = !0) : "mercator" === i && t1.zoom < e.aU && (t1.setProjection({
                        name: "globe"
                    }), o = !0), o && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
                }
                _prioritizeAndUpdateProjection(e, t1) {
                    return this._updateProjection(e || t1 || {
                        name: "mercator"
                    });
                }
                _updateProjection(t1) {
                    let i;
                    return i = "globe" === t1.name && this.transform.zoom >= e.aU ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t1), this.style.applyProjectionUpdate(), i && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(!0), this._forceMarkerAndPopupUpdate(!0)), this;
                }
                project(t1) {
                    return this.transform.locationPoint3D(e.aI.convert(t1));
                }
                unproject(t1) {
                    return this.transform.pointLocation3D(e.P.convert(t1));
                }
                isMoving() {
                    return this._moving || this.handlers && this.handlers.isMoving() || !1;
                }
                isZooming() {
                    return this._zooming || this.handlers && this.handlers.isZooming() || !1;
                }
                isRotating() {
                    return this._rotating || this.handlers && this.handlers.isRotating() || !1;
                }
                _isDragging() {
                    return this.handlers && this.handlers._isDragging() || !1;
                }
                _createDelegatedListener(e, t1, i) {
                    if ("mouseenter" === e || "mouseover" === e) {
                        let o = !1;
                        const r = (r)=>{
                            const a = t1.filter((e)=>this.getLayer(e)), n = a.length ? this.queryRenderedFeatures(r.point, {
                                layers: a
                            }) : [];
                            n.length ? o || (o = !0, i.call(this, new Wa(e, this, r.originalEvent, {
                                features: n
                            }))) : o = !1;
                        }, a = ()=>{
                            o = !1;
                        };
                        return {
                            layers: new Set(t1),
                            listener: i,
                            delegates: {
                                mousemove: r,
                                mouseout: a
                            }
                        };
                    }
                    if ("mouseleave" === e || "mouseout" === e) {
                        let o = !1;
                        const r = (r)=>{
                            const a = t1.filter((e)=>this.getLayer(e));
                            (a.length ? this.queryRenderedFeatures(r.point, {
                                layers: a
                            }) : []).length ? o = !0 : o && (o = !1, i.call(this, new Wa(e, this, r.originalEvent)));
                        }, a = (t1)=>{
                            o && (o = !1, i.call(this, new Wa(e, this, t1.originalEvent)));
                        };
                        return {
                            layers: new Set(t1),
                            listener: i,
                            delegates: {
                                mousemove: r,
                                mouseout: a
                            }
                        };
                    }
                    {
                        const o = (e)=>{
                            const o = t1.filter((e)=>this.getLayer(e)), r = o.length ? this.queryRenderedFeatures(e.point, {
                                layers: o
                            }) : [];
                            r.length && (e.features = r, i.call(this, e), delete e.features);
                        };
                        return {
                            layers: new Set(t1),
                            listener: i,
                            delegates: {
                                [e]: o
                            }
                        };
                    }
                }
                on(e, t1, i) {
                    if ("function" == typeof t1 || void 0 === i) return super.on(e, t1);
                    if (Array.isArray(t1) || (t1 = [
                        t1
                    ]), t1) {
                        for (const e of t1)if (!this._isValidId(e)) return this;
                    }
                    const o = this._createDelegatedListener(e, t1, i);
                    this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(o);
                    for(const e in o.delegates)this.on(e, o.delegates[e]);
                    return this;
                }
                once(e, t1, i) {
                    if ("function" == typeof t1 || void 0 === i) return super.once(e, t1);
                    if (Array.isArray(t1) || (t1 = [
                        t1
                    ]), t1) {
                        for (const e of t1)if (!this._isValidId(e)) return this;
                    }
                    const o = this._createDelegatedListener(e, t1, i);
                    for(const e in o.delegates)this.once(e, o.delegates[e]);
                    return this;
                }
                off(e, t1, i) {
                    if ("function" == typeof t1 || void 0 === i) return super.off(e, t1);
                    const o = new Set(Array.isArray(t1) ? t1 : [
                        t1
                    ]);
                    for (const e of o)if (!this._isValidId(e)) return this;
                    const r = (e, t1)=>{
                        if (e.size !== t1.size) return !1;
                        for (const i of e)if (!t1.has(i)) return !1;
                        return !0;
                    }, a = this._delegatedListeners ? this._delegatedListeners[e] : void 0;
                    return a && ((e)=>{
                        for(let t1 = 0; t1 < e.length; t1++){
                            const a = e[t1];
                            if (a.listener === i && r(a.layers, o)) {
                                for(const e in a.delegates)this.off(e, a.delegates[e]);
                                return e.splice(t1, 1), this;
                            }
                        }
                    })(a), this;
                }
                queryRenderedFeatures(t1, i) {
                    if (!this.style) return [];
                    if (void 0 !== i || void 0 === t1 || t1 instanceof e.P || Array.isArray(t1) || (i = t1, t1 = void 0), t1 = t1 || [
                        [
                            0,
                            0
                        ],
                        [
                            this.transform.width,
                            this.transform.height
                        ]
                    ], (i = i || {}).layers && Array.isArray(i.layers)) {
                        for (const e of i.layers)if (!this._isValidId(e)) return [];
                    }
                    return this.style.queryRenderedFeatures(t1, i, this.transform);
                }
                querySourceFeatures(e, t1) {
                    return this._isValidId(e) ? this.style.querySourceFeatures(e, t1) : [];
                }
                isPointOnSurface(t1) {
                    const { name: i } = this.transform.projection;
                    return "globe" !== i && "mercator" !== i && e.w(`${i} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e.P.convert(t1));
                }
                setStyle(t1, i) {
                    return i = e.W({}, {
                        localIdeographFontFamily: this._localIdeographFontFamily,
                        localFontFamily: this._localFontFamily
                    }, i), this.style && t1 && !1 !== i.diff && i.localFontFamily === this._localFontFamily && i.localIdeographFontFamily === this._localIdeographFontFamily && !i.config ? (this.style._diffStyle(t1, (o, r)=>{
                        o ? (e.w(`Unable to perform style diff: ${String(o.message || o.error || o)}. Rebuilding the style from scratch.`), this._updateStyle(t1, i)) : r && this._update(!0);
                    }, ()=>{
                        this._postStyleLoadEvent();
                    }), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._localFontFamily = i.localFontFamily, this._updateStyle(t1, i));
                }
                _getUIString(e) {
                    const t1 = this._locale[e];
                    if (null == t1) throw new Error(`Missing UI string '${e}'`);
                    return t1;
                }
                _updateStyle(t1, i) {
                    if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), t1) {
                        const o = e.W({}, i);
                        i && i.config && (o.initialConfig = i.config, delete o.config), this.style = new Da(this, o).load(t1), this.style.setEventedParent(this, {
                            style: this.style
                        });
                    }
                    return this._updateTerrain(), this;
                }
                _lazyInitEmptyStyle() {
                    this.style || (this.style = new Da(this, {}), this.style.setEventedParent(this, {
                        style: this.style
                    }), this.style.loadEmpty());
                }
                getStyle() {
                    if (this.style) return this.style.serialize();
                }
                isStyleLoaded() {
                    return this.style ? this.style.loaded() : (e.w("There is no style added to the map."), !1);
                }
                _isValidId(t1) {
                    return null == t1 ? (this.fire(new e.d(new Error("IDs can't be empty."))), !1) : !e.cV(t1) || (this.fire(new e.d(new Error(`IDs can't contain special symbols: "${t1}".`))), !1);
                }
                addSource(e, t1) {
                    return this._isValidId(e) ? (this._lazyInitEmptyStyle(), this.style.addSource(e, t1), this._update(!0)) : this;
                }
                isSourceLoaded(e) {
                    return !!this._isValidId(e) && !!this.style && this.style._isSourceCacheLoaded(e);
                }
                areTilesLoaded() {
                    return this.style.areTilesLoaded();
                }
                addSourceType(e, t1, i) {
                    this._lazyInitEmptyStyle(), this.style.addSourceType(e, t1, i);
                }
                removeSource(e) {
                    return this._isValidId(e) ? (this.style.removeSource(e), this._updateTerrain(), this._update(!0)) : this;
                }
                getSource(e) {
                    return this._isValidId(e) ? this.style.getOwnSource(e) : null;
                }
                addImage(t1, i, { pixelRatio: o = 1, sdf: r = !1, stretchX: a, stretchY: n, content: s } = {}) {
                    if (this._lazyInitEmptyStyle(), i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap) {
                        const { width: l, height: c, data: h } = e.e.getImageData(i);
                        this.style.addImage(t1, {
                            data: new e.i({
                                width: l,
                                height: c
                            }, h),
                            pixelRatio: o,
                            stretchX: a,
                            stretchY: n,
                            content: s,
                            sdf: r,
                            version: 0
                        });
                    } else if (void 0 === i.width || void 0 === i.height) this.fire(new e.d(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                    else {
                        const { width: l, height: c } = i, h = i;
                        this.style.addImage(t1, {
                            data: new e.i({
                                width: l,
                                height: c
                            }, new Uint8Array(h.data)),
                            pixelRatio: o,
                            stretchX: a,
                            stretchY: n,
                            content: s,
                            sdf: r,
                            version: 0,
                            userImage: h
                        }), h.onAdd && h.onAdd(this, t1);
                    }
                }
                updateImage(t1, i) {
                    this._lazyInitEmptyStyle();
                    const o = this.style.getImage(t1);
                    if (!o) return void this.fire(new e.d(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                    const r = i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap ? e.e.getImageData(i) : i, { width: a, height: n, data: s } = r;
                    if (void 0 === a || void 0 === n) return void this.fire(new e.d(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                    if (a !== o.data.width || n !== o.data.height) return void this.fire(new e.d(new Error(`The width and height of the updated image (${a}, ${n})\n                must be that same as the previous version of the image\n                (${o.data.width}, ${o.data.height})`)));
                    const l = !(i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap);
                    o.data.replace(s, l), this.style.updateImage(t1, o);
                }
                hasImage(t1) {
                    return t1 ? !!this.style && !!this.style.getImage(t1) : (this.fire(new e.d(new Error("Missing required image id"))), !1);
                }
                removeImage(e) {
                    this.style.removeImage(e);
                }
                loadImage(t1, i) {
                    e.h(this._requestManager.transformRequest(t1, e.R.Image), (t1, o)=>{
                        i(t1, o instanceof HTMLImageElement ? e.e.getImageData(o) : o);
                    });
                }
                listImages() {
                    return this.style.listImages();
                }
                addModel(e, t1) {
                    this._lazyInitEmptyStyle(), this.style.addModel(e, t1);
                }
                hasModel(t1) {
                    return t1 ? this.style.hasModel(t1) : (this.fire(new e.d(new Error("Missing required model id"))), !1);
                }
                removeModel(e) {
                    this.style.removeModel(e);
                }
                listModels() {
                    return this.style.listModels();
                }
                addLayer(e, t1) {
                    return this._isValidId(e.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e, t1), this._update(!0)) : this;
                }
                getSlot(e) {
                    const t1 = this.getLayer(e);
                    return t1 && t1.slot || null;
                }
                setSlot(e, t1) {
                    return this.style.setSlot(e, t1), this.style.mergeLayers(), this._update(!0);
                }
                addImport(e, t1) {
                    return this.style.addImport(e, t1), this;
                }
                updateImport(e, t1) {
                    return "string" != typeof t1 && t1.id !== e ? (this.removeImport(e), this.addImport(t1)) : (this.style.updateImport(e, t1), this._update(!0));
                }
                removeImport(e) {
                    return this.style.removeImport(e), this;
                }
                moveImport(e, t1) {
                    return this.style.moveImport(e, t1), this._update(!0);
                }
                moveLayer(e, t1) {
                    return this._isValidId(e) ? (this.style.moveLayer(e, t1), this._update(!0)) : this;
                }
                removeLayer(e) {
                    return this._isValidId(e) ? (this.style.removeLayer(e), this._update(!0)) : this;
                }
                getLayer(e) {
                    if (!this._isValidId(e)) return null;
                    const t1 = this.style.getOwnLayer(e);
                    return t1 ? t1.serialize() : void 0;
                }
                getSlots() {
                    return this.style.getSlots();
                }
                setLayerZoomRange(e, t1, i) {
                    return this._isValidId(e) ? (this.style.setLayerZoomRange(e, t1, i), this._update(!0)) : this;
                }
                setFilter(e, t1, i = {}) {
                    return this._isValidId(e) ? (this.style.setFilter(e, t1, i), this._update(!0)) : this;
                }
                getFilter(e) {
                    return this._isValidId(e) ? this.style.getFilter(e) : null;
                }
                setPaintProperty(e, t1, i, o = {}) {
                    return this._isValidId(e) ? (this.style.setPaintProperty(e, t1, i, o), this._update(!0)) : this;
                }
                getPaintProperty(e, t1) {
                    return this._isValidId(e) ? this.style.getPaintProperty(e, t1) : null;
                }
                setLayoutProperty(e, t1, i, o = {}) {
                    return this._isValidId(e) ? (this.style.setLayoutProperty(e, t1, i, o), this._update(!0)) : this;
                }
                getLayoutProperty(e, t1) {
                    return this._isValidId(e) ? this.style.getLayoutProperty(e, t1) : null;
                }
                getSchema(e) {
                    return this.style.getSchema(e);
                }
                setSchema(e, t1) {
                    return this.style.setSchema(e, t1), this._update(!0);
                }
                getConfig(e) {
                    return this.style.getConfig(e);
                }
                setConfig(e, t1) {
                    return this.style.setConfig(e, t1), this._update(!0);
                }
                getConfigProperty(e, t1) {
                    return this.style.getConfigProperty(e, t1);
                }
                setConfigProperty(e, t1, i) {
                    return this.style.setConfigProperty(e, t1, i), this._update(!0);
                }
                setLights(e) {
                    if (this._lazyInitEmptyStyle(), e && 1 === e.length && "flat" === e[0].type) {
                        const t1 = e[0];
                        t1.properties ? this.style.setFlatLight(t1.properties, t1.id, {}) : this.style.setFlatLight({}, "flat");
                    } else this.style.setLights(e), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = !0);
                    return this._update(!0);
                }
                getLights() {
                    const e = this.style.getLights() || [];
                    return 0 === e.length && e.push({
                        id: this.style.light.id,
                        type: "flat",
                        properties: this.style.getFlatLight()
                    }), e;
                }
                setLight(e, t1 = {}) {
                    return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([
                        {
                            id: "flat",
                            type: "flat",
                            properties: e
                        }
                    ]);
                }
                getLight() {
                    return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
                }
                setTerrain(e) {
                    return this._lazyInitEmptyStyle(), !e && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);
                }
                getTerrain() {
                    return this.style ? this.style.getTerrain() : null;
                }
                setFog(e) {
                    return this._lazyInitEmptyStyle(), this.style.setFog(e), this._update(!0);
                }
                getFog() {
                    return this.style ? this.style.getFog() : null;
                }
                setColorTheme(e) {
                    return this._lazyInitEmptyStyle(), this.style.setColorTheme(e), this._update(!0);
                }
                setCamera(e) {
                    return this.style.setCamera(e), this._triggerCameraUpdate(e);
                }
                _triggerCameraUpdate(e) {
                    return this._update(this.transform.setOrthographicProjectionAtLowPitch("orthographic" === e["camera-projection"]));
                }
                getCamera() {
                    return this.style.camera;
                }
                _queryFogOpacity(t1) {
                    return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.aI.convert(t1), this.transform) : 0;
                }
                setFeatureState(e, t1) {
                    return this._isValidId(e.source) ? (this.style.setFeatureState(e, t1), this._update()) : this;
                }
                removeFeatureState(e, t1) {
                    return this._isValidId(e.source) ? (this.style.removeFeatureState(e, t1), this._update()) : this;
                }
                getFeatureState(e) {
                    return this._isValidId(e.source) ? this.style.getFeatureState(e) : null;
                }
                _updateContainerDimensions() {
                    if (!this._container) return;
                    const e = this._container.getBoundingClientRect().width || 400, t1 = this._container.getBoundingClientRect().height || 300;
                    let i, o, r, a = this._container;
                    for(; a && (!o || !r);){
                        const e = window.getComputedStyle(a).transform;
                        e && "none" !== e && (i = e.match(/matrix.*\((.+)\)/)[1].split(", "), i[0] && "0" !== i[0] && "1" !== i[0] && (o = i[0]), i[3] && "0" !== i[3] && "1" !== i[3] && (r = i[3])), a = a.parentElement;
                    }
                    this._containerWidth = o ? Math.abs(e / o) : e, this._containerHeight = r ? Math.abs(t1 / r) : t1;
                }
                _detectMissingCSS() {
                    "rgb(250, 128, 114)" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
                }
                _setupContainer() {
                    const e = this._container;
                    e.classList.add("mapboxgl-map"), (this._missingCSSCanary = a("div", "mapboxgl-canary", e)).style.visibility = "hidden", this._detectMissingCSS();
                    const t1 = this._canvasContainer = a("div", "mapboxgl-canvas-container", e);
                    this._canvas = a("canvas", "mapboxgl-canvas", t1), this._interactive && (t1.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
                    const i = this._controlContainer = a("div", "mapboxgl-control-container", e), o = this._controlPositions = {};
                    [
                        "top-left",
                        "top-right",
                        "bottom-left",
                        "bottom-right"
                    ].forEach((e)=>{
                        o[e] = a("div", `mapboxgl-ctrl-${e}`, i);
                    }), this._container.addEventListener("scroll", this._onMapScroll, !1);
                }
                _resizeCanvas(t1, i) {
                    const o = e.e.devicePixelRatio || 1;
                    this._canvas.width = o * Math.ceil(t1), this._canvas.height = o * Math.ceil(i), this._canvas.style.width = `${t1}px`, this._canvas.style.height = `${i}px`;
                }
                _addMarker(e) {
                    this._markers.push(e);
                }
                _removeMarker(e) {
                    const t1 = this._markers.indexOf(e);
                    -1 !== t1 && this._markers.splice(t1, 1);
                }
                _addPopup(e) {
                    this._popups.push(e);
                }
                _removePopup(e) {
                    const t1 = this._popups.indexOf(e);
                    -1 !== t1 && this._popups.splice(t1, 1);
                }
                _setupPainter() {
                    const t1 = e.W({}, i.webGLContextAttributes, {
                        failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
                        preserveDrawingBuffer: this._preserveDrawingBuffer,
                        antialias: this._antialias || !1
                    }), o = this._canvas.getContext("webgl2", t1);
                    o ? (e.dh(o, !0), this.painter = new Ar(o, this._contextCreateOptions, this.transform, this._tp), this.on("data", (e)=>{
                        "source" === e.dataType && this.painter.setTileLoadedFlag(!0);
                    }), e.di.testSupport(o)) : this.fire(new e.d(new Error("Failed to initialize WebGL")));
                }
                _contextLost(t1) {
                    t1.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.f("webglcontextlost", {
                        originalEvent: t1
                    }));
                }
                _contextRestored(t1) {
                    this._setupPainter(), this.resize(), this._update(), this.fire(new e.f("webglcontextrestored", {
                        originalEvent: t1
                    }));
                }
                _onMapScroll(e) {
                    if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
                }
                loaded() {
                    return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
                }
                frameReady() {
                    return this.loaded() && !this._placementDirty && !this._occlusionOpacityChanged && this._occlusionCriteriaSatisfied();
                }
                _update(e) {
                    return this.style ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
                }
                _requestRenderFrame(e) {
                    return this._update(), this._renderTaskQueue.add(e);
                }
                _cancelRenderFrame(e) {
                    this._renderTaskQueue.remove(e);
                }
                _requestDomTask(e) {
                    !this.loaded() || this.loaded() && !this.isMoving() ? e() : this._domRenderTaskQueue.add(e);
                }
                _render(t1) {
                    let i;
                    this.fire(new e.f("renderstart")), ++this._frameId;
                    const o = this.painter.context.extTimerQuery, r = e.e.now(), a = this.painter.context.gl;
                    if (this.listens("gpu-timing-frame") && (i = a.createQuery(), a.beginQuery(o.TIME_ELAPSED_EXT, i)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(t1), this._domRenderTaskQueue.run(t1), this._removed) return;
                    this._updateProjectionTransition();
                    const n = this._isInitialLoad ? 0 : this._fadeDuration;
                    if (this.style && this._styleDirty) {
                        this._styleDirty = !1;
                        const t1 = this.transform.zoom, i = this.transform.pitch, o = e.e.now(), r = new e.X(t1, {
                            now: o,
                            fadeDuration: n,
                            pitch: i,
                            transition: this.style.transition
                        });
                        this.style.update(r);
                    }
                    this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);
                    let s = !1;
                    this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), s = this._updateAverageElevation(r), this.style.updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : s = this._updateAverageElevation(r);
                    const l = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, n, this._crossSourceCollisions, this.painter.replacementSource);
                    if (l && (this._placementDirty = l.needsRerender, this._occlusionOpacityChanged = l.occlusionQueryBasedOpacityChanged), this.style && this.painter.render(this.style, {
                        showTileBoundaries: this.showTileBoundaries,
                        showParseStatus: this.showParseStatus,
                        wireframe: {
                            terrain: this.showTerrainWireframe,
                            layers2D: this.showLayers2DWireframe,
                            layers3D: this.showLayers3DWireframe
                        },
                        showOverdrawInspector: this._showOverdrawInspector,
                        showQueryGeometry: !!this._showQueryGeometry,
                        showTileAABBs: this.showTileAABBs,
                        rotating: this.isRotating(),
                        zooming: this.isZooming(),
                        moving: this.isMoving(),
                        fadeDuration: n,
                        isInitialLoad: this._isInitialLoad,
                        showPadding: this.showPadding,
                        gpuTiming: !!this.listens("gpu-timing-layer"),
                        gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"),
                        speedIndexTiming: this.speedIndexTiming
                    }), this.fire(new e.f("render")), this.loaded() && !this._loaded && (this._loaded = !0, e.dc.mark(e.dd.load), this.fire(new e.f("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i) {
                        const t1 = e.e.now() - r;
                        a.endQuery(o.TIME_ELAPSED_EXT), setTimeout(()=>{
                            const o = a.getQueryParameter(i, a.QUERY_RESULT) / 1e6;
                            a.deleteQuery(i), this.fire(new e.f("gpu-timing-frame", {
                                cpuTime: t1,
                                gpuTime: o
                            }));
                        }, 50);
                    }
                    if (this.listens("gpu-timing-layer")) {
                        const t1 = this.painter.collectGpuTimers();
                        setTimeout(()=>{
                            const i = this.painter.queryGpuTimers(t1);
                            this.fire(new e.f("gpu-timing-layer", {
                                layerTimes: i
                            }));
                        }, 50);
                    }
                    if (this.listens("gpu-timing-deferred-render")) {
                        const t1 = this.painter.collectDeferredRenderGpuQueries();
                        setTimeout(()=>{
                            const i = this.painter.queryGpuTimeDeferredRender(t1);
                            this.fire(new e.f("gpu-timing-deferred-render", {
                                gpuTime: i
                            }));
                        }, 50);
                    }
                    const c = this._sourcesDirty || this._styleDirty || this._placementDirty || this._occlusionOpacityChanged || s;
                    if ((this._sourcesDirty || this._styleDirty || s || this._occlusionOpacityChanged) && (this._lastDirtyFrameId = this._frameId), c || this._repaint || !this._occlusionCriteriaSatisfied()) this.triggerRepaint();
                    else {
                        const t1 = !this.isMoving() && this.loaded();
                        if (t1 && (s = this._updateAverageElevation(r, !0)), s) this.triggerRepaint();
                        else if (this._triggerFrame(!1), t1 && (this.fire(new e.f("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
                            const t1 = this._calculateSpeedIndex();
                            this.fire(new e.f("speedindexcompleted", {
                                speedIndex: t1
                            })), this.speedIndexTiming = !1;
                        }
                    }
                    this._loaded && !this._fullyLoaded && !c && this._occlusionCriteriaSatisfied() && (this._fullyLoaded = !0, e.dc.mark(e.dd.fullLoad), this._performanceMetricsCollection && e.dj(this._requestManager._customAccessToken, {
                        width: this.painter.width,
                        height: this.painter.height,
                        interactionRange: this._interactionRange,
                        visibilityHidden: this._visibilityHidden,
                        terrainEnabled: !!this.painter.style.getTerrain(),
                        fogEnabled: !!this.painter.style.getFog(),
                        projection: this.getProjection().name,
                        zoom: this.transform.zoom,
                        renderer: this.painter.context.renderer,
                        vendor: this.painter.context.vendor
                    }), this._authenticate());
                }
                _forceMarkerAndPopupUpdate(e) {
                    for (const t1 of this._markers)e && !this.getRenderWorldCopies() && (t1._lngLat = t1._lngLat.wrap()), t1._update();
                    for (const t1 of this._popups)!e || this.getRenderWorldCopies() || t1._trackPointer || (t1._lngLat = t1._lngLat.wrap()), t1._update();
                }
                _updateAverageElevation(e, t1 = !1) {
                    const i = (e)=>(this.transform.averageElevation = e, this._update(!1), !0);
                    if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i(0);
                    const o = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
                    if (o || (t1 || e - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e)) {
                        const t1 = this.transform.averageElevation;
                        let r = this.transform.sampleAverageElevation();
                        null != this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(r) ? r = 0 : this._averageElevationLastSampledAt = e;
                        const a = Math.abs(t1 - r);
                        if (a > 1) {
                            if (this._isInitialLoad || o) return this._averageElevation.jumpTo(r), i(r);
                            this._averageElevation.easeTo(r, e, 300);
                        } else if (a > 1e-4) return this._averageElevation.jumpTo(r), i(r);
                    }
                    return !!this._averageElevation.isEasing(e) && i(this._averageElevation.getValue(e));
                }
                _authenticate() {
                    e.dk(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t1)=>{
                        if (t1 && (t1.message === e.dl || 401 === t1.status)) {
                            const t1 = this.painter.context.gl;
                            e.dh(t1, !1), this._logoControl instanceof On && this._logoControl._updateLogo(), t1 && t1.clear(t1.DEPTH_BUFFER_BIT | t1.COLOR_BUFFER_BIT | t1.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.d(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
                        }
                    }), e.dm(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, ()=>{});
                }
                _postStyleLoadEvent() {
                    this.style.globalId && e.dn(this._requestManager._customAccessToken, {
                        map: this,
                        skuToken: this._requestManager._skuToken,
                        style: this.style.globalId,
                        importedStyles: this.style.getImportGlobalIds()
                    });
                }
                _updateTerrain() {
                    const e = this._isDragging();
                    this.painter.updateTerrain(this.style, e);
                }
                _calculateSpeedIndex() {
                    const e = this.painter.canvasCopy(), t1 = this.painter.getCanvasCopiesAndTimestamps();
                    t1.timeStamps.push(performance.now());
                    const i = this.painter.context.gl, o = i.createFramebuffer();
                    function r(e) {
                        i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0);
                        const t1 = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);
                        return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, t1), t1;
                    }
                    return i.bindFramebuffer(i.FRAMEBUFFER, o), this._canvasPixelComparison(r(e), t1.canvasCopies.map(r), t1.timeStamps);
                }
                _canvasPixelComparison(e, t1, i) {
                    let o = i[1] - i[0];
                    const r = e.length / 4;
                    for(let a = 0; a < t1.length; a++){
                        const n = t1[a];
                        let s = 0;
                        for(let t1 = 0; t1 < n.length; t1 += 4)n[t1] === e[t1] && n[t1 + 1] === e[t1 + 1] && n[t1 + 2] === e[t1 + 2] && n[t1 + 3] === e[t1 + 3] && (s += 1);
                        o += (i[a + 2] - i[a + 1]) * (1 - s / r);
                    }
                    return o;
                }
                remove() {
                    this._hash && this._hash.remove();
                    for (const e of this._controls)e.onRemove(this);
                    this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, !1), window.removeEventListener("orientationchange", this._onWindowResize, !1), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.removeEventListener("online", this._onWindowOnline, !1), window.removeEventListener("visibilitychange", this._onVisibilityChange, !1);
                    const t1 = this.painter.context.gl.getExtension("WEBGL_lose_context");
                    t1 && t1.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), e.dp(this.painter.context.gl), e.dq.remove(), e.dr.remove(), this._removed = !0, this.fire(new e.f("remove"));
                }
                triggerRepaint() {
                    this._triggerFrame(!0);
                }
                _triggerFrame(t1) {
                    this._renderNextFrame = this._renderNextFrame || t1, this.style && !this._frame && (this._frame = e.e.frame((e)=>{
                        const t1 = !!this._renderNextFrame;
                        this._frame = null, this._renderNextFrame = null, t1 && this._render(e);
                    }));
                }
                _preloadTiles(t1) {
                    const i = this.style ? this.style.getSourceCaches() : [];
                    return e.ds(i, (e, i)=>e._preloadTiles(t1, i), ()=>{
                        this.triggerRepaint();
                    }), this;
                }
                _onWindowOnline() {
                    this._update();
                }
                _onWindowResize(e) {
                    this._trackResize && this.resize({
                        originalEvent: e
                    })._update();
                }
                _onVisibilityChange() {
                    "hidden" === document.visibilityState && this._visibilityHidden++;
                }
                get showTileBoundaries() {
                    return !!this._showTileBoundaries;
                }
                set showTileBoundaries(e) {
                    this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._tp.refreshUI(), this._update());
                }
                get showParseStatus() {
                    return !!this._showParseStatus;
                }
                set showParseStatus(e) {
                    this._showParseStatus !== e && (this._showParseStatus = e, this._tp.refreshUI(), this._update());
                }
                get showTerrainWireframe() {
                    return !!this._showTerrainWireframe;
                }
                set showTerrainWireframe(e) {
                    this._showTerrainWireframe !== e && (this._showTerrainWireframe = e, this._tp.refreshUI(), this._update());
                }
                get showLayers2DWireframe() {
                    return !!this._showLayers2DWireframe;
                }
                set showLayers2DWireframe(e) {
                    this._showLayers2DWireframe !== e && (this._showLayers2DWireframe = e, this._tp.refreshUI(), this._update());
                }
                get showLayers3DWireframe() {
                    return !!this._showLayers3DWireframe;
                }
                set showLayers3DWireframe(e) {
                    this._showLayers3DWireframe !== e && (this._showLayers3DWireframe = e, this._tp.refreshUI(), this._update());
                }
                get speedIndexTiming() {
                    return !!this._speedIndexTiming;
                }
                set speedIndexTiming(e) {
                    this._speedIndexTiming !== e && (this._speedIndexTiming = e, this._update());
                }
                get showPadding() {
                    return !!this._showPadding;
                }
                set showPadding(e) {
                    this._showPadding !== e && (this._showPadding = e, this._tp.refreshUI(), this._update());
                }
                get showCollisionBoxes() {
                    return !!this._showCollisionBoxes;
                }
                set showCollisionBoxes(e) {
                    this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, this._tp.refreshUI(), e ? this.style._generateCollisionBoxes() : this._update());
                }
                get showOverdrawInspector() {
                    return !!this._showOverdrawInspector;
                }
                set showOverdrawInspector(e) {
                    this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._tp.refreshUI(), this._update());
                }
                get repaint() {
                    return !!this._repaint;
                }
                set repaint(e) {
                    this._repaint !== e && (this._repaint = e, this._tp.refreshUI(), this.triggerRepaint());
                }
                get vertices() {
                    return !!this._vertices;
                }
                set vertices(e) {
                    this._vertices = e, this._update();
                }
                get showTileAABBs() {
                    return !!this._showTileAABBs;
                }
                set showTileAABBs(e) {
                    this._showTileAABBs !== e && (this._showTileAABBs = e, this._tp.refreshUI(), e && this._update());
                }
                _setCacheLimits(t1, i) {
                    e.du(t1, i);
                }
                _occlusionCriteriaSatisfied() {
                    const e = this.style && (this.style.has3DLayers() || this.style.terrain && !this.style.disableElevatedTerrain);
                    return !(this.style && this.style.hasSymbolLayers() && e && this.painter) || this._frameId - this._lastDirtyFrameId > 5 + 2 * this.painter.symbolParams.occlusionQueryFrameWindow;
                }
                get version() {
                    return e.dt;
                }
            },
            NavigationControl: class {
                constructor(t1 = {}){
                    this.options = e.W({}, Hn, t1), this._container = a("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e)=>e.preventDefault()), this.options.showZoom && (e.bp([
                        "_setButtonTitle",
                        "_updateZoomButtons"
                    ], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e)=>{
                        this._map && this._map.zoomIn({}, {
                            originalEvent: e
                        });
                    }), a("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e)=>{
                        this._map && this._map.zoomOut({}, {
                            originalEvent: e
                        });
                    }), a("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.bp([
                        "_rotateCompassArrow"
                    ], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e)=>{
                        const t1 = this._map;
                        t1 && (this.options.visualizePitch ? t1.resetNorthPitch({}, {
                            originalEvent: e
                        }) : t1.resetNorth({}, {
                            originalEvent: e
                        }));
                    }), this._compassIcon = a("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
                }
                _updateZoomButtons() {
                    const e = this._map;
                    if (!e) return;
                    const t1 = e.getZoom(), i = t1 === e.getMaxZoom(), o = t1 === e.getMinZoom();
                    this._zoomInButton.disabled = i, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute("aria-disabled", i.toString()), this._zoomOutButton.setAttribute("aria-disabled", o.toString());
                }
                _rotateCompassArrow() {
                    const e = this._map;
                    if (!e) return;
                    const t1 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${e.transform.pitch}deg) rotateZ(${e.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e.transform.angle * (180 / Math.PI)}deg)`;
                    e._requestDomTask(()=>{
                        this._compassIcon && (this._compassIcon.style.transform = t1);
                    });
                }
                onAdd(e) {
                    return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e.on("pitch", this._rotateCompassArrow), e.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new $n(e, this._compass, this.options.visualizePitch)), this._container;
                }
                onRemove() {
                    const e = this._map;
                    e && (this._container.remove(), this.options.showZoom && e.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e.off("pitch", this._rotateCompassArrow), e.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
                }
                _createButton(e, t1) {
                    const i = a("button", e, this._container);
                    return i.type = "button", i.addEventListener("click", t1), i;
                }
                _setButtonTitle(e, t1) {
                    if (!this._map) return;
                    const i = this._map._getUIString(`NavigationControl.${t1}`);
                    e.setAttribute("aria-label", i), e.firstElementChild && e.firstElementChild.setAttribute("title", i);
                }
            },
            GeolocateControl: class extends e.E {
                constructor(t1 = {}){
                    super();
                    const i = navigator.geolocation;
                    this.options = e.W({
                        geolocation: i
                    }, Xn, t1), e.bp([
                        "_onSuccess",
                        "_onError",
                        "_onZoom",
                        "_finish",
                        "_setupUI",
                        "_updateCamera",
                        "_updateMarker",
                        "_updateMarkerRotation",
                        "_onDeviceOrientation"
                    ], this), this._updateMarkerRotationThrottled = Ma(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
                }
                onAdd(e) {
                    return this._map = e, this._container = a("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
                }
                onRemove() {
                    void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;
                }
                _checkGeolocationSupport(e) {
                    const t1 = (t1 = !!this.options.geolocation)=>{
                        this._supportsGeolocation = t1, e(t1);
                    };
                    void 0 !== this._supportsGeolocation ? e(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({
                        name: "geolocation"
                    }).then((e)=>t1("denied" !== e.state)).catch(()=>t1()) : t1();
                }
                _isOutOfMapMaxBounds(e) {
                    const t1 = this._map.getMaxBounds(), i = e.coords;
                    return !!t1 && (i.longitude < t1.getWest() || i.longitude > t1.getEast() || i.latitude < t1.getSouth() || i.latitude > t1.getNorth());
                }
                _setErrorState() {
                    switch(this._watchState){
                        case "WAITING_ACTIVE":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                            break;
                        case "ACTIVE_LOCK":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                            break;
                        case "BACKGROUND":
                            this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                    }
                }
                _onSuccess(t1) {
                    if (this._map) {
                        if (this._isOutOfMapMaxBounds(t1)) return this._setErrorState(), this.fire(new e.f("outofmaxbounds", t1)), this._updateMarker(), void this._finish();
                        if (this.options.trackUserLocation) switch(this._lastKnownPosition = t1, this._watchState){
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "BACKGROUND":
                            case "BACKGROUND_ERROR":
                                this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                        }
                        this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t1), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t1), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.f("geolocate", t1)), this._finish();
                    }
                }
                _updateCamera(t1) {
                    const i = new e.aI(t1.coords.longitude, t1.coords.latitude), o = t1.coords.accuracy, r = this._map.getBearing(), a = e.W({
                        bearing: r
                    }, this.options.fitBoundsOptions);
                    this._map.fitBounds(i.toBounds(o), a, {
                        geolocateSource: !0
                    });
                }
                _updateMarker(t1) {
                    if (t1) {
                        const i = new e.aI(t1.coords.longitude, t1.coords.latitude);
                        this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t1.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                    } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
                }
                _updateCircleRadius() {
                    const t1 = this._map.transform, i = e.ax(1, t1._center.lat) * t1.worldSize, o = Math.ceil(2 * this._accuracy * i);
                    this._circleElement.style.width = `${o}px`, this._circleElement.style.height = `${o}px`;
                }
                _onZoom() {
                    this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                }
                _updateMarkerRotation() {
                    this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
                }
                _onError(t1) {
                    if (this._map) {
                        if (this.options.trackUserLocation) {
                            if (1 === t1.code) {
                                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                                const e = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e), void 0 !== this._geolocationWatchID && this._clearWatch();
                            } else {
                                if (3 === t1.code && this._noTimeout) return;
                                this._setErrorState();
                            }
                        }
                        "OFF" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.f("error", t1)), this._finish();
                    }
                }
                _finish() {
                    this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
                }
                _setupUI(t1) {
                    if (void 0 !== this._map) {
                        if (this._container.addEventListener("contextmenu", (e)=>e.preventDefault()), this._geolocateButton = a("button", "mapboxgl-ctrl-geolocate", this._container), a("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", !1 === t1) {
                            e.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                            const t1 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                            this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t1), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t1);
                        } else {
                            const e = this._map._getUIString("GeolocateControl.FindMyLocation");
                            this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e);
                        }
                        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = a("div", "mapboxgl-user-location"), this._dotElement.appendChild(a("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(a("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new Nn({
                            element: this._dotElement,
                            rotationAlignment: "map",
                            pitchAlignment: "map"
                        }), this._circleElement = a("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Nn({
                            element: this._circleElement,
                            pitchAlignment: "map"
                        }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (t1)=>{
                            t1.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t1.originalEvent && "resize" === t1.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.f("trackuserlocationend")));
                        });
                    }
                }
                _onDeviceOrientation(e) {
                    this._userLocationDotMarker && (e.webkitCompassHeading ? this._heading = e.webkitCompassHeading : !0 === e.absolute && (this._heading = -1 * e.alpha), this._updateMarkerRotationThrottled());
                }
                trigger() {
                    if (!this._setup) return e.w("Geolocate control triggered before added to a map"), !1;
                    if (this.options.trackUserLocation) {
                        switch(this._watchState){
                            case "OFF":
                                this._watchState = "WAITING_ACTIVE", this.fire(new e.f("trackuserlocationstart"));
                                break;
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                            case "BACKGROUND_ERROR":
                                this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.f("trackuserlocationend"));
                                break;
                            case "BACKGROUND":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.f("trackuserlocationstart"));
                        }
                        switch(this._watchState){
                            case "WAITING_ACTIVE":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_LOCK":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                break;
                            case "BACKGROUND":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                                break;
                            case "BACKGROUND_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
                        }
                        if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
                        else if (void 0 === this._geolocationWatchID) {
                            let e;
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e = {
                                maximumAge: 6e5,
                                timeout: 0
                            }, this._noTimeout = !0) : (e = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e), this.options.showUserHeading && this._addDeviceOrientationListener();
                        }
                    } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
                    return !0;
                }
                _addDeviceOrientationListener() {
                    const e = ()=>{
                        "ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation);
                    };
                    "undefined" != typeof DeviceMotionEvent && "function" == typeof DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((t1)=>{
                        "granted" === t1 && e();
                    }).catch(console.error) : e();
                }
                _clearWatch() {
                    this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
                }
            },
            AttributionControl: zn,
            ScaleControl: class {
                constructor(t1 = {}){
                    this.options = e.W({}, Yn, t1), this._isNumberFormatSupported = function() {
                        try {
                            return new Intl.NumberFormat("en", {
                                style: "unit",
                                unitDisplay: "short",
                                unit: "meter"
                            }), !0;
                        } catch (e) {
                            return !1;
                        }
                    }(), e.bp([
                        "_update",
                        "_setScale",
                        "setUnit"
                    ], this);
                }
                getDefaultPosition() {
                    return "bottom-left";
                }
                _update() {
                    const e = this.options.maxWidth || 100, t1 = this._map, i = t1._containerHeight / 2, o = t1._containerWidth / 2 - e / 2, r = t1.unproject([
                        o,
                        i
                    ]), a = t1.unproject([
                        o + e,
                        i
                    ]), n = r.distanceTo(a);
                    if ("imperial" === this.options.unit) {
                        const t1 = 3.2808 * n;
                        t1 > 5280 ? this._setScale(e, t1 / 5280, "mile") : this._setScale(e, t1, "foot");
                    } else "nautical" === this.options.unit ? this._setScale(e, n / 1852, "nautical-mile") : n >= 1e3 ? this._setScale(e, n / 1e3, "kilometer") : this._setScale(e, n, "meter");
                }
                _setScale(e, t1, i) {
                    this._map._requestDomTask(()=>{
                        const o = function(e) {
                            const t1 = Math.pow(10, `${Math.floor(e)}`.length - 1);
                            let i = e / t1;
                            return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function(e) {
                                const t1 = Math.pow(10, Math.ceil(-Math.log(e) / Math.LN10));
                                return Math.round(e * t1) / t1;
                            }(i), t1 * i;
                        }(t1), r = o / t1;
                        this._container.innerHTML = this._isNumberFormatSupported && "nautical-mile" !== i ? new Intl.NumberFormat(this._language, {
                            style: "unit",
                            unitDisplay: "short",
                            unit: i
                        }).format(o) : `${o}&nbsp;${Kn[i]}`, this._container.style.width = e * r + "px";
                    });
                }
                onAdd(e) {
                    return this._map = e, this._language = e.getLanguage(), this._container = a("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
                }
                onRemove() {
                    this._container.remove(), this._map.off("move", this._update), this._map = void 0;
                }
                _setLanguage(e) {
                    this._language = e, this._update();
                }
                setUnit(e) {
                    this.options.unit = e, this._update();
                }
            },
            FullscreenControl: class {
                constructor(t1 = {}){
                    this._fullscreen = !1, t1 && t1.container && (t1.container instanceof HTMLElement ? this._container = t1.container : e.w("Full screen control 'container' must be a DOM element.")), e.bp([
                        "_onClickFullscreen",
                        "_changeIcon"
                    ], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
                }
                onAdd(t1) {
                    return this._map = t1, this._container || (this._container = this._map.getContainer()), this._controlContainer = a("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.w("This device does not support fullscreen mode.")), this._controlContainer;
                }
                onRemove() {
                    this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
                }
                _checkFullscreenSupport() {
                    return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
                }
                _setupUI() {
                    const e = this._fullscreenButton = a("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
                    a("span", "mapboxgl-ctrl-icon", e).setAttribute("aria-hidden", "true"), e.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
                }
                _updateTitle() {
                    const e = this._getTitle();
                    this._fullscreenButton.setAttribute("aria-label", e), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e);
                }
                _getTitle() {
                    return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
                }
                _isFullscreen() {
                    return this._fullscreen;
                }
                _changeIcon() {
                    (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
                }
                _onClickFullscreen() {
                    this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
                }
            },
            Popup: class extends e.E {
                constructor(t1){
                    super(), this.options = e.W(Object.create(Un), t1), e.bp([
                        "_update",
                        "_onClose",
                        "remove",
                        "_onMouseEvent"
                    ], this), this._classList = new Set(t1 && t1.className ? t1.className.trim().split(/\s+/) : []);
                }
                addTo(t1) {
                    return this._map && this.remove(), this._map = t1, this.options.closeOnClick && t1.on("preclick", this._onClose), this.options.closeOnMove && t1.on("move", this._onClose), t1.on("remove", this.remove), this._update(), t1._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t1.on("mousemove", this._onMouseEvent), t1.on("mouseup", this._onMouseEvent), t1._canvasContainer.classList.add("mapboxgl-track-pointer")) : t1.on("move", this._update), this.fire(new e.f("open")), this;
                }
                isOpen() {
                    return !!this._map;
                }
                remove() {
                    this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
                    const t1 = this._map;
                    return t1 && (t1.off("move", this._update), t1.off("move", this._onClose), t1.off("preclick", this._onClose), t1.off("click", this._onClose), t1.off("remove", this.remove), t1.off("mousemove", this._onMouseEvent), t1.off("mouseup", this._onMouseEvent), t1.off("drag", this._onMouseEvent), t1._canvasContainer && t1._canvasContainer.classList.remove("mapboxgl-track-pointer"), t1._removePopup(this), this._map = void 0), this.fire(new e.f("close")), this;
                }
                getLngLat() {
                    return this._lngLat;
                }
                setLngLat(t1) {
                    this._lngLat = e.aI.convert(t1), this._pos = null, this._trackPointer = !1, this._update();
                    const i = this._map;
                    return i && (i.on("move", this._update), i.off("mousemove", this._onMouseEvent), i._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
                }
                trackPointer() {
                    this._trackPointer = !0, this._pos = null, this._update();
                    const e = this._map;
                    return e && (e.off("move", this._update), e.on("mousemove", this._onMouseEvent), e.on("drag", this._onMouseEvent), e._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
                }
                getElement() {
                    return this._container;
                }
                setText(e) {
                    return this.setDOMContent(document.createTextNode(e));
                }
                setHTML(e) {
                    const t1 = document.createDocumentFragment(), i = document.createElement("body");
                    let o;
                    for(i.innerHTML = e; o = i.firstChild, o;)t1.appendChild(o);
                    return this.setDOMContent(t1);
                }
                getMaxWidth() {
                    return this._container && this._container.style.maxWidth;
                }
                setMaxWidth(e) {
                    return this.options.maxWidth = e, this._update(), this;
                }
                setDOMContent(e) {
                    let t1 = this._content;
                    if (t1) for(; t1.hasChildNodes();)t1.firstChild && t1.removeChild(t1.firstChild);
                    else t1 = this._content = a("div", "mapboxgl-popup-content", this._container || void 0);
                    if (t1.appendChild(e), this.options.closeButton) {
                        const e = this._closeButton = a("button", "mapboxgl-popup-close-button", t1);
                        e.type = "button", e.setAttribute("aria-label", "Close popup"), e.setAttribute("aria-hidden", "true"), e.innerHTML = "&#215;", e.addEventListener("click", this._onClose);
                    }
                    return this._update(), this._focusFirstElement(), this;
                }
                addClassName(e) {
                    return this._classList.add(e), this._updateClassList(), this;
                }
                removeClassName(e) {
                    return this._classList.delete(e), this._updateClassList(), this;
                }
                setOffset(e) {
                    return this.options.offset = e, this._update(), this;
                }
                toggleClassName(e) {
                    let t1;
                    return this._classList.delete(e) ? t1 = !1 : (this._classList.add(e), t1 = !0), this._updateClassList(), t1;
                }
                _onMouseEvent(e) {
                    this._update(e.point);
                }
                _getAnchor(e) {
                    if (this.options.anchor) return this.options.anchor;
                    const t1 = this._map, i = this._container, o = this._pos;
                    if (!t1 || !i || !o) return "bottom";
                    const r = i.offsetWidth, a = i.offsetHeight, n = o.x < r / 2, s = o.x > t1.transform.width - r / 2;
                    if (o.y + e < a) return n ? "top-left" : s ? "top-right" : "top";
                    if (o.y > t1.transform.height - a) {
                        if (n) return "bottom-left";
                        if (s) return "bottom-right";
                    }
                    return n ? "left" : s ? "right" : "bottom";
                }
                _updateClassList() {
                    const e = this._container;
                    if (!e) return;
                    const t1 = [
                        ...this._classList
                    ];
                    t1.push("mapboxgl-popup"), this._anchor && t1.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t1.push("mapboxgl-popup-track-pointer"), e.className = t1.join(" ");
                }
                _update(t1) {
                    const i = this._map, o = this._content;
                    if (!i || !this._lngLat && !this._trackPointer || !o) return;
                    let r = this._container;
                    if (r || (r = this._container = a("div", "mapboxgl-popup", i.getContainer()), this._tip = a("div", "mapboxgl-popup-tip", r), r.appendChild(o)), this.options.maxWidth && r.style.maxWidth !== this.options.maxWidth && (r.style.maxWidth = this.options.maxWidth), i.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Bn(this._lngLat, this._pos, i.transform)), !this._trackPointer || t1) {
                        const o = this._pos = this._trackPointer && t1 instanceof e.P ? t1 : i.project(this._lngLat), r = jn(this.options.offset), a = this._anchor = this._getAnchor(r.y), n = jn(this.options.offset, a), s = o.add(n).round();
                        i._requestDomTask(()=>{
                            this._container && a && (this._container.style.transform = `${kn[a]} translate(${s.x}px,${s.y}px)`);
                        });
                    }
                    if (!this._marker && i._showingGlobe()) {
                        const t1 = e.d9(i.transform, this._lngLat) ? 0 : 1;
                        this._setOpacity(t1);
                    }
                    this._updateClassList();
                }
                _focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container) return;
                    const e = this._container.querySelector(Gn);
                    e && e.focus();
                }
                _onClose() {
                    this.remove();
                }
                _setOpacity(e) {
                    this._container && (this._container.style.opacity = `${e}`), this._content && (this._content.style.pointerEvents = e ? "auto" : "none");
                }
            },
            Marker: Nn,
            Style: Da,
            LngLat: e.aI,
            LngLatBounds: e.ai,
            Point: e.P,
            MercatorCoordinate: e.Y,
            FreeCameraOptions: qt,
            Evented: e.E,
            config: e.d8,
            prewarm: e.dx,
            clearPrewarmedResources: e.dy,
            get accessToken () {
                return e.d8.ACCESS_TOKEN;
            },
            set accessToken (t){
                e.d8.ACCESS_TOKEN = t;
            },
            get baseApiUrl () {
                return e.d8.API_URL;
            },
            set baseApiUrl (t){
                e.d8.API_URL = t;
            },
            get workerCount () {
                return e.dz.workerCount;
            },
            set workerCount (t){
                e.dz.workerCount = t;
            },
            get maxParallelImageRequests () {
                return e.d8.MAX_PARALLEL_IMAGE_REQUESTS;
            },
            set maxParallelImageRequests (t){
                e.d8.MAX_PARALLEL_IMAGE_REQUESTS = t;
            },
            clearStorage (t1) {
                e.dA(t1);
            },
            get workerUrl () {
                return e.dB.workerUrl;
            },
            set workerUrl (t){
                e.dB.workerUrl = t;
            },
            get workerClass () {
                return e.dB.workerClass;
            },
            set workerClass (t){
                e.dB.workerClass = t;
            },
            get workerParams () {
                return e.dB.workerParams;
            },
            set workerParams (t){
                e.dB.workerParams = t;
            },
            get dracoUrl () {
                return e.dC();
            },
            set dracoUrl (t){
                e.dD(t);
            },
            get meshoptUrl () {
                return e.dE();
            },
            set meshoptUrl (t){
                e.dF(t);
            },
            setNow: e.e.setNow,
            restoreNow: e.e.restoreNow
        };
        return Qn;
    });
    //
    // Our custom intro provides a specialized "define()" function, called by the
    // AMD modules below, that sets up the worker blob URL and then executes the
    // main module, storing its exported value as 'mapboxgl'
    var mapboxgl$1 = mapboxgl;
    return mapboxgl$1;
});

},{}],"f0qvZ":[function(require,module,exports) {
module.exports = require("2e3ceef1d130b93").getBundleURL("bLxZJ") + "state.e761c31f.png" + "?" + Date.now();

},{"2e3ceef1d130b93":"lgJ39"}],"lgJ39":[function(require,module,exports) {
"use strict";
var bundleURL = {};
function getBundleURLCached(id) {
    var value = bundleURL[id];
    if (!value) {
        value = getBundleURL();
        bundleURL[id] = value;
    }
    return value;
}
function getBundleURL() {
    try {
        throw new Error();
    } catch (err) {
        var matches = ("" + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^)\n]+/g);
        if (matches) // The first two stack frames will be this function and getBundleURLCached.
        // Use the 3rd one, which will be a runtime in the original bundle.
        return getBaseURL(matches[2]);
    }
    return "/";
}
function getBaseURL(url) {
    return ("" + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/.+)\/[^/]+$/, "$1") + "/";
}
// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.
function getOrigin(url) {
    var matches = ("" + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^/]+/);
    if (!matches) throw new Error("Origin not found");
    return matches[0];
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;

},{}],"1PBVp":[function(require,module,exports) {
module.exports = require("39ec3daeb80d134b").getBundleURL("bLxZJ") + "country.1fcb7762.png" + "?" + Date.now();

},{"39ec3daeb80d134b":"lgJ39"}],"dPSuH":[function(require,module,exports) {
module.exports = require("e73aa27a9569db92").getBundleURL("bLxZJ") + "running-bolt.e50c40c3.png" + "?" + Date.now();

},{"e73aa27a9569db92":"lgJ39"}],"l4x0p":[function(require,module,exports) {
module.exports = require("70af6b2ce14b494d").getBundleURL("bLxZJ") + "running-time.0fe8d92a.png" + "?" + Date.now();

},{"70af6b2ce14b494d":"lgJ39"}],"knKF0":[function(require,module,exports) {
module.exports = require("4ffbe58576580796").getBundleURL("bLxZJ") + "running-activity.684599a7.png" + "?" + Date.now();

},{"4ffbe58576580796":"lgJ39"}],"c2u2T":[function(require,module,exports) {
module.exports = require("f0a77a8d98715aec").getBundleURL("bLxZJ") + "running.7d9c1f86.png" + "?" + Date.now();

},{"f0a77a8d98715aec":"lgJ39"}],"cV8VT":[function(require,module,exports) {
module.exports = require("22e651a3e9d90aaa").getBundleURL("bLxZJ") + "cycling-bolt.8cf17e1c.png" + "?" + Date.now();

},{"22e651a3e9d90aaa":"lgJ39"}],"ju7M8":[function(require,module,exports) {
module.exports = require("b590908fdff18eb3").getBundleURL("bLxZJ") + "cycling-time.57da884f.png" + "?" + Date.now();

},{"b590908fdff18eb3":"lgJ39"}],"ekBrc":[function(require,module,exports) {
module.exports = require("45ecdd7e72b9cd3d").getBundleURL("bLxZJ") + "cycling-activity.0f57d343.png" + "?" + Date.now();

},{"45ecdd7e72b9cd3d":"lgJ39"}],"fMgm3":[function(require,module,exports) {
module.exports = require("80d890b47694f98c").getBundleURL("bLxZJ") + "cycling.2b550f60.png" + "?" + Date.now();

},{"80d890b47694f98c":"lgJ39"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}]},["farZc","8lqZg"], "8lqZg", "parcelRequire8112")

//# sourceMappingURL=index.975ef6c8.js.map
